(self.webpackChunk_masatomakino_pixijs_basic_scrollbar=self.webpackChunk_masatomakino_pixijs_basic_scrollbar||[]).push([[736],{471:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZP\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"kX\": () => (/* binding */ Tween),\n/* harmony export */   \"oY\": () => (/* binding */ Easing)\n/* harmony export */ });\n/* unused harmony exports Group, Interpolation, Sequence, VERSION, add, getAll, nextId, now, remove, removeAll, update */\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\nvar Easing = {\n    Linear: {\n        None: function (amount) {\n            return amount;\n        },\n    },\n    Quadratic: {\n        In: function (amount) {\n            return amount * amount;\n        },\n        Out: function (amount) {\n            return amount * (2 - amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount;\n            }\n            return -0.5 * (--amount * (amount - 2) - 1);\n        },\n    },\n    Cubic: {\n        In: function (amount) {\n            return amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount + 2);\n        },\n    },\n    Quartic: {\n        In: function (amount) {\n            return amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return 1 - --amount * amount * amount * amount;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount;\n            }\n            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n        },\n    },\n    Quintic: {\n        In: function (amount) {\n            return amount * amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n        },\n    },\n    Sinusoidal: {\n        In: function (amount) {\n            return 1 - Math.cos((amount * Math.PI) / 2);\n        },\n        Out: function (amount) {\n            return Math.sin((amount * Math.PI) / 2);\n        },\n        InOut: function (amount) {\n            return 0.5 * (1 - Math.cos(Math.PI * amount));\n        },\n    },\n    Exponential: {\n        In: function (amount) {\n            return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n        },\n        Out: function (amount) {\n            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            if ((amount *= 2) < 1) {\n                return 0.5 * Math.pow(1024, amount - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n        },\n    },\n    Circular: {\n        In: function (amount) {\n            return 1 - Math.sqrt(1 - amount * amount);\n        },\n        Out: function (amount) {\n            return Math.sqrt(1 - --amount * amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n        },\n    },\n    Elastic: {\n        In: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n        },\n        Out: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            amount *= 2;\n            if (amount < 1) {\n                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n            }\n            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n        },\n    },\n    Back: {\n        In: function (amount) {\n            var s = 1.70158;\n            return amount * amount * ((s + 1) * amount - s);\n        },\n        Out: function (amount) {\n            var s = 1.70158;\n            return --amount * amount * ((s + 1) * amount + s) + 1;\n        },\n        InOut: function (amount) {\n            var s = 1.70158 * 1.525;\n            if ((amount *= 2) < 1) {\n                return 0.5 * (amount * amount * ((s + 1) * amount - s));\n            }\n            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n        },\n    },\n    Bounce: {\n        In: function (amount) {\n            return 1 - Easing.Bounce.Out(1 - amount);\n        },\n        Out: function (amount) {\n            if (amount < 1 / 2.75) {\n                return 7.5625 * amount * amount;\n            }\n            else if (amount < 2 / 2.75) {\n                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n            }\n            else if (amount < 2.5 / 2.75) {\n                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n            }\n            else {\n                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n            }\n        },\n        InOut: function (amount) {\n            if (amount < 0.5) {\n                return Easing.Bounce.In(amount * 2) * 0.5;\n            }\n            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n        },\n    },\n};\n\nvar now;\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\n// eslint-disable-next-line\n// @ts-ignore\nif (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {\n    now = function () {\n        // eslint-disable-next-line\n        // @ts-ignore\n        var time = process.hrtime();\n        // Convert [seconds, nanoseconds] to milliseconds.\n        return time[0] * 1000 + time[1] / 1000000;\n    };\n}\n// In a browser, use self.performance.now if it is available.\nelse if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {\n    // This must be bound, because directly assigning this function\n    // leads to an invocation exception in Chrome.\n    now = self.performance.now.bind(self.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n    now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n    now = function () {\n        return new Date().getTime();\n    };\n}\nvar now$1 = now;\n\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tween\n */\nvar Group = /** @class */ (function () {\n    function Group() {\n        this._tweens = {};\n        this._tweensAddedDuringUpdate = {};\n    }\n    Group.prototype.getAll = function () {\n        var _this = this;\n        return Object.keys(this._tweens).map(function (tweenId) {\n            return _this._tweens[tweenId];\n        });\n    };\n    Group.prototype.removeAll = function () {\n        this._tweens = {};\n    };\n    Group.prototype.add = function (tween) {\n        this._tweens[tween.getId()] = tween;\n        this._tweensAddedDuringUpdate[tween.getId()] = tween;\n    };\n    Group.prototype.remove = function (tween) {\n        delete this._tweens[tween.getId()];\n        delete this._tweensAddedDuringUpdate[tween.getId()];\n    };\n    Group.prototype.update = function (time, preserve) {\n        if (time === void 0) { time = now$1(); }\n        if (preserve === void 0) { preserve = false; }\n        var tweenIds = Object.keys(this._tweens);\n        if (tweenIds.length === 0) {\n            return false;\n        }\n        // Tweens are updated in \"batches\". If you add a new tween during an\n        // update, then the new tween will be updated in the next batch.\n        // If you remove a tween during an update, it may or may not be updated.\n        // However, if the removed tween was added during the current batch,\n        // then it will not be updated.\n        while (tweenIds.length > 0) {\n            this._tweensAddedDuringUpdate = {};\n            for (var i = 0; i < tweenIds.length; i++) {\n                var tween = this._tweens[tweenIds[i]];\n                var autoStart = !preserve;\n                if (tween && tween.update(time, autoStart) === false && !preserve) {\n                    delete this._tweens[tweenIds[i]];\n                }\n            }\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n        }\n        return true;\n    };\n    return Group;\n}());\n\n/**\n *\n */\nvar Interpolation = {\n    Linear: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.Linear;\n        if (k < 0) {\n            return fn(v[0], v[1], f);\n        }\n        if (k > 1) {\n            return fn(v[m], v[m - 1], m - f);\n        }\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n    },\n    Bezier: function (v, k) {\n        var b = 0;\n        var n = v.length - 1;\n        var pw = Math.pow;\n        var bn = Interpolation.Utils.Bernstein;\n        for (var i = 0; i <= n; i++) {\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n        }\n        return b;\n    },\n    CatmullRom: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.CatmullRom;\n        if (v[0] === v[m]) {\n            if (k < 0) {\n                i = Math.floor((f = m * (1 + k)));\n            }\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else {\n            if (k < 0) {\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n            if (k > 1) {\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n    },\n    Utils: {\n        Linear: function (p0, p1, t) {\n            return (p1 - p0) * t + p0;\n        },\n        Bernstein: function (n, i) {\n            var fc = Interpolation.Utils.Factorial;\n            return fc(n) / fc(i) / fc(n - i);\n        },\n        Factorial: (function () {\n            var a = [1];\n            return function (n) {\n                var s = 1;\n                if (a[n]) {\n                    return a[n];\n                }\n                for (var i = n; i > 1; i--) {\n                    s *= i;\n                }\n                a[n] = s;\n                return s;\n            };\n        })(),\n        CatmullRom: function (p0, p1, p2, p3, t) {\n            var v0 = (p2 - p0) * 0.5;\n            var v1 = (p3 - p1) * 0.5;\n            var t2 = t * t;\n            var t3 = t * t2;\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n        },\n    },\n};\n\n/**\n * Utils\n */\nvar Sequence = /** @class */ (function () {\n    function Sequence() {\n    }\n    Sequence.nextId = function () {\n        return Sequence._nextId++;\n    };\n    Sequence._nextId = 0;\n    return Sequence;\n}());\n\nvar mainGroup = new Group();\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar Tween = /** @class */ (function () {\n    function Tween(_object, _group) {\n        if (_group === void 0) { _group = mainGroup; }\n        this._object = _object;\n        this._group = _group;\n        this._isPaused = false;\n        this._pauseStart = 0;\n        this._valuesStart = {};\n        this._valuesEnd = {};\n        this._valuesStartRepeat = {};\n        this._duration = 1000;\n        this._initialRepeat = 0;\n        this._repeat = 0;\n        this._yoyo = false;\n        this._isPlaying = false;\n        this._reversed = false;\n        this._delayTime = 0;\n        this._startTime = 0;\n        this._easingFunction = Easing.Linear.None;\n        this._interpolationFunction = Interpolation.Linear;\n        this._chainedTweens = [];\n        this._onStartCallbackFired = false;\n        this._id = Sequence.nextId();\n        this._isChainStopped = false;\n        this._goToEnd = false;\n    }\n    Tween.prototype.getId = function () {\n        return this._id;\n    };\n    Tween.prototype.isPlaying = function () {\n        return this._isPlaying;\n    };\n    Tween.prototype.isPaused = function () {\n        return this._isPaused;\n    };\n    Tween.prototype.to = function (properties, duration) {\n        // TODO? restore this, then update the 07_dynamic_to example to set fox\n        // tween's to on each update. That way the behavior is opt-in (there's\n        // currently no opt-out).\n        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]\n        this._valuesEnd = Object.create(properties);\n        if (duration !== undefined) {\n            this._duration = duration;\n        }\n        return this;\n    };\n    Tween.prototype.duration = function (d) {\n        this._duration = d;\n        return this;\n    };\n    Tween.prototype.start = function (time) {\n        if (this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        this._repeat = this._initialRepeat;\n        if (this._reversed) {\n            // If we were reversed (f.e. using the yoyo feature) then we need to\n            // flip the tween direction back to forward.\n            this._reversed = false;\n            for (var property in this._valuesStartRepeat) {\n                this._swapEndStartRepeatValues(property);\n                this._valuesStart[property] = this._valuesStartRepeat[property];\n            }\n        }\n        this._isPlaying = true;\n        this._isPaused = false;\n        this._onStartCallbackFired = false;\n        this._isChainStopped = false;\n        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();\n        this._startTime += this._delayTime;\n        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);\n        return this;\n    };\n    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {\n        for (var property in _valuesEnd) {\n            var startValue = _object[property];\n            var startValueIsArray = Array.isArray(startValue);\n            var propType = startValueIsArray ? 'array' : typeof startValue;\n            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\n            // If `to()` specifies a property that doesn't exist in the source object,\n            // we should not set that property in the object\n            if (propType === 'undefined' || propType === 'function') {\n                continue;\n            }\n            // Check if an Array was provided as property value\n            if (isInterpolationList) {\n                var endValues = _valuesEnd[property];\n                if (endValues.length === 0) {\n                    continue;\n                }\n                // handle an array of relative values\n                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));\n                // Create a local copy of the Array with the start value at the front\n                _valuesEnd[property] = [startValue].concat(endValues);\n            }\n            // handle the deepness of the values\n            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {\n                _valuesStart[property] = startValueIsArray ? [] : {};\n                // eslint-disable-next-line\n                for (var prop in startValue) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property][prop] = startValue[prop];\n                }\n                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);\n            }\n            else {\n                // Save the starting value, but only once.\n                if (typeof _valuesStart[property] === 'undefined') {\n                    _valuesStart[property] = startValue;\n                }\n                if (!startValueIsArray) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n                }\n                if (isInterpolationList) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\n                }\n                else {\n                    _valuesStartRepeat[property] = _valuesStart[property] || 0;\n                }\n            }\n        }\n    };\n    Tween.prototype.stop = function () {\n        if (!this._isChainStopped) {\n            this._isChainStopped = true;\n            this.stopChainedTweens();\n        }\n        if (!this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        this._isPlaying = false;\n        this._isPaused = false;\n        if (this._onStopCallback) {\n            this._onStopCallback(this._object);\n        }\n        return this;\n    };\n    Tween.prototype.end = function () {\n        this._goToEnd = true;\n        this.update(Infinity);\n        return this;\n    };\n    Tween.prototype.pause = function (time) {\n        if (time === void 0) { time = now$1(); }\n        if (this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = true;\n        this._pauseStart = time;\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        return this;\n    };\n    Tween.prototype.resume = function (time) {\n        if (time === void 0) { time = now$1(); }\n        if (!this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = false;\n        this._startTime += time - this._pauseStart;\n        this._pauseStart = 0;\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        return this;\n    };\n    Tween.prototype.stopChainedTweens = function () {\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n            this._chainedTweens[i].stop();\n        }\n        return this;\n    };\n    Tween.prototype.group = function (group) {\n        this._group = group;\n        return this;\n    };\n    Tween.prototype.delay = function (amount) {\n        this._delayTime = amount;\n        return this;\n    };\n    Tween.prototype.repeat = function (times) {\n        this._initialRepeat = times;\n        this._repeat = times;\n        return this;\n    };\n    Tween.prototype.repeatDelay = function (amount) {\n        this._repeatDelayTime = amount;\n        return this;\n    };\n    Tween.prototype.yoyo = function (yoyo) {\n        this._yoyo = yoyo;\n        return this;\n    };\n    Tween.prototype.easing = function (easingFunction) {\n        this._easingFunction = easingFunction;\n        return this;\n    };\n    Tween.prototype.interpolation = function (interpolationFunction) {\n        this._interpolationFunction = interpolationFunction;\n        return this;\n    };\n    Tween.prototype.chain = function () {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        this._chainedTweens = tweens;\n        return this;\n    };\n    Tween.prototype.onStart = function (callback) {\n        this._onStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onUpdate = function (callback) {\n        this._onUpdateCallback = callback;\n        return this;\n    };\n    Tween.prototype.onRepeat = function (callback) {\n        this._onRepeatCallback = callback;\n        return this;\n    };\n    Tween.prototype.onComplete = function (callback) {\n        this._onCompleteCallback = callback;\n        return this;\n    };\n    Tween.prototype.onStop = function (callback) {\n        this._onStopCallback = callback;\n        return this;\n    };\n    /**\n     * @returns true if the tween is still playing after the update, false\n     * otherwise (calling update on a paused tween still returns true because\n     * it is still playing, just paused).\n     */\n    Tween.prototype.update = function (time, autoStart) {\n        if (time === void 0) { time = now$1(); }\n        if (autoStart === void 0) { autoStart = true; }\n        if (this._isPaused)\n            return true;\n        var property;\n        var elapsed;\n        var endTime = this._startTime + this._duration;\n        if (!this._goToEnd && !this._isPlaying) {\n            if (time > endTime)\n                return false;\n            if (autoStart)\n                this.start(time);\n        }\n        this._goToEnd = false;\n        if (time < this._startTime) {\n            return true;\n        }\n        if (this._onStartCallbackFired === false) {\n            if (this._onStartCallback) {\n                this._onStartCallback(this._object);\n            }\n            this._onStartCallbackFired = true;\n        }\n        elapsed = (time - this._startTime) / this._duration;\n        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n        var value = this._easingFunction(elapsed);\n        // properties transformations\n        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);\n        if (this._onUpdateCallback) {\n            this._onUpdateCallback(this._object, elapsed);\n        }\n        if (elapsed === 1) {\n            if (this._repeat > 0) {\n                if (isFinite(this._repeat)) {\n                    this._repeat--;\n                }\n                // Reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat) {\n                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {\n                        this._valuesStartRepeat[property] =\n                            // eslint-disable-next-line\n                            // @ts-ignore FIXME?\n                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n                    }\n                    if (this._yoyo) {\n                        this._swapEndStartRepeatValues(property);\n                    }\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n                if (this._yoyo) {\n                    this._reversed = !this._reversed;\n                }\n                if (this._repeatDelayTime !== undefined) {\n                    this._startTime = time + this._repeatDelayTime;\n                }\n                else {\n                    this._startTime = time + this._delayTime;\n                }\n                if (this._onRepeatCallback) {\n                    this._onRepeatCallback(this._object);\n                }\n                return true;\n            }\n            else {\n                if (this._onCompleteCallback) {\n                    this._onCompleteCallback(this._object);\n                }\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n                    // Make the chained tweens start exactly at the time they should,\n                    // even if the `update()` method was called way past the duration of the tween\n                    this._chainedTweens[i].start(this._startTime + this._duration);\n                }\n                this._isPlaying = false;\n                return false;\n            }\n        }\n        return true;\n    };\n    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {\n        for (var property in _valuesEnd) {\n            // Don't update properties that do not exist in the source object\n            if (_valuesStart[property] === undefined) {\n                continue;\n            }\n            var start = _valuesStart[property] || 0;\n            var end = _valuesEnd[property];\n            var startIsArray = Array.isArray(_object[property]);\n            var endIsArray = Array.isArray(end);\n            var isInterpolationList = !startIsArray && endIsArray;\n            if (isInterpolationList) {\n                _object[property] = this._interpolationFunction(end, value);\n            }\n            else if (typeof end === 'object' && end) {\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._updateProperties(_object[property], start, end, value);\n            }\n            else {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                end = this._handleRelativeValue(start, end);\n                // Protect against non numeric properties.\n                if (typeof end === 'number') {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _object[property] = start + (end - start) * value;\n                }\n            }\n        }\n    };\n    Tween.prototype._handleRelativeValue = function (start, end) {\n        if (typeof end !== 'string') {\n            return end;\n        }\n        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n            return start + parseFloat(end);\n        }\n        else {\n            return parseFloat(end);\n        }\n    };\n    Tween.prototype._swapEndStartRepeatValues = function (property) {\n        var tmp = this._valuesStartRepeat[property];\n        var endValue = this._valuesEnd[property];\n        if (typeof endValue === 'string') {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\n        }\n        else {\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\n        }\n        this._valuesEnd[property] = tmp;\n    };\n    return Tween;\n}());\n\nvar VERSION = '18.6.4';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar nextId = Sequence.nextId;\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tweens.\n */\nvar TWEEN = mainGroup;\n// This is the best way to export things in a way that's compatible with both ES\n// Modules and CommonJS, without build hacks, and so as not to break the\n// existing API.\n// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881\nvar getAll = TWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nvar add = TWEEN.add.bind(TWEEN);\nvar remove = TWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN);\nvar exports = {\n    Easing: Easing,\n    Group: Group,\n    Interpolation: Interpolation,\n    now: now$1,\n    Sequence: Sequence,\n    nextId: nextId,\n    Tween: Tween,\n    VERSION: VERSION,\n    getAll: getAll,\n    removeAll: removeAll,\n    add: add,\n    remove: remove,\n    update: update,\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((/* runtime-dependent pure expression or super */ 545 == __webpack_require__.j ? (exports) : null));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsc0JBQXNCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNCQUFzQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUseUZBQU8sV0FBQztBQUN5RyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AdHdlZW5qcy90d2Vlbi5qcy9kaXN0L3R3ZWVuLmVzbS5qcz9kODFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIEVhc2UgY2xhc3MgcHJvdmlkZXMgYSBjb2xsZWN0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMgZm9yIHVzZSB3aXRoIHR3ZWVuLmpzLlxuICovXG52YXIgRWFzaW5nID0ge1xuICAgIExpbmVhcjoge1xuICAgICAgICBOb25lOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgUXVhZHJhdGljOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiAoMiAtIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS1hbW91bnQgKiAoYW1vdW50IC0gMikgLSAxKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIEN1YmljOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogYW1vdW50ICsgMik7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBRdWFydGljOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAtIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgUXVpbnRpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgU2ludXNvaWRhbDoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoYW1vdW50ICogTWF0aC5QSSkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oKGFtb3VudCAqIE1hdGguUEkpIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogYW1vdW50KSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBFeHBvbmVudGlhbDoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBhbW91bnQgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGFtb3VudCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGFtb3VudCAtIDEpKSArIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgQ2lyY3VsYXI6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBhbW91bnQgKiBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tYW1vdW50ICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gYW1vdW50ICogYW1vdW50KSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChhbW91bnQgLT0gMikgKiBhbW91bnQpICsgMSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBFbGFzdGljOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLU1hdGgucG93KDIsIDEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBhbW91bnQpICogTWF0aC5zaW4oKGFtb3VudCAtIDAuMSkgKiA1ICogTWF0aC5QSSkgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW1vdW50ICo9IDI7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogTWF0aC5wb3coMiwgMTAgKiAoYW1vdW50IC0gMSkpICogTWF0aC5zaW4oKGFtb3VudCAtIDEuMSkgKiA1ICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMiwgLTEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpICsgMTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIEJhY2s6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCAtIHMpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50ICsgcykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKGFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50IC0gcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgKyBzKSArIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgQm91bmNlOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIEVhc2luZy5Cb3VuY2UuT3V0KDEgLSBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPCAxIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoYW1vdW50IC09IDEuNSAvIDIuNzUpICogYW1vdW50ICsgMC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFtb3VudCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjI1IC8gMi43NSkgKiBhbW91bnQgKyAwLjkzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjYyNSAvIDIuNzUpICogYW1vdW50ICsgMC45ODQzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMC41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuSW4oYW1vdW50ICogMikgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRWFzaW5nLkJvdW5jZS5PdXQoYW1vdW50ICogMiAtIDEpICogMC41ICsgMC41O1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG52YXIgbm93O1xuLy8gSW5jbHVkZSBhIHBlcmZvcm1hbmNlLm5vdyBwb2x5ZmlsbC5cbi8vIEluIG5vZGUuanMsIHVzZSBwcm9jZXNzLmhydGltZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuLy8gQHRzLWlnbm9yZVxuaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciB0aW1lID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgLy8gQ29udmVydCBbc2Vjb25kcywgbmFub3NlY29uZHNdIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgcmV0dXJuIHRpbWVbMF0gKiAxMDAwICsgdGltZVsxXSAvIDEwMDAwMDA7XG4gICAgfTtcbn1cbi8vIEluIGEgYnJvd3NlciwgdXNlIHNlbGYucGVyZm9ybWFuY2Uubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbmVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRoaXMgbXVzdCBiZSBib3VuZCwgYmVjYXVzZSBkaXJlY3RseSBhc3NpZ25pbmcgdGhpcyBmdW5jdGlvblxuICAgIC8vIGxlYWRzIHRvIGFuIGludm9jYXRpb24gZXhjZXB0aW9uIGluIENocm9tZS5cbiAgICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufVxuLy8gVXNlIERhdGUubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbmVsc2UgaWYgKERhdGUubm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBub3cgPSBEYXRlLm5vdztcbn1cbi8vIE90aGVyd2lzZSwgdXNlICduZXcgRGF0ZSgpLmdldFRpbWUoKScuXG5lbHNlIHtcbiAgICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xufVxudmFyIG5vdyQxID0gbm93O1xuXG4vKipcbiAqIENvbnRyb2xsaW5nIGdyb3VwcyBvZiB0d2VlbnNcbiAqXG4gKiBVc2luZyB0aGUgVFdFRU4gc2luZ2xldG9uIHRvIG1hbmFnZSB5b3VyIHR3ZWVucyBjYW4gY2F1c2UgaXNzdWVzIGluIGxhcmdlIGFwcHMgd2l0aCBtYW55IGNvbXBvbmVudHMuXG4gKiBJbiB0aGVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBzbWFsbGVyIGdyb3VwcyBvZiB0d2VlblxuICovXG52YXIgR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgICAgIHRoaXMuX3R3ZWVucyA9IHt9O1xuICAgICAgICB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSA9IHt9O1xuICAgIH1cbiAgICBHcm91cC5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKS5tYXAoZnVuY3Rpb24gKHR3ZWVuSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdHdlZW5zW3R3ZWVuSWRdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3R3ZWVucyA9IHt9O1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcbiAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGVbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc1t0d2Vlbi5nZXRJZCgpXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldO1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBwcmVzZXJ2ZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZSA9PT0gdm9pZCAwKSB7IHByZXNlcnZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKTtcbiAgICAgICAgaWYgKHR3ZWVuSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR3ZWVucyBhcmUgdXBkYXRlZCBpbiBcImJhdGNoZXNcIi4gSWYgeW91IGFkZCBhIG5ldyB0d2VlbiBkdXJpbmcgYW5cbiAgICAgICAgLy8gdXBkYXRlLCB0aGVuIHRoZSBuZXcgdHdlZW4gd2lsbCBiZSB1cGRhdGVkIGluIHRoZSBuZXh0IGJhdGNoLlxuICAgICAgICAvLyBJZiB5b3UgcmVtb3ZlIGEgdHdlZW4gZHVyaW5nIGFuIHVwZGF0ZSwgaXQgbWF5IG9yIG1heSBub3QgYmUgdXBkYXRlZC5cbiAgICAgICAgLy8gSG93ZXZlciwgaWYgdGhlIHJlbW92ZWQgdHdlZW4gd2FzIGFkZGVkIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCxcbiAgICAgICAgLy8gdGhlbiBpdCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgICAgICB3aGlsZSAodHdlZW5JZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5JZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xuICAgICAgICAgICAgICAgIHZhciBhdXRvU3RhcnQgPSAhcHJlc2VydmU7XG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuICYmIHR3ZWVuLnVwZGF0ZSh0aW1lLCBhdXRvU3RhcnQpID09PSBmYWxzZSAmJiAhcHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc1t0d2Vlbklkc1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHdlZW5JZHMgPSBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXA7XG59KCkpO1xuXG4vKipcbiAqXG4gKi9cbnZhciBJbnRlcnBvbGF0aW9uID0ge1xuICAgIExpbmVhcjogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmID0gbSAqIGs7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcbiAgICAgICAgdmFyIGZuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5MaW5lYXI7XG4gICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZbMF0sIHZbMV0sIGYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZbbV0sIHZbbSAtIDFdLCBtIC0gZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKHZbaV0sIHZbaSArIDEgPiBtID8gbSA6IGkgKyAxXSwgZiAtIGkpO1xuICAgIH0sXG4gICAgQmV6aWVyOiBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgIHZhciBuID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgcHcgPSBNYXRoLnBvdztcbiAgICAgICAgdmFyIGJuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5CZXJuc3RlaW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgYiArPSBwdygxIC0gaywgbiAtIGkpICogcHcoaywgaSkgKiB2W2ldICogYm4obiwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfSxcbiAgICBDYXRtdWxsUm9tOiBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGYgPSBtICogaztcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xuICAgICAgICB2YXIgZm4gPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkNhdG11bGxSb207XG4gICAgICAgIGlmICh2WzBdID09PSB2W21dKSB7XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICBpID0gTWF0aC5mbG9vcigoZiA9IG0gKiAoMSArIGspKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2WzBdIC0gKGZuKHZbMF0sIHZbMF0sIHZbMV0sIHZbMV0sIC1mKSAtIHZbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoZm4odlttXSwgdlttXSwgdlttIC0gMV0sIHZbbSAtIDFdLCBmIC0gbSkgLSB2W21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbih2W2kgPyBpIC0gMSA6IDBdLCB2W2ldLCB2W20gPCBpICsgMSA/IG0gOiBpICsgMV0sIHZbbSA8IGkgKyAyID8gbSA6IGkgKyAyXSwgZiAtIGkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBVdGlsczoge1xuICAgICAgICBMaW5lYXI6IGZ1bmN0aW9uIChwMCwgcDEsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiAocDEgLSBwMCkgKiB0ICsgcDA7XG4gICAgICAgIH0sXG4gICAgICAgIEJlcm5zdGVpbjogZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgICAgICAgIHZhciBmYyA9IEludGVycG9sYXRpb24uVXRpbHMuRmFjdG9yaWFsO1xuICAgICAgICAgICAgcmV0dXJuIGZjKG4pIC8gZmMoaSkgLyBmYyhuIC0gaSk7XG4gICAgICAgIH0sXG4gICAgICAgIEZhY3RvcmlhbDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhID0gWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChhW25dKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhW25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA+IDE7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBzICo9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFbbl0gPSBzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcbiAgICAgICAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgdDIgPSB0ICogdDtcbiAgICAgICAgICAgIHZhciB0MyA9IHQgKiB0MjtcbiAgICAgICAgICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG52YXIgU2VxdWVuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VxdWVuY2UoKSB7XG4gICAgfVxuICAgIFNlcXVlbmNlLm5leHRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFNlcXVlbmNlLl9uZXh0SWQrKztcbiAgICB9O1xuICAgIFNlcXVlbmNlLl9uZXh0SWQgPSAwO1xuICAgIHJldHVybiBTZXF1ZW5jZTtcbn0oKSk7XG5cbnZhciBtYWluR3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuLyoqXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanMvZ3JhcGhzL2NvbnRyaWJ1dG9ycyBmb3IgdGhlIGZ1bGwgbGlzdCBvZiBjb250cmlidXRvcnMuXG4gKiBUaGFuayB5b3UgYWxsLCB5b3UncmUgYXdlc29tZSFcbiAqL1xudmFyIFR3ZWVuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR3ZWVuKF9vYmplY3QsIF9ncm91cCkge1xuICAgICAgICBpZiAoX2dyb3VwID09PSB2b2lkIDApIHsgX2dyb3VwID0gbWFpbkdyb3VwOyB9XG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgICAgIHRoaXMuX2dyb3VwID0gX2dyb3VwO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnQgPSB7fTtcbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kID0ge307XG4gICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0ID0ge307XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMDtcbiAgICAgICAgdGhpcy5faW5pdGlhbFJlcGVhdCA9IDA7XG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IDA7XG4gICAgICAgIHRoaXMuX3lveW8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JldmVyc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX2Vhc2luZ0Z1bmN0aW9uID0gRWFzaW5nLkxpbmVhci5Ob25lO1xuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBJbnRlcnBvbGF0aW9uLkxpbmVhcjtcbiAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVucyA9IFtdO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pZCA9IFNlcXVlbmNlLm5leHRJZCgpO1xuICAgICAgICB0aGlzLl9pc0NoYWluU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9nb1RvRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIFR3ZWVuLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGF1c2VkO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIGR1cmF0aW9uKSB7XG4gICAgICAgIC8vIFRPRE8/IHJlc3RvcmUgdGhpcywgdGhlbiB1cGRhdGUgdGhlIDA3X2R5bmFtaWNfdG8gZXhhbXBsZSB0byBzZXQgZm94XG4gICAgICAgIC8vIHR3ZWVuJ3MgdG8gb24gZWFjaCB1cGRhdGUuIFRoYXQgd2F5IHRoZSBiZWhhdmlvciBpcyBvcHQtaW4gKHRoZXJlJ3NcbiAgICAgICAgLy8gY3VycmVudGx5IG5vIG9wdC1vdXQpLlxuICAgICAgICAvLyBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydGllcykgdGhpcy5fdmFsdWVzRW5kW3Byb3BdID0gcHJvcGVydGllc1twcm9wXVxuICAgICAgICB0aGlzLl92YWx1ZXNFbmQgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMpO1xuICAgICAgICBpZiAoZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aGlzLl9pbml0aWFsUmVwZWF0O1xuICAgICAgICBpZiAodGhpcy5fcmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgcmV2ZXJzZWQgKGYuZS4gdXNpbmcgdGhlIHlveW8gZmVhdHVyZSkgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSB0d2VlbiBkaXJlY3Rpb24gYmFjayB0byBmb3J3YXJkLlxuICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZSAhPT0gdW5kZWZpbmVkID8gKHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJyA/IG5vdyQxKCkgKyBwYXJzZUZsb2F0KHRpbWUpIDogdGltZSkgOiBub3ckMSgpO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgKz0gdGhpcy5fZGVsYXlUaW1lO1xuICAgICAgICB0aGlzLl9zZXR1cFByb3BlcnRpZXModGhpcy5fb2JqZWN0LCB0aGlzLl92YWx1ZXNTdGFydCwgdGhpcy5fdmFsdWVzRW5kLCB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl9zZXR1cFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoX29iamVjdCwgX3ZhbHVlc1N0YXJ0LCBfdmFsdWVzRW5kLCBfdmFsdWVzU3RhcnRSZXBlYXQpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBfb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHZhciBzdGFydFZhbHVlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgcHJvcFR5cGUgPSBzdGFydFZhbHVlSXNBcnJheSA/ICdhcnJheScgOiB0eXBlb2Ygc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHZhciBpc0ludGVycG9sYXRpb25MaXN0ID0gIXN0YXJ0VmFsdWVJc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgLy8gSWYgYHRvKClgIHNwZWNpZmllcyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdCxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBub3Qgc2V0IHRoYXQgcHJvcGVydHkgaW4gdGhlIG9iamVjdFxuICAgICAgICAgICAgaWYgKHByb3BUeXBlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gQXJyYXkgd2FzIHByb3ZpZGVkIGFzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRWYWx1ZXMgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGFuIGFycmF5IG9mIHJlbGF0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgIGVuZFZhbHVlcyA9IGVuZFZhbHVlcy5tYXAodGhpcy5faGFuZGxlUmVsYXRpdmVWYWx1ZS5iaW5kKHRoaXMsIHN0YXJ0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCBjb3B5IG9mIHRoZSBBcnJheSB3aXRoIHRoZSBzdGFydCB2YWx1ZSBhdCB0aGUgZnJvbnRcbiAgICAgICAgICAgICAgICBfdmFsdWVzRW5kW3Byb3BlcnR5XSA9IFtzdGFydFZhbHVlXS5jb25jYXQoZW5kVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSB0aGUgZGVlcG5lc3Mgb2YgdGhlIHZhbHVlc1xuICAgICAgICAgICAgaWYgKChwcm9wVHlwZSA9PT0gJ29iamVjdCcgfHwgc3RhcnRWYWx1ZUlzQXJyYXkpICYmIHN0YXJ0VmFsdWUgJiYgIWlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XVtwcm9wXSA9IHN0YXJ0VmFsdWVbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlSXNBcnJheSA/IFtdIDoge307IC8vIFRPRE8/IHJlcGVhdCBuZXN0ZWQgdmFsdWVzPyBBbmQgeW95bz8gQW5kIGFycmF5IHZhbHVlcz9cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwUHJvcGVydGllcyhzdGFydFZhbHVlLCBfdmFsdWVzU3RhcnRbcHJvcGVydHldLCBfdmFsdWVzRW5kW3Byb3BlcnR5XSwgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBzdGFydGluZyB2YWx1ZSwgYnV0IG9ubHkgb25jZS5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldICo9IDEuMDsgLy8gRW5zdXJlcyB3ZSdyZSB1c2luZyBudW1iZXJzLCBub3Qgc3RyaW5nc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNFbmRbcHJvcGVydHldLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhaW5TdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYWluU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0b3BDaGFpbmVkVHdlZW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fb25TdG9wQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RvcENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9nb1RvRW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoSW5maW5pdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdyQxKCk7IH1cbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IHRpbWU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdyQxKCk7IH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgKz0gdGltZSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAuYWRkKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5zdG9wQ2hhaW5lZFR3ZWVucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZ3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdGhpcy5fZ3JvdXAgPSBncm91cDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IGFtb3VudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxSZXBlYXQgPSB0aW1lcztcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGltZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICB0aGlzLl9yZXBlYXREZWxheVRpbWUgPSBhbW91bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnlveW8gPSBmdW5jdGlvbiAoeW95bykge1xuICAgICAgICB0aGlzLl95b3lvID0geW95bztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZWFzaW5nID0gZnVuY3Rpb24gKGVhc2luZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2Vhc2luZ0Z1bmN0aW9uID0gZWFzaW5nRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb25GdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0d2VlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHR3ZWVuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnMgPSB0d2VlbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uVXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25SZXBlYXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25SZXBlYXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vbkNvbXBsZXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblN0b3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25TdG9wQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB0d2VlbiBpcyBzdGlsbCBwbGF5aW5nIGFmdGVyIHRoZSB1cGRhdGUsIGZhbHNlXG4gICAgICogb3RoZXJ3aXNlIChjYWxsaW5nIHVwZGF0ZSBvbiBhIHBhdXNlZCB0d2VlbiBzdGlsbCByZXR1cm5zIHRydWUgYmVjYXVzZVxuICAgICAqIGl0IGlzIHN0aWxsIHBsYXlpbmcsIGp1c3QgcGF1c2VkKS5cbiAgICAgKi9cbiAgICBUd2Vlbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRpbWUsIGF1dG9TdGFydCkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XG4gICAgICAgIGlmIChhdXRvU3RhcnQgPT09IHZvaWQgMCkgeyBhdXRvU3RhcnQgPSB0cnVlOyB9XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgcHJvcGVydHk7XG4gICAgICAgIHZhciBlbGFwc2VkO1xuICAgICAgICB2YXIgZW5kVGltZSA9IHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuX2dvVG9FbmQgJiYgIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgaWYgKHRpbWUgPiBlbmRUaW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdXRvU3RhcnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nb1RvRW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aW1lIDwgdGhpcy5fc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxhcHNlZCA9ICh0aW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBlbGFwc2VkID0gdGhpcy5fZHVyYXRpb24gPT09IDAgfHwgZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZWFzaW5nRnVuY3Rpb24oZWxhcHNlZCk7XG4gICAgICAgIC8vIHByb3BlcnRpZXMgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnRpZXModGhpcy5fb2JqZWN0LCB0aGlzLl92YWx1ZXNTdGFydCwgdGhpcy5fdmFsdWVzRW5kLCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCwgZWxhcHNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsYXBzZWQgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHRoaXMuX3JlcGVhdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYXNzaWduIHN0YXJ0aW5nIHZhbHVlcywgcmVzdGFydCBieSBtYWtpbmcgc3RhcnRUaW1lID0gbm93XG4gICAgICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3lveW8gJiYgdHlwZW9mIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdCh0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5feW95bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl95b3lvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JldmVyc2VkID0gIXRoaXMuX3JldmVyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVwZWF0RGVsYXlUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZSArIHRoaXMuX3JlcGVhdERlbGF5VGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgKyB0aGlzLl9kZWxheVRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vblJlcGVhdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IHRoaXMuX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGNoYWluZWQgdHdlZW5zIHN0YXJ0IGV4YWN0bHkgYXQgdGhlIHRpbWUgdGhleSBzaG91bGQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIGB1cGRhdGUoKWAgbWV0aG9kIHdhcyBjYWxsZWQgd2F5IHBhc3QgdGhlIGR1cmF0aW9uIG9mIHRoZSB0d2VlblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zW2ldLnN0YXJ0KHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl91cGRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKF9vYmplY3QsIF92YWx1ZXNTdGFydCwgX3ZhbHVlc0VuZCwgdmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHByb3BlcnRpZXMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydCA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcbiAgICAgICAgICAgIHZhciBlbmQgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHZhciBzdGFydElzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9vYmplY3RbcHJvcGVydHldKTtcbiAgICAgICAgICAgIHZhciBlbmRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShlbmQpO1xuICAgICAgICAgICAgdmFyIGlzSW50ZXJwb2xhdGlvbkxpc3QgPSAhc3RhcnRJc0FycmF5ICYmIGVuZElzQXJyYXk7XG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgIF9vYmplY3RbcHJvcGVydHldID0gdGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGVuZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ29iamVjdCcgJiYgZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKF9vYmplY3RbcHJvcGVydHldLCBzdGFydCwgZW5kLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZXMgcmVsYXRpdmUgZW5kIHZhbHVlcyB3aXRoIHN0YXJ0IGFzIGJhc2UgKGUuZy46ICsxMCwgLTMpXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5faGFuZGxlUmVsYXRpdmVWYWx1ZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3Qgbm9uIG51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF9vYmplY3RbcHJvcGVydHldID0gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX2hhbmRsZVJlbGF0aXZlVmFsdWUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZC5jaGFyQXQoMCkgPT09ICcrJyB8fCBlbmQuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydCArIHBhcnNlRmxvYXQoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGVuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG4gICAgICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgIGlmICh0eXBlb2YgZW5kVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gKyBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSA9IHRtcDtcbiAgICB9O1xuICAgIHJldHVybiBUd2Vlbjtcbn0oKSk7XG5cbnZhciBWRVJTSU9OID0gJzE4LjYuNCc7XG5cbi8qKlxuICogVHdlZW4uanMgLSBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzL2dyYXBocy9jb250cmlidXRvcnMgZm9yIHRoZSBmdWxsIGxpc3Qgb2YgY29udHJpYnV0b3JzLlxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXG4gKi9cbnZhciBuZXh0SWQgPSBTZXF1ZW5jZS5uZXh0SWQ7XG4vKipcbiAqIENvbnRyb2xsaW5nIGdyb3VwcyBvZiB0d2VlbnNcbiAqXG4gKiBVc2luZyB0aGUgVFdFRU4gc2luZ2xldG9uIHRvIG1hbmFnZSB5b3VyIHR3ZWVucyBjYW4gY2F1c2UgaXNzdWVzIGluIGxhcmdlIGFwcHMgd2l0aCBtYW55IGNvbXBvbmVudHMuXG4gKiBJbiB0aGVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBzbWFsbGVyIGdyb3VwcyBvZiB0d2VlbnMuXG4gKi9cbnZhciBUV0VFTiA9IG1haW5Hcm91cDtcbi8vIFRoaXMgaXMgdGhlIGJlc3Qgd2F5IHRvIGV4cG9ydCB0aGluZ3MgaW4gYSB3YXkgdGhhdCdzIGNvbXBhdGlibGUgd2l0aCBib3RoIEVTXG4vLyBNb2R1bGVzIGFuZCBDb21tb25KUywgd2l0aG91dCBidWlsZCBoYWNrcywgYW5kIHNvIGFzIG5vdCB0byBicmVhayB0aGVcbi8vIGV4aXN0aW5nIEFQSS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xOTYxI2lzc3VlY29tbWVudC00MjMwMzc4ODFcbnZhciBnZXRBbGwgPSBUV0VFTi5nZXRBbGwuYmluZChUV0VFTik7XG52YXIgcmVtb3ZlQWxsID0gVFdFRU4ucmVtb3ZlQWxsLmJpbmQoVFdFRU4pO1xudmFyIGFkZCA9IFRXRUVOLmFkZC5iaW5kKFRXRUVOKTtcbnZhciByZW1vdmUgPSBUV0VFTi5yZW1vdmUuYmluZChUV0VFTik7XG52YXIgdXBkYXRlID0gVFdFRU4udXBkYXRlLmJpbmQoVFdFRU4pO1xudmFyIGV4cG9ydHMgPSB7XG4gICAgRWFzaW5nOiBFYXNpbmcsXG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIEludGVycG9sYXRpb246IEludGVycG9sYXRpb24sXG4gICAgbm93OiBub3ckMSxcbiAgICBTZXF1ZW5jZTogU2VxdWVuY2UsXG4gICAgbmV4dElkOiBuZXh0SWQsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFZFUlNJT046IFZFUlNJT04sXG4gICAgZ2V0QWxsOiBnZXRBbGwsXG4gICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXG4gICAgYWRkOiBhZGQsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgdXBkYXRlOiB1cGRhdGUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHBvcnRzO1xuZXhwb3J0IHsgRWFzaW5nLCBHcm91cCwgSW50ZXJwb2xhdGlvbiwgU2VxdWVuY2UsIFR3ZWVuLCBWRVJTSU9OLCBhZGQsIGdldEFsbCwgbmV4dElkLCBub3ckMSBhcyBub3csIHJlbW92ZSwgcmVtb3ZlQWxsLCB1cGRhdGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///471\n")},720:module=>{"use strict";eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHdCQUF3QixvQkFBb0I7QUFDNUMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcz85ZTU2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldikgcmV0dXJuIHRyaWFuZ2xlcztcblxuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXG4gICAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xuXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcbiAgICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMzI3NjcgLyBpbnZTaXplIDogMDtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIGJyZWFrO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBpbnZTaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKGludlNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG4gICAgdmFyIGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciB4MCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTAgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgIHgxID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KTtcblxuICAgIHZhciBwID0gYy5uZXh0O1xuICAgIHdoaWxlIChwICE9PSBhKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgdmFyIGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciB4MCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTAgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgIHgxID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KTtcblxuICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG4gICAgdmFyIG1pblogPSB6T3JkZXIoeDAsIHkwLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcih4MSwgeTEsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHAgPSBlYXIucHJldlosXG4gICAgICAgIG4gPSBlYXIubmV4dFo7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG5cbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltIHwgMCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKHApO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIGJyaWRnZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKCFicmlkZ2UpIHtcbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG5cbiAgICB2YXIgYnJpZGdlUmV2ZXJzZSA9IHNwbGl0UG9seWdvbihicmlkZ2UsIGhvbGUpO1xuXG4gICAgLy8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgZmlsdGVyUG9pbnRzKGJyaWRnZVJldmVyc2UsIGJyaWRnZVJldmVyc2UubmV4dCk7XG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhicmlkZ2UsIGJyaWRnZS5uZXh0KTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcbiAgICAgICAgICAgIGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuICAgICAgICAgICAgICAgIHF4ID0geDtcbiAgICAgICAgICAgICAgICBtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkgcmV0dXJuIG07IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxlZnRtb3N0IGVuZHBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbTtcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAobG9jYWxseUluc2lkZShwLCBob2xlKSAmJlxuICAgICAgICAgICAgICAgICh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIChwLnggPiBtLnggfHwgKHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApKSkpKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RvcCk7XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gd2hldGhlciBzZWN0b3IgaW4gdmVydGV4IG0gY29udGFpbnMgc2VjdG9yIGluIHZlcnRleCBwIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5mdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSB7XG4gICAgcmV0dXJuIGFyZWEobS5wcmV2LCBtLCBwLnByZXYpIDwgMCAmJiBhcmVhKHAubmV4dCwgbSwgbS5uZXh0KSA8IDA7XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gMCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gKHggLSBtaW5YKSAqIGludlNpemUgfCAwO1xuICAgIHkgPSAoeSAtIG1pblkpICogaW52U2l6ZSB8IDA7XG5cbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54IHx8IChwLnggPT09IGxlZnRtb3N0LnggJiYgcC55IDwgbGVmdG1vc3QueSkpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpID49IChheCAtIHB4KSAqIChjeSAtIHB5KSAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgPj0gKGJ4IC0gcHgpICogKGF5IC0gcHkpICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSA+PSAoY3ggLSBweCkgKiAoYnkgLSBweSk7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJiAvLyBkb25lcyd0IGludGVyc2VjdCBvdGhlciBlZGdlc1xuICAgICAgICAgICAobG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKSAmJiAvLyBsb2NhbGx5IHZpc2libGVcbiAgICAgICAgICAgIChhcmVhKGEucHJldiwgYSwgYi5wcmV2KSB8fCBhcmVhKGEsIGIucHJldiwgYikpIHx8IC8vIGRvZXMgbm90IGNyZWF0ZSBvcHBvc2l0ZS1mYWNpbmcgc2VjdG9yc1xuICAgICAgICAgICAgZXF1YWxzKGEsIGIpICYmIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpID4gMCAmJiBhcmVhKGIucHJldiwgYiwgYi5uZXh0KSA+IDApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2Vcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICB2YXIgbzEgPSBzaWduKGFyZWEocDEsIHExLCBwMikpO1xuICAgIHZhciBvMiA9IHNpZ24oYXJlYShwMSwgcTEsIHEyKSk7XG4gICAgdmFyIG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcbiAgICB2YXIgbzQgPSBzaWduKGFyZWEocDIsIHEyLCBxMSkpO1xuXG4gICAgaWYgKG8xICE9PSBvMiAmJiBvMyAhPT0gbzQpIHJldHVybiB0cnVlOyAvLyBnZW5lcmFsIGNhc2VcblxuICAgIGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHAyIGFyZSBjb2xsaW5lYXIgYW5kIHAyIGxpZXMgb24gcDFxMVxuICAgIGlmIChvMiA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHEyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHEyIGFyZSBjb2xsaW5lYXIgYW5kIHEyIGxpZXMgb24gcDFxMVxuICAgIGlmIChvMyA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHAxLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHAxIGFyZSBjb2xsaW5lYXIgYW5kIHAxIGxpZXMgb24gcDJxMlxuICAgIGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHExIGFyZSBjb2xsaW5lYXIgYW5kIHExIGxpZXMgb24gcDJxMlxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBmb3IgY29sbGluZWFyIHBvaW50cyBwLCBxLCByLCBjaGVjayBpZiBwb2ludCBxIGxpZXMgb24gc2VnbWVudCBwclxuZnVuY3Rpb24gb25TZWdtZW50KHAsIHEsIHIpIHtcbiAgICByZXR1cm4gcS54IDw9IE1hdGgubWF4KHAueCwgci54KSAmJiBxLnggPj0gTWF0aC5taW4ocC54LCByLngpICYmIHEueSA8PSBNYXRoLm1heChwLnksIHIueSkgJiYgcS55ID49IE1hdGgubWluKHAueSwgci55KTtcbn1cblxuZnVuY3Rpb24gc2lnbihudW0pIHtcbiAgICByZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLTEgOiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBiMjtcbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgIHZhciBwID0gbmV3IE5vZGUoaSwgeCwgeSk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgcC5wcmV2ID0gcDtcbiAgICAgICAgcC5uZXh0ID0gcDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgcC5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBwO1xuICAgICAgICBsYXN0Lm5leHQgPSBwO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XG4gICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XG4gICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XG5cbiAgICBpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG4gICAgaWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xufVxuXG5mdW5jdGlvbiBOb2RlKGksIHgsIHkpIHtcbiAgICAvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGV4IG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgIHRoaXMueiA9IDA7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG5cbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XG4gICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufTtcblxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///720\n")},34:module=>{"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcz83MDJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n")},63:module=>{"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzPzk3MGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///63\n")},957:module=>{"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcz82ZTQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///957\n")},582:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nexports.decode = exports.parse = __webpack_require__(63);\nexports.encode = exports.stringify = __webpack_require__(957);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsR0FBRyx1Q0FBbUM7QUFDcEQsY0FBYyxHQUFHLDRDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcz81MzFjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///582\n")},928:function(module,exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUVVO0FBQ1o7QUFDQSxFQUFFLG1DQUFtQjtBQUNyQjtBQUNBLEdBQUc7QUFBQSxrR0FBQztBQUNKLEdBQUcsS0FBSyxFQVVOOztBQUVGLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcz9iZTU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///928\n")},44:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("var __webpack_unused_export__;\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(928);\nvar util = __webpack_require__(944);\n\nexports.Qc = urlParse;\nexports.DB = urlResolve;\n__webpack_unused_export__ = urlResolveObject;\nexports.WU = urlFormat;\n\n__webpack_unused_export__ = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(582);\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcz81NzAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44\n")},944:module=>{"use strict";eval("\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanM/Yzk4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///944\n")},126:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "I": () => (/* reexport */ Color)\n});\n\n;// CONCATENATED MODULE: ./node_modules/colord/index.mjs\nvar r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n;// CONCATENATED MODULE: ./node_modules/colord/plugins/names.mjs\n/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/color/lib/Color.mjs\n\n\n\nk([names]);\nconst _Color = class {\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  get red() {\n    return this._components[0];\n  }\n  get green() {\n    return this._components[1];\n  }\n  get blue() {\n    return this._components[2];\n  }\n  get alpha() {\n    return this._components[3];\n  }\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this.cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error("Cannot set PIXI.Color#value to null");\n    } else if (this._value === null || !this.isSourceEqual(this._value, value)) {\n      this.normalize(value);\n      this._value = this.cloneSource(value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  cloneSource(value) {\n    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === "object" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    out = out ?? [];\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toRgbArray(out) {\n    out = out ?? [];\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  toNumber() {\n    return this._int;\n  }\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  multiply(value) {\n    const [r, g, b, a] = _Color.temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this.refreshInt();\n    this._value = null;\n    return this;\n  }\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this.refreshInt();\n    this._value = null;\n    return this;\n  }\n  toPremultiplied(alpha) {\n    if (alpha === 1) {\n      return (alpha * 255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return 0;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    r = r * alpha + 0.5 | 0;\n    g = g * alpha + 0.5 | 0;\n    b = b * alpha + 0.5 | 0;\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  round(steps) {\n    const [r, g, b] = this._components;\n    this._components[0] = Math.round(r * steps) / steps;\n    this._components[1] = Math.round(g * steps) / steps;\n    this._components[2] = Math.round(b * steps) / steps;\n    this.refreshInt();\n    this._value = null;\n    return this;\n  }\n  toArray(out) {\n    out = out ?? [];\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  normalize(value) {\n    let components;\n    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      components = [\n        (int >> 16 & 255) / 255,\n        (int >> 8 & 255) / 255,\n        (int & 255) / 255,\n        1\n      ];\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      const [r, g, b, a = 1] = value;\n      components = [r, g, b, a];\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      const [r, g, b, a = 255] = value;\n      components = [r / 255, g / 255, b / 255, a / 255];\n    } else if (typeof value === "string" || typeof value === "object") {\n      if (typeof value === "string") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = w(value);\n      if (color.isValid()) {\n        const { r, g, b, a } = color.rgba;\n        components = [r / 255, g / 255, b / 255, a];\n      }\n    }\n    if (components) {\n      this._components.set(components);\n      this.refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === "number") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n};\nlet Color = _Color;\nColor.shared = new _Color();\nColor.temp = new _Color();\nColor.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n\n//# sourceMappingURL=Color.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/color/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0Esd0NBQXdDLEVBQUUsRUFBRSxJQUFJLFVBQVUsRUFBRTs7QUFFM0M7QUFDakI7OztBQzVPb0M7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvY29sb3JkL2luZGV4Lm1qcz82MWJiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9jb2xvcmQvcGx1Z2lucy9uYW1lcy5tanM/OGU3NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29sb3IvbGliL0NvbG9yLm1qcz84YjUxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvci9saWIvaW5kZXgubWpzPzI2YjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHI9e2dyYWQ6LjksdHVybjozNjAscmFkOjM2MC8oMipNYXRoLlBJKX0sdD1mdW5jdGlvbihyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygcj9yLmxlbmd0aD4wOlwibnVtYmVyXCI9PXR5cGVvZiByfSxuPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49TWF0aC5wb3coMTAsdCkpLE1hdGgucm91bmQobipyKS9uKzB9LGU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj0xKSxyPm4/bjpyPnQ/cjp0fSx1PWZ1bmN0aW9uKHIpe3JldHVybihyPWlzRmluaXRlKHIpP3IlMzYwOjApPjA/cjpyKzM2MH0sYT1mdW5jdGlvbihyKXtyZXR1cm57cjplKHIuciwwLDI1NSksZzplKHIuZywwLDI1NSksYjplKHIuYiwwLDI1NSksYTplKHIuYSl9fSxvPWZ1bmN0aW9uKHIpe3JldHVybntyOm4oci5yKSxnOm4oci5nKSxiOm4oci5iKSxhOm4oci5hLDMpfX0saT0vXiMoWzAtOWEtZl17Myw4fSkkL2kscz1mdW5jdGlvbihyKXt2YXIgdD1yLnRvU3RyaW5nKDE2KTtyZXR1cm4gdC5sZW5ndGg8Mj9cIjBcIit0OnR9LGg9ZnVuY3Rpb24ocil7dmFyIHQ9ci5yLG49ci5nLGU9ci5iLHU9ci5hLGE9TWF0aC5tYXgodCxuLGUpLG89YS1NYXRoLm1pbih0LG4sZSksaT1vP2E9PT10PyhuLWUpL286YT09PW4/MisoZS10KS9vOjQrKHQtbikvbzowO3JldHVybntoOjYwKihpPDA/aSs2OmkpLHM6YT9vL2EqMTAwOjAsdjphLzI1NSoxMDAsYTp1fX0sYj1mdW5jdGlvbihyKXt2YXIgdD1yLmgsbj1yLnMsZT1yLnYsdT1yLmE7dD10LzM2MCo2LG4vPTEwMCxlLz0xMDA7dmFyIGE9TWF0aC5mbG9vcih0KSxvPWUqKDEtbiksaT1lKigxLSh0LWEpKm4pLHM9ZSooMS0oMS10K2EpKm4pLGg9YSU2O3JldHVybntyOjI1NSpbZSxpLG8sbyxzLGVdW2hdLGc6MjU1KltzLGUsZSxpLG8sb11baF0sYjoyNTUqW28sbyxzLGUsZSxpXVtoXSxhOnV9fSxnPWZ1bmN0aW9uKHIpe3JldHVybntoOnUoci5oKSxzOmUoci5zLDAsMTAwKSxsOmUoci5sLDAsMTAwKSxhOmUoci5hKX19LGQ9ZnVuY3Rpb24ocil7cmV0dXJue2g6bihyLmgpLHM6bihyLnMpLGw6bihyLmwpLGE6bihyLmEsMyl9fSxmPWZ1bmN0aW9uKHIpe3JldHVybiBiKChuPSh0PXIpLnMse2g6dC5oLHM6KG4qPSgoZT10LmwpPDUwP2U6MTAwLWUpLzEwMCk+MD8yKm4vKGUrbikqMTAwOjAsdjplK24sYTp0LmF9KSk7dmFyIHQsbixlfSxjPWZ1bmN0aW9uKHIpe3JldHVybntoOih0PWgocikpLmgsczoodT0oMjAwLShuPXQucykpKihlPXQudikvMTAwKT4wJiZ1PDIwMD9uKmUvMTAwLyh1PD0xMDA/dToyMDAtdSkqMTAwOjAsbDp1LzIsYTp0LmF9O3ZhciB0LG4sZSx1fSxsPS9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKShkZWd8cmFkfGdyYWR8dHVybik/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspJVxccyooPzosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHA9L15oc2xhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKGRlZ3xyYWR8Z3JhZHx0dXJuKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHY9L15yZ2JhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86LFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSxtPS9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHk9e3N0cmluZzpbW2Z1bmN0aW9uKHIpe3ZhciB0PWkuZXhlYyhyKTtyZXR1cm4gdD8ocj10WzFdKS5sZW5ndGg8PTQ/e3I6cGFyc2VJbnQoclswXStyWzBdLDE2KSxnOnBhcnNlSW50KHJbMV0rclsxXSwxNiksYjpwYXJzZUludChyWzJdK3JbMl0sMTYpLGE6ND09PXIubGVuZ3RoP24ocGFyc2VJbnQoclszXStyWzNdLDE2KS8yNTUsMik6MX06Nj09PXIubGVuZ3RofHw4PT09ci5sZW5ndGg/e3I6cGFyc2VJbnQoci5zdWJzdHIoMCwyKSwxNiksZzpwYXJzZUludChyLnN1YnN0cigyLDIpLDE2KSxiOnBhcnNlSW50KHIuc3Vic3RyKDQsMiksMTYpLGE6OD09PXIubGVuZ3RoP24ocGFyc2VJbnQoci5zdWJzdHIoNiwyKSwxNikvMjU1LDIpOjF9Om51bGw6bnVsbH0sXCJoZXhcIl0sW2Z1bmN0aW9uKHIpe3ZhciB0PXYuZXhlYyhyKXx8bS5leGVjKHIpO3JldHVybiB0P3RbMl0hPT10WzRdfHx0WzRdIT09dFs2XT9udWxsOmEoe3I6TnVtYmVyKHRbMV0pLyh0WzJdPzEwMC8yNTU6MSksZzpOdW1iZXIodFszXSkvKHRbNF0/MTAwLzI1NToxKSxiOk51bWJlcih0WzVdKS8odFs2XT8xMDAvMjU1OjEpLGE6dm9pZCAwPT09dFs3XT8xOk51bWJlcih0WzddKS8odFs4XT8xMDA6MSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24odCl7dmFyIG49bC5leGVjKHQpfHxwLmV4ZWModCk7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGUsdSxhPWcoe2g6KGU9blsxXSx1PW5bMl0sdm9pZCAwPT09dSYmKHU9XCJkZWdcIiksTnVtYmVyKGUpKihyW3VdfHwxKSksczpOdW1iZXIoblszXSksbDpOdW1iZXIobls0XSksYTp2b2lkIDA9PT1uWzVdPzE6TnVtYmVyKG5bNV0pLyhuWzZdPzEwMDoxKX0pO3JldHVybiBmKGEpfSxcImhzbFwiXV0sb2JqZWN0OltbZnVuY3Rpb24ocil7dmFyIG49ci5yLGU9ci5nLHU9ci5iLG89ci5hLGk9dm9pZCAwPT09bz8xOm87cmV0dXJuIHQobikmJnQoZSkmJnQodSk/YSh7cjpOdW1iZXIobiksZzpOdW1iZXIoZSksYjpOdW1iZXIodSksYTpOdW1iZXIoaSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGU9ci5zLHU9ci5sLGE9ci5hLG89dm9pZCAwPT09YT8xOmE7aWYoIXQobil8fCF0KGUpfHwhdCh1KSlyZXR1cm4gbnVsbDt2YXIgaT1nKHtoOk51bWJlcihuKSxzOk51bWJlcihlKSxsOk51bWJlcih1KSxhOk51bWJlcihvKX0pO3JldHVybiBmKGkpfSxcImhzbFwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGE9ci5zLG89ci52LGk9ci5hLHM9dm9pZCAwPT09aT8xOmk7aWYoIXQobil8fCF0KGEpfHwhdChvKSlyZXR1cm4gbnVsbDt2YXIgaD1mdW5jdGlvbihyKXtyZXR1cm57aDp1KHIuaCksczplKHIucywwLDEwMCksdjplKHIudiwwLDEwMCksYTplKHIuYSl9fSh7aDpOdW1iZXIobiksczpOdW1iZXIoYSksdjpOdW1iZXIobyksYTpOdW1iZXIocyl9KTtyZXR1cm4gYihoKX0sXCJoc3ZcIl1dfSxOPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBlPXRbbl1bMF0ocik7aWYoZSlyZXR1cm5bZSx0W25dWzFdXX1yZXR1cm5bbnVsbCx2b2lkIDBdfSx4PWZ1bmN0aW9uKHIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiByP04oci50cmltKCkseS5zdHJpbmcpOlwib2JqZWN0XCI9PXR5cGVvZiByJiZudWxsIT09cj9OKHIseS5vYmplY3QpOltudWxsLHZvaWQgMF19LEk9ZnVuY3Rpb24ocil7cmV0dXJuIHgocilbMV19LE09ZnVuY3Rpb24ocix0KXt2YXIgbj1jKHIpO3JldHVybntoOm4uaCxzOmUobi5zKzEwMCp0LDAsMTAwKSxsOm4ubCxhOm4uYX19LEg9ZnVuY3Rpb24ocil7cmV0dXJuKDI5OSpyLnIrNTg3KnIuZysxMTQqci5iKS8xZTMvMjU1fSwkPWZ1bmN0aW9uKHIsdCl7dmFyIG49YyhyKTtyZXR1cm57aDpuLmgsczpuLnMsbDplKG4ubCsxMDAqdCwwLDEwMCksYTpuLmF9fSxqPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyKXt0aGlzLnBhcnNlZD14KHIpWzBdLHRoaXMucmdiYT10aGlzLnBhcnNlZHx8e3I6MCxnOjAsYjowLGE6MX19cmV0dXJuIHIucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucGFyc2VkfSxyLnByb3RvdHlwZS5icmlnaHRuZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG4oSCh0aGlzLnJnYmEpLDIpfSxyLnByb3RvdHlwZS5pc0Rhcms9ZnVuY3Rpb24oKXtyZXR1cm4gSCh0aGlzLnJnYmEpPC41fSxyLnByb3RvdHlwZS5pc0xpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEgodGhpcy5yZ2JhKT49LjV9LHIucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHI9byh0aGlzLnJnYmEpLHQ9ci5yLGU9ci5nLHU9ci5iLGk9KGE9ci5hKTwxP3MobigyNTUqYSkpOlwiXCIsXCIjXCIrcyh0KStzKGUpK3ModSkraTt2YXIgcix0LGUsdSxhLGl9LHIucHJvdG90eXBlLnRvUmdiPWZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcy5yZ2JhKX0sci5wcm90b3R5cGUudG9SZ2JTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcj1vKHRoaXMucmdiYSksdD1yLnIsbj1yLmcsZT1yLmIsKHU9ci5hKTwxP1wicmdiYShcIit0K1wiLCBcIituK1wiLCBcIitlK1wiLCBcIit1K1wiKVwiOlwicmdiKFwiK3QrXCIsIFwiK24rXCIsIFwiK2UrXCIpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic2w9ZnVuY3Rpb24oKXtyZXR1cm4gZChjKHRoaXMucmdiYSkpfSxyLnByb3RvdHlwZS50b0hzbFN0cmluZz1mdW5jdGlvbigpe3JldHVybiByPWQoYyh0aGlzLnJnYmEpKSx0PXIuaCxuPXIucyxlPXIubCwodT1yLmEpPDE/XCJoc2xhKFwiK3QrXCIsIFwiK24rXCIlLCBcIitlK1wiJSwgXCIrdStcIilcIjpcImhzbChcIit0K1wiLCBcIituK1wiJSwgXCIrZStcIiUpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic3Y9ZnVuY3Rpb24oKXtyZXR1cm4gcj1oKHRoaXMucmdiYSkse2g6bihyLmgpLHM6bihyLnMpLHY6bihyLnYpLGE6bihyLmEsMyl9O3ZhciByfSxyLnByb3RvdHlwZS5pbnZlcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdyh7cjoyNTUtKHI9dGhpcy5yZ2JhKS5yLGc6MjU1LXIuZyxiOjI1NS1yLmIsYTpyLmF9KTt2YXIgcn0sci5wcm90b3R5cGUuc2F0dXJhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KE0odGhpcy5yZ2JhLHIpKX0sci5wcm90b3R5cGUuZGVzYXR1cmF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoTSh0aGlzLnJnYmEsLXIpKX0sci5wcm90b3R5cGUuZ3JheXNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHcoTSh0aGlzLnJnYmEsLTEpKX0sci5wcm90b3R5cGUubGlnaHRlbj1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoJCh0aGlzLnJnYmEscikpfSxyLnByb3RvdHlwZS5kYXJrZW49ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KCQodGhpcy5yZ2JhLC1yKSl9LHIucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MTUpLHRoaXMuaHVlKHRoaXMuaHVlKCkrcil9LHIucHJvdG90eXBlLmFscGhhPWZ1bmN0aW9uKHIpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByP3coe3I6KHQ9dGhpcy5yZ2JhKS5yLGc6dC5nLGI6dC5iLGE6cn0pOm4odGhpcy5yZ2JhLmEsMyk7dmFyIHR9LHIucHJvdG90eXBlLmh1ZT1mdW5jdGlvbihyKXt2YXIgdD1jKHRoaXMucmdiYSk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/dyh7aDpyLHM6dC5zLGw6dC5sLGE6dC5hfSk6bih0LmgpfSxyLnByb3RvdHlwZS5pc0VxdWFsPWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvSGV4KCk9PT13KHIpLnRvSGV4KCl9LHJ9KCksdz1mdW5jdGlvbihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIGo/cjpuZXcgaihyKX0sUz1bXSxrPWZ1bmN0aW9uKHIpe3IuZm9yRWFjaChmdW5jdGlvbihyKXtTLmluZGV4T2Yocik8MCYmKHIoaix5KSxTLnB1c2gocikpfSl9LEU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGooe3I6MjU1Kk1hdGgucmFuZG9tKCksZzoyNTUqTWF0aC5yYW5kb20oKSxiOjI1NSpNYXRoLnJhbmRvbSgpfSl9O2V4cG9ydHtqIGFzIENvbG9yZCx3IGFzIGNvbG9yZCxrIGFzIGV4dGVuZCxJIGFzIGdldEZvcm1hdCxFIGFzIHJhbmRvbX07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlLGYpe3ZhciBhPXt3aGl0ZTpcIiNmZmZmZmZcIixiaXNxdWU6XCIjZmZlNGM0XCIsYmx1ZTpcIiMwMDAwZmZcIixjYWRldGJsdWU6XCIjNWY5ZWEwXCIsY2hhcnRyZXVzZTpcIiM3ZmZmMDBcIixjaG9jb2xhdGU6XCIjZDI2OTFlXCIsY29yYWw6XCIjZmY3ZjUwXCIsYW50aXF1ZXdoaXRlOlwiI2ZhZWJkN1wiLGFxdWE6XCIjMDBmZmZmXCIsYXp1cmU6XCIjZjBmZmZmXCIsd2hpdGVzbW9rZTpcIiNmNWY1ZjVcIixwYXBheWF3aGlwOlwiI2ZmZWZkNVwiLHBsdW06XCIjZGRhMGRkXCIsYmxhbmNoZWRhbG1vbmQ6XCIjZmZlYmNkXCIsYmxhY2s6XCIjMDAwMDAwXCIsZ29sZDpcIiNmZmQ3MDBcIixnb2xkZW5yb2Q6XCIjZGFhNTIwXCIsZ2FpbnNib3JvOlwiI2RjZGNkY1wiLGNvcm5zaWxrOlwiI2ZmZjhkY1wiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVlZFwiLGJ1cmx5d29vZDpcIiNkZWI4ODdcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGNyaW1zb246XCIjZGMxNDNjXCIsY3lhbjpcIiMwMGZmZmZcIixkYXJrYmx1ZTpcIiMwMDAwOGJcIixkYXJrY3lhbjpcIiMwMDhiOGJcIixkYXJrZ29sZGVucm9kOlwiI2I4ODYwYlwiLGRhcmtraGFraTpcIiNiZGI3NmJcIixkYXJrZ3JheTpcIiNhOWE5YTlcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsZGFya2dyZXk6XCIjYTlhOWE5XCIscGVhY2hwdWZmOlwiI2ZmZGFiOVwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLGRhcmtyZWQ6XCIjOGIwMDAwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkYXJrb3JhbmdlOlwiI2ZmOGMwMFwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzZDhiXCIsZ3JheTpcIiM4MDgwODBcIixkYXJrc2xhdGVncmF5OlwiIzJmNGY0ZlwiLGRhcmtzbGF0ZWdyZXk6XCIjMmY0ZjRmXCIsZGVlcHBpbms6XCIjZmYxNDkzXCIsZGVlcHNreWJsdWU6XCIjMDBiZmZmXCIsd2hlYXQ6XCIjZjVkZWIzXCIsZmlyZWJyaWNrOlwiI2IyMjIyMlwiLGZsb3JhbHdoaXRlOlwiI2ZmZmFmMFwiLGdob3N0d2hpdGU6XCIjZjhmOGZmXCIsZGFya3Zpb2xldDpcIiM5NDAwZDNcIixtYWdlbnRhOlwiI2ZmMDBmZlwiLGdyZWVuOlwiIzAwODAwMFwiLGRvZGdlcmJsdWU6XCIjMWU5MGZmXCIsZ3JleTpcIiM4MDgwODBcIixob25leWRldzpcIiNmMGZmZjBcIixob3RwaW5rOlwiI2ZmNjliNFwiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsZm9yZXN0Z3JlZW46XCIjMjI4YjIyXCIsbGF3bmdyZWVuOlwiIzdjZmMwMFwiLGluZGlhbnJlZDpcIiNjZDVjNWNcIixpbmRpZ286XCIjNGIwMDgyXCIsZnVjaHNpYTpcIiNmZjAwZmZcIixicm93bjpcIiNhNTJhMmFcIixtYXJvb246XCIjODAwMDAwXCIsbWVkaXVtYmx1ZTpcIiMwMDAwY2RcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLGRhcmt0dXJxdW9pc2U6XCIjMDBjZWQxXCIsbGlnaHRjeWFuOlwiI2UwZmZmZlwiLGl2b3J5OlwiI2ZmZmZmMFwiLGxpZ2h0eWVsbG93OlwiI2ZmZmZlMFwiLGxpZ2h0c2FsbW9uOlwiI2ZmYTA3YVwiLGxpZ2h0c2VhZ3JlZW46XCIjMjBiMmFhXCIsbGluZW46XCIjZmFmMGU2XCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixsZW1vbmNoaWZmb246XCIjZmZmYWNkXCIsbGltZTpcIiMwMGZmMDBcIixraGFraTpcIiNmMGU2OGNcIixtZWRpdW1zZWFncmVlbjpcIiMzY2IzNzFcIixsaW1lZ3JlZW46XCIjMzJjZDMyXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBmYTlhXCIsbGlnaHRza3libHVlOlwiIzg3Y2VmYVwiLGxpZ2h0Ymx1ZTpcIiNhZGQ4ZTZcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbGlnaHRwaW5rOlwiI2ZmYjZjMVwiLG1pc3R5cm9zZTpcIiNmZmU0ZTFcIixtb2NjYXNpbjpcIiNmZmU0YjVcIixtaW50Y3JlYW06XCIjZjVmZmZhXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbmF2YWpvd2hpdGU6XCIjZmZkZWFkXCIsbmF2eTpcIiMwMDAwODBcIixtZWRpdW12aW9sZXRyZWQ6XCIjYzcxNTg1XCIscG93ZGVyYmx1ZTpcIiNiMGUwZTZcIixwYWxlZ29sZGVucm9kOlwiI2VlZThhYVwiLG9sZGxhY2U6XCIjZmRmNWU2XCIscGFsZXR1cnF1b2lzZTpcIiNhZmVlZWVcIixtZWRpdW10dXJxdW9pc2U6XCIjNDhkMWNjXCIsbWVkaXVtb3JjaGlkOlwiI2JhNTVkM1wiLHJlYmVjY2FwdXJwbGU6XCIjNjYzMzk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLHRoaXN0bGU6XCIjZDhiZmQ4XCIsdGFuOlwiI2QyYjQ4Y1wiLG9yY2hpZDpcIiNkYTcwZDZcIixtZWRpdW1wdXJwbGU6XCIjOTM3MGRiXCIscHVycGxlOlwiIzgwMDA4MFwiLHBpbms6XCIjZmZjMGNiXCIsc2t5Ymx1ZTpcIiM4N2NlZWJcIixzcHJpbmdncmVlbjpcIiMwMGZmN2ZcIixwYWxlZ3JlZW46XCIjOThmYjk4XCIscmVkOlwiI2ZmMDAwMFwiLHllbGxvdzpcIiNmZmZmMDBcIixzbGF0ZWJsdWU6XCIjNmE1YWNkXCIsbGF2ZW5kZXJibHVzaDpcIiNmZmYwZjVcIixwZXJ1OlwiI2NkODUzZlwiLHBhbGV2aW9sZXRyZWQ6XCIjZGI3MDkzXCIsdmlvbGV0OlwiI2VlODJlZVwiLHRlYWw6XCIjMDA4MDgwXCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixhbGljZWJsdWU6XCIjZjBmOGZmXCIsZGFya3NlYWdyZWVuOlwiIzhmYmM4ZlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLGdyZWVueWVsbG93OlwiI2FkZmYyZlwiLHNlYWdyZWVuOlwiIzJlOGI1N1wiLHNlYXNoZWxsOlwiI2ZmZjVlZVwiLHRvbWF0bzpcIiNmZjYzNDdcIixzaWx2ZXI6XCIjYzBjMGMwXCIsc2llbm5hOlwiI2EwNTIyZFwiLGxhdmVuZGVyOlwiI2U2ZTZmYVwiLGxpZ2h0Z3JlZW46XCIjOTBlZTkwXCIsb3JhbmdlOlwiI2ZmYTUwMFwiLG9yYW5nZXJlZDpcIiNmZjQ1MDBcIixzdGVlbGJsdWU6XCIjNDY4MmI0XCIscm95YWxibHVlOlwiIzQxNjllMVwiLHR1cnF1b2lzZTpcIiM0MGUwZDBcIix5ZWxsb3dncmVlbjpcIiM5YWNkMzJcIixzYWxtb246XCIjZmE4MDcyXCIsc2FkZGxlYnJvd246XCIjOGI0NTEzXCIsc2FuZHlicm93bjpcIiNmNGE0NjBcIixyb3N5YnJvd246XCIjYmM4ZjhmXCIsZGFya3NhbG1vbjpcIiNlOTk2N2FcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNmYWZhZDJcIixzbm93OlwiI2ZmZmFmYVwiLGxpZ2h0Z3JleTpcIiNkM2QzZDNcIixsaWdodGdyYXk6XCIjZDNkM2QzXCIsZGltZ3JheTpcIiM2OTY5NjlcIixkaW1ncmV5OlwiIzY5Njk2OVwiLG9saXZlZHJhYjpcIiM2YjhlMjNcIixvbGl2ZTpcIiM4MDgwMDBcIn0scj17fTtmb3IodmFyIGQgaW4gYSlyW2FbZF1dPWQ7dmFyIGw9e307ZS5wcm90b3R5cGUudG9OYW1lPWZ1bmN0aW9uKGYpe2lmKCEodGhpcy5yZ2JhLmF8fHRoaXMucmdiYS5yfHx0aGlzLnJnYmEuZ3x8dGhpcy5yZ2JhLmIpKXJldHVyblwidHJhbnNwYXJlbnRcIjt2YXIgZCxpLG49clt0aGlzLnRvSGV4KCldO2lmKG4pcmV0dXJuIG47aWYobnVsbD09Zj92b2lkIDA6Zi5jbG9zZXN0KXt2YXIgbz10aGlzLnRvUmdiKCksdD0xLzAsYj1cImJsYWNrXCI7aWYoIWwubGVuZ3RoKWZvcih2YXIgYyBpbiBhKWxbY109bmV3IGUoYVtjXSkudG9SZ2IoKTtmb3IodmFyIGcgaW4gYSl7dmFyIHU9KGQ9byxpPWxbZ10sTWF0aC5wb3coZC5yLWkuciwyKStNYXRoLnBvdyhkLmctaS5nLDIpK01hdGgucG93KGQuYi1pLmIsMikpO3U8dCYmKHQ9dSxiPWcpfXJldHVybiBifX07Zi5zdHJpbmcucHVzaChbZnVuY3Rpb24oZil7dmFyIHI9Zi50b0xvd2VyQ2FzZSgpLGQ9XCJ0cmFuc3BhcmVudFwiPT09cj9cIiMwMDAwXCI6YVtyXTtyZXR1cm4gZD9uZXcgZShkKS50b1JnYigpOm51bGx9LFwibmFtZVwiXSl9XG4iLCJpbXBvcnQgeyBleHRlbmQsIGNvbG9yZCB9IGZyb20gJ2NvbG9yZCc7XG5pbXBvcnQgbmFtZXNQbHVnaW4gZnJvbSAnY29sb3JkL3BsdWdpbnMvbmFtZXMnO1xuXG5leHRlbmQoW25hbWVzUGx1Z2luXSk7XG5jb25zdCBfQ29sb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlID0gMTY3NzcyMTUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgdGhpcy5fY29tcG9uZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgdGhpcy5fY29tcG9uZW50cy5maWxsKDEpO1xuICAgIHRoaXMuX2ludCA9IDE2Nzc3MjE1O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzBdO1xuICB9XG4gIGdldCBncmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1sxXTtcbiAgfVxuICBnZXQgYmx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1syXTtcbiAgfVxuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbM107XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX0NvbG9yKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY2xvbmVTb3VyY2UodmFsdWUuX3ZhbHVlKTtcbiAgICAgIHRoaXMuX2ludCA9IHZhbHVlLl9pbnQ7XG4gICAgICB0aGlzLl9jb21wb25lbnRzLnNldCh2YWx1ZS5fY29tcG9uZW50cyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBQSVhJLkNvbG9yI3ZhbHVlIHRvIG51bGxcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLl92YWx1ZSA9PT0gbnVsbCB8fCAhdGhpcy5pc1NvdXJjZUVxdWFsKHRoaXMuX3ZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHRoaXMubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5jbG9uZVNvdXJjZSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgY2xvbmVTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyAuLi52YWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaXNTb3VyY2VFcXVhbCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIGNvbnN0IHR5cGUxID0gdHlwZW9mIHZhbHVlMTtcbiAgICBjb25zdCB0eXBlMiA9IHR5cGVvZiB2YWx1ZTI7XG4gICAgaWYgKHR5cGUxICE9PSB0eXBlMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZTEgPT09IFwibnVtYmVyXCIgfHwgdHlwZTEgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUxIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTEpICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTIpKSB7XG4gICAgICBpZiAodmFsdWUxLmxlbmd0aCAhPT0gdmFsdWUyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSB2YWx1ZTJbaV0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUxICE9PSBudWxsICYmIHZhbHVlMiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyh2YWx1ZTEpO1xuICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyh2YWx1ZTIpO1xuICAgICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzMS5ldmVyeSgoa2V5KSA9PiB2YWx1ZTFba2V5XSA9PT0gdmFsdWUyW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gIH1cbiAgdG9SZ2JhKCkge1xuICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIHsgciwgZywgYiwgYSB9O1xuICB9XG4gIHRvUmdiKCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIHsgciwgZywgYiB9O1xuICB9XG4gIHRvUmdiYVN0cmluZygpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiBgcmdiYSgke3J9LCR7Z30sJHtifSwke3RoaXMuYWxwaGF9KWA7XG4gIH1cbiAgdG9VaW50OFJnYkFycmF5KG91dCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgb3V0ID0gb3V0ID8/IFtdO1xuICAgIG91dFswXSA9IE1hdGgucm91bmQociAqIDI1NSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBvdXRbMl0gPSBNYXRoLnJvdW5kKGIgKiAyNTUpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9SZ2JBcnJheShvdXQpIHtcbiAgICBvdXQgPSBvdXQgPz8gW107XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHRvTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnQ7XG4gIH1cbiAgdG9MaXR0bGVFbmRpYW5OdW1iZXIoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9pbnQ7XG4gICAgcmV0dXJuICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiA2NTI4MCkgKyAoKHZhbHVlICYgMjU1KSA8PCAxNik7XG4gIH1cbiAgbXVsdGlwbHkodmFsdWUpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSBfQ29sb3IudGVtcC5zZXRWYWx1ZSh2YWx1ZSkuX2NvbXBvbmVudHM7XG4gICAgdGhpcy5fY29tcG9uZW50c1swXSAqPSByO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMV0gKj0gZztcbiAgICB0aGlzLl9jb21wb25lbnRzWzJdICo9IGI7XG4gICAgdGhpcy5fY29tcG9uZW50c1szXSAqPSBhO1xuICAgIHRoaXMucmVmcmVzaEludCgpO1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwcmVtdWx0aXBseShhbHBoYSwgYXBwbHlUb1JHQiA9IHRydWUpIHtcbiAgICBpZiAoYXBwbHlUb1JHQikge1xuICAgICAgdGhpcy5fY29tcG9uZW50c1swXSAqPSBhbHBoYTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMV0gKj0gYWxwaGE7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzJdICo9IGFscGhhO1xuICAgIH1cbiAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gYWxwaGE7XG4gICAgdGhpcy5yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvUHJlbXVsdGlwbGllZChhbHBoYSkge1xuICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgcmV0dXJuIChhbHBoYSAqIDI1NSA8PCAyNCkgKyB0aGlzLl9pbnQ7XG4gICAgfVxuICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCByID0gdGhpcy5faW50ID4+IDE2ICYgMjU1O1xuICAgIGxldCBnID0gdGhpcy5faW50ID4+IDggJiAyNTU7XG4gICAgbGV0IGIgPSB0aGlzLl9pbnQgJiAyNTU7XG4gICAgciA9IHIgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgZyA9IGcgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgYiA9IGIgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgcmV0dXJuIChhbHBoYSAqIDI1NSA8PCAyNCkgKyAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgY29uc3QgaGV4U3RyaW5nID0gdGhpcy5faW50LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gYCMke1wiMDAwMDAwXCIuc3Vic3RyaW5nKDAsIDYgLSBoZXhTdHJpbmcubGVuZ3RoKSArIGhleFN0cmluZ31gO1xuICB9XG4gIHRvSGV4YSgpIHtcbiAgICBjb25zdCBhbHBoYVZhbHVlID0gTWF0aC5yb3VuZCh0aGlzLl9jb21wb25lbnRzWzNdICogMjU1KTtcbiAgICBjb25zdCBhbHBoYVN0cmluZyA9IGFscGhhVmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiB0aGlzLnRvSGV4KCkgKyBcIjAwXCIuc3Vic3RyaW5nKDAsIDIgLSBhbHBoYVN0cmluZy5sZW5ndGgpICsgYWxwaGFTdHJpbmc7XG4gIH1cbiAgc2V0QWxwaGEoYWxwaGEpIHtcbiAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gdGhpcy5fY2xhbXAoYWxwaGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kKHN0ZXBzKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB0aGlzLl9jb21wb25lbnRzWzBdID0gTWF0aC5yb3VuZChyICogc3RlcHMpIC8gc3RlcHM7XG4gICAgdGhpcy5fY29tcG9uZW50c1sxXSA9IE1hdGgucm91bmQoZyAqIHN0ZXBzKSAvIHN0ZXBzO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gPSBNYXRoLnJvdW5kKGIgKiBzdGVwcykgLyBzdGVwcztcbiAgICB0aGlzLnJlZnJlc2hJbnQoKTtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9BcnJheShvdXQpIHtcbiAgICBvdXQgPSBvdXQgPz8gW107XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICBvdXRbM10gPSBhO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgbm9ybWFsaXplKHZhbHVlKSB7XG4gICAgbGV0IGNvbXBvbmVudHM7XG4gICAgaWYgKCh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTY3NzcyMTUpIHtcbiAgICAgIGNvbnN0IGludCA9IHZhbHVlO1xuICAgICAgY29tcG9uZW50cyA9IFtcbiAgICAgICAgKGludCA+PiAxNiAmIDI1NSkgLyAyNTUsXG4gICAgICAgIChpbnQgPj4gOCAmIDI1NSkgLyAyNTUsXG4gICAgICAgIChpbnQgJiAyNTUpIC8gMjU1LFxuICAgICAgICAxXG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAoKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSAmJiB2YWx1ZS5sZW5ndGggPj0gMyAmJiB2YWx1ZS5sZW5ndGggPD0gNCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jbGFtcCh2YWx1ZSk7XG4gICAgICBjb25zdCBbciwgZywgYiwgYSA9IDFdID0gdmFsdWU7XG4gICAgICBjb21wb25lbnRzID0gW3IsIGcsIGIsIGFdO1xuICAgIH0gZWxzZSBpZiAoKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAmJiB2YWx1ZS5sZW5ndGggPj0gMyAmJiB2YWx1ZS5sZW5ndGggPD0gNCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jbGFtcCh2YWx1ZSwgMCwgMjU1KTtcbiAgICAgIGNvbnN0IFtyLCBnLCBiLCBhID0gMjU1XSA9IHZhbHVlO1xuICAgICAgY29tcG9uZW50cyA9IFtyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhIC8gMjU1XTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfQ29sb3IuSEVYX1BBVFRFUk4uZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhbHVlID0gYCMke21hdGNoWzJdfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JkKHZhbHVlKTtcbiAgICAgIGlmIChjb2xvci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgY29uc3QgeyByLCBnLCBiLCBhIH0gPSBjb2xvci5yZ2JhO1xuICAgICAgICBjb21wb25lbnRzID0gW3IgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTUsIGFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgdGhpcy5fY29tcG9uZW50cy5zZXQoY29tcG9uZW50cyk7XG4gICAgICB0aGlzLnJlZnJlc2hJbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29udmVydCBjb2xvciAke3ZhbHVlfWApO1xuICAgIH1cbiAgfVxuICByZWZyZXNoSW50KCkge1xuICAgIHRoaXMuX2NsYW1wKHRoaXMuX2NvbXBvbmVudHMpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdGhpcy5faW50ID0gKHIgKiAyNTUgPDwgMTYpICsgKGcgKiAyNTUgPDwgOCkgKyAoYiAqIDI1NSB8IDApO1xuICB9XG4gIF9jbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICB9XG4gICAgdmFsdWUuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgdmFsdWVbaV0gPSBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcbmxldCBDb2xvciA9IF9Db2xvcjtcbkNvbG9yLnNoYXJlZCA9IG5ldyBfQ29sb3IoKTtcbkNvbG9yLnRlbXAgPSBuZXcgX0NvbG9yKCk7XG5Db2xvci5IRVhfUEFUVEVSTiA9IC9eKCN8MHgpPygoW2EtZjAtOV17M30pezEsMn0oW2EtZjAtOV17Mn0pPykkL2k7XG5cbmV4cG9ydCB7IENvbG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvci5tanMubWFwXG4iLCJleHBvcnQgeyBDb2xvciB9IGZyb20gJy4vQ29sb3IubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///126\n')},361:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "A7": () => (/* binding */ MASK_TYPES),\n/* harmony export */   "G5": () => (/* binding */ MSAA_QUALITY),\n/* harmony export */   "I2": () => (/* binding */ FORMATS),\n/* harmony export */   "N3": () => (/* binding */ RENDERER_TYPE),\n/* harmony export */   "Nt": () => (/* binding */ WRAP_MODES),\n/* harmony export */   "T$": () => (/* binding */ BLEND_MODES),\n/* harmony export */   "UN": () => (/* binding */ GC_MODES),\n/* harmony export */   "V0": () => (/* binding */ BUFFER_BITS),\n/* harmony export */   "Vi": () => (/* binding */ ENV),\n/* harmony export */   "WB": () => (/* binding */ MIPMAP_MODES),\n/* harmony export */   "aH": () => (/* binding */ SCALE_MODES),\n/* harmony export */   "cB": () => (/* binding */ PRECISION),\n/* harmony export */   "iw": () => (/* binding */ ALPHA_MODES),\n/* harmony export */   "lg": () => (/* binding */ DRAW_MODES),\n/* harmony export */   "mr": () => (/* binding */ BUFFER_TYPE),\n/* harmony export */   "oT": () => (/* binding */ SAMPLER_TYPES),\n/* harmony export */   "sp": () => (/* binding */ TARGETS),\n/* harmony export */   "vK": () => (/* binding */ TYPES),\n/* harmony export */   "yl": () => (/* binding */ CLEAR_MODES)\n/* harmony export */ });\n/* unused harmony export COLOR_MASK_BITS */\nvar ENV = /* @__PURE__ */ ((ENV2) => {\n  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";\n  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";\n  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";\n  return ENV2;\n})(ENV || {});\nvar RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {\n  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";\n  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";\n  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";\n  return RENDERER_TYPE2;\n})(RENDERER_TYPE || {});\nvar BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {\n  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";\n  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";\n  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";\n  return BUFFER_BITS2;\n})(BUFFER_BITS || {});\nvar BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {\n  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";\n  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";\n  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";\n  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";\n  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";\n  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";\n  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";\n  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";\n  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";\n  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";\n  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";\n  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";\n  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";\n  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";\n  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";\n  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";\n  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";\n  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";\n  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";\n  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";\n  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";\n  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";\n  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";\n  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";\n  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";\n  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";\n  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";\n  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";\n  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";\n  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";\n  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";\n  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";\n  return BLEND_MODES2;\n})(BLEND_MODES || {});\nvar DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {\n  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";\n  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";\n  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";\n  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";\n  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";\n  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";\n  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";\n  return DRAW_MODES2;\n})(DRAW_MODES || {});\nvar FORMATS = /* @__PURE__ */ ((FORMATS2) => {\n  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";\n  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";\n  FORMATS2[FORMATS2["RG"] = 33319] = "RG";\n  FORMATS2[FORMATS2["RED"] = 6403] = "RED";\n  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";\n  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";\n  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";\n  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";\n  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";\n  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";\n  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";\n  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";\n  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";\n  return FORMATS2;\n})(FORMATS || {});\nvar TARGETS = /* @__PURE__ */ ((TARGETS2) => {\n  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";\n  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";\n  return TARGETS2;\n})(TARGETS || {});\nvar TYPES = /* @__PURE__ */ ((TYPES2) => {\n  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";\n  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";\n  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";\n  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";\n  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";\n  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";\n  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";\n  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";\n  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";\n  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";\n  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";\n  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";\n  TYPES2[TYPES2["INT"] = 5124] = "INT";\n  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";\n  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";\n  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";\n  return TYPES2;\n})(TYPES || {});\nvar SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {\n  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";\n  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";\n  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";\n  return SAMPLER_TYPES2;\n})(SAMPLER_TYPES || {});\nvar SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {\n  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";\n  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";\n  return SCALE_MODES2;\n})(SCALE_MODES || {});\nvar WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {\n  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";\n  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";\n  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";\n  return WRAP_MODES2;\n})(WRAP_MODES || {});\nvar MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {\n  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";\n  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";\n  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";\n  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";\n  return MIPMAP_MODES2;\n})(MIPMAP_MODES || {});\nvar ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {\n  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";\n  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";\n  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";\n  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";\n  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";\n  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";\n  return ALPHA_MODES2;\n})(ALPHA_MODES || {});\nvar CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {\n  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";\n  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";\n  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";\n  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";\n  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";\n  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";\n  return CLEAR_MODES2;\n})(CLEAR_MODES || {});\nvar GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {\n  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";\n  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";\n  return GC_MODES2;\n})(GC_MODES || {});\nvar PRECISION = /* @__PURE__ */ ((PRECISION2) => {\n  PRECISION2["LOW"] = "lowp";\n  PRECISION2["MEDIUM"] = "mediump";\n  PRECISION2["HIGH"] = "highp";\n  return PRECISION2;\n})(PRECISION || {});\nvar MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {\n  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";\n  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";\n  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";\n  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";\n  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";\n  return MASK_TYPES2;\n})(MASK_TYPES || {});\nvar COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {\n  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";\n  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";\n  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";\n  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";\n  return COLOR_MASK_BITS2;\n})(COLOR_MASK_BITS || {});\nvar MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {\n  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";\n  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";\n  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";\n  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";\n  return MSAA_QUALITY2;\n})(MSAA_QUALITY || {});\nvar BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {\n  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";\n  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";\n  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";\n  return BUFFER_TYPE2;\n})(BUFFER_TYPE || {});\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxXQUFXO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1COztBQUVzTztBQUMxUCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb25zdGFudHMvbGliL2luZGV4Lm1qcz8xOWY4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBFTlYgPSAvKiBAX19QVVJFX18gKi8gKChFTlYyKSA9PiB7XG4gIEVOVjJbRU5WMltcIldFQkdMX0xFR0FDWVwiXSA9IDBdID0gXCJXRUJHTF9MRUdBQ1lcIjtcbiAgRU5WMltFTlYyW1wiV0VCR0xcIl0gPSAxXSA9IFwiV0VCR0xcIjtcbiAgRU5WMltFTlYyW1wiV0VCR0wyXCJdID0gMl0gPSBcIldFQkdMMlwiO1xuICByZXR1cm4gRU5WMjtcbn0pKEVOViB8fCB7fSk7XG52YXIgUkVOREVSRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJFTkRFUkVSX1RZUEUyKSA9PiB7XG4gIFJFTkRFUkVSX1RZUEUyW1JFTkRFUkVSX1RZUEUyW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XG4gIFJFTkRFUkVSX1RZUEUyW1JFTkRFUkVSX1RZUEUyW1wiV0VCR0xcIl0gPSAxXSA9IFwiV0VCR0xcIjtcbiAgUkVOREVSRVJfVFlQRTJbUkVOREVSRVJfVFlQRTJbXCJDQU5WQVNcIl0gPSAyXSA9IFwiQ0FOVkFTXCI7XG4gIHJldHVybiBSRU5ERVJFUl9UWVBFMjtcbn0pKFJFTkRFUkVSX1RZUEUgfHwge30pO1xudmFyIEJVRkZFUl9CSVRTID0gLyogQF9fUFVSRV9fICovICgoQlVGRkVSX0JJVFMyKSA9PiB7XG4gIEJVRkZFUl9CSVRTMltCVUZGRVJfQklUUzJbXCJDT0xPUlwiXSA9IDE2Mzg0XSA9IFwiQ09MT1JcIjtcbiAgQlVGRkVSX0JJVFMyW0JVRkZFUl9CSVRTMltcIkRFUFRIXCJdID0gMjU2XSA9IFwiREVQVEhcIjtcbiAgQlVGRkVSX0JJVFMyW0JVRkZFUl9CSVRTMltcIlNURU5DSUxcIl0gPSAxMDI0XSA9IFwiU1RFTkNJTFwiO1xuICByZXR1cm4gQlVGRkVSX0JJVFMyO1xufSkoQlVGRkVSX0JJVFMgfHwge30pO1xudmFyIEJMRU5EX01PREVTID0gLyogQF9fUFVSRV9fICovICgoQkxFTkRfTU9ERVMyKSA9PiB7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJOT1JNQUxcIl0gPSAwXSA9IFwiTk9STUFMXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJBRERcIl0gPSAxXSA9IFwiQUREXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJNVUxUSVBMWVwiXSA9IDJdID0gXCJNVUxUSVBMWVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU0NSRUVOXCJdID0gM10gPSBcIlNDUkVFTlwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiT1ZFUkxBWVwiXSA9IDRdID0gXCJPVkVSTEFZXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEQVJLRU5cIl0gPSA1XSA9IFwiREFSS0VOXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJMSUdIVEVOXCJdID0gNl0gPSBcIkxJR0hURU5cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkNPTE9SX0RPREdFXCJdID0gN10gPSBcIkNPTE9SX0RPREdFXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJDT0xPUl9CVVJOXCJdID0gOF0gPSBcIkNPTE9SX0JVUk5cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkhBUkRfTElHSFRcIl0gPSA5XSA9IFwiSEFSRF9MSUdIVFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU09GVF9MSUdIVFwiXSA9IDEwXSA9IFwiU09GVF9MSUdIVFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiRElGRkVSRU5DRVwiXSA9IDExXSA9IFwiRElGRkVSRU5DRVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiRVhDTFVTSU9OXCJdID0gMTJdID0gXCJFWENMVVNJT05cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkhVRVwiXSA9IDEzXSA9IFwiSFVFXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJTQVRVUkFUSU9OXCJdID0gMTRdID0gXCJTQVRVUkFUSU9OXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJDT0xPUlwiXSA9IDE1XSA9IFwiQ09MT1JcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkxVTUlOT1NJVFlcIl0gPSAxNl0gPSBcIkxVTUlOT1NJVFlcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIk5PUk1BTF9OUE1cIl0gPSAxN10gPSBcIk5PUk1BTF9OUE1cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkFERF9OUE1cIl0gPSAxOF0gPSBcIkFERF9OUE1cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNDUkVFTl9OUE1cIl0gPSAxOV0gPSBcIlNDUkVFTl9OUE1cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIk5PTkVcIl0gPSAyMF0gPSBcIk5PTkVcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNSQ19PVkVSXCJdID0gMF0gPSBcIlNSQ19PVkVSXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJTUkNfSU5cIl0gPSAyMV0gPSBcIlNSQ19JTlwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU1JDX09VVFwiXSA9IDIyXSA9IFwiU1JDX09VVFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU1JDX0FUT1BcIl0gPSAyM10gPSBcIlNSQ19BVE9QXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEU1RfT1ZFUlwiXSA9IDI0XSA9IFwiRFNUX09WRVJcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkRTVF9JTlwiXSA9IDI1XSA9IFwiRFNUX0lOXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEU1RfT1VUXCJdID0gMjZdID0gXCJEU1RfT1VUXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEU1RfQVRPUFwiXSA9IDI3XSA9IFwiRFNUX0FUT1BcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkVSQVNFXCJdID0gMjZdID0gXCJFUkFTRVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU1VCVFJBQ1RcIl0gPSAyOF0gPSBcIlNVQlRSQUNUXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJYT1JcIl0gPSAyOV0gPSBcIlhPUlwiO1xuICByZXR1cm4gQkxFTkRfTU9ERVMyO1xufSkoQkxFTkRfTU9ERVMgfHwge30pO1xudmFyIERSQVdfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChEUkFXX01PREVTMikgPT4ge1xuICBEUkFXX01PREVTMltEUkFXX01PREVTMltcIlBPSU5UU1wiXSA9IDBdID0gXCJQT0lOVFNcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJMSU5FU1wiXSA9IDFdID0gXCJMSU5FU1wiO1xuICBEUkFXX01PREVTMltEUkFXX01PREVTMltcIkxJTkVfTE9PUFwiXSA9IDJdID0gXCJMSU5FX0xPT1BcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJMSU5FX1NUUklQXCJdID0gM10gPSBcIkxJTkVfU1RSSVBcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJUUklBTkdMRVNcIl0gPSA0XSA9IFwiVFJJQU5HTEVTXCI7XG4gIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyW1wiVFJJQU5HTEVfU1RSSVBcIl0gPSA1XSA9IFwiVFJJQU5HTEVfU1RSSVBcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJUUklBTkdMRV9GQU5cIl0gPSA2XSA9IFwiVFJJQU5HTEVfRkFOXCI7XG4gIHJldHVybiBEUkFXX01PREVTMjtcbn0pKERSQVdfTU9ERVMgfHwge30pO1xudmFyIEZPUk1BVFMgPSAvKiBAX19QVVJFX18gKi8gKChGT1JNQVRTMikgPT4ge1xuICBGT1JNQVRTMltGT1JNQVRTMltcIlJHQkFcIl0gPSA2NDA4XSA9IFwiUkdCQVwiO1xuICBGT1JNQVRTMltGT1JNQVRTMltcIlJHQlwiXSA9IDY0MDddID0gXCJSR0JcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSR1wiXSA9IDMzMzE5XSA9IFwiUkdcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSRURcIl0gPSA2NDAzXSA9IFwiUkVEXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiUkdCQV9JTlRFR0VSXCJdID0gMzYyNDldID0gXCJSR0JBX0lOVEVHRVJcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSR0JfSU5URUdFUlwiXSA9IDM2MjQ4XSA9IFwiUkdCX0lOVEVHRVJcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSR19JTlRFR0VSXCJdID0gMzMzMjBdID0gXCJSR19JTlRFR0VSXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiUkVEX0lOVEVHRVJcIl0gPSAzNjI0NF0gPSBcIlJFRF9JTlRFR0VSXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiQUxQSEFcIl0gPSA2NDA2XSA9IFwiQUxQSEFcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJMVU1JTkFOQ0VcIl0gPSA2NDA5XSA9IFwiTFVNSU5BTkNFXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiTFVNSU5BTkNFX0FMUEhBXCJdID0gNjQxMF0gPSBcIkxVTUlOQU5DRV9BTFBIQVwiO1xuICBGT1JNQVRTMltGT1JNQVRTMltcIkRFUFRIX0NPTVBPTkVOVFwiXSA9IDY0MDJdID0gXCJERVBUSF9DT01QT05FTlRcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJERVBUSF9TVEVOQ0lMXCJdID0gMzQwNDFdID0gXCJERVBUSF9TVEVOQ0lMXCI7XG4gIHJldHVybiBGT1JNQVRTMjtcbn0pKEZPUk1BVFMgfHwge30pO1xudmFyIFRBUkdFVFMgPSAvKiBAX19QVVJFX18gKi8gKChUQVJHRVRTMikgPT4ge1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfMkRcIl0gPSAzNTUzXSA9IFwiVEVYVFVSRV8yRFwiO1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBcIl0gPSAzNDA2N10gPSBcIlRFWFRVUkVfQ1VCRV9NQVBcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFXzJEX0FSUkFZXCJdID0gMzU4NjZdID0gXCJURVhUVVJFXzJEX0FSUkFZXCI7XG4gIFRBUkdFVFMyW1RBUkdFVFMyW1wiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YXCJdID0gMzQwNjldID0gXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1hcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1hcIl0gPSAzNDA3MF0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWFwiO1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWVwiXSA9IDM0MDcxXSA9IFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZXCI7XG4gIFRBUkdFVFMyW1RBUkdFVFMyW1wiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZXCJdID0gMzQwNzJdID0gXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1lcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1pcIl0gPSAzNDA3M10gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWlwiO1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWlwiXSA9IDM0MDc0XSA9IFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aXCI7XG4gIHJldHVybiBUQVJHRVRTMjtcbn0pKFRBUkdFVFMgfHwge30pO1xudmFyIFRZUEVTID0gLyogQF9fUFVSRV9fICovICgoVFlQRVMyKSA9PiB7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9CWVRFXCJdID0gNTEyMV0gPSBcIlVOU0lHTkVEX0JZVEVcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXCJdID0gNTEyM10gPSBcIlVOU0lHTkVEX1NIT1JUXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9TSE9SVF81XzZfNVwiXSA9IDMzNjM1XSA9IFwiVU5TSUdORURfU0hPUlRfNV82XzVcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXzRfNF80XzRcIl0gPSAzMjgxOV0gPSBcIlVOU0lHTkVEX1NIT1JUXzRfNF80XzRcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXzVfNV81XzFcIl0gPSAzMjgyMF0gPSBcIlVOU0lHTkVEX1NIT1JUXzVfNV81XzFcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX0lOVFwiXSA9IDUxMjVdID0gXCJVTlNJR05FRF9JTlRcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZcIl0gPSAzNTg5OV0gPSBcIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVlwiXSA9IDMzNjQwXSA9IFwiVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9JTlRfMjRfOFwiXSA9IDM0MDQyXSA9IFwiVU5TSUdORURfSU5UXzI0XzhcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVlwiXSA9IDM1OTAyXSA9IFwiVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJCWVRFXCJdID0gNTEyMF0gPSBcIkJZVEVcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlNIT1JUXCJdID0gNTEyMl0gPSBcIlNIT1JUXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJJTlRcIl0gPSA1MTI0XSA9IFwiSU5UXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJGTE9BVFwiXSA9IDUxMjZdID0gXCJGTE9BVFwiO1xuICBUWVBFUzJbVFlQRVMyW1wiRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXCJdID0gMzYyNjldID0gXCJGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZcIjtcbiAgVFlQRVMyW1RZUEVTMltcIkhBTEZfRkxPQVRcIl0gPSAzNjE5M10gPSBcIkhBTEZfRkxPQVRcIjtcbiAgcmV0dXJuIFRZUEVTMjtcbn0pKFRZUEVTIHx8IHt9KTtcbnZhciBTQU1QTEVSX1RZUEVTID0gLyogQF9fUFVSRV9fICovICgoU0FNUExFUl9UWVBFUzIpID0+IHtcbiAgU0FNUExFUl9UWVBFUzJbU0FNUExFUl9UWVBFUzJbXCJGTE9BVFwiXSA9IDBdID0gXCJGTE9BVFwiO1xuICBTQU1QTEVSX1RZUEVTMltTQU1QTEVSX1RZUEVTMltcIklOVFwiXSA9IDFdID0gXCJJTlRcIjtcbiAgU0FNUExFUl9UWVBFUzJbU0FNUExFUl9UWVBFUzJbXCJVSU5UXCJdID0gMl0gPSBcIlVJTlRcIjtcbiAgcmV0dXJuIFNBTVBMRVJfVFlQRVMyO1xufSkoU0FNUExFUl9UWVBFUyB8fCB7fSk7XG52YXIgU0NBTEVfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChTQ0FMRV9NT0RFUzIpID0+IHtcbiAgU0NBTEVfTU9ERVMyW1NDQUxFX01PREVTMltcIk5FQVJFU1RcIl0gPSAwXSA9IFwiTkVBUkVTVFwiO1xuICBTQ0FMRV9NT0RFUzJbU0NBTEVfTU9ERVMyW1wiTElORUFSXCJdID0gMV0gPSBcIkxJTkVBUlwiO1xuICByZXR1cm4gU0NBTEVfTU9ERVMyO1xufSkoU0NBTEVfTU9ERVMgfHwge30pO1xudmFyIFdSQVBfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChXUkFQX01PREVTMikgPT4ge1xuICBXUkFQX01PREVTMltXUkFQX01PREVTMltcIkNMQU1QXCJdID0gMzMwNzFdID0gXCJDTEFNUFwiO1xuICBXUkFQX01PREVTMltXUkFQX01PREVTMltcIlJFUEVBVFwiXSA9IDEwNDk3XSA9IFwiUkVQRUFUXCI7XG4gIFdSQVBfTU9ERVMyW1dSQVBfTU9ERVMyW1wiTUlSUk9SRURfUkVQRUFUXCJdID0gMzM2NDhdID0gXCJNSVJST1JFRF9SRVBFQVRcIjtcbiAgcmV0dXJuIFdSQVBfTU9ERVMyO1xufSkoV1JBUF9NT0RFUyB8fCB7fSk7XG52YXIgTUlQTUFQX01PREVTID0gLyogQF9fUFVSRV9fICovICgoTUlQTUFQX01PREVTMikgPT4ge1xuICBNSVBNQVBfTU9ERVMyW01JUE1BUF9NT0RFUzJbXCJPRkZcIl0gPSAwXSA9IFwiT0ZGXCI7XG4gIE1JUE1BUF9NT0RFUzJbTUlQTUFQX01PREVTMltcIlBPVzJcIl0gPSAxXSA9IFwiUE9XMlwiO1xuICBNSVBNQVBfTU9ERVMyW01JUE1BUF9NT0RFUzJbXCJPTlwiXSA9IDJdID0gXCJPTlwiO1xuICBNSVBNQVBfTU9ERVMyW01JUE1BUF9NT0RFUzJbXCJPTl9NQU5VQUxcIl0gPSAzXSA9IFwiT05fTUFOVUFMXCI7XG4gIHJldHVybiBNSVBNQVBfTU9ERVMyO1xufSkoTUlQTUFQX01PREVTIHx8IHt9KTtcbnZhciBBTFBIQV9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEFMUEhBX01PREVTMikgPT4ge1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiTlBNXCJdID0gMF0gPSBcIk5QTVwiO1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiVU5QQUNLXCJdID0gMV0gPSBcIlVOUEFDS1wiO1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiUE1BXCJdID0gMl0gPSBcIlBNQVwiO1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiTk9fUFJFTVVMVElQTElFRF9BTFBIQVwiXSA9IDBdID0gXCJOT19QUkVNVUxUSVBMSUVEX0FMUEhBXCI7XG4gIEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzJbXCJQUkVNVUxUSVBMWV9PTl9VUExPQURcIl0gPSAxXSA9IFwiUFJFTVVMVElQTFlfT05fVVBMT0FEXCI7XG4gIEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzJbXCJQUkVNVUxUSVBMSUVEX0FMUEhBXCJdID0gMl0gPSBcIlBSRU1VTFRJUExJRURfQUxQSEFcIjtcbiAgcmV0dXJuIEFMUEhBX01PREVTMjtcbn0pKEFMUEhBX01PREVTIHx8IHt9KTtcbnZhciBDTEVBUl9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKENMRUFSX01PREVTMikgPT4ge1xuICBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyW1wiTk9cIl0gPSAwXSA9IFwiTk9cIjtcbiAgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMltcIllFU1wiXSA9IDFdID0gXCJZRVNcIjtcbiAgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMltcIkFVVE9cIl0gPSAyXSA9IFwiQVVUT1wiO1xuICBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyW1wiQkxFTkRcIl0gPSAwXSA9IFwiQkxFTkRcIjtcbiAgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMltcIkNMRUFSXCJdID0gMV0gPSBcIkNMRUFSXCI7XG4gIENMRUFSX01PREVTMltDTEVBUl9NT0RFUzJbXCJCTElUXCJdID0gMl0gPSBcIkJMSVRcIjtcbiAgcmV0dXJuIENMRUFSX01PREVTMjtcbn0pKENMRUFSX01PREVTIHx8IHt9KTtcbnZhciBHQ19NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEdDX01PREVTMikgPT4ge1xuICBHQ19NT0RFUzJbR0NfTU9ERVMyW1wiQVVUT1wiXSA9IDBdID0gXCJBVVRPXCI7XG4gIEdDX01PREVTMltHQ19NT0RFUzJbXCJNQU5VQUxcIl0gPSAxXSA9IFwiTUFOVUFMXCI7XG4gIHJldHVybiBHQ19NT0RFUzI7XG59KShHQ19NT0RFUyB8fCB7fSk7XG52YXIgUFJFQ0lTSU9OID0gLyogQF9fUFVSRV9fICovICgoUFJFQ0lTSU9OMikgPT4ge1xuICBQUkVDSVNJT04yW1wiTE9XXCJdID0gXCJsb3dwXCI7XG4gIFBSRUNJU0lPTjJbXCJNRURJVU1cIl0gPSBcIm1lZGl1bXBcIjtcbiAgUFJFQ0lTSU9OMltcIkhJR0hcIl0gPSBcImhpZ2hwXCI7XG4gIHJldHVybiBQUkVDSVNJT04yO1xufSkoUFJFQ0lTSU9OIHx8IHt9KTtcbnZhciBNQVNLX1RZUEVTID0gLyogQF9fUFVSRV9fICovICgoTUFTS19UWVBFUzIpID0+IHtcbiAgTUFTS19UWVBFUzJbTUFTS19UWVBFUzJbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgTUFTS19UWVBFUzJbTUFTS19UWVBFUzJbXCJTQ0lTU09SXCJdID0gMV0gPSBcIlNDSVNTT1JcIjtcbiAgTUFTS19UWVBFUzJbTUFTS19UWVBFUzJbXCJTVEVOQ0lMXCJdID0gMl0gPSBcIlNURU5DSUxcIjtcbiAgTUFTS19UWVBFUzJbTUFTS19UWVBFUzJbXCJTUFJJVEVcIl0gPSAzXSA9IFwiU1BSSVRFXCI7XG4gIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyW1wiQ09MT1JcIl0gPSA0XSA9IFwiQ09MT1JcIjtcbiAgcmV0dXJuIE1BU0tfVFlQRVMyO1xufSkoTUFTS19UWVBFUyB8fCB7fSk7XG52YXIgQ09MT1JfTUFTS19CSVRTID0gLyogQF9fUFVSRV9fICovICgoQ09MT1JfTUFTS19CSVRTMikgPT4ge1xuICBDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzJbXCJSRURcIl0gPSAxXSA9IFwiUkVEXCI7XG4gIENPTE9SX01BU0tfQklUUzJbQ09MT1JfTUFTS19CSVRTMltcIkdSRUVOXCJdID0gMl0gPSBcIkdSRUVOXCI7XG4gIENPTE9SX01BU0tfQklUUzJbQ09MT1JfTUFTS19CSVRTMltcIkJMVUVcIl0gPSA0XSA9IFwiQkxVRVwiO1xuICBDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzJbXCJBTFBIQVwiXSA9IDhdID0gXCJBTFBIQVwiO1xuICByZXR1cm4gQ09MT1JfTUFTS19CSVRTMjtcbn0pKENPTE9SX01BU0tfQklUUyB8fCB7fSk7XG52YXIgTVNBQV9RVUFMSVRZID0gLyogQF9fUFVSRV9fICovICgoTVNBQV9RVUFMSVRZMikgPT4ge1xuICBNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTJbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgTVNBQV9RVUFMSVRZMltNU0FBX1FVQUxJVFkyW1wiTE9XXCJdID0gMl0gPSBcIkxPV1wiO1xuICBNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTJbXCJNRURJVU1cIl0gPSA0XSA9IFwiTUVESVVNXCI7XG4gIE1TQUFfUVVBTElUWTJbTVNBQV9RVUFMSVRZMltcIkhJR0hcIl0gPSA4XSA9IFwiSElHSFwiO1xuICByZXR1cm4gTVNBQV9RVUFMSVRZMjtcbn0pKE1TQUFfUVVBTElUWSB8fCB7fSk7XG52YXIgQlVGRkVSX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gKChCVUZGRVJfVFlQRTIpID0+IHtcbiAgQlVGRkVSX1RZUEUyW0JVRkZFUl9UWVBFMltcIkVMRU1FTlRfQVJSQVlfQlVGRkVSXCJdID0gMzQ5NjNdID0gXCJFTEVNRU5UX0FSUkFZX0JVRkZFUlwiO1xuICBCVUZGRVJfVFlQRTJbQlVGRkVSX1RZUEUyW1wiQVJSQVlfQlVGRkVSXCJdID0gMzQ5NjJdID0gXCJBUlJBWV9CVUZGRVJcIjtcbiAgQlVGRkVSX1RZUEUyW0JVRkZFUl9UWVBFMltcIlVOSUZPUk1fQlVGRkVSXCJdID0gMzUzNDVdID0gXCJVTklGT1JNX0JVRkZFUlwiO1xuICByZXR1cm4gQlVGRkVSX1RZUEUyO1xufSkoQlVGRkVSX1RZUEUgfHwge30pO1xuXG5leHBvcnQgeyBBTFBIQV9NT0RFUywgQkxFTkRfTU9ERVMsIEJVRkZFUl9CSVRTLCBCVUZGRVJfVFlQRSwgQ0xFQVJfTU9ERVMsIENPTE9SX01BU0tfQklUUywgRFJBV19NT0RFUywgRU5WLCBGT1JNQVRTLCBHQ19NT0RFUywgTUFTS19UWVBFUywgTUlQTUFQX01PREVTLCBNU0FBX1FVQUxJVFksIFBSRUNJU0lPTiwgUkVOREVSRVJfVFlQRSwgU0FNUExFUl9UWVBFUywgU0NBTEVfTU9ERVMsIFRBUkdFVFMsIFRZUEVTLCBXUkFQX01PREVTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///361\n')},525:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "iw": () => (/* reexport */ lib/* ALPHA_MODES */.iw),\n  "T$": () => (/* reexport */ lib/* BLEND_MODES */.T$),\n  "VL": () => (/* reexport */ BaseTexture),\n  "a$": () => (/* reexport */ BatchDrawCall),\n  "JZ": () => (/* reexport */ BatchGeometry),\n  "Ie": () => (/* reexport */ BatchTextureArray),\n  "lW": () => (/* reexport */ Buffer),\n  "qm": () => (/* reexport */ BufferResource),\n  "yl": () => (/* reexport */ lib/* CLEAR_MODES */.yl),\n  "Cd": () => (/* reexport */ math_lib/* Circle */.Cd),\n  "Il": () => (/* reexport */ color_lib/* Color */.I),\n  "ZX": () => (/* reexport */ math_lib/* DEG_TO_RAD */.ZX),\n  "lg": () => (/* reexport */ lib/* DRAW_MODES */.lg),\n  "Pj": () => (/* reexport */ math_lib/* Ellipse */.Pj),\n  "nw": () => (/* reexport */ ExtensionType),\n  "I2": () => (/* reexport */ lib/* FORMATS */.I2),\n  "wn": () => (/* reexport */ Filter),\n  "wG": () => (/* reexport */ Geometry),\n  "A7": () => (/* reexport */ lib/* MASK_TYPES */.A7),\n  "KI": () => (/* reexport */ lib/* MIPMAP_MODES */.WB),\n  "G5": () => (/* reexport */ lib/* MSAA_QUALITY */.G5),\n  "y3": () => (/* reexport */ math_lib/* Matrix */.y3),\n  "bO": () => (/* reexport */ ObjectRenderer),\n  "AB": () => (/* reexport */ math_lib/* ObservablePoint */.AB),\n  "_b": () => (/* reexport */ math_lib/* PI_2 */._b),\n  "E9": () => (/* reexport */ math_lib/* Point */.E9),\n  "mg": () => (/* reexport */ math_lib/* Polygon */.mg),\n  "$r": () => (/* reexport */ Program),\n  "ud": () => (/* reexport */ QuadUv),\n  "jl": () => (/* reexport */ math_lib/* RAD_TO_DEG */.jl),\n  "Ae": () => (/* reexport */ math_lib/* Rectangle */.Ae),\n  "TI": () => (/* reexport */ RenderTexture),\n  "c9": () => (/* reexport */ math_lib/* RoundedRectangle */.c9),\n  "HS": () => (/* reexport */ math_lib/* SHAPES */.HS),\n  "pX": () => (/* reexport */ SVGResource),\n  "ex": () => (/* reexport */ Shader),\n  "ZM": () => (/* reexport */ State),\n  "vK": () => (/* reexport */ lib/* TYPES */.vK),\n  "xE": () => (/* reexport */ Texture),\n  "UX": () => (/* reexport */ TextureMatrix),\n  "vB": () => (/* reexport */ Ticker),\n  "wx": () => (/* reexport */ math_lib/* Transform */.wx),\n  "uF": () => (/* reexport */ UPDATE_PRIORITY),\n  "oo": () => (/* reexport */ UniformGroup),\n  "Rv": () => (/* reexport */ ViewableBuffer),\n  "Nt": () => (/* reexport */ lib/* WRAP_MODES */.Nt),\n  "e6": () => (/* reexport */ autoDetectRenderer),\n  "Y9": () => (/* reexport */ defaultFilterVertex),\n  "kP": () => (/* reexport */ fragments_defaultVertex),\n  "Rw": () => (/* reexport */ extensions),\n  "Xd": () => (/* reexport */ settings_lib/* settings */.Xd),\n  "P6": () => (/* reexport */ utils_lib)\n});\n\n// UNUSED EXPORTS: AbstractMultiResource, ArrayResource, Attribute, BUFFER_BITS, BUFFER_TYPE, BackgroundSystem, BaseImageResource, BaseRenderTexture, BatchRenderer, BatchShaderGenerator, BatchSystem, BrowserAdapter, BufferSystem, COLOR_MASK_BITS, CanvasResource, ContextSystem, CubeResource, ENV, FilterState, FilterSystem, Framebuffer, FramebufferSystem, GC_MODES, GLFramebuffer, GLProgram, GLTexture, GenerateTextureSystem, GeometrySystem, IGLUniformData, INSTALLED, ImageBitmapResource, ImageResource, MaskData, MaskSystem, MultisampleSystem, ObjectRendererSystem, PRECISION, PluginSystem, ProjectionSystem, Quad, RENDERER_TYPE, RenderTexturePool, RenderTextureSystem, Renderer, Resource, Runner, SAMPLER_TYPES, SCALE_MODES, ScissorSystem, ShaderSystem, SpriteMaskFilter, StartupSystem, StateSystem, StencilSystem, SystemManager, TARGETS, TextureGCSystem, TextureSystem, TextureUvs, TickerPlugin, TransformFeedback, TransformFeedbackSystem, VERSION, VideoResource, ViewSystem, autoDetectResource, checkMaxIfStatementsInShader, createUBOElements, generateProgram, generateUniformBufferSync, getTestContext, getUBOData, groupD8, isMobile, uniformParsers, unsafeEvalSupported\n\n// EXTERNAL MODULE: ./node_modules/@pixi/constants/lib/index.mjs\nvar lib = __webpack_require__(361);\n// EXTERNAL MODULE: ./node_modules/@pixi/settings/lib/index.mjs + 4 modules\nvar settings_lib = __webpack_require__(116);\n// EXTERNAL MODULE: ./node_modules/@pixi/utils/lib/index.mjs + 24 modules\nvar utils_lib = __webpack_require__(441);\n// EXTERNAL MODULE: ./node_modules/@pixi/color/lib/index.mjs + 3 modules\nvar color_lib = __webpack_require__(126);\n;// CONCATENATED MODULE: ./node_modules/@pixi/extensions/lib/index.mjs\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2["Renderer"] = "renderer";\n  ExtensionType2["Application"] = "application";\n  ExtensionType2["RendererSystem"] = "renderer-webgl-system";\n  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";\n  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";\n  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";\n  ExtensionType2["Asset"] = "asset";\n  ExtensionType2["LoadParser"] = "load-parser";\n  ExtensionType2["ResolveParser"] = "resolve-parser";\n  ExtensionType2["CacheParser"] = "cache-parser";\n  ExtensionType2["DetectionParser"] = "detection-parser";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error("Extension class must have an extension object");\n    }\n    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === "object") {\n    ext = { ...ext };\n  } else {\n    throw new Error("Invalid extension type");\n  }\n  if (typeof ext.type === "string") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  _addHandlers: {},\n  _removeHandlers: {},\n  _queue: {},\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type].push(ext);\n        } else {\n          handlers[type](ext);\n        }\n      });\n    });\n    return this;\n  },\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type].forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  handleByMap(type, map) {\n    return this.handle(type, (extension) => {\n      map[extension.name] = extension.ref;\n    }, (extension) => {\n      delete map[extension.name];\n    });\n  },\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(type, (extension) => {\n      if (list.includes(extension.ref)) {\n        return;\n      }\n      list.push(extension.ref);\n      list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority));\n    }, (extension) => {\n      const index = list.indexOf(extension.ref);\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    });\n  }\n};\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === "number") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n  }\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  get uint16View() {\n    if (!this._uint16View) {\n      this._uint16View = new Uint16Array(this.rawBinaryData);\n    }\n    return this._uint16View;\n  }\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  view(type) {\n    return this[`${type}View`];\n  }\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this._uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  static sizeOf(type) {\n    switch (type) {\n      case "int8":\n      case "uint8":\n        return 1;\n      case "int16":\n      case "uint16":\n        return 2;\n      case "int32":\n      case "uint32":\n      case "float32":\n        return 4;\n      default:\n        throw new Error(`${type} isn\'t a valid view type`);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ViewableBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs\nconst fragTemplate = [\n  "precision mediump float;",\n  "void main(void){",\n  "float test = 0.1;",\n  "%forloop%",\n  "gl_FragColor = vec4(0.0);",\n  "}"\n].join("\\n");\nfunction generateIfTestSrc(maxIfs) {\n  let src = "";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += "\\nelse ";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  while (true) {\n    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n    gl.shaderSource(shader, fragmentSrc);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      maxIfs = maxIfs / 2 | 0;\n    } else {\n      break;\n    }\n  }\n  return maxIfs;\n}\n\n\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/State.mjs\n\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nclass State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = lib/* BLEND_MODES.NORMAL */.T$.NORMAL;\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== lib/* BLEND_MODES.NONE */.T$.NONE;\n    this._blendMode = value;\n  }\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  static for2d() {\n    const state = new State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n}\n\n\n//# sourceMappingURL=State.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs\nconst INSTALLED = [];\nfunction autoDetectResource(source, options) {\n  if (!source) {\n    return null;\n  }\n  let extension = "";\n  if (typeof source === "string") {\n    const result = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(source);\n    if (result) {\n      extension = result[1].toLowerCase();\n    }\n  }\n  for (let i = INSTALLED.length - 1; i >= 0; --i) {\n    const ResourcePlugin = INSTALLED[i];\n    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {\n      return new ResourcePlugin(source, options);\n    }\n  }\n  throw new Error("Unrecognized source type to auto-detect Resource");\n}\n\n\n//# sourceMappingURL=autoDetectResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/runner/lib/Runner.mjs\nclass Runner_Runner {\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n    this._aliasCount = 0;\n  }\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    if (arguments.length > 8) {\n      throw new Error("max arguments reached");\n    }\n    const { name, items } = this;\n    this._aliasCount++;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    if (items === this.items) {\n      this._aliasCount--;\n    }\n    return this;\n  }\n  ensureNonAliasedItems() {\n    if (this._aliasCount > 0 && this.items.length > 1) {\n      this._aliasCount = 0;\n      this.items = this.items.slice(0);\n    }\n  }\n  add(item) {\n    if (item[this._name]) {\n      this.ensureNonAliasedItems();\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.ensureNonAliasedItems();\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  contains(item) {\n    return this.items.includes(item);\n  }\n  removeAll() {\n    this.ensureNonAliasedItems();\n    this.items.length = 0;\n    return this;\n  }\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  get empty() {\n    return this.items.length === 0;\n  }\n  get name() {\n    return this._name;\n  }\n}\nObject.defineProperties(Runner_Runner.prototype, {\n  dispatch: { value: Runner_Runner.prototype.emit },\n  run: { value: Runner_Runner.prototype.emit }\n});\n\n\n//# sourceMappingURL=Runner.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/runner/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/Resource.mjs\n\n\nclass Resource {\n  constructor(width = 0, height = 0) {\n    this._width = width;\n    this._height = height;\n    this.destroyed = false;\n    this.internal = false;\n    this.onResize = new Runner_Runner("setRealSize");\n    this.onUpdate = new Runner_Runner("update");\n    this.onError = new Runner_Runner("onError");\n  }\n  bind(baseTexture) {\n    this.onResize.add(baseTexture);\n    this.onUpdate.add(baseTexture);\n    this.onError.add(baseTexture);\n    if (this._width || this._height) {\n      this.onResize.emit(this._width, this._height);\n    }\n  }\n  unbind(baseTexture) {\n    this.onResize.remove(baseTexture);\n    this.onUpdate.remove(baseTexture);\n    this.onError.remove(baseTexture);\n  }\n  resize(width, height) {\n    if (width !== this._width || height !== this._height) {\n      this._width = width;\n      this._height = height;\n      this.onResize.emit(width, height);\n    }\n  }\n  get valid() {\n    return !!this._width && !!this._height;\n  }\n  update() {\n    if (!this.destroyed) {\n      this.onUpdate.emit();\n    }\n  }\n  load() {\n    return Promise.resolve(this);\n  }\n  get width() {\n    return this._width;\n  }\n  get height() {\n    return this._height;\n  }\n  style(_renderer, _baseTexture, _glTexture) {\n    return false;\n  }\n  dispose() {\n  }\n  destroy() {\n    if (!this.destroyed) {\n      this.destroyed = true;\n      this.dispose();\n      this.onError.removeAll();\n      this.onError = null;\n      this.onResize.removeAll();\n      this.onResize = null;\n      this.onUpdate.removeAll();\n      this.onUpdate = null;\n    }\n  }\n  static test(_source, _extension) {\n    return false;\n  }\n}\n\n\n//# sourceMappingURL=Resource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs\n\n\n\nclass BufferResource extends Resource {\n  constructor(source, options) {\n    const { width, height } = options || {};\n    if (!width || !height) {\n      throw new Error("BufferResource width or height invalid");\n    }\n    super(width, height);\n    this.data = source;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    const gl = renderer.gl;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === lib/* ALPHA_MODES.UNPACK */.iw.UNPACK);\n    const width = baseTexture.realWidth;\n    const height = baseTexture.realHeight;\n    if (glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);\n    }\n    return true;\n  }\n  dispose() {\n    this.data = null;\n  }\n  static test(source) {\n    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;\n  }\n}\n\n\n//# sourceMappingURL=BufferResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/BaseTexture.mjs\n\n\n\n\n\n\n\nconst defaultBufferOptions = {\n  scaleMode: lib/* SCALE_MODES.NEAREST */.aH.NEAREST,\n  format: lib/* FORMATS.RGBA */.I2.RGBA,\n  alphaMode: lib/* ALPHA_MODES.NPM */.iw.NPM\n};\nconst _BaseTexture = class extends utils_lib.EventEmitter {\n  constructor(resource = null, options = null) {\n    super();\n    options = Object.assign({}, _BaseTexture.defaultOptions, options);\n    const {\n      alphaMode,\n      mipmap,\n      anisotropicLevel,\n      scaleMode,\n      width,\n      height,\n      wrapMode,\n      format,\n      type,\n      target,\n      resolution,\n      resourceOptions\n    } = options;\n    if (resource && !(resource instanceof Resource)) {\n      resource = autoDetectResource(resource, resourceOptions);\n      resource.internal = true;\n    }\n    this.resolution = resolution || settings_lib/* settings.RESOLUTION */.Xd.RESOLUTION;\n    this.width = Math.round((width || 0) * this.resolution) / this.resolution;\n    this.height = Math.round((height || 0) * this.resolution) / this.resolution;\n    this._mipmap = mipmap;\n    this.anisotropicLevel = anisotropicLevel;\n    this._wrapMode = wrapMode;\n    this._scaleMode = scaleMode;\n    this.format = format;\n    this.type = type;\n    this.target = target;\n    this.alphaMode = alphaMode;\n    this.uid = (0,utils_lib.uid)();\n    this.touched = 0;\n    this.isPowerOfTwo = false;\n    this._refreshPOT();\n    this._glTextures = {};\n    this.dirtyId = 0;\n    this.dirtyStyleId = 0;\n    this.cacheId = null;\n    this.valid = width > 0 && height > 0;\n    this.textureCacheIds = [];\n    this.destroyed = false;\n    this.resource = null;\n    this._batchEnabled = 0;\n    this._batchLocation = 0;\n    this.parentTextureArray = null;\n    this.setResource(resource);\n  }\n  get realWidth() {\n    return Math.round(this.width * this.resolution);\n  }\n  get realHeight() {\n    return Math.round(this.height * this.resolution);\n  }\n  get mipmap() {\n    return this._mipmap;\n  }\n  set mipmap(value) {\n    if (this._mipmap !== value) {\n      this._mipmap = value;\n      this.dirtyStyleId++;\n    }\n  }\n  get scaleMode() {\n    return this._scaleMode;\n  }\n  set scaleMode(value) {\n    if (this._scaleMode !== value) {\n      this._scaleMode = value;\n      this.dirtyStyleId++;\n    }\n  }\n  get wrapMode() {\n    return this._wrapMode;\n  }\n  set wrapMode(value) {\n    if (this._wrapMode !== value) {\n      this._wrapMode = value;\n      this.dirtyStyleId++;\n    }\n  }\n  setStyle(scaleMode, mipmap) {\n    let dirty;\n    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {\n      this.scaleMode = scaleMode;\n      dirty = true;\n    }\n    if (mipmap !== void 0 && mipmap !== this.mipmap) {\n      this.mipmap = mipmap;\n      dirty = true;\n    }\n    if (dirty) {\n      this.dirtyStyleId++;\n    }\n    return this;\n  }\n  setSize(desiredWidth, desiredHeight, resolution) {\n    resolution = resolution || this.resolution;\n    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n  }\n  setRealSize(realWidth, realHeight, resolution) {\n    this.resolution = resolution || this.resolution;\n    this.width = Math.round(realWidth) / this.resolution;\n    this.height = Math.round(realHeight) / this.resolution;\n    this._refreshPOT();\n    this.update();\n    return this;\n  }\n  _refreshPOT() {\n    this.isPowerOfTwo = (0,utils_lib.isPow2)(this.realWidth) && (0,utils_lib.isPow2)(this.realHeight);\n  }\n  setResolution(resolution) {\n    const oldResolution = this.resolution;\n    if (oldResolution === resolution) {\n      return this;\n    }\n    this.resolution = resolution;\n    if (this.valid) {\n      this.width = Math.round(this.width * oldResolution) / resolution;\n      this.height = Math.round(this.height * oldResolution) / resolution;\n      this.emit("update", this);\n    }\n    this._refreshPOT();\n    return this;\n  }\n  setResource(resource) {\n    if (this.resource === resource) {\n      return this;\n    }\n    if (this.resource) {\n      throw new Error("Resource can be set only once");\n    }\n    resource.bind(this);\n    this.resource = resource;\n    return this;\n  }\n  update() {\n    if (!this.valid) {\n      if (this.width > 0 && this.height > 0) {\n        this.valid = true;\n        this.emit("loaded", this);\n        this.emit("update", this);\n      }\n    } else {\n      this.dirtyId++;\n      this.dirtyStyleId++;\n      this.emit("update", this);\n    }\n  }\n  onError(event) {\n    this.emit("error", this, event);\n  }\n  destroy() {\n    if (this.resource) {\n      this.resource.unbind(this);\n      if (this.resource.internal) {\n        this.resource.destroy();\n      }\n      this.resource = null;\n    }\n    if (this.cacheId) {\n      delete utils_lib.BaseTextureCache[this.cacheId];\n      delete utils_lib.TextureCache[this.cacheId];\n      this.cacheId = null;\n    }\n    this.dispose();\n    _BaseTexture.removeFromCache(this);\n    this.textureCacheIds = null;\n    this.destroyed = true;\n  }\n  dispose() {\n    this.emit("dispose", this);\n  }\n  castToBaseTexture() {\n    return this;\n  }\n  static from(source, options, strict = settings_lib/* settings.STRICT_TEXTURE_CACHE */.Xd.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source === "string";\n    let cacheId = null;\n    if (isFrame) {\n      cacheId = source;\n    } else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source._pixiId = `${prefix}_${(0,utils_lib.uid)()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let baseTexture = utils_lib.BaseTextureCache[cacheId];\n    if (isFrame && strict && !baseTexture) {\n      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);\n    }\n    if (!baseTexture) {\n      baseTexture = new _BaseTexture(source, options);\n      baseTexture.cacheId = cacheId;\n      _BaseTexture.addToCache(baseTexture, cacheId);\n    }\n    return baseTexture;\n  }\n  static fromBuffer(buffer, width, height, options) {\n    buffer = buffer || new Float32Array(width * height * 4);\n    const resource = new BufferResource(buffer, { width, height });\n    const type = buffer instanceof Float32Array ? lib/* TYPES.FLOAT */.vK.FLOAT : lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE;\n    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, options || { width, height, type }));\n  }\n  static addToCache(baseTexture, id) {\n    if (id) {\n      if (!baseTexture.textureCacheIds.includes(id)) {\n        baseTexture.textureCacheIds.push(id);\n      }\n      if (utils_lib.BaseTextureCache[id] && utils_lib.BaseTextureCache[id] !== baseTexture) {\n        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);\n      }\n      utils_lib.BaseTextureCache[id] = baseTexture;\n    }\n  }\n  static removeFromCache(baseTexture) {\n    if (typeof baseTexture === "string") {\n      const baseTextureFromCache = utils_lib.BaseTextureCache[baseTexture];\n      if (baseTextureFromCache) {\n        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n        if (index > -1) {\n          baseTextureFromCache.textureCacheIds.splice(index, 1);\n        }\n        delete utils_lib.BaseTextureCache[baseTexture];\n        return baseTextureFromCache;\n      }\n    } else if (baseTexture?.textureCacheIds) {\n      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {\n        delete utils_lib.BaseTextureCache[baseTexture.textureCacheIds[i]];\n      }\n      baseTexture.textureCacheIds.length = 0;\n      return baseTexture;\n    }\n    return null;\n  }\n};\nlet BaseTexture = _BaseTexture;\nBaseTexture.defaultOptions = {\n  mipmap: lib/* MIPMAP_MODES.POW2 */.WB.POW2,\n  anisotropicLevel: 0,\n  scaleMode: lib/* SCALE_MODES.LINEAR */.aH.LINEAR,\n  wrapMode: lib/* WRAP_MODES.CLAMP */.Nt.CLAMP,\n  alphaMode: lib/* ALPHA_MODES.UNPACK */.iw.UNPACK,\n  target: lib/* TARGETS.TEXTURE_2D */.sp.TEXTURE_2D,\n  format: lib/* FORMATS.RGBA */.I2.RGBA,\n  type: lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE\n};\nBaseTexture._globalBatch = 0;\n\n\n//# sourceMappingURL=BaseTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs\n\n\nclass BatchDrawCall {\n  constructor() {\n    this.texArray = null;\n    this.blend = 0;\n    this.type = lib/* DRAW_MODES.TRIANGLES */.lg.TRIANGLES;\n    this.start = 0;\n    this.size = 0;\n    this.data = null;\n  }\n}\n\n\n//# sourceMappingURL=BatchDrawCall.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Buffer.mjs\n\n\n\nlet UID = 0;\nclass Buffer {\n  constructor(data, _static = true, index = false) {\n    this.data = data || new Float32Array(1);\n    this._glBuffers = {};\n    this._updateID = 0;\n    this.index = index;\n    this.static = _static;\n    this.id = UID++;\n    this.disposeRunner = new Runner_Runner("disposeBuffer");\n  }\n  update(data) {\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this.data = data || this.data;\n    this._updateID++;\n  }\n  dispose() {\n    this.disposeRunner.emit(this, false);\n  }\n  destroy() {\n    this.dispose();\n    this.data = null;\n  }\n  set index(value) {\n    this.type = value ? lib/* BUFFER_TYPE.ELEMENT_ARRAY_BUFFER */.mr.ELEMENT_ARRAY_BUFFER : lib/* BUFFER_TYPE.ARRAY_BUFFER */.mr.ARRAY_BUFFER;\n  }\n  get index() {\n    return this.type === lib/* BUFFER_TYPE.ELEMENT_ARRAY_BUFFER */.mr.ELEMENT_ARRAY_BUFFER;\n  }\n  static from(data) {\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    return new Buffer(data);\n  }\n}\n\n\n//# sourceMappingURL=Buffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Attribute.mjs\n\n\nclass Attribute {\n  constructor(buffer, size = 0, normalized = false, type = lib/* TYPES.FLOAT */.vK.FLOAT, stride, start, instance, divisor = 1) {\n    this.buffer = buffer;\n    this.size = size;\n    this.normalized = normalized;\n    this.type = type;\n    this.stride = stride;\n    this.start = start;\n    this.instance = instance;\n    this.divisor = divisor;\n  }\n  destroy() {\n    this.buffer = null;\n  }\n  static from(buffer, size, normalized, type, stride) {\n    return new Attribute(buffer, size, normalized, type, stride);\n  }\n}\n\n\n//# sourceMappingURL=Attribute.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs\n\n\nconst map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0;\n  let stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++) {\n    stride += sizes[i];\n    outSize += arrays[i].length;\n  }\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null;\n  let littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i];\n    const array = arrays[i];\n    const type = (0,utils_lib.getBufferType)(array);\n    if (!views[type]) {\n      views[type] = new map[type](buffer);\n    }\n    out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset;\n      const index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\n\n\n//# sourceMappingURL=interleaveTypedArrays.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Geometry.mjs\n\n\n\n\n\n\n\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nlet Geometry_UID = 0;\nconst Geometry_map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n};\nclass Geometry {\n  constructor(buffers = [], attributes = {}) {\n    this.buffers = buffers;\n    this.indexBuffer = null;\n    this.attributes = attributes;\n    this.glVertexArrayObjects = {};\n    this.id = Geometry_UID++;\n    this.instanced = false;\n    this.instanceCount = 1;\n    this.disposeRunner = new Runner_Runner("disposeGeometry");\n    this.refCount = 0;\n  }\n  addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {\n    if (!buffer) {\n      throw new Error("You must pass a buffer when creating an attribute");\n    }\n    if (!(buffer instanceof Buffer)) {\n      if (buffer instanceof Array) {\n        buffer = new Float32Array(buffer);\n      }\n      buffer = new Buffer(buffer);\n    }\n    const ids = id.split("|");\n    if (ids.length > 1) {\n      for (let i = 0; i < ids.length; i++) {\n        this.addAttribute(ids[i], buffer, size, normalized, type);\n      }\n      return this;\n    }\n    let bufferIndex = this.buffers.indexOf(buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(buffer);\n      bufferIndex = this.buffers.length - 1;\n    }\n    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);\n    this.instanced = this.instanced || instance;\n    return this;\n  }\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  getBuffer(id) {\n    return this.buffers[this.getAttribute(id).buffer];\n  }\n  addIndex(buffer) {\n    if (!(buffer instanceof Buffer)) {\n      if (buffer instanceof Array) {\n        buffer = new Uint16Array(buffer);\n      }\n      buffer = new Buffer(buffer);\n    }\n    buffer.type = lib/* BUFFER_TYPE.ELEMENT_ARRAY_BUFFER */.mr.ELEMENT_ARRAY_BUFFER;\n    this.indexBuffer = buffer;\n    if (!this.buffers.includes(buffer)) {\n      this.buffers.push(buffer);\n    }\n    return this;\n  }\n  getIndex() {\n    return this.indexBuffer;\n  }\n  interleave() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n      return this;\n    const arrays = [];\n    const sizes = [];\n    const interleavedBuffer = new Buffer();\n    let i;\n    for (i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = this.buffers[attribute.buffer];\n      arrays.push(buffer.data);\n      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);\n      attribute.buffer = 0;\n    }\n    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);\n    for (i = 0; i < this.buffers.length; i++) {\n      if (this.buffers[i] !== this.indexBuffer) {\n        this.buffers[i].destroy();\n      }\n    }\n    this.buffers = [interleavedBuffer];\n    if (this.indexBuffer) {\n      this.buffers.push(this.indexBuffer);\n    }\n    return this;\n  }\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = this.buffers[attribute.buffer];\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  dispose() {\n    this.disposeRunner.emit(this, false);\n  }\n  destroy() {\n    this.dispose();\n    this.buffers = null;\n    this.indexBuffer = null;\n    this.attributes = null;\n  }\n  clone() {\n    const geometry = new Geometry();\n    for (let i = 0; i < this.buffers.length; i++) {\n      geometry.buffers[i] = new Buffer(this.buffers[i].data.slice(0));\n    }\n    for (const i in this.attributes) {\n      const attrib = this.attributes[i];\n      geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);\n    }\n    if (this.indexBuffer) {\n      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];\n      geometry.indexBuffer.type = lib/* BUFFER_TYPE.ELEMENT_ARRAY_BUFFER */.mr.ELEMENT_ARRAY_BUFFER;\n    }\n    return geometry;\n  }\n  static merge(geometries) {\n    const geometryOut = new Geometry();\n    const arrays = [];\n    const sizes = [];\n    const offsets = [];\n    let geometry;\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++) {\n        sizes[j] = sizes[j] || 0;\n        sizes[j] += geometry.buffers[j].data.length;\n        offsets[j] = 0;\n      }\n    }\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      arrays[i] = new Geometry_map[(0,utils_lib.getBufferType)(geometry.buffers[i].data)](sizes[i]);\n      geometryOut.buffers[i] = new Buffer(arrays[i]);\n    }\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++) {\n        arrays[j].set(geometry.buffers[j].data, offsets[j]);\n        offsets[j] += geometry.buffers[j].data.length;\n      }\n    }\n    geometryOut.attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];\n      geometryOut.indexBuffer.type = lib/* BUFFER_TYPE.ELEMENT_ARRAY_BUFFER */.mr.ELEMENT_ARRAY_BUFFER;\n      let offset = 0;\n      let stride = 0;\n      let offset2 = 0;\n      let bufferIndexToCount = 0;\n      for (let i = 0; i < geometry.buffers.length; i++) {\n        if (geometry.buffers[i] !== geometry.indexBuffer) {\n          bufferIndexToCount = i;\n          break;\n        }\n      }\n      for (const i in geometry.attributes) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.buffer | 0) === bufferIndexToCount) {\n          stride += attribute.size * byteSizeMap[attribute.type] / 4;\n        }\n      }\n      for (let i = 0; i < geometries.length; i++) {\n        const indexBufferData = geometries[i].indexBuffer.data;\n        for (let j = 0; j < indexBufferData.length; j++) {\n          geometryOut.indexBuffer.data[j + offset2] += offset;\n        }\n        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;\n        offset2 += indexBufferData.length;\n      }\n    }\n    return geometryOut;\n  }\n}\n\n\n//# sourceMappingURL=Geometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchGeometry.mjs\n\n\n\n\nclass BatchGeometry extends Geometry {\n  constructor(_static = false) {\n    super();\n    this._buffer = new Buffer(null, _static, false);\n    this._indexBuffer = new Buffer(null, _static, true);\n    this.addAttribute("aVertexPosition", this._buffer, 2, false, lib/* TYPES.FLOAT */.vK.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, lib/* TYPES.FLOAT */.vK.FLOAT).addAttribute("aColor", this._buffer, 4, true, lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, lib/* TYPES.FLOAT */.vK.FLOAT).addIndex(this._indexBuffer);\n  }\n}\n\n\n//# sourceMappingURL=BatchGeometry.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/@pixi/math/lib/index.mjs + 11 modules\nvar math_lib = __webpack_require__(363);\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/defaultProgram.mjs\nvar defaultFragment = "varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\\n}";\n\n\n//# sourceMappingURL=defaultProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/defaultProgram2.mjs\nvar defaultVertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void){\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vTextureCoord = aTextureCoord;\\n}\\n";\n\n\n//# sourceMappingURL=defaultProgram2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs\nconst uniformParsers = [\n  {\n    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,\n    code: (name) => `\n            if(uv["${name}"] !== ud["${name}"].value)\n            {\n                ud["${name}"].value = uv["${name}"]\n                gl.uniform1f(ud["${name}"].location, uv["${name}"])\n            }\n            `\n  },\n  {\n    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),\n    code: (name) => `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${name}"], t);\n\n            if(ud["${name}"].value !== t)\n            {\n                ud["${name}"].value = t;\n                gl.uniform1i(ud["${name}"].location, t);\n; // eslint-disable-line max-len\n            }`\n  },\n  {\n    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,\n    code: (name) => `\n            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));\n            `,\n    codeUbo: (name) => `\n                var ${name}_matrix = uv.${name}.toArray(true);\n\n                data[offset] = ${name}_matrix[0];\n                data[offset+1] = ${name}_matrix[1];\n                data[offset+2] = ${name}_matrix[2];\n        \n                data[offset + 4] = ${name}_matrix[3];\n                data[offset + 5] = ${name}_matrix[4];\n                data[offset + 6] = ${name}_matrix[5];\n        \n                data[offset + 8] = ${name}_matrix[6];\n                data[offset + 9] = ${name}_matrix[7];\n                data[offset + 10] = ${name}_matrix[8];\n            `\n  },\n  {\n    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${name}"].location, v.x, v.y);\n                }`,\n    codeUbo: (name) => `\n                v = uv.${name};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `\n  },\n  {\n    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);\n                }\n            `\n  },\n  {\n    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `\n  },\n  {\n    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `\n  },\n  {\n    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `\n  },\n  {\n    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])\n                }`\n  }\n];\n\n\n//# sourceMappingURL=uniformParsers.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs\n\n\nconst GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: "gl.uniformMatrix2fv(location, false, v)",\n  mat3: "gl.uniformMatrix3fv(location, false, v)",\n  mat4: "gl.uniformMatrix4fv(location, false, v)",\n  sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`\n};\nconst GLSL_TO_ARRAY_SETTERS = {\n  float: `gl.uniform1fv(location, v)`,\n  vec2: `gl.uniform2fv(location, v)`,\n  vec3: `gl.uniform3fv(location, v)`,\n  vec4: "gl.uniform4fv(location, v)",\n  mat4: "gl.uniformMatrix4fv(location, false, v)",\n  mat3: "gl.uniformMatrix3fv(location, false, v)",\n  mat2: "gl.uniformMatrix2fv(location, false, v)",\n  int: "gl.uniform1iv(location, v)",\n  ivec2: "gl.uniform2iv(location, v)",\n  ivec3: "gl.uniform3iv(location, v)",\n  ivec4: "gl.uniform4iv(location, v)",\n  uint: "gl.uniform1uiv(location, v)",\n  uvec2: "gl.uniform2uiv(location, v)",\n  uvec3: "gl.uniform3uiv(location, v)",\n  uvec4: "gl.uniform4uiv(location, v)",\n  bool: "gl.uniform1iv(location, v)",\n  bvec2: "gl.uniform2iv(location, v)",\n  bvec3: "gl.uniform3iv(location, v)",\n  bvec4: "gl.uniform4iv(location, v)",\n  sampler2D: "gl.uniform1iv(location, v)",\n  samplerCube: "gl.uniform1iv(location, v)",\n  sampler2DArray: "gl.uniform1iv(location, v)"\n};\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (const i in group.uniforms) {\n    const data = uniformData[i];\n    if (!data) {\n      if (group.uniforms[i]?.group) {\n        if (group.uniforms[i].ubo) {\n          funcFragments.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${i}, \'${i}\');\n                    `);\n        } else {\n          funcFragments.push(`\n                        renderer.shader.syncUniformGroup(uv.${i}, syncData);\n                    `);\n        }\n      }\n      continue;\n    }\n    const uniform = group.uniforms[i];\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      if (uniformParsers[j].test(data, uniform)) {\n        funcFragments.push(uniformParsers[j].code(i, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;\n      const template = templateType[data.type].replace("location", `ud["${i}"].location`);\n      funcFragments.push(`\n            cu = ud["${i}"];\n            cv = cu.value;\n            v = uv["${i}"];\n            ${template};`);\n    }\n  }\n  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\\n"));\n}\n\n\n//# sourceMappingURL=generateUniformsSync.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs\n\n\n\nconst unknownContext = {};\nlet context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context?.isContextLost()) {\n    const canvas = settings_lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n    let gl;\n    if (settings_lib/* settings.PREFER_ENV */.Xd.PREFER_ENV >= lib/* ENV.WEBGL2 */.Vi.WEBGL2) {\n      gl = canvas.getContext("webgl2", {});\n    }\n    if (!gl) {\n      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});\n      if (!gl) {\n        gl = null;\n      } else {\n        gl.getExtension("WEBGL_draw_buffers");\n      }\n    }\n    context = gl;\n  }\n  return context;\n}\n\n\n//# sourceMappingURL=getTestContext.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs\n\n\n\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = lib/* PRECISION.MEDIUM */.cB.MEDIUM;\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? lib/* PRECISION.HIGH */.cB.HIGH : lib/* PRECISION.MEDIUM */.cB.MEDIUM;\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\n\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs\nconst GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(type) {\n  return GLSL_TO_SIZE[type];\n}\n\n\n//# sourceMappingURL=mapSize.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/mapType.mjs\nlet GL_TABLE = null;\nconst GL_TO_GLSL_TYPES = {\n  FLOAT: "float",\n  FLOAT_VEC2: "vec2",\n  FLOAT_VEC3: "vec3",\n  FLOAT_VEC4: "vec4",\n  INT: "int",\n  INT_VEC2: "ivec2",\n  INT_VEC3: "ivec3",\n  INT_VEC4: "ivec4",\n  UNSIGNED_INT: "uint",\n  UNSIGNED_INT_VEC2: "uvec2",\n  UNSIGNED_INT_VEC3: "uvec3",\n  UNSIGNED_INT_VEC4: "uvec4",\n  BOOL: "bool",\n  BOOL_VEC2: "bvec2",\n  BOOL_VEC3: "bvec3",\n  BOOL_VEC4: "bvec4",\n  FLOAT_MAT2: "mat2",\n  FLOAT_MAT3: "mat3",\n  FLOAT_MAT4: "mat4",\n  SAMPLER_2D: "sampler2D",\n  INT_SAMPLER_2D: "sampler2D",\n  UNSIGNED_INT_SAMPLER_2D: "sampler2D",\n  SAMPLER_CUBE: "samplerCube",\n  INT_SAMPLER_CUBE: "samplerCube",\n  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",\n  SAMPLER_2D_ARRAY: "sampler2DArray",\n  INT_SAMPLER_2D_ARRAY: "sampler2DArray",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"\n};\nfunction mapType(gl, type) {\n  if (!GL_TABLE) {\n    const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (let i = 0; i < typeNames.length; ++i) {\n      const tn = typeNames[i];\n      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n    }\n  }\n  return GL_TABLE[type];\n}\n\n\n//# sourceMappingURL=mapType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs\n\n\nfunction setPrecision(src, requestedPrecision, maxSupportedPrecision) {\n  if (src.substring(0, 9) !== "precision") {\n    let precision = requestedPrecision;\n    if (requestedPrecision === lib/* PRECISION.HIGH */.cB.HIGH && maxSupportedPrecision !== lib/* PRECISION.HIGH */.cB.HIGH) {\n      precision = lib/* PRECISION.MEDIUM */.cB.MEDIUM;\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== lib/* PRECISION.HIGH */.cB.HIGH && src.substring(0, 15) === "precision highp") {\n    return src.replace("precision highp", "precision mediump");\n  }\n  return src;\n}\n\n\n//# sourceMappingURL=setPrecision.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/Program.mjs\n\n\n\n\n\n\n\n\nlet Program_UID = 0;\nconst nameCache = {};\nconst _Program = class {\n  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {\n    this.extra = {};\n    this.id = Program_UID++;\n    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;\n    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;\n    this.vertexSrc = this.vertexSrc.trim();\n    this.fragmentSrc = this.fragmentSrc.trim();\n    this.extra = extra;\n    if (this.vertexSrc.substring(0, 8) !== "#version") {\n      name = name.replace(/\\s+/g, "-");\n      if (nameCache[name]) {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n      } else {\n        nameCache[name] = 1;\n      }\n      this.vertexSrc = `#define SHADER_NAME ${name}\n${this.vertexSrc}`;\n      this.fragmentSrc = `#define SHADER_NAME ${name}\n${this.fragmentSrc}`;\n      this.vertexSrc = setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, lib/* PRECISION.HIGH */.cB.HIGH);\n      this.fragmentSrc = setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision());\n    }\n    this.glPrograms = {};\n    this.syncUniforms = null;\n  }\n  static get defaultVertexSrc() {\n    return defaultVertex;\n  }\n  static get defaultFragmentSrc() {\n    return defaultFragment;\n  }\n  static from(vertexSrc, fragmentSrc, name) {\n    const key = vertexSrc + fragmentSrc;\n    let program = utils_lib.ProgramCache[key];\n    if (!program) {\n      utils_lib.ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);\n    }\n    return program;\n  }\n};\nlet Program = _Program;\nProgram.defaultVertexPrecision = lib/* PRECISION.HIGH */.cB.HIGH;\nProgram.defaultFragmentPrecision = utils_lib.isMobile.apple.device ? lib/* PRECISION.HIGH */.cB.HIGH : lib/* PRECISION.MEDIUM */.cB.MEDIUM;\n\n\n//# sourceMappingURL=Program.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/UniformGroup.mjs\n\n\n\nlet UniformGroup_UID = 0;\nclass UniformGroup {\n  constructor(uniforms, isStatic, isUbo) {\n    this.group = true;\n    this.syncUniforms = {};\n    this.dirtyId = 0;\n    this.id = UniformGroup_UID++;\n    this.static = !!isStatic;\n    this.ubo = !!isUbo;\n    if (uniforms instanceof Buffer) {\n      this.buffer = uniforms;\n      this.buffer.type = lib/* BUFFER_TYPE.UNIFORM_BUFFER */.mr.UNIFORM_BUFFER;\n      this.autoManage = false;\n      this.ubo = true;\n    } else {\n      this.uniforms = uniforms;\n      if (this.ubo) {\n        this.buffer = new Buffer(new Float32Array(1));\n        this.buffer.type = lib/* BUFFER_TYPE.UNIFORM_BUFFER */.mr.UNIFORM_BUFFER;\n        this.autoManage = true;\n      }\n    }\n  }\n  update() {\n    this.dirtyId++;\n    if (!this.autoManage && this.buffer) {\n      this.buffer.update();\n    }\n  }\n  add(name, uniforms, _static) {\n    if (!this.ubo) {\n      this.uniforms[name] = new UniformGroup(uniforms, _static);\n    } else {\n      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");\n    }\n  }\n  static from(uniforms, _static, _ubo) {\n    return new UniformGroup(uniforms, _static, _ubo);\n  }\n  static uboFrom(uniforms, _static) {\n    return new UniformGroup(uniforms, _static ?? true, true);\n  }\n}\n\n\n//# sourceMappingURL=UniformGroup.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/Shader.mjs\n\n\n\n\nclass Shader {\n  constructor(program, uniforms) {\n    this.uniformBindCount = 0;\n    this.program = program;\n    if (uniforms) {\n      if (uniforms instanceof UniformGroup) {\n        this.uniformGroup = uniforms;\n      } else {\n        this.uniformGroup = new UniformGroup(uniforms);\n      }\n    } else {\n      this.uniformGroup = new UniformGroup({});\n    }\n    this.disposeRunner = new Runner_Runner("disposeShader");\n  }\n  checkUniformExists(name, group) {\n    if (group.uniforms[name]) {\n      return true;\n    }\n    for (const i in group.uniforms) {\n      const uniform = group.uniforms[i];\n      if (uniform.group) {\n        if (this.checkUniformExists(name, uniform)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  destroy() {\n    this.uniformGroup = null;\n    this.disposeRunner.emit(this);\n    this.disposeRunner.destroy();\n  }\n  get uniforms() {\n    return this.uniformGroup.uniforms;\n  }\n  static from(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.from(vertexSrc, fragmentSrc);\n    return new Shader(program, uniforms);\n  }\n}\n\n\n//# sourceMappingURL=Shader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs\n\n\n\n\n\nclass BatchShaderGenerator {\n  constructor(vertexSrc, fragTemplate) {\n    this.vertexSrc = vertexSrc;\n    this.fragTemplate = fragTemplate;\n    this.programCache = {};\n    this.defaultGroupCache = {};\n    if (!fragTemplate.includes("%count%")) {\n      throw new Error(\'Fragment template must contain "%count%".\');\n    }\n    if (!fragTemplate.includes("%forloop%")) {\n      throw new Error(\'Fragment template must contain "%forloop%".\');\n    }\n  }\n  generateShader(maxTextures) {\n    if (!this.programCache[maxTextures]) {\n      const sampleValues = new Int32Array(maxTextures);\n      for (let i = 0; i < maxTextures; i++) {\n        sampleValues[i] = i;\n      }\n      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);\n      let fragmentSrc = this.fragTemplate;\n      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);\n      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n    }\n    const uniforms = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new math_lib/* Matrix */.y3(),\n      default: this.defaultGroupCache[maxTextures]\n    };\n    return new Shader(this.programCache[maxTextures], uniforms);\n  }\n  generateSampleSrc(maxTextures) {\n    let src = "";\n    src += "\\n";\n    src += "\\n";\n    for (let i = 0; i < maxTextures; i++) {\n      if (i > 0) {\n        src += "\\nelse ";\n      }\n      if (i < maxTextures - 1) {\n        src += `if(vTextureId < ${i}.5)`;\n      }\n      src += "\\n{";\n      src += `\n\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`;\n      src += "\\n}";\n    }\n    src += "\\n";\n    src += "\\n";\n    return src;\n  }\n}\n\n\n//# sourceMappingURL=BatchShaderGenerator.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs\nclass BatchTextureArray {\n  constructor() {\n    this.elements = [];\n    this.ids = [];\n    this.count = 0;\n  }\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      this.elements[i] = null;\n    }\n    this.count = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs\n\n\nfunction canUploadSameBuffer() {\n  return !settings_lib/* isMobile.apple.device */.tq.apple.device;\n}\n\n\n//# sourceMappingURL=canUploadSameBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs\n\n\nfunction maxRecommendedTextures(max) {\n  let allowMax = true;\n  const navigator = settings_lib/* settings.ADAPTER.getNavigator */.Xd.ADAPTER.getNavigator();\n  if (settings_lib/* isMobile.tablet */.tq.tablet || settings_lib/* isMobile.phone */.tq.phone) {\n    if (settings_lib/* isMobile.apple.device */.tq.apple.device) {\n      const match = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (match) {\n        const majorVersion = parseInt(match[1], 10);\n        if (majorVersion < 11) {\n          allowMax = false;\n        }\n      }\n    }\n    if (settings_lib/* isMobile.android.device */.tq.android.device) {\n      const match = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (match) {\n        const majorVersion = parseInt(match[1], 10);\n        if (majorVersion < 7) {\n          allowMax = false;\n        }\n      }\n    }\n  }\n  return allowMax ? max : 4;\n}\n\n\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs\nclass ObjectRenderer {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  flush() {\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  start() {\n  }\n  stop() {\n    this.flush();\n  }\n  render(_object) {\n  }\n}\n\n\n//# sourceMappingURL=ObjectRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/texture.mjs\nvar texture_defaultFragment = "varying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying float vTextureId;\\nuniform sampler2D uSamplers[%count%];\\n\\nvoid main(void){\\n    vec4 color;\\n    %forloop%\\n    gl_FragColor = color * vColor;\\n}\\n";\n\n\n//# sourceMappingURL=texture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/texture2.mjs\nvar texture2_defaultVertex = "precision highp float;\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\nattribute float aTextureId;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform vec4 tint;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying float vTextureId;\\n\\nvoid main(void){\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vTextureId = aTextureId;\\n    vColor = aColor * tint;\\n}\\n";\n\n\n//# sourceMappingURL=texture2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchRenderer.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _BatchRenderer = class extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    this.setShaderGenerator();\n    this.geometryClass = BatchGeometry;\n    this.vertexSize = 6;\n    this.state = State.for2d();\n    this.size = _BatchRenderer.defaultBatchSize * 4;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n    this._bufferedElements = [];\n    this._bufferedTextures = [];\n    this._bufferSize = 0;\n    this._shader = null;\n    this._packedGeometries = [];\n    this._packedGeometryPoolSize = 2;\n    this._flushId = 0;\n    this._aBuffers = {};\n    this._iBuffers = {};\n    this.maxTextures = 1;\n    this.renderer.on("prerender", this.onPrerender, this);\n    renderer.runners.contextChange.add(this);\n    this._dcIndex = 0;\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    this._tempBoundTextures = [];\n  }\n  static get defaultMaxTextures() {\n    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);\n    return this._defaultMaxTextures;\n  }\n  static set defaultMaxTextures(value) {\n    this._defaultMaxTextures = value;\n  }\n  static get canUploadSameBuffer() {\n    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();\n    return this._canUploadSameBuffer;\n  }\n  static set canUploadSameBuffer(value) {\n    this._canUploadSameBuffer = value;\n  }\n  get MAX_TEXTURES() {\n    (0,utils_lib.deprecation)("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");\n    return this.maxTextures;\n  }\n  static get defaultVertexSrc() {\n    return texture2_defaultVertex;\n  }\n  static get defaultFragmentTemplate() {\n    return texture_defaultFragment;\n  }\n  setShaderGenerator({\n    vertex = _BatchRenderer.defaultVertexSrc,\n    fragment = _BatchRenderer.defaultFragmentTemplate\n  } = {}) {\n    this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n  }\n  contextChange() {\n    const gl = this.renderer.gl;\n    if (settings_lib/* settings.PREFER_ENV */.Xd.PREFER_ENV === lib/* ENV.WEBGL_LEGACY */.Vi.WEBGL_LEGACY) {\n      this.maxTextures = 1;\n    } else {\n      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);\n      this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);\n    }\n    this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n    for (let i = 0; i < this._packedGeometryPoolSize; i++) {\n      this._packedGeometries[i] = new this.geometryClass();\n    }\n    this.initFlushBuffers();\n  }\n  initFlushBuffers() {\n    const {\n      _drawCallPool,\n      _textureArrayPool\n    } = _BatchRenderer;\n    const MAX_SPRITES = this.size / 4;\n    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n    while (_drawCallPool.length < MAX_SPRITES) {\n      _drawCallPool.push(new BatchDrawCall());\n    }\n    while (_textureArrayPool.length < MAX_TA) {\n      _textureArrayPool.push(new BatchTextureArray());\n    }\n    for (let i = 0; i < this.maxTextures; i++) {\n      this._tempBoundTextures[i] = null;\n    }\n  }\n  onPrerender() {\n    this._flushId = 0;\n  }\n  render(element) {\n    if (!element._texture.valid) {\n      return;\n    }\n    if (this._vertexCount + element.vertexData.length / 2 > this.size) {\n      this.flush();\n    }\n    this._vertexCount += element.vertexData.length / 2;\n    this._indexCount += element.indices.length;\n    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n    this._bufferedElements[this._bufferSize++] = element;\n  }\n  buildTexturesAndDrawCalls() {\n    const {\n      _bufferedTextures: textures,\n      maxTextures\n    } = this;\n    const textureArrays = _BatchRenderer._textureArrayPool;\n    const batch = this.renderer.batch;\n    const boundTextures = this._tempBoundTextures;\n    const touch = this.renderer.textureGC.count;\n    let TICK = ++BaseTexture._globalBatch;\n    let countTexArrays = 0;\n    let texArray = textureArrays[0];\n    let start = 0;\n    batch.copyBoundTextures(boundTextures, maxTextures);\n    for (let i = 0; i < this._bufferSize; ++i) {\n      const tex = textures[i];\n      textures[i] = null;\n      if (tex._batchEnabled === TICK) {\n        continue;\n      }\n      if (texArray.count >= maxTextures) {\n        batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n        this.buildDrawCalls(texArray, start, i);\n        start = i;\n        texArray = textureArrays[++countTexArrays];\n        ++TICK;\n      }\n      tex._batchEnabled = TICK;\n      tex.touched = touch;\n      texArray.elements[texArray.count++] = tex;\n    }\n    if (texArray.count > 0) {\n      batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n      this.buildDrawCalls(texArray, start, this._bufferSize);\n      ++countTexArrays;\n      ++TICK;\n    }\n    for (let i = 0; i < boundTextures.length; i++) {\n      boundTextures[i] = null;\n    }\n    BaseTexture._globalBatch = TICK;\n  }\n  buildDrawCalls(texArray, start, finish) {\n    const {\n      _bufferedElements: elements,\n      _attributeBuffer,\n      _indexBuffer,\n      vertexSize\n    } = this;\n    const drawCalls = _BatchRenderer._drawCallPool;\n    let dcIndex = this._dcIndex;\n    let aIndex = this._aIndex;\n    let iIndex = this._iIndex;\n    let drawCall = drawCalls[dcIndex];\n    drawCall.start = this._iIndex;\n    drawCall.texArray = texArray;\n    for (let i = start; i < finish; ++i) {\n      const sprite = elements[i];\n      const tex = sprite._texture.baseTexture;\n      const spriteBlendMode = utils_lib.premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n      elements[i] = null;\n      if (start < i && drawCall.blend !== spriteBlendMode) {\n        drawCall.size = iIndex - drawCall.start;\n        start = i;\n        drawCall = drawCalls[++dcIndex];\n        drawCall.texArray = texArray;\n        drawCall.start = iIndex;\n      }\n      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n      aIndex += sprite.vertexData.length / 2 * vertexSize;\n      iIndex += sprite.indices.length;\n      drawCall.blend = spriteBlendMode;\n    }\n    if (start < finish) {\n      drawCall.size = iIndex - drawCall.start;\n      ++dcIndex;\n    }\n    this._dcIndex = dcIndex;\n    this._aIndex = aIndex;\n    this._iIndex = iIndex;\n  }\n  bindAndClearTexArray(texArray) {\n    const textureSystem = this.renderer.texture;\n    for (let j = 0; j < texArray.count; j++) {\n      textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n      texArray.elements[j] = null;\n    }\n    texArray.count = 0;\n  }\n  updateGeometry() {\n    const {\n      _packedGeometries: packedGeometries,\n      _attributeBuffer: attributeBuffer,\n      _indexBuffer: indexBuffer\n    } = this;\n    if (!_BatchRenderer.canUploadSameBuffer) {\n      if (this._packedGeometryPoolSize <= this._flushId) {\n        this._packedGeometryPoolSize++;\n        packedGeometries[this._flushId] = new this.geometryClass();\n      }\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.bind(packedGeometries[this._flushId]);\n      this.renderer.geometry.updateBuffers();\n      this._flushId++;\n    } else {\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.updateBuffers();\n    }\n  }\n  drawBatches() {\n    const dcCount = this._dcIndex;\n    const { gl, state: stateSystem } = this.renderer;\n    const drawCalls = _BatchRenderer._drawCallPool;\n    let curTexArray = null;\n    for (let i = 0; i < dcCount; i++) {\n      const { texArray, type, size, start, blend } = drawCalls[i];\n      if (curTexArray !== texArray) {\n        curTexArray = texArray;\n        this.bindAndClearTexArray(texArray);\n      }\n      this.state.blendMode = blend;\n      stateSystem.set(this.state);\n      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n    }\n  }\n  flush() {\n    if (this._vertexCount === 0) {\n      return;\n    }\n    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n    this._indexBuffer = this.getIndexBuffer(this._indexCount);\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._dcIndex = 0;\n    this.buildTexturesAndDrawCalls();\n    this.updateGeometry();\n    this.drawBatches();\n    this._bufferSize = 0;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n  }\n  start() {\n    this.renderer.state.set(this.state);\n    this.renderer.texture.ensureSamplerType(this.maxTextures);\n    this.renderer.shader.bind(this._shader);\n    if (_BatchRenderer.canUploadSameBuffer) {\n      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n    }\n  }\n  stop() {\n    this.flush();\n  }\n  destroy() {\n    for (let i = 0; i < this._packedGeometryPoolSize; i++) {\n      if (this._packedGeometries[i]) {\n        this._packedGeometries[i].destroy();\n      }\n    }\n    this.renderer.off("prerender", this.onPrerender, this);\n    this._aBuffers = null;\n    this._iBuffers = null;\n    this._packedGeometries = null;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    if (this._shader) {\n      this._shader.destroy();\n      this._shader = null;\n    }\n    super.destroy();\n  }\n  getAttributeBuffer(size) {\n    const roundedP2 = (0,utils_lib.nextPow2)(Math.ceil(size / 8));\n    const roundedSizeIndex = (0,utils_lib.log2)(roundedP2);\n    const roundedSize = roundedP2 * 8;\n    if (this._aBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    let buffer = this._aBuffers[roundedSize];\n    if (!buffer) {\n      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n    }\n    return buffer;\n  }\n  getIndexBuffer(size) {\n    const roundedP2 = (0,utils_lib.nextPow2)(Math.ceil(size / 12));\n    const roundedSizeIndex = (0,utils_lib.log2)(roundedP2);\n    const roundedSize = roundedP2 * 12;\n    if (this._iBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    let buffer = this._iBuffers[roundedSizeIndex];\n    if (!buffer) {\n      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n    }\n    return buffer;\n  }\n  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n    const {\n      uint32View,\n      float32View\n    } = attributeBuffer;\n    const packedVertices = aIndex / this.vertexSize;\n    const uvs = element.uvs;\n    const indicies = element.indices;\n    const vertexData = element.vertexData;\n    const textureId = element._texture.baseTexture._batchLocation;\n    const alpha = Math.min(element.worldAlpha, 1);\n    const argb = color_lib/* Color.shared.setValue */.I.shared.setValue(element._tintRGB).toPremultiplied(alpha);\n    for (let i = 0; i < vertexData.length; i += 2) {\n      float32View[aIndex++] = vertexData[i];\n      float32View[aIndex++] = vertexData[i + 1];\n      float32View[aIndex++] = uvs[i];\n      float32View[aIndex++] = uvs[i + 1];\n      uint32View[aIndex++] = argb;\n      float32View[aIndex++] = textureId;\n    }\n    for (let i = 0; i < indicies.length; i++) {\n      indexBuffer[iIndex++] = packedVertices + indicies[i];\n    }\n  }\n};\nlet BatchRenderer = _BatchRenderer;\nBatchRenderer.defaultBatchSize = 4096;\nBatchRenderer.extension = {\n  name: "batch",\n  type: ExtensionType.RendererPlugin\n};\nBatchRenderer._drawCallPool = [];\nBatchRenderer._textureArrayPool = [];\nextensions.add(BatchRenderer);\n\n\n//# sourceMappingURL=BatchRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/defaultFilter.mjs\nvar defaultFilter_defaultFragment = "varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\\n}\\n";\n\n\n//# sourceMappingURL=defaultFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/defaultFilter2.mjs\nvar defaultFilter2_defaultVertex = "attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n";\n\n\n//# sourceMappingURL=defaultFilter2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/Filter.mjs\n\n\n\n\n\n\n\nconst _Filter = class extends Shader {\n  constructor(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);\n    super(program, uniforms);\n    this.padding = 0;\n    this.resolution = _Filter.defaultResolution;\n    this.multisample = _Filter.defaultMultisample;\n    this.enabled = true;\n    this.autoFit = true;\n    this.state = new State();\n  }\n  apply(filterManager, input, output, clearMode, _currentState) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._resolution = value;\n  }\n  static get defaultVertexSrc() {\n    return defaultFilter2_defaultVertex;\n  }\n  static get defaultFragmentSrc() {\n    return defaultFilter_defaultFragment;\n  }\n};\nlet Filter = _Filter;\nFilter.defaultResolution = 1;\nFilter.defaultMultisample = lib/* MSAA_QUALITY.NONE */.G5.NONE;\n\n\n//# sourceMappingURL=Filter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs\n\n\n\nclass BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new color_lib/* Color */.I(0);\n    this.alpha = 1;\n  }\n  init(options) {\n    this.clearBeforeRender = options.clearBeforeRender;\n    const { backgroundColor, background, backgroundAlpha } = options;\n    const color = background ?? backgroundColor;\n    if (color !== void 0) {\n      this.color = color;\n    }\n    this.alpha = backgroundAlpha;\n  }\n  get color() {\n    return this._backgroundColor.value;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  destroy() {\n  }\n}\nBackgroundSystem.defaultOptions = {\n  backgroundAlpha: 1,\n  backgroundColor: 0,\n  clearBeforeRender: true\n};\nBackgroundSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "background"\n};\nextensions.add(BackgroundSystem);\n\n\n//# sourceMappingURL=BackgroundSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchSystem.mjs\n\n\n\nclass BatchSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.emptyRenderer = new ObjectRenderer(renderer);\n    this.currentRenderer = this.emptyRenderer;\n  }\n  setObjectRenderer(objectRenderer) {\n    if (this.currentRenderer === objectRenderer) {\n      return;\n    }\n    this.currentRenderer.stop();\n    this.currentRenderer = objectRenderer;\n    this.currentRenderer.start();\n  }\n  flush() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }\n  reset() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }\n  copyBoundTextures(arr, maxTextures) {\n    const { boundTextures } = this.renderer.texture;\n    for (let i = maxTextures - 1; i >= 0; --i) {\n      arr[i] = boundTextures[i] || null;\n      if (arr[i]) {\n        arr[i]._batchLocation = i;\n      }\n    }\n  }\n  boundArray(texArray, boundTextures, batchId, maxTextures) {\n    const { elements, ids, count } = texArray;\n    let j = 0;\n    for (let i = 0; i < count; i++) {\n      const tex = elements[i];\n      const loc = tex._batchLocation;\n      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {\n        ids[i] = loc;\n        continue;\n      }\n      while (j < maxTextures) {\n        const bound = boundTextures[j];\n        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {\n          j++;\n          continue;\n        }\n        ids[i] = j;\n        tex._batchLocation = j;\n        boundTextures[j] = tex;\n        break;\n      }\n    }\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nBatchSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "batch"\n};\nextensions.add(BatchSystem);\n\n\n//# sourceMappingURL=BatchSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/context/ContextSystem.mjs\n\n\n\n\nlet CONTEXT_UID_COUNTER = 0;\nclass ContextSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.webGLVersion = 1;\n    this.extensions = {};\n    this.supports = {\n      uint32Indices: false\n    };\n    this.handleContextLost = this.handleContextLost.bind(this);\n    this.handleContextRestored = this.handleContextRestored.bind(this);\n  }\n  get isLost() {\n    return !this.gl || this.gl.isContextLost();\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.renderer.gl = gl;\n    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n  }\n  init(options) {\n    if (options.context) {\n      this.initFromContext(options.context);\n    } else {\n      const alpha = this.renderer.background.alpha < 1;\n      const premultipliedAlpha = options.premultipliedAlpha;\n      this.preserveDrawingBuffer = options.preserveDrawingBuffer;\n      this.useContextAlpha = options.useContextAlpha;\n      this.powerPreference = options.powerPreference;\n      this.initFromOptions({\n        alpha,\n        premultipliedAlpha,\n        antialias: options.antialias,\n        stencil: true,\n        preserveDrawingBuffer: options.preserveDrawingBuffer,\n        powerPreference: options.powerPreference\n      });\n    }\n  }\n  initFromContext(gl) {\n    this.gl = gl;\n    this.validateContext(gl);\n    this.renderer.gl = gl;\n    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n    this.renderer.runners.contextChange.emit(gl);\n    const view = this.renderer.view;\n    if (view.addEventListener !== void 0) {\n      view.addEventListener("webglcontextlost", this.handleContextLost, false);\n      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);\n    }\n  }\n  initFromOptions(options) {\n    const gl = this.createContext(this.renderer.view, options);\n    this.initFromContext(gl);\n  }\n  createContext(canvas, options) {\n    let gl;\n    if (settings_lib/* settings.PREFER_ENV */.Xd.PREFER_ENV >= lib/* ENV.WEBGL2 */.Vi.WEBGL2) {\n      gl = canvas.getContext("webgl2", options);\n    }\n    if (gl) {\n      this.webGLVersion = 2;\n    } else {\n      this.webGLVersion = 1;\n      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);\n      if (!gl) {\n        throw new Error("This browser does not support WebGL. Try using the canvas renderer");\n      }\n    }\n    this.gl = gl;\n    this.getExtensions();\n    return this.gl;\n  }\n  getExtensions() {\n    const { gl } = this;\n    const common = {\n      loseContext: gl.getExtension("WEBGL_lose_context"),\n      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),\n      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),\n      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),\n      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),\n      etc: gl.getExtension("WEBGL_compressed_texture_etc"),\n      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),\n      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),\n      atc: gl.getExtension("WEBGL_compressed_texture_atc"),\n      astc: gl.getExtension("WEBGL_compressed_texture_astc")\n    };\n    if (this.webGLVersion === 1) {\n      Object.assign(this.extensions, common, {\n        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),\n        depthTexture: gl.getExtension("WEBGL_depth_texture"),\n        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),\n        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),\n        floatTexture: gl.getExtension("OES_texture_float"),\n        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),\n        textureHalfFloat: gl.getExtension("OES_texture_half_float"),\n        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")\n      });\n    } else if (this.webGLVersion === 2) {\n      Object.assign(this.extensions, common, {\n        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")\n      });\n    }\n  }\n  handleContextLost(event) {\n    event.preventDefault();\n    setTimeout(() => {\n      if (this.gl.isContextLost() && this.extensions.loseContext) {\n        this.extensions.loseContext.restoreContext();\n      }\n    }, 0);\n  }\n  handleContextRestored() {\n    this.renderer.runners.contextChange.emit(this.gl);\n  }\n  destroy() {\n    const view = this.renderer.view;\n    this.renderer = null;\n    if (view.removeEventListener !== void 0) {\n      view.removeEventListener("webglcontextlost", this.handleContextLost);\n      view.removeEventListener("webglcontextrestored", this.handleContextRestored);\n    }\n    this.gl.useProgram(null);\n    if (this.extensions.loseContext) {\n      this.extensions.loseContext.loseContext();\n    }\n  }\n  postrender() {\n    if (this.renderer.objectRenderer.renderingToScreen) {\n      this.gl.flush();\n    }\n  }\n  validateContext(gl) {\n    const attributes = gl.getContextAttributes();\n    const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;\n    if (isWebGl2) {\n      this.webGLVersion = 2;\n    }\n    if (attributes && !attributes.stencil) {\n      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");\n    }\n    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");\n    this.supports.uint32Indices = hasuint32;\n    if (!hasuint32) {\n      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");\n    }\n  }\n}\nContextSystem.defaultOptions = {\n  context: null,\n  antialias: false,\n  premultipliedAlpha: true,\n  preserveDrawingBuffer: false,\n  powerPreference: "default"\n};\nContextSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "context"\n};\nextensions.add(ContextSystem);\n\n\n//# sourceMappingURL=ContextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/DepthResource.mjs\n\n\n\nclass DepthResource extends BufferResource {\n  upload(renderer, baseTexture, glTexture) {\n    const gl = renderer.gl;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === lib/* ALPHA_MODES.UNPACK */.iw.UNPACK);\n    const width = baseTexture.realWidth;\n    const height = baseTexture.realHeight;\n    if (glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);\n    }\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=DepthResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs\n\n\n\n\n\nclass Framebuffer {\n  constructor(width, height) {\n    this.width = Math.round(width || 100);\n    this.height = Math.round(height || 100);\n    this.stencil = false;\n    this.depth = false;\n    this.dirtyId = 0;\n    this.dirtyFormat = 0;\n    this.dirtySize = 0;\n    this.depthTexture = null;\n    this.colorTextures = [];\n    this.glFramebuffers = {};\n    this.disposeRunner = new Runner_Runner("disposeFramebuffer");\n    this.multisample = lib/* MSAA_QUALITY.NONE */.G5.NONE;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  addColorTexture(index = 0, texture) {\n    this.colorTextures[index] = texture || new BaseTexture(null, {\n      scaleMode: lib/* SCALE_MODES.NEAREST */.aH.NEAREST,\n      resolution: 1,\n      mipmap: lib/* MIPMAP_MODES.OFF */.WB.OFF,\n      width: this.width,\n      height: this.height\n    });\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  addDepthTexture(texture) {\n    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {\n      scaleMode: lib/* SCALE_MODES.NEAREST */.aH.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: lib/* MIPMAP_MODES.OFF */.WB.OFF,\n      format: lib/* FORMATS.DEPTH_COMPONENT */.I2.DEPTH_COMPONENT,\n      type: lib/* TYPES.UNSIGNED_SHORT */.vK.UNSIGNED_SHORT\n    });\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  enableDepth() {\n    this.depth = true;\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  enableStencil() {\n    this.stencil = true;\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  resize(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    if (width === this.width && height === this.height)\n      return;\n    this.width = width;\n    this.height = height;\n    this.dirtyId++;\n    this.dirtySize++;\n    for (let i = 0; i < this.colorTextures.length; i++) {\n      const texture = this.colorTextures[i];\n      const resolution = texture.resolution;\n      texture.setSize(width / resolution, height / resolution);\n    }\n    if (this.depthTexture) {\n      const resolution = this.depthTexture.resolution;\n      this.depthTexture.setSize(width / resolution, height / resolution);\n    }\n  }\n  dispose() {\n    this.disposeRunner.emit(this, false);\n  }\n  destroyDepthTexture() {\n    if (this.depthTexture) {\n      this.depthTexture.destroy();\n      this.depthTexture = null;\n      ++this.dirtyId;\n      ++this.dirtyFormat;\n    }\n  }\n}\n\n\n//# sourceMappingURL=Framebuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs\n\n\n\n\n\nclass BaseRenderTexture extends BaseTexture {\n  constructor(options = {}) {\n    if (typeof options === "number") {\n      const width = arguments[0];\n      const height = arguments[1];\n      const scaleMode = arguments[2];\n      const resolution = arguments[3];\n      options = { width, height, scaleMode, resolution };\n    }\n    options.width = options.width || 100;\n    options.height = options.height || 100;\n    options.multisample ?? (options.multisample = lib/* MSAA_QUALITY.NONE */.G5.NONE);\n    super(null, options);\n    this.mipmap = lib/* MIPMAP_MODES.OFF */.WB.OFF;\n    this.valid = true;\n    this._clear = new color_lib/* Color */.I([0, 0, 0, 0]);\n    this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);\n    this.framebuffer.multisample = options.multisample;\n    this.maskStack = [];\n    this.filterStack = [{}];\n  }\n  set clearColor(value) {\n    this._clear.setValue(value);\n  }\n  get clearColor() {\n    return this._clear.value;\n  }\n  get clear() {\n    return this._clear;\n  }\n  resize(desiredWidth, desiredHeight) {\n    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);\n    this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n  }\n  dispose() {\n    this.framebuffer.dispose();\n    super.dispose();\n  }\n  destroy() {\n    super.destroy();\n    this.framebuffer.destroyDepthTexture();\n    this.framebuffer = null;\n  }\n}\n\n\n//# sourceMappingURL=BaseRenderTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs\n\n\n\n\nclass BaseImageResource extends Resource {\n  constructor(source) {\n    const sourceAny = source;\n    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;\n    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;\n    super(width, height);\n    this.source = source;\n    this.noSubImage = false;\n  }\n  static crossOrigin(element, url, crossorigin) {\n    if (crossorigin === void 0 && !url.startsWith("data:")) {\n      element.crossOrigin = (0,utils_lib.determineCrossOrigin)(url);\n    } else if (crossorigin !== false) {\n      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";\n    }\n  }\n  upload(renderer, baseTexture, glTexture, source) {\n    const gl = renderer.gl;\n    const width = baseTexture.realWidth;\n    const height = baseTexture.realHeight;\n    source = source || this.source;\n    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {\n      if (!source.complete || source.naturalWidth === 0) {\n        return false;\n      }\n    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {\n      if (source.readyState <= 1 && source.buffered.length === 0) {\n        return false;\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === lib/* ALPHA_MODES.UNPACK */.iw.UNPACK);\n    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);\n    }\n    return true;\n  }\n  update() {\n    if (this.destroyed) {\n      return;\n    }\n    const source = this.source;\n    const width = source.naturalWidth || source.videoWidth || source.width;\n    const height = source.naturalHeight || source.videoHeight || source.height;\n    this.resize(width, height);\n    super.update();\n  }\n  dispose() {\n    this.source = null;\n  }\n}\n\n\n//# sourceMappingURL=BaseImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs\n\n\n\n\nclass ImageResource extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    if (typeof source === "string") {\n      const imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n      imageElement.src = source;\n      source = imageElement;\n    }\n    super(source);\n    if (!source.complete && !!this._width && !!this._height) {\n      this._width = 0;\n      this._height = 0;\n    }\n    this.url = source.src;\n    this._process = null;\n    this.preserveBitmap = false;\n    this.createBitmap = (options.createBitmap ?? settings_lib/* settings.CREATE_IMAGE_BITMAP */.Xd.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;\n    this.bitmap = null;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load(createBitmap) {\n    if (this._load) {\n      return this._load;\n    }\n    if (createBitmap !== void 0) {\n      this.createBitmap = createBitmap;\n    }\n    this._load = new Promise((resolve, reject) => {\n      const source = this.source;\n      this.url = source.src;\n      const completed = () => {\n        if (this.destroyed) {\n          return;\n        }\n        source.onload = null;\n        source.onerror = null;\n        this.resize(source.width, source.height);\n        this._load = null;\n        if (this.createBitmap) {\n          resolve(this.process());\n        } else {\n          resolve(this);\n        }\n      };\n      if (source.complete && source.src) {\n        completed();\n      } else {\n        source.onload = completed;\n        source.onerror = (event) => {\n          reject(event);\n          this.onError.emit(event);\n        };\n      }\n    });\n    return this._load;\n  }\n  process() {\n    const source = this.source;\n    if (this._process !== null) {\n      return this._process;\n    }\n    if (this.bitmap !== null || !globalThis.createImageBitmap) {\n      return Promise.resolve(this);\n    }\n    const createImageBitmap = globalThis.createImageBitmap;\n    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";\n    this._process = fetch(source.src, {\n      mode: cors ? "cors" : "no-cors"\n    }).then((r) => r.blob()).then((blob) => createImageBitmap(blob, 0, 0, source.width, source.height, {\n      premultiplyAlpha: this.alphaMode === null || this.alphaMode === lib/* ALPHA_MODES.UNPACK */.iw.UNPACK ? "premultiply" : "none"\n    })).then((bitmap) => {\n      if (this.destroyed) {\n        return Promise.reject();\n      }\n      this.bitmap = bitmap;\n      this.update();\n      this._process = null;\n      return Promise.resolve(this);\n    });\n    return this._process;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode === "number") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    if (!this.createBitmap) {\n      return super.upload(renderer, baseTexture, glTexture);\n    }\n    if (!this.bitmap) {\n      this.process();\n      if (!this.bitmap) {\n        return false;\n      }\n    }\n    super.upload(renderer, baseTexture, glTexture, this.bitmap);\n    if (!this.preserveBitmap) {\n      let flag = true;\n      const glTextures = baseTexture._glTextures;\n      for (const key in glTextures) {\n        const otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        if (this.bitmap.close) {\n          this.bitmap.close();\n        }\n        this.bitmap = null;\n      }\n    }\n    return true;\n  }\n  dispose() {\n    this.source.onload = null;\n    this.source.onerror = null;\n    super.dispose();\n    if (this.bitmap) {\n      this.bitmap.close();\n      this.bitmap = null;\n    }\n    this._process = null;\n    this._load = null;\n  }\n  static test(source) {\n    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);\n  }\n}\n\n\n//# sourceMappingURL=ImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureUvs.mjs\n\n\nclass TextureUvs {\n  constructor() {\n    this.x0 = 0;\n    this.y0 = 0;\n    this.x1 = 1;\n    this.y1 = 0;\n    this.x2 = 1;\n    this.y2 = 1;\n    this.x3 = 0;\n    this.y3 = 1;\n    this.uvsFloat32 = new Float32Array(8);\n  }\n  set(frame, baseFrame, rotate) {\n    const tw = baseFrame.width;\n    const th = baseFrame.height;\n    if (rotate) {\n      const w2 = frame.width / 2 / tw;\n      const h2 = frame.height / 2 / th;\n      const cX = frame.x / tw + w2;\n      const cY = frame.y / th + h2;\n      rotate = math_lib/* groupD8.add */.Lv.add(rotate, math_lib/* groupD8.NW */.Lv.NW);\n      this.x0 = cX + w2 * math_lib/* groupD8.uX */.Lv.uX(rotate);\n      this.y0 = cY + h2 * math_lib/* groupD8.uY */.Lv.uY(rotate);\n      rotate = math_lib/* groupD8.add */.Lv.add(rotate, 2);\n      this.x1 = cX + w2 * math_lib/* groupD8.uX */.Lv.uX(rotate);\n      this.y1 = cY + h2 * math_lib/* groupD8.uY */.Lv.uY(rotate);\n      rotate = math_lib/* groupD8.add */.Lv.add(rotate, 2);\n      this.x2 = cX + w2 * math_lib/* groupD8.uX */.Lv.uX(rotate);\n      this.y2 = cY + h2 * math_lib/* groupD8.uY */.Lv.uY(rotate);\n      rotate = math_lib/* groupD8.add */.Lv.add(rotate, 2);\n      this.x3 = cX + w2 * math_lib/* groupD8.uX */.Lv.uX(rotate);\n      this.y3 = cY + h2 * math_lib/* groupD8.uY */.Lv.uY(rotate);\n    } else {\n      this.x0 = frame.x / tw;\n      this.y0 = frame.y / th;\n      this.x1 = (frame.x + frame.width) / tw;\n      this.y1 = frame.y / th;\n      this.x2 = (frame.x + frame.width) / tw;\n      this.y2 = (frame.y + frame.height) / th;\n      this.x3 = frame.x / tw;\n      this.y3 = (frame.y + frame.height) / th;\n    }\n    this.uvsFloat32[0] = this.x0;\n    this.uvsFloat32[1] = this.y0;\n    this.uvsFloat32[2] = this.x1;\n    this.uvsFloat32[3] = this.y1;\n    this.uvsFloat32[4] = this.x2;\n    this.uvsFloat32[5] = this.y2;\n    this.uvsFloat32[6] = this.x3;\n    this.uvsFloat32[7] = this.y3;\n  }\n  toString() {\n    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;\n  }\n}\n\n\n//# sourceMappingURL=TextureUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/Texture.mjs\n\n\n\n\n\n\n\nconst DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(tex) {\n  tex.destroy = function _emptyDestroy() {\n  };\n  tex.on = function _emptyOn() {\n  };\n  tex.once = function _emptyOnce() {\n  };\n  tex.emit = function _emptyEmit() {\n  };\n}\nclass Texture extends utils_lib.EventEmitter {\n  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {\n    super();\n    this.noFrame = false;\n    if (!frame) {\n      this.noFrame = true;\n      frame = new math_lib/* Rectangle */.Ae(0, 0, 1, 1);\n    }\n    if (baseTexture instanceof Texture) {\n      baseTexture = baseTexture.baseTexture;\n    }\n    this.baseTexture = baseTexture;\n    this._frame = frame;\n    this.trim = trim;\n    this.valid = false;\n    this._uvs = DEFAULT_UVS;\n    this.uvMatrix = null;\n    this.orig = orig || frame;\n    this._rotate = Number(rotate || 0);\n    if (rotate === true) {\n      this._rotate = 2;\n    } else if (this._rotate % 2 !== 0) {\n      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");\n    }\n    this.defaultAnchor = anchor ? new math_lib/* Point */.E9(anchor.x, anchor.y) : new math_lib/* Point */.E9(0, 0);\n    this.defaultBorders = borders;\n    this._updateID = 0;\n    this.textureCacheIds = [];\n    if (!baseTexture.valid) {\n      baseTexture.once("loaded", this.onBaseTextureUpdated, this);\n    } else if (this.noFrame) {\n      if (baseTexture.valid) {\n        this.onBaseTextureUpdated(baseTexture);\n      }\n    } else {\n      this.frame = frame;\n    }\n    if (this.noFrame) {\n      baseTexture.on("update", this.onBaseTextureUpdated, this);\n    }\n  }\n  update() {\n    if (this.baseTexture.resource) {\n      this.baseTexture.resource.update();\n    }\n  }\n  onBaseTextureUpdated(baseTexture) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid) {\n        return;\n      }\n      this._frame.width = baseTexture.width;\n      this._frame.height = baseTexture.height;\n      this.valid = true;\n      this.updateUvs();\n    } else {\n      this.frame = this._frame;\n    }\n    this.emit("update", this);\n  }\n  destroy(destroyBase) {\n    if (this.baseTexture) {\n      if (destroyBase) {\n        const { resource } = this.baseTexture;\n        if (resource?.url && utils_lib.TextureCache[resource.url]) {\n          Texture.removeFromCache(resource.url);\n        }\n        this.baseTexture.destroy();\n      }\n      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);\n      this.baseTexture.off("update", this.onBaseTextureUpdated, this);\n      this.baseTexture = null;\n    }\n    this._frame = null;\n    this._uvs = null;\n    this.trim = null;\n    this.orig = null;\n    this.valid = false;\n    Texture.removeFromCache(this);\n    this.textureCacheIds = null;\n  }\n  clone() {\n    const clonedFrame = this._frame.clone();\n    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();\n    const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);\n    if (this.noFrame) {\n      clonedTexture._frame = clonedFrame;\n    }\n    return clonedTexture;\n  }\n  updateUvs() {\n    if (this._uvs === DEFAULT_UVS) {\n      this._uvs = new TextureUvs();\n    }\n    this._uvs.set(this._frame, this.baseTexture, this.rotate);\n    this._updateID++;\n  }\n  static from(source, options = {}, strict = settings_lib/* settings.STRICT_TEXTURE_CACHE */.Xd.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source === "string";\n    let cacheId = null;\n    if (isFrame) {\n      cacheId = source;\n    } else if (source instanceof BaseTexture) {\n      if (!source.cacheId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source.cacheId = `${prefix}-${(0,utils_lib.uid)()}`;\n        BaseTexture.addToCache(source, source.cacheId);\n      }\n      cacheId = source.cacheId;\n    } else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source._pixiId = `${prefix}_${(0,utils_lib.uid)()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let texture = utils_lib.TextureCache[cacheId];\n    if (isFrame && strict && !texture) {\n      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);\n    }\n    if (!texture && !(source instanceof BaseTexture)) {\n      if (!options.resolution) {\n        options.resolution = (0,utils_lib.getResolutionOfUrl)(source);\n      }\n      texture = new Texture(new BaseTexture(source, options));\n      texture.baseTexture.cacheId = cacheId;\n      BaseTexture.addToCache(texture.baseTexture, cacheId);\n      Texture.addToCache(texture, cacheId);\n    } else if (!texture && source instanceof BaseTexture) {\n      texture = new Texture(source);\n      Texture.addToCache(texture, cacheId);\n    }\n    return texture;\n  }\n  static fromURL(url, options) {\n    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions);\n    const texture = Texture.from(url, Object.assign({ resourceOptions }, options), false);\n    const resource = texture.baseTexture.resource;\n    if (texture.baseTexture.valid) {\n      return Promise.resolve(texture);\n    }\n    return resource.load().then(() => Promise.resolve(texture));\n  }\n  static fromBuffer(buffer, width, height, options) {\n    return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));\n  }\n  static fromLoader(source, imageUrl, name, options) {\n    const baseTexture = new BaseTexture(source, Object.assign({\n      scaleMode: BaseTexture.defaultOptions.scaleMode,\n      resolution: (0,utils_lib.getResolutionOfUrl)(imageUrl)\n    }, options));\n    const { resource } = baseTexture;\n    if (resource instanceof ImageResource) {\n      resource.url = imageUrl;\n    }\n    const texture = new Texture(baseTexture);\n    if (!name) {\n      name = imageUrl;\n    }\n    BaseTexture.addToCache(texture.baseTexture, name);\n    Texture.addToCache(texture, name);\n    if (name !== imageUrl) {\n      BaseTexture.addToCache(texture.baseTexture, imageUrl);\n      Texture.addToCache(texture, imageUrl);\n    }\n    if (texture.baseTexture.valid) {\n      return Promise.resolve(texture);\n    }\n    return new Promise((resolve) => {\n      texture.baseTexture.once("loaded", () => resolve(texture));\n    });\n  }\n  static addToCache(texture, id) {\n    if (id) {\n      if (!texture.textureCacheIds.includes(id)) {\n        texture.textureCacheIds.push(id);\n      }\n      if (utils_lib.TextureCache[id] && utils_lib.TextureCache[id] !== texture) {\n        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);\n      }\n      utils_lib.TextureCache[id] = texture;\n    }\n  }\n  static removeFromCache(texture) {\n    if (typeof texture === "string") {\n      const textureFromCache = utils_lib.TextureCache[texture];\n      if (textureFromCache) {\n        const index = textureFromCache.textureCacheIds.indexOf(texture);\n        if (index > -1) {\n          textureFromCache.textureCacheIds.splice(index, 1);\n        }\n        delete utils_lib.TextureCache[texture];\n        return textureFromCache;\n      }\n    } else if (texture?.textureCacheIds) {\n      for (let i = 0; i < texture.textureCacheIds.length; ++i) {\n        if (utils_lib.TextureCache[texture.textureCacheIds[i]] === texture) {\n          delete utils_lib.TextureCache[texture.textureCacheIds[i]];\n        }\n      }\n      texture.textureCacheIds.length = 0;\n      return texture;\n    }\n    return null;\n  }\n  get resolution() {\n    return this.baseTexture.resolution;\n  }\n  get frame() {\n    return this._frame;\n  }\n  set frame(frame) {\n    this._frame = frame;\n    this.noFrame = false;\n    const { x, y, width, height } = frame;\n    const xNotFit = x + width > this.baseTexture.width;\n    const yNotFit = y + height > this.baseTexture.height;\n    if (xNotFit || yNotFit) {\n      const relationship = xNotFit && yNotFit ? "and" : "or";\n      const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;\n      const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;\n      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);\n    }\n    this.valid = width && height && this.baseTexture.valid;\n    if (!this.trim && !this.rotate) {\n      this.orig = frame;\n    }\n    if (this.valid) {\n      this.updateUvs();\n    }\n  }\n  get rotate() {\n    return this._rotate;\n  }\n  set rotate(rotate) {\n    this._rotate = rotate;\n    if (this.valid) {\n      this.updateUvs();\n    }\n  }\n  get width() {\n    return this.orig.width;\n  }\n  get height() {\n    return this.orig.height;\n  }\n  castToBaseTexture() {\n    return this.baseTexture;\n  }\n  static get EMPTY() {\n    if (!Texture._EMPTY) {\n      Texture._EMPTY = new Texture(new BaseTexture());\n      removeAllHandlers(Texture._EMPTY);\n      removeAllHandlers(Texture._EMPTY.baseTexture);\n    }\n    return Texture._EMPTY;\n  }\n  static get WHITE() {\n    if (!Texture._WHITE) {\n      const canvas = settings_lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas(16, 16);\n      const context = canvas.getContext("2d");\n      canvas.width = 16;\n      canvas.height = 16;\n      context.fillStyle = "white";\n      context.fillRect(0, 0, 16, 16);\n      Texture._WHITE = new Texture(BaseTexture.from(canvas));\n      removeAllHandlers(Texture._WHITE);\n      removeAllHandlers(Texture._WHITE.baseTexture);\n    }\n    return Texture._WHITE;\n  }\n}\n\n\n//# sourceMappingURL=Texture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs\n\n\n\nclass RenderTexture extends Texture {\n  constructor(baseRenderTexture, frame) {\n    super(baseRenderTexture, frame);\n    this.valid = true;\n    this.filterFrame = null;\n    this.filterPoolKey = null;\n    this.updateUvs();\n  }\n  get framebuffer() {\n    return this.baseTexture.framebuffer;\n  }\n  get multisample() {\n    return this.framebuffer.multisample;\n  }\n  set multisample(value) {\n    this.framebuffer.multisample = value;\n  }\n  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {\n    const resolution = this.baseTexture.resolution;\n    const width = Math.round(desiredWidth * resolution) / resolution;\n    const height = Math.round(desiredHeight * resolution) / resolution;\n    this.valid = width > 0 && height > 0;\n    this._frame.width = this.orig.width = width;\n    this._frame.height = this.orig.height = height;\n    if (resizeBaseTexture) {\n      this.baseTexture.resize(width, height);\n    }\n    this.updateUvs();\n  }\n  setResolution(resolution) {\n    const { baseTexture } = this;\n    if (baseTexture.resolution === resolution) {\n      return;\n    }\n    baseTexture.setResolution(resolution);\n    this.resize(baseTexture.width, baseTexture.height, false);\n  }\n  static create(options) {\n    return new RenderTexture(new BaseRenderTexture(options));\n  }\n}\n\n\n//# sourceMappingURL=RenderTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs\n\n\n\n\n\nclass RenderTexturePool {\n  constructor(textureOptions) {\n    this.texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n    this._pixelsWidth = 0;\n    this._pixelsHeight = 0;\n  }\n  createTexture(realWidth, realHeight, multisample = lib/* MSAA_QUALITY.NONE */.G5.NONE) {\n    const baseRenderTexture = new BaseRenderTexture(Object.assign({\n      width: realWidth,\n      height: realHeight,\n      resolution: 1,\n      multisample\n    }, this.textureOptions));\n    return new RenderTexture(baseRenderTexture);\n  }\n  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = lib/* MSAA_QUALITY.NONE */.G5.NONE) {\n    let key;\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {\n      minWidth = (0,utils_lib.nextPow2)(minWidth);\n      minHeight = (0,utils_lib.nextPow2)(minHeight);\n      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;\n      if (multisample > 1) {\n        key += multisample * 4294967296;\n      }\n    } else {\n      key = multisample > 1 ? -multisample : -1;\n    }\n    if (!this.texturePool[key]) {\n      this.texturePool[key] = [];\n    }\n    let renderTexture = this.texturePool[key].pop();\n    if (!renderTexture) {\n      renderTexture = this.createTexture(minWidth, minHeight, multisample);\n    }\n    renderTexture.filterPoolKey = key;\n    renderTexture.setResolution(resolution);\n    return renderTexture;\n  }\n  getFilterTexture(input, resolution, multisample) {\n    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || lib/* MSAA_QUALITY.NONE */.G5.NONE);\n    filterTexture.filterFrame = input.filterFrame;\n    return filterTexture;\n  }\n  returnTexture(renderTexture) {\n    const key = renderTexture.filterPoolKey;\n    renderTexture.filterFrame = null;\n    this.texturePool[key].push(renderTexture);\n  }\n  returnFilterTexture(renderTexture) {\n    this.returnTexture(renderTexture);\n  }\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this.texturePool) {\n        const textures = this.texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this.texturePool = {};\n  }\n  setScreenSize(size) {\n    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {\n      return;\n    }\n    this.enableFullScreen = size.width > 0 && size.height > 0;\n    for (const i in this.texturePool) {\n      if (!(Number(i) < 0)) {\n        continue;\n      }\n      const textures = this.texturePool[i];\n      if (textures) {\n        for (let j = 0; j < textures.length; j++) {\n          textures[j].destroy(true);\n        }\n      }\n      this.texturePool[i] = [];\n    }\n    this._pixelsWidth = size.width;\n    this._pixelsHeight = size.height;\n  }\n}\nRenderTexturePool.SCREEN_KEY = -1;\n\n\n//# sourceMappingURL=RenderTexturePool.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/utils/Quad.mjs\n\n\nclass Quad extends Geometry {\n  constructor() {\n    super();\n    this.addAttribute("aVertexPosition", new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ])).addIndex([0, 1, 3, 2]);\n  }\n}\n\n\n//# sourceMappingURL=Quad.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/utils/QuadUv.mjs\n\n\n\nclass QuadUv extends Geometry {\n  constructor() {\n    super();\n    this.vertices = new Float32Array([\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      -1,\n      1\n    ]);\n    this.uvs = new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ]);\n    this.vertexBuffer = new Buffer(this.vertices);\n    this.uvBuffer = new Buffer(this.uvs);\n    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);\n  }\n  map(targetTextureFrame, destinationFrame) {\n    let x = 0;\n    let y = 0;\n    this.uvs[0] = x;\n    this.uvs[1] = y;\n    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;\n    this.uvs[3] = y;\n    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;\n    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;\n    this.uvs[6] = x;\n    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;\n    x = destinationFrame.x;\n    y = destinationFrame.y;\n    this.vertices[0] = x;\n    this.vertices[1] = y;\n    this.vertices[2] = x + destinationFrame.width;\n    this.vertices[3] = y;\n    this.vertices[4] = x + destinationFrame.width;\n    this.vertices[5] = y + destinationFrame.height;\n    this.vertices[6] = x;\n    this.vertices[7] = y + destinationFrame.height;\n    this.invalidate();\n    return this;\n  }\n  invalidate() {\n    this.vertexBuffer._updateID++;\n    this.uvBuffer._updateID++;\n    return this;\n  }\n}\n\n\n//# sourceMappingURL=QuadUv.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/FilterState.mjs\n\n\n\nclass FilterState {\n  constructor() {\n    this.renderTexture = null;\n    this.target = null;\n    this.legacy = false;\n    this.resolution = 1;\n    this.multisample = lib/* MSAA_QUALITY.NONE */.G5.NONE;\n    this.sourceFrame = new math_lib/* Rectangle */.Ae();\n    this.destinationFrame = new math_lib/* Rectangle */.Ae();\n    this.bindingSourceFrame = new math_lib/* Rectangle */.Ae();\n    this.bindingDestinationFrame = new math_lib/* Rectangle */.Ae();\n    this.filters = [];\n    this.transform = null;\n  }\n  clear() {\n    this.target = null;\n    this.filters = null;\n    this.renderTexture = null;\n  }\n}\n\n\n//# sourceMappingURL=FilterState.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/FilterSystem.mjs\n\n\n\n\n\n\n\n\n\nconst tempPoints = [new math_lib/* Point */.E9(), new math_lib/* Point */.E9(), new math_lib/* Point */.E9(), new math_lib/* Point */.E9()];\nconst tempMatrix = new math_lib/* Matrix */.y3();\nclass FilterSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.defaultFilterStack = [{}];\n    this.texturePool = new RenderTexturePool();\n    this.statePool = [];\n    this.quad = new Quad();\n    this.quadUv = new QuadUv();\n    this.tempRect = new math_lib/* Rectangle */.Ae();\n    this.activeState = {};\n    this.globalUniforms = new UniformGroup({\n      outputFrame: new math_lib/* Rectangle */.Ae(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, true);\n    this.forceClear = false;\n    this.useMaxPadding = false;\n  }\n  init() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  push(target, filters) {\n    const renderer = this.renderer;\n    const filterStack = this.defaultFilterStack;\n    const state = this.statePool.pop() || new FilterState();\n    const renderTextureSystem = this.renderer.renderTexture;\n    let resolution = filters[0].resolution;\n    let multisample = filters[0].multisample;\n    let padding = filters[0].padding;\n    let autoFit = filters[0].autoFit;\n    let legacy = filters[0].legacy ?? true;\n    for (let i = 1; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      multisample = Math.min(multisample, filter.multisample);\n      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;\n      autoFit = autoFit && filter.autoFit;\n      legacy = legacy || (filter.legacy ?? true);\n    }\n    if (filterStack.length === 1) {\n      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n    }\n    filterStack.push(state);\n    state.resolution = resolution;\n    state.multisample = multisample;\n    state.legacy = legacy;\n    state.target = target;\n    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n    state.sourceFrame.pad(padding);\n    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n    if (renderer.projection.transform) {\n      this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);\n    }\n    if (autoFit) {\n      state.sourceFrame.fit(sourceFrameProjected);\n      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {\n        state.sourceFrame.width = 0;\n        state.sourceFrame.height = 0;\n      }\n    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {\n      state.sourceFrame.width = 0;\n      state.sourceFrame.height = 0;\n    }\n    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);\n    state.filters = filters;\n    state.destinationFrame.width = state.renderTexture.width;\n    state.destinationFrame.height = state.renderTexture.height;\n    const destinationFrame = this.tempRect;\n    destinationFrame.x = 0;\n    destinationFrame.y = 0;\n    destinationFrame.width = state.sourceFrame.width;\n    destinationFrame.height = state.sourceFrame.height;\n    state.renderTexture.filterFrame = state.sourceFrame;\n    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n    state.transform = renderer.projection.transform;\n    renderer.projection.transform = null;\n    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n    renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  pop() {\n    const filterStack = this.defaultFilterStack;\n    const state = filterStack.pop();\n    const filters = state.filters;\n    this.activeState = state;\n    const globalUniforms = this.globalUniforms.uniforms;\n    globalUniforms.outputFrame = state.sourceFrame;\n    globalUniforms.resolution = state.resolution;\n    const inputSize = globalUniforms.inputSize;\n    const inputPixel = globalUniforms.inputPixel;\n    const inputClamp = globalUniforms.inputClamp;\n    inputSize[0] = state.destinationFrame.width;\n    inputSize[1] = state.destinationFrame.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n    inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];\n    if (state.legacy) {\n      const filterArea = globalUniforms.filterArea;\n      filterArea[0] = state.destinationFrame.width;\n      filterArea[1] = state.destinationFrame.height;\n      filterArea[2] = state.sourceFrame.x;\n      filterArea[3] = state.sourceFrame.y;\n      globalUniforms.filterClamp = globalUniforms.inputClamp;\n    }\n    this.globalUniforms.update();\n    const lastState = filterStack[filterStack.length - 1];\n    this.renderer.framebuffer.blit();\n    if (filters.length === 1) {\n      filters[0].apply(this, state.renderTexture, lastState.renderTexture, lib/* CLEAR_MODES.BLEND */.yl.BLEND, state);\n      this.returnFilterTexture(state.renderTexture);\n    } else {\n      let flip = state.renderTexture;\n      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n      flop.filterFrame = flip.filterFrame;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        if (i === 1 && state.multisample > 1) {\n          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n          flop.filterFrame = flip.filterFrame;\n        }\n        filters[i].apply(this, flip, flop, lib/* CLEAR_MODES.CLEAR */.yl.CLEAR, state);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, lastState.renderTexture, lib/* CLEAR_MODES.BLEND */.yl.BLEND, state);\n      if (i > 1 && state.multisample > 1) {\n        this.returnFilterTexture(state.renderTexture);\n      }\n      this.returnFilterTexture(flip);\n      this.returnFilterTexture(flop);\n    }\n    state.clear();\n    this.statePool.push(state);\n  }\n  bindAndClear(filterTexture, clearMode = lib/* CLEAR_MODES.CLEAR */.yl.CLEAR) {\n    const {\n      renderTexture: renderTextureSystem,\n      state: stateSystem\n    } = this.renderer;\n    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n      this.renderer.projection.transform = this.activeState.transform;\n    } else {\n      this.renderer.projection.transform = null;\n    }\n    if (filterTexture?.filterFrame) {\n      const destinationFrame = this.tempRect;\n      destinationFrame.x = 0;\n      destinationFrame.y = 0;\n      destinationFrame.width = filterTexture.filterFrame.width;\n      destinationFrame.height = filterTexture.filterFrame.height;\n      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n      renderTextureSystem.bind(filterTexture);\n    } else {\n      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n    }\n    const autoClear = stateSystem.stateId & 1 || this.forceClear;\n    if (clearMode === lib/* CLEAR_MODES.CLEAR */.yl.CLEAR || clearMode === lib/* CLEAR_MODES.BLIT */.yl.BLIT && autoClear) {\n      this.renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n  }\n  applyFilter(filter, input, output, clearMode) {\n    const renderer = this.renderer;\n    renderer.state.set(filter.state);\n    this.bindAndClear(output, clearMode);\n    filter.uniforms.uSampler = input;\n    filter.uniforms.filterGlobals = this.globalUniforms;\n    renderer.shader.bind(filter);\n    filter.legacy = !!filter.program.attributeData.aTextureCoord;\n    if (filter.legacy) {\n      this.quadUv.map(input._frame, input.filterFrame);\n      renderer.geometry.bind(this.quadUv);\n      renderer.geometry.draw(lib/* DRAW_MODES.TRIANGLES */.lg.TRIANGLES);\n    } else {\n      renderer.geometry.bind(this.quad);\n      renderer.geometry.draw(lib/* DRAW_MODES.TRIANGLE_STRIP */.lg.TRIANGLE_STRIP);\n    }\n  }\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const { sourceFrame, destinationFrame } = this.activeState;\n    const { orig } = sprite._texture;\n    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);\n    const worldTransform = sprite.worldTransform.copyTo(math_lib/* Matrix.TEMP_MATRIX */.y3.TEMP_MATRIX);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1 / orig.width, 1 / orig.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n    this.renderer = null;\n    this.texturePool.clear(false);\n  }\n  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = lib/* MSAA_QUALITY.NONE */.G5.NONE) {\n    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n  }\n  getFilterTexture(input, resolution, multisample) {\n    if (typeof input === "number") {\n      const swap = input;\n      input = resolution;\n      resolution = swap;\n    }\n    input = input || this.activeState.renderTexture;\n    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || lib/* MSAA_QUALITY.NONE */.G5.NONE);\n    filterTexture.filterFrame = input.filterFrame;\n    return filterTexture;\n  }\n  returnFilterTexture(renderTexture) {\n    this.texturePool.returnTexture(renderTexture);\n  }\n  emptyPool() {\n    this.texturePool.clear(true);\n  }\n  resize() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  transformAABB(matrix, rect) {\n    const lt = tempPoints[0];\n    const lb = tempPoints[1];\n    const rt = tempPoints[2];\n    const rb = tempPoints[3];\n    lt.set(rect.left, rect.top);\n    lb.set(rect.left, rect.bottom);\n    rt.set(rect.right, rect.top);\n    rb.set(rect.right, rect.bottom);\n    matrix.apply(lt, lt);\n    matrix.apply(lb, lb);\n    matrix.apply(rt, rt);\n    matrix.apply(rb, rb);\n    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n    rect.x = x0;\n    rect.y = y0;\n    rect.width = x1 - x0;\n    rect.height = y1 - y0;\n  }\n  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {\n      return;\n    }\n    if (transform) {\n      const { a, b, c, d } = transform;\n      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {\n        return;\n      }\n    }\n    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.transformAABB(transform, frame);\n    frame.ceil(resolution);\n    this.transformAABB(transform.invert(), frame);\n  }\n}\nFilterSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "filter"\n};\nextensions.add(FilterSystem);\n\n\n//# sourceMappingURL=FilterSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs\n\n\nclass GLFramebuffer {\n  constructor(framebuffer) {\n    this.framebuffer = framebuffer;\n    this.stencil = null;\n    this.dirtyId = -1;\n    this.dirtyFormat = -1;\n    this.dirtySize = -1;\n    this.multisample = lib/* MSAA_QUALITY.NONE */.G5.NONE;\n    this.msaaBuffer = null;\n    this.blitFramebuffer = null;\n    this.mipLevel = 0;\n  }\n}\n\n\n//# sourceMappingURL=GLFramebuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs\n\n\n\n\n\n\n\nconst tempRectangle = new math_lib/* Rectangle */.Ae();\nclass FramebufferSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.managedFramebuffers = [];\n    this.unknownFramebuffer = new Framebuffer(10, 10);\n    this.msaaSamples = null;\n  }\n  contextChange() {\n    this.disposeAll(true);\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.current = this.unknownFramebuffer;\n    this.viewport = new math_lib/* Rectangle */.Ae();\n    this.hasMRT = true;\n    this.writeDepthTexture = true;\n    if (this.renderer.context.webGLVersion === 1) {\n      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;\n      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;\n      if (settings_lib/* settings.PREFER_ENV */.Xd.PREFER_ENV === lib/* ENV.WEBGL_LEGACY */.Vi.WEBGL_LEGACY) {\n        nativeDrawBuffersExtension = null;\n        nativeDepthTextureExtension = null;\n      }\n      if (nativeDrawBuffersExtension) {\n        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);\n      } else {\n        this.hasMRT = false;\n        gl.drawBuffers = () => {\n        };\n      }\n      if (!nativeDepthTextureExtension) {\n        this.writeDepthTexture = false;\n      }\n    } else {\n      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);\n    }\n  }\n  bind(framebuffer, frame, mipLevel = 0) {\n    const { gl } = this;\n    if (framebuffer) {\n      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);\n      if (this.current !== framebuffer) {\n        this.current = framebuffer;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);\n      }\n      if (fbo.mipLevel !== mipLevel) {\n        framebuffer.dirtyId++;\n        framebuffer.dirtyFormat++;\n        fbo.mipLevel = mipLevel;\n      }\n      if (fbo.dirtyId !== framebuffer.dirtyId) {\n        fbo.dirtyId = framebuffer.dirtyId;\n        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {\n          fbo.dirtyFormat = framebuffer.dirtyFormat;\n          fbo.dirtySize = framebuffer.dirtySize;\n          this.updateFramebuffer(framebuffer, mipLevel);\n        } else if (fbo.dirtySize !== framebuffer.dirtySize) {\n          fbo.dirtySize = framebuffer.dirtySize;\n          this.resizeFramebuffer(framebuffer);\n        }\n      }\n      for (let i = 0; i < framebuffer.colorTextures.length; i++) {\n        const tex = framebuffer.colorTextures[i];\n        this.renderer.texture.unbind(tex.parentTextureArray || tex);\n      }\n      if (framebuffer.depthTexture) {\n        this.renderer.texture.unbind(framebuffer.depthTexture);\n      }\n      if (frame) {\n        const mipWidth = frame.width >> mipLevel;\n        const mipHeight = frame.height >> mipLevel;\n        const scale = mipWidth / frame.width;\n        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);\n      } else {\n        const mipWidth = framebuffer.width >> mipLevel;\n        const mipHeight = framebuffer.height >> mipLevel;\n        this.setViewport(0, 0, mipWidth, mipHeight);\n      }\n    } else {\n      if (this.current) {\n        this.current = null;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      }\n      if (frame) {\n        this.setViewport(frame.x, frame.y, frame.width, frame.height);\n      } else {\n        this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n      }\n    }\n  }\n  setViewport(x, y, width, height) {\n    const v = this.viewport;\n    x = Math.round(x);\n    y = Math.round(y);\n    width = Math.round(width);\n    height = Math.round(height);\n    if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {\n      v.x = x;\n      v.y = y;\n      v.width = width;\n      v.height = height;\n      this.gl.viewport(x, y, width, height);\n    }\n  }\n  get size() {\n    if (this.current) {\n      return { x: 0, y: 0, width: this.current.width, height: this.current.height };\n    }\n    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n  }\n  clear(r, g, b, a, mask = lib/* BUFFER_BITS.COLOR */.V0.COLOR | lib/* BUFFER_BITS.DEPTH */.V0.DEPTH) {\n    const { gl } = this;\n    gl.clearColor(r, g, b, a);\n    gl.clear(mask);\n  }\n  initFramebuffer(framebuffer) {\n    const { gl } = this;\n    const fbo = new GLFramebuffer(gl.createFramebuffer());\n    fbo.multisample = this.detectSamples(framebuffer.multisample);\n    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;\n    this.managedFramebuffers.push(framebuffer);\n    framebuffer.disposeRunner.add(this);\n    return fbo;\n  }\n  resizeFramebuffer(framebuffer) {\n    const { gl } = this;\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (fbo.stencil) {\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);\n      if (fbo.msaaBuffer) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);\n      }\n    }\n    const colorTextures = framebuffer.colorTextures;\n    let count = colorTextures.length;\n    if (!gl.drawBuffers) {\n      count = Math.min(count, 1);\n    }\n    for (let i = 0; i < count; i++) {\n      const texture = colorTextures[i];\n      const parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0);\n      if (i === 0 && fbo.msaaBuffer) {\n        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);\n      }\n    }\n    if (framebuffer.depthTexture && this.writeDepthTexture) {\n      this.renderer.texture.bind(framebuffer.depthTexture, 0);\n    }\n  }\n  updateFramebuffer(framebuffer, mipLevel) {\n    const { gl } = this;\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    const colorTextures = framebuffer.colorTextures;\n    let count = colorTextures.length;\n    if (!gl.drawBuffers) {\n      count = Math.min(count, 1);\n    }\n    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {\n      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();\n    } else if (fbo.msaaBuffer) {\n      gl.deleteRenderbuffer(fbo.msaaBuffer);\n      fbo.msaaBuffer = null;\n      if (fbo.blitFramebuffer) {\n        fbo.blitFramebuffer.dispose();\n        fbo.blitFramebuffer = null;\n      }\n    }\n    const activeTextures = [];\n    for (let i = 0; i < count; i++) {\n      const texture = colorTextures[i];\n      const parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0);\n      if (i === 0 && fbo.msaaBuffer) {\n        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);\n      } else {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);\n        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);\n      }\n    }\n    if (activeTextures.length > 1) {\n      gl.drawBuffers(activeTextures);\n    }\n    if (framebuffer.depthTexture) {\n      const writeDepthTexture = this.writeDepthTexture;\n      if (writeDepthTexture) {\n        const depthTexture = framebuffer.depthTexture;\n        this.renderer.texture.bind(depthTexture, 0);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);\n      }\n    }\n    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {\n      fbo.stencil = fbo.stencil || gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);\n      if (fbo.msaaBuffer) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);\n    } else if (fbo.stencil) {\n      gl.deleteRenderbuffer(fbo.stencil);\n      fbo.stencil = null;\n    }\n  }\n  canMultisampleFramebuffer(framebuffer) {\n    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;\n  }\n  detectSamples(samples) {\n    const { msaaSamples } = this;\n    let res = lib/* MSAA_QUALITY.NONE */.G5.NONE;\n    if (samples <= 1 || msaaSamples === null) {\n      return res;\n    }\n    for (let i = 0; i < msaaSamples.length; i++) {\n      if (msaaSamples[i] <= samples) {\n        res = msaaSamples[i];\n        break;\n      }\n    }\n    if (res === 1) {\n      res = lib/* MSAA_QUALITY.NONE */.G5.NONE;\n    }\n    return res;\n  }\n  blit(framebuffer, sourcePixels, destPixels) {\n    const { current, renderer, gl, CONTEXT_UID } = this;\n    if (renderer.context.webGLVersion !== 2) {\n      return;\n    }\n    if (!current) {\n      return;\n    }\n    const fbo = current.glFramebuffers[CONTEXT_UID];\n    if (!fbo) {\n      return;\n    }\n    if (!framebuffer) {\n      if (!fbo.msaaBuffer) {\n        return;\n      }\n      const colorTexture = current.colorTextures[0];\n      if (!colorTexture) {\n        return;\n      }\n      if (!fbo.blitFramebuffer) {\n        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);\n        fbo.blitFramebuffer.addColorTexture(0, colorTexture);\n      }\n      framebuffer = fbo.blitFramebuffer;\n      if (framebuffer.colorTextures[0] !== colorTexture) {\n        framebuffer.colorTextures[0] = colorTexture;\n        framebuffer.dirtyId++;\n        framebuffer.dirtyFormat++;\n      }\n      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {\n        framebuffer.width = current.width;\n        framebuffer.height = current.height;\n        framebuffer.dirtyId++;\n        framebuffer.dirtySize++;\n      }\n    }\n    if (!sourcePixels) {\n      sourcePixels = tempRectangle;\n      sourcePixels.width = current.width;\n      sourcePixels.height = current.height;\n    }\n    if (!destPixels) {\n      destPixels = sourcePixels;\n    }\n    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;\n    this.bind(framebuffer);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);\n    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);\n  }\n  disposeFramebuffer(framebuffer, contextLost) {\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    const gl = this.gl;\n    if (!fbo) {\n      return;\n    }\n    delete framebuffer.glFramebuffers[this.CONTEXT_UID];\n    const index = this.managedFramebuffers.indexOf(framebuffer);\n    if (index >= 0) {\n      this.managedFramebuffers.splice(index, 1);\n    }\n    framebuffer.disposeRunner.remove(this);\n    if (!contextLost) {\n      gl.deleteFramebuffer(fbo.framebuffer);\n      if (fbo.msaaBuffer) {\n        gl.deleteRenderbuffer(fbo.msaaBuffer);\n      }\n      if (fbo.stencil) {\n        gl.deleteRenderbuffer(fbo.stencil);\n      }\n    }\n    if (fbo.blitFramebuffer) {\n      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);\n    }\n  }\n  disposeAll(contextLost) {\n    const list = this.managedFramebuffers;\n    this.managedFramebuffers = [];\n    for (let i = 0; i < list.length; i++) {\n      this.disposeFramebuffer(list[i], contextLost);\n    }\n  }\n  forceStencil() {\n    const framebuffer = this.current;\n    if (!framebuffer) {\n      return;\n    }\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (!fbo || fbo.stencil) {\n      return;\n    }\n    framebuffer.stencil = true;\n    const w = framebuffer.width;\n    const h = framebuffer.height;\n    const gl = this.gl;\n    const stencil = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);\n    if (fbo.msaaBuffer) {\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);\n    } else {\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);\n    }\n    fbo.stencil = stencil;\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);\n  }\n  reset() {\n    this.current = this.unknownFramebuffer;\n    this.viewport = new math_lib/* Rectangle */.Ae();\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nFramebufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "framebuffer"\n};\nextensions.add(FramebufferSystem);\n\n\n//# sourceMappingURL=FramebufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs\n\n\n\n\nconst GeometrySystem_byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nclass GeometrySystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n    this.canUseUInt32ElementIndex = false;\n    this.managedGeometries = {};\n  }\n  contextChange() {\n    this.disposeAll(true);\n    const gl = this.gl = this.renderer.gl;\n    const context = this.renderer.context;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    if (context.webGLVersion !== 2) {\n      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n      if (settings_lib/* settings.PREFER_ENV */.Xd.PREFER_ENV === lib/* ENV.WEBGL_LEGACY */.Vi.WEBGL_LEGACY) {\n        nativeVaoExtension = null;\n      }\n      if (nativeVaoExtension) {\n        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();\n        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);\n        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);\n      } else {\n        this.hasVao = false;\n        gl.createVertexArray = () => null;\n        gl.bindVertexArray = () => null;\n        gl.deleteVertexArray = () => null;\n      }\n    }\n    if (context.webGLVersion !== 2) {\n      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");\n      if (instanceExt) {\n        gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b);\n        gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n        gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n      } else {\n        this.hasInstance = false;\n      }\n    }\n    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n  }\n  bind(geometry, shader) {\n    shader = shader || this.renderer.shader.shader;\n    const { gl } = this;\n    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let incRefCount = false;\n    if (!vaos) {\n      this.managedGeometries[geometry.id] = geometry;\n      geometry.disposeRunner.add(this);\n      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n      incRefCount = true;\n    }\n    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n    this._activeGeometry = geometry;\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      if (this.hasVao) {\n        gl.bindVertexArray(vao);\n      } else {\n        this.activateVao(geometry, shader.program);\n      }\n    }\n    this.updateBuffers();\n  }\n  reset() {\n    this.unbind();\n  }\n  updateBuffers() {\n    const geometry = this._activeGeometry;\n    const bufferSystem = this.renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.update(buffer);\n    }\n  }\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes;\n    const shaderAttributes = program.attributeData;\n    for (const j in shaderAttributes) {\n      if (!geometryAttributes[j]) {\n        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);\n      }\n    }\n  }\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes;\n    const shaderAttributes = program.attributeData;\n    const strings = ["g", geometry.id];\n    for (const i in attribs) {\n      if (shaderAttributes[i]) {\n        strings.push(i, shaderAttributes[i].location);\n      }\n    }\n    return strings.join("-");\n  }\n  initGeometryVao(geometry, shader, incRefCount = true) {\n    const gl = this.gl;\n    const CONTEXT_UID = this.CONTEXT_UID;\n    const bufferSystem = this.renderer.buffer;\n    const program = shader.program;\n    if (!program.glPrograms[CONTEXT_UID]) {\n      this.renderer.shader.generateProgram(shader);\n    }\n    this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program);\n    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program.id] = vao;\n      return vao;\n    }\n    const buffers = geometry.buffers;\n    const attributes = geometry.attributes;\n    const tempStride = {};\n    const tempStart = {};\n    for (const j in buffers) {\n      tempStride[j] = 0;\n      tempStart[j] = 0;\n    }\n    for (const j in attributes) {\n      if (!attributes[j].size && program.attributeData[j]) {\n        attributes[j].size = program.attributeData[j].size;\n      } else if (!attributes[j].size) {\n        console.warn(`PIXI Geometry attribute \'${j}\' size cannot be determined (likely the bound shader does not have the attribute)`);\n      }\n      tempStride[attributes[j].buffer] += attributes[j].size * GeometrySystem_byteSizeMap[attributes[j].type];\n    }\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const attribSize = attribute.size;\n      if (attribute.stride === void 0) {\n        if (tempStride[attribute.buffer] === attribSize * GeometrySystem_byteSizeMap[attribute.type]) {\n          attribute.stride = 0;\n        } else {\n          attribute.stride = tempStride[attribute.buffer];\n        }\n      }\n      if (attribute.start === void 0) {\n        attribute.start = tempStart[attribute.buffer];\n        tempStart[attribute.buffer] += attribSize * GeometrySystem_byteSizeMap[attribute.type];\n      }\n    }\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer);\n      if (incRefCount) {\n        buffer._glBuffers[CONTEXT_UID].refCount++;\n      }\n    }\n    this.activateVao(geometry, program);\n    vaoObjectHash[program.id] = vao;\n    vaoObjectHash[signature] = vao;\n    gl.bindVertexArray(null);\n    bufferSystem.unbind(lib/* BUFFER_TYPE.ARRAY_BUFFER */.mr.ARRAY_BUFFER);\n    return vao;\n  }\n  disposeGeometry(geometry, contextLost) {\n    if (!this.managedGeometries[geometry.id]) {\n      return;\n    }\n    delete this.managedGeometries[geometry.id];\n    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    const gl = this.gl;\n    const buffers = geometry.buffers;\n    const bufferSystem = this.renderer?.buffer;\n    geometry.disposeRunner.remove(this);\n    if (!vaos) {\n      return;\n    }\n    if (bufferSystem) {\n      for (let i = 0; i < buffers.length; i++) {\n        const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n        if (buf) {\n          buf.refCount--;\n          if (buf.refCount === 0 && !contextLost) {\n            bufferSystem.dispose(buffers[i], contextLost);\n          }\n        }\n      }\n    }\n    if (!contextLost) {\n      for (const vaoId in vaos) {\n        if (vaoId[0] === "g") {\n          const vao = vaos[vaoId];\n          if (this._activeVao === vao) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vao);\n        }\n      }\n    }\n    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n  }\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedGeometries);\n    for (let i = 0; i < all.length; i++) {\n      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n    }\n  }\n  activateVao(geometry, program) {\n    const gl = this.gl;\n    const CONTEXT_UID = this.CONTEXT_UID;\n    const bufferSystem = this.renderer.buffer;\n    const buffers = geometry.buffers;\n    const attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const buffer = buffers[attribute.buffer];\n      const glBuffer = buffer._glBuffers[CONTEXT_UID];\n      if (program.attributeData[j]) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        const location = program.attributeData[j].location;\n        gl.enableVertexAttribArray(location);\n        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            gl.vertexAttribDivisor(location, attribute.divisor);\n          } else {\n            throw new Error("geometry error, GPU Instancing is not supported on this device");\n          }\n        }\n      }\n    }\n  }\n  draw(type, size, start, instanceCount) {\n    const { gl } = this;\n    const geometry = this._activeGeometry;\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {\n        if (geometry.instanced) {\n          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n        } else {\n          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n        }\n      } else {\n        console.warn("unsupported index buffer type: uint32");\n      }\n    } else if (geometry.instanced) {\n      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n    } else {\n      gl.drawArrays(type, start, size || geometry.getSize());\n    }\n    return this;\n  }\n  unbind() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nGeometrySystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "geometry"\n};\nextensions.add(GeometrySystem);\n\n\n//# sourceMappingURL=GeometrySystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureMatrix.mjs\n\n\nconst tempMat = new math_lib/* Matrix */.y3();\nclass TextureMatrix {\n  constructor(texture, clampMargin) {\n    this._texture = texture;\n    this.mapCoord = new math_lib/* Matrix */.y3();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;\n    this.isSimple = false;\n  }\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    this._texture = value;\n    this._textureID = -1;\n  }\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  update(forceUpdate) {\n    const tex = this._texture;\n    if (!tex || !tex.valid) {\n      return false;\n    }\n    if (!forceUpdate && this._textureID === tex._updateID) {\n      return false;\n    }\n    this._textureID = tex._updateID;\n    this._updateID++;\n    const uvs = tex._uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.baseTexture;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase.resolution;\n    const offset = this.clampOffset;\n    frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = offset / texBase.realWidth;\n    this.uClampOffset[1] = offset / texBase.realHeight;\n    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=TextureMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.mjs\nvar fragment = "varying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D mask;\\nuniform float alpha;\\nuniform float npmAlpha;\\nuniform vec4 maskClamp;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(maskClamp.x, vMaskCoord.x) +\\n        step(maskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, maskClamp.z) +\\n        step(vMaskCoord.y, maskClamp.w));\\n\\n    vec4 original = texture2D(uSampler, vTextureCoord);\\n    vec4 masky = texture2D(mask, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    original *= (alphaMul * masky.r * alpha * clip);\\n\\n    gl_FragColor = original;\\n}\\n";\n\n\n//# sourceMappingURL=spriteMaskFilter2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.mjs\nvar vertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 otherMatrix;\\n\\nvarying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\\n}\\n";\n\n\n//# sourceMappingURL=spriteMaskFilter3.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs\n\n\n\n\n\n\nclass SpriteMaskFilter extends Filter {\n  constructor(vertexSrc, fragmentSrc, uniforms) {\n    let sprite = null;\n    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {\n      sprite = vertexSrc;\n      vertexSrc = void 0;\n      fragmentSrc = void 0;\n      uniforms = void 0;\n    }\n    super(vertexSrc || vertex, fragmentSrc || fragment, uniforms);\n    this.maskSprite = sprite;\n    this.maskMatrix = new math_lib/* Matrix */.y3();\n  }\n  get maskSprite() {\n    return this._maskSprite;\n  }\n  set maskSprite(value) {\n    this._maskSprite = value;\n    if (this._maskSprite) {\n      this._maskSprite.renderable = false;\n    }\n  }\n  apply(filterManager, input, output, clearMode) {\n    const maskSprite = this._maskSprite;\n    const tex = maskSprite._texture;\n    if (!tex.valid) {\n      return;\n    }\n    if (!tex.uvMatrix) {\n      tex.uvMatrix = new TextureMatrix(tex, 0);\n    }\n    tex.uvMatrix.update();\n    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;\n    this.uniforms.mask = tex;\n    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);\n    this.uniforms.alpha = maskSprite.worldAlpha;\n    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\n\n//# sourceMappingURL=SpriteMaskFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/MaskData.mjs\n\n\n\nclass MaskData {\n  constructor(maskObject = null) {\n    this.type = lib/* MASK_TYPES.NONE */.A7.NONE;\n    this.autoDetect = true;\n    this.maskObject = maskObject || null;\n    this.pooled = false;\n    this.isMaskData = true;\n    this.resolution = null;\n    this.multisample = Filter.defaultMultisample;\n    this.enabled = true;\n    this.colorMask = 15;\n    this._filters = null;\n    this._stencilCounter = 0;\n    this._scissorCounter = 0;\n    this._scissorRect = null;\n    this._scissorRectLocal = null;\n    this._colorMask = 15;\n    this._target = null;\n  }\n  get filter() {\n    return this._filters ? this._filters[0] : null;\n  }\n  set filter(value) {\n    if (value) {\n      if (this._filters) {\n        this._filters[0] = value;\n      } else {\n        this._filters = [value];\n      }\n    } else {\n      this._filters = null;\n    }\n  }\n  reset() {\n    if (this.pooled) {\n      this.maskObject = null;\n      this.type = lib/* MASK_TYPES.NONE */.A7.NONE;\n      this.autoDetect = true;\n    }\n    this._target = null;\n    this._scissorRectLocal = null;\n  }\n  copyCountersOrReset(maskAbove) {\n    if (maskAbove) {\n      this._stencilCounter = maskAbove._stencilCounter;\n      this._scissorCounter = maskAbove._scissorCounter;\n      this._scissorRect = maskAbove._scissorRect;\n    } else {\n      this._stencilCounter = 0;\n      this._scissorCounter = 0;\n      this._scissorRect = null;\n    }\n  }\n}\n\n\n//# sourceMappingURL=MaskData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/MaskSystem.mjs\n\n\n\n\n\nclass MaskSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.enableScissor = true;\n    this.alphaMaskPool = [];\n    this.maskDataPool = [];\n    this.maskStack = [];\n    this.alphaMaskIndex = 0;\n  }\n  setMaskStack(maskStack) {\n    this.maskStack = maskStack;\n    this.renderer.scissor.setMaskStack(maskStack);\n    this.renderer.stencil.setMaskStack(maskStack);\n  }\n  push(target, maskDataOrTarget) {\n    let maskData = maskDataOrTarget;\n    if (!maskData.isMaskData) {\n      const d = this.maskDataPool.pop() || new MaskData();\n      d.pooled = true;\n      d.maskObject = maskDataOrTarget;\n      maskData = d;\n    }\n    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    maskData.copyCountersOrReset(maskAbove);\n    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;\n    if (maskData.autoDetect) {\n      this.detect(maskData);\n    }\n    maskData._target = target;\n    if (maskData.type !== lib/* MASK_TYPES.SPRITE */.A7.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case lib/* MASK_TYPES.SCISSOR */.A7.SCISSOR:\n          this.renderer.scissor.push(maskData);\n          break;\n        case lib/* MASK_TYPES.STENCIL */.A7.STENCIL:\n          this.renderer.stencil.push(maskData);\n          break;\n        case lib/* MASK_TYPES.SPRITE */.A7.SPRITE:\n          maskData.copyCountersOrReset(null);\n          this.pushSpriteMask(maskData);\n          break;\n        case lib/* MASK_TYPES.COLOR */.A7.COLOR:\n          this.pushColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    }\n    if (maskData.type === lib/* MASK_TYPES.SPRITE */.A7.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n  }\n  pop(target) {\n    const maskData = this.maskStack.pop();\n    if (!maskData || maskData._target !== target) {\n      return;\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case lib/* MASK_TYPES.SCISSOR */.A7.SCISSOR:\n          this.renderer.scissor.pop(maskData);\n          break;\n        case lib/* MASK_TYPES.STENCIL */.A7.STENCIL:\n          this.renderer.stencil.pop(maskData.maskObject);\n          break;\n        case lib/* MASK_TYPES.SPRITE */.A7.SPRITE:\n          this.popSpriteMask(maskData);\n          break;\n        case lib/* MASK_TYPES.COLOR */.A7.COLOR:\n          this.popColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    }\n    maskData.reset();\n    if (maskData.pooled) {\n      this.maskDataPool.push(maskData);\n    }\n    if (this.maskStack.length !== 0) {\n      const maskCurrent = this.maskStack[this.maskStack.length - 1];\n      if (maskCurrent.type === lib/* MASK_TYPES.SPRITE */.A7.SPRITE && maskCurrent._filters) {\n        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n      }\n    }\n  }\n  detect(maskData) {\n    const maskObject = maskData.maskObject;\n    if (!maskObject) {\n      maskData.type = lib/* MASK_TYPES.COLOR */.A7.COLOR;\n    } else if (maskObject.isSprite) {\n      maskData.type = lib/* MASK_TYPES.SPRITE */.A7.SPRITE;\n    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {\n      maskData.type = lib/* MASK_TYPES.SCISSOR */.A7.SCISSOR;\n    } else {\n      maskData.type = lib/* MASK_TYPES.STENCIL */.A7.STENCIL;\n    }\n  }\n  pushSpriteMask(maskData) {\n    const { maskObject } = maskData;\n    const target = maskData._target;\n    let alphaMaskFilter = maskData._filters;\n    if (!alphaMaskFilter) {\n      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n      if (!alphaMaskFilter) {\n        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];\n      }\n    }\n    const renderer = this.renderer;\n    const renderTextureSystem = renderer.renderTexture;\n    let resolution;\n    let multisample;\n    if (renderTextureSystem.current) {\n      const renderTexture = renderTextureSystem.current;\n      resolution = maskData.resolution || renderTexture.resolution;\n      multisample = maskData.multisample ?? renderTexture.multisample;\n    } else {\n      resolution = maskData.resolution || renderer.resolution;\n      multisample = maskData.multisample ?? renderer.multisample;\n    }\n    alphaMaskFilter[0].resolution = resolution;\n    alphaMaskFilter[0].multisample = multisample;\n    alphaMaskFilter[0].maskSprite = maskObject;\n    const stashFilterArea = target.filterArea;\n    target.filterArea = maskObject.getBounds(true);\n    renderer.filter.push(target, alphaMaskFilter);\n    target.filterArea = stashFilterArea;\n    if (!maskData._filters) {\n      this.alphaMaskIndex++;\n    }\n  }\n  popSpriteMask(maskData) {\n    this.renderer.filter.pop();\n    if (maskData._filters) {\n      maskData._filters[0].maskSprite = null;\n    } else {\n      this.alphaMaskIndex--;\n      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n    }\n  }\n  pushColorMask(maskData) {\n    const currColorMask = maskData._colorMask;\n    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n    if (nextColorMask !== currColorMask) {\n      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n    }\n  }\n  popColorMask(maskData) {\n    const currColorMask = maskData._colorMask;\n    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    if (nextColorMask !== currColorMask) {\n      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n    }\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nMaskSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "mask"\n};\nextensions.add(MaskSystem);\n\n\n//# sourceMappingURL=MaskSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs\nclass AbstractMaskSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.maskStack = [];\n    this.glConst = 0;\n  }\n  getStackLength() {\n    return this.maskStack.length;\n  }\n  setMaskStack(maskStack) {\n    const { gl } = this.renderer;\n    const curStackLen = this.getStackLength();\n    this.maskStack = maskStack;\n    const newStackLen = this.getStackLength();\n    if (newStackLen !== curStackLen) {\n      if (newStackLen === 0) {\n        gl.disable(this.glConst);\n      } else {\n        gl.enable(this.glConst);\n        this._useCurrent();\n      }\n    }\n  }\n  _useCurrent() {\n  }\n  destroy() {\n    this.renderer = null;\n    this.maskStack = null;\n  }\n}\n\n\n//# sourceMappingURL=AbstractMaskSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/ScissorSystem.mjs\n\n\n\n\n\nconst ScissorSystem_tempMatrix = new math_lib/* Matrix */.y3();\nconst rectPool = [];\nconst _ScissorSystem = class extends AbstractMaskSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.glConst = settings_lib/* settings.ADAPTER.getWebGLRenderingContext */.Xd.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._scissorCounter;\n    }\n    return 0;\n  }\n  calcScissorRect(maskData) {\n    if (maskData._scissorRectLocal) {\n      return;\n    }\n    const prevData = maskData._scissorRect;\n    const { maskObject } = maskData;\n    const { renderer } = this;\n    const renderTextureSystem = renderer.renderTexture;\n    const rect = maskObject.getBounds(true, rectPool.pop() ?? new math_lib/* Rectangle */.Ae());\n    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    if (prevData) {\n      rect.fit(prevData);\n    }\n    maskData._scissorRectLocal = rect;\n  }\n  static isMatrixRotated(matrix) {\n    if (!matrix) {\n      return false;\n    }\n    const { a, b, c, d } = matrix;\n    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);\n  }\n  testScissor(maskData) {\n    const { maskObject } = maskData;\n    if (!maskObject.isFastRect || !maskObject.isFastRect()) {\n      return false;\n    }\n    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {\n      return false;\n    }\n    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {\n      return false;\n    }\n    this.calcScissorRect(maskData);\n    const rect = maskData._scissorRectLocal;\n    return rect.width > 0 && rect.height > 0;\n  }\n  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (_ScissorSystem.isMatrixRotated(transform)) {\n      return;\n    }\n    transform = transform ? ScissorSystem_tempMatrix.copyFrom(transform) : ScissorSystem_tempMatrix.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.renderer.filter.transformAABB(transform, frame);\n    frame.fit(bindingDestinationFrame);\n    frame.x = Math.round(frame.x * resolution);\n    frame.y = Math.round(frame.y * resolution);\n    frame.width = Math.round(frame.width * resolution);\n    frame.height = Math.round(frame.height * resolution);\n  }\n  push(maskData) {\n    if (!maskData._scissorRectLocal) {\n      this.calcScissorRect(maskData);\n    }\n    const { gl } = this.renderer;\n    if (!maskData._scissorRect) {\n      gl.enable(gl.SCISSOR_TEST);\n    }\n    maskData._scissorCounter++;\n    maskData._scissorRect = maskData._scissorRectLocal;\n    this._useCurrent();\n  }\n  pop(maskData) {\n    const { gl } = this.renderer;\n    if (maskData) {\n      rectPool.push(maskData._scissorRectLocal);\n    }\n    if (this.getStackLength() > 0) {\n      this._useCurrent();\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  }\n  _useCurrent() {\n    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n    let y;\n    if (this.renderer.renderTexture.current) {\n      y = rect.y;\n    } else {\n      y = this.renderer.height - rect.height - rect.y;\n    }\n    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n  }\n};\nlet ScissorSystem = _ScissorSystem;\nScissorSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "scissor"\n};\nextensions.add(ScissorSystem);\n\n\n//# sourceMappingURL=ScissorSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/StencilSystem.mjs\n\n\n\n\nclass StencilSystem extends AbstractMaskSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.glConst = settings_lib/* settings.ADAPTER.getWebGLRenderingContext */.Xd.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._stencilCounter;\n    }\n    return 0;\n  }\n  push(maskData) {\n    const maskObject = maskData.maskObject;\n    const { gl } = this.renderer;\n    const prevMaskCount = maskData._stencilCounter;\n    if (prevMaskCount === 0) {\n      this.renderer.framebuffer.forceStencil();\n      gl.clearStencil(0);\n      gl.clear(gl.STENCIL_BUFFER_BIT);\n      gl.enable(gl.STENCIL_TEST);\n    }\n    maskData._stencilCounter++;\n    const colorMask = maskData._colorMask;\n    if (colorMask !== 0) {\n      maskData._colorMask = 0;\n      gl.colorMask(false, false, false, false);\n    }\n    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n    maskObject.renderable = true;\n    maskObject.render(this.renderer);\n    this.renderer.batch.flush();\n    maskObject.renderable = false;\n    if (colorMask !== 0) {\n      maskData._colorMask = colorMask;\n      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);\n    }\n    this._useCurrent();\n  }\n  pop(maskObject) {\n    const gl = this.renderer.gl;\n    if (this.getStackLength() === 0) {\n      gl.disable(gl.STENCIL_TEST);\n    } else {\n      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n      const colorMask = maskData ? maskData._colorMask : 15;\n      if (colorMask !== 0) {\n        maskData._colorMask = 0;\n        gl.colorMask(false, false, false, false);\n      }\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\n      maskObject.renderable = true;\n      maskObject.render(this.renderer);\n      this.renderer.batch.flush();\n      maskObject.renderable = false;\n      if (colorMask !== 0) {\n        maskData._colorMask = colorMask;\n        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);\n      }\n      this._useCurrent();\n    }\n  }\n  _useCurrent() {\n    const gl = this.renderer.gl;\n    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n  }\n}\nStencilSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "stencil"\n};\nextensions.add(StencilSystem);\n\n\n//# sourceMappingURL=StencilSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/plugin/PluginSystem.mjs\n\n\n\nclass PluginSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.plugins = {};\n    Object.defineProperties(this.plugins, {\n      extract: {\n        enumerable: false,\n        get() {\n          (0,utils_lib.deprecation)("7.0.0", "renderer.plugins.extract has moved to renderer.extract");\n          return renderer.extract;\n        }\n      },\n      prepare: {\n        enumerable: false,\n        get() {\n          (0,utils_lib.deprecation)("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");\n          return renderer.prepare;\n        }\n      },\n      interaction: {\n        enumerable: false,\n        get() {\n          (0,utils_lib.deprecation)("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");\n          return renderer.events;\n        }\n      }\n    });\n  }\n  init() {\n    const staticMap = this.rendererPlugins;\n    for (const o in staticMap) {\n      this.plugins[o] = new staticMap[o](this.renderer);\n    }\n  }\n  destroy() {\n    for (const o in this.plugins) {\n      this.plugins[o].destroy();\n      this.plugins[o] = null;\n    }\n  }\n}\nPluginSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "_plugin"\n};\nextensions.add(PluginSystem);\n\n\n//# sourceMappingURL=PluginSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs\n\n\n\nclass ProjectionSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.destinationFrame = null;\n    this.sourceFrame = null;\n    this.defaultFrame = null;\n    this.projectionMatrix = new math_lib/* Matrix */.y3();\n    this.transform = null;\n  }\n  update(destinationFrame, sourceFrame, resolution, root) {\n    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;\n    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);\n    if (this.transform) {\n      this.projectionMatrix.append(this.transform);\n    }\n    const renderer = this.renderer;\n    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;\n    renderer.globalUniforms.update();\n    if (renderer.shader.shader) {\n      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);\n    }\n  }\n  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {\n    const pm = this.projectionMatrix;\n    const sign = !root ? 1 : -1;\n    pm.identity();\n    pm.a = 1 / sourceFrame.width * 2;\n    pm.d = sign * (1 / sourceFrame.height * 2);\n    pm.tx = -1 - sourceFrame.x * pm.a;\n    pm.ty = -sign - sourceFrame.y * pm.d;\n  }\n  setTransform(_matrix) {\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nProjectionSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "projection"\n};\nextensions.add(ProjectionSystem);\n\n\n//# sourceMappingURL=ProjectionSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs\n\n\n\n\nconst tempTransform = new math_lib/* Transform */.wx();\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this._tempMatrix = new math_lib/* Matrix */.y3();\n  }\n  generateTexture(displayObject, options) {\n    const { region: manualRegion, ...textureOptions } = options || {};\n    const region = manualRegion || displayObject.getLocalBounds(null, true);\n    if (region.width === 0)\n      region.width = 1;\n    if (region.height === 0)\n      region.height = 1;\n    const renderTexture = RenderTexture.create({\n      width: region.width,\n      height: region.height,\n      ...textureOptions\n    });\n    this._tempMatrix.tx = -region.x;\n    this._tempMatrix.ty = -region.y;\n    const transform = displayObject.transform;\n    displayObject.transform = tempTransform;\n    this.renderer.render(displayObject, {\n      renderTexture,\n      transform: this._tempMatrix,\n      skipUpdateTransform: !!displayObject.parent,\n      blit: true\n    });\n    displayObject.transform = transform;\n    return renderTexture;\n  }\n  destroy() {\n  }\n}\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "textureGenerator"\n};\nextensions.add(GenerateTextureSystem);\n\n\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs\n\n\n\n\nconst tempRect = new math_lib/* Rectangle */.Ae();\nconst tempRect2 = new math_lib/* Rectangle */.Ae();\nclass RenderTextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.defaultMaskStack = [];\n    this.current = null;\n    this.sourceFrame = new math_lib/* Rectangle */.Ae();\n    this.destinationFrame = new math_lib/* Rectangle */.Ae();\n    this.viewportFrame = new math_lib/* Rectangle */.Ae();\n  }\n  bind(renderTexture = null, sourceFrame, destinationFrame) {\n    const renderer = this.renderer;\n    this.current = renderTexture;\n    let baseTexture;\n    let framebuffer;\n    let resolution;\n    if (renderTexture) {\n      baseTexture = renderTexture.baseTexture;\n      resolution = baseTexture.resolution;\n      if (!sourceFrame) {\n        tempRect.width = renderTexture.frame.width;\n        tempRect.height = renderTexture.frame.height;\n        sourceFrame = tempRect;\n      }\n      if (!destinationFrame) {\n        tempRect2.x = renderTexture.frame.x;\n        tempRect2.y = renderTexture.frame.y;\n        tempRect2.width = sourceFrame.width;\n        tempRect2.height = sourceFrame.height;\n        destinationFrame = tempRect2;\n      }\n      framebuffer = baseTexture.framebuffer;\n    } else {\n      resolution = renderer.resolution;\n      if (!sourceFrame) {\n        tempRect.width = renderer._view.screen.width;\n        tempRect.height = renderer._view.screen.height;\n        sourceFrame = tempRect;\n      }\n      if (!destinationFrame) {\n        destinationFrame = tempRect;\n        destinationFrame.width = sourceFrame.width;\n        destinationFrame.height = sourceFrame.height;\n      }\n    }\n    const viewportFrame = this.viewportFrame;\n    viewportFrame.x = destinationFrame.x * resolution;\n    viewportFrame.y = destinationFrame.y * resolution;\n    viewportFrame.width = destinationFrame.width * resolution;\n    viewportFrame.height = destinationFrame.height * resolution;\n    if (!renderTexture) {\n      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);\n    }\n    viewportFrame.ceil();\n    this.renderer.framebuffer.bind(framebuffer, viewportFrame);\n    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);\n    if (renderTexture) {\n      this.renderer.mask.setMaskStack(baseTexture.maskStack);\n    } else {\n      this.renderer.mask.setMaskStack(this.defaultMaskStack);\n    }\n    this.sourceFrame.copyFrom(sourceFrame);\n    this.destinationFrame.copyFrom(destinationFrame);\n  }\n  clear(clearColor, mask) {\n    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;\n    const color = clearColor ? color_lib/* Color.shared.setValue */.I.shared.setValue(clearColor) : fallbackColor;\n    const destinationFrame = this.destinationFrame;\n    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;\n    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n    if (clearMask) {\n      let { x, y, width, height } = this.viewportFrame;\n      x = Math.round(x);\n      y = Math.round(y);\n      width = Math.round(width);\n      height = Math.round(height);\n      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n      this.renderer.gl.scissor(x, y, width, height);\n    }\n    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);\n    if (clearMask) {\n      this.renderer.scissor.pop();\n    }\n  }\n  resize() {\n    this.bind(null);\n  }\n  reset() {\n    this.bind(null);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nRenderTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "renderTexture"\n};\nextensions.add(RenderTextureSystem);\n\n\n//# sourceMappingURL=RenderTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/GLProgram.mjs\nclass IGLUniformData {\n}\nclass GLProgram {\n  constructor(program, uniformData) {\n    this.program = program;\n    this.uniformData = uniformData;\n    this.uniformGroups = {};\n    this.uniformDirtyGroups = {};\n    this.uniformBufferBindings = {};\n  }\n  destroy() {\n    this.uniformData = null;\n    this.uniformGroups = null;\n    this.uniformDirtyGroups = null;\n    this.uniformBufferBindings = null;\n    this.program = null;\n  }\n}\n\n\n//# sourceMappingURL=GLProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/compileShader.mjs\nfunction compileShader(gl, type, src) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, src);\n  gl.compileShader(shader);\n  return shader;\n}\n\n\n//# sourceMappingURL=compileShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs\nfunction booleanArray(size) {\n  const array = new Array(size);\n  for (let i = 0; i < array.length; i++) {\n    array[i] = false;\n  }\n  return array;\n}\nfunction defaultValue(type, size) {\n  switch (type) {\n    case "float":\n      return 0;\n    case "vec2":\n      return new Float32Array(2 * size);\n    case "vec3":\n      return new Float32Array(3 * size);\n    case "vec4":\n      return new Float32Array(4 * size);\n    case "int":\n    case "uint":\n    case "sampler2D":\n    case "sampler2DArray":\n      return 0;\n    case "ivec2":\n      return new Int32Array(2 * size);\n    case "ivec3":\n      return new Int32Array(3 * size);\n    case "ivec4":\n      return new Int32Array(4 * size);\n    case "uvec2":\n      return new Uint32Array(2 * size);\n    case "uvec3":\n      return new Uint32Array(3 * size);\n    case "uvec4":\n      return new Uint32Array(4 * size);\n    case "bool":\n      return false;\n    case "bvec2":\n      return booleanArray(2 * size);\n    case "bvec3":\n      return booleanArray(3 * size);\n    case "bvec4":\n      return booleanArray(4 * size);\n    case "mat2":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case "mat3":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case "mat4":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=defaultValue.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs\n\n\n\nfunction getAttributeData(program, gl) {\n  const attributes = {};\n  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < totalAttributes; i++) {\n    const attribData = gl.getActiveAttrib(program, i);\n    if (attribData.name.startsWith("gl_")) {\n      continue;\n    }\n    const type = mapType(gl, attribData.type);\n    const data = {\n      type,\n      name: attribData.name,\n      size: mapSize(type),\n      location: gl.getAttribLocation(program, attribData.name)\n    };\n    attributes[attribData.name] = data;\n  }\n  return attributes;\n}\n\n\n//# sourceMappingURL=getAttributeData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs\n\n\n\nfunction getUniformData(program, gl) {\n  const uniforms = {};\n  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (let i = 0; i < totalUniforms; i++) {\n    const uniformData = gl.getActiveUniform(program, i);\n    const name = uniformData.name.replace(/\\[.*?\\]$/, "");\n    const isArray = !!uniformData.name.match(/\\[.*?\\]$/);\n    const type = mapType(gl, uniformData.type);\n    uniforms[name] = {\n      name,\n      index: i,\n      type,\n      size: uniformData.size,\n      isArray,\n      value: defaultValue(type, uniformData.size)\n    };\n  }\n  return uniforms;\n}\n\n\n//# sourceMappingURL=getUniformData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs\nfunction logPrettyShaderError(gl, shader) {\n  const shaderSrc = gl.getShaderSource(shader).split("\\n").map((line, index) => `${index}: ${line}`);\n  const shaderLog = gl.getShaderInfoLog(shader);\n  const splitShader = shaderLog.split("\\n");\n  const dedupe = {};\n  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, "$1"))).filter((n) => {\n    if (n && !dedupe[n]) {\n      dedupe[n] = true;\n      return true;\n    }\n    return false;\n  });\n  const logArgs = [""];\n  lineNumbers.forEach((number) => {\n    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");\n  });\n  const fragmentSourceToLog = shaderSrc.join("\\n");\n  logArgs[0] = fragmentSourceToLog;\n  console.error(shaderLog);\n  console.groupCollapsed("click to view full shader code");\n  console.warn(...logArgs);\n  console.groupEnd();\n}\nfunction logProgramError(gl, program, vertexShader, fragmentShader) {\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, vertexShader);\n    }\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, fragmentShader);\n    }\n    console.error("PixiJS Error: Could not initialize shader.");\n    if (gl.getProgramInfoLog(program) !== "") {\n      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));\n    }\n  }\n}\n\n\n//# sourceMappingURL=logProgramError.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs\n\n\n\n\n\n\n\nfunction generateProgram(gl, program) {\n  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);\n  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);\n  const webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader);\n  gl.attachShader(webGLProgram, glFragShader);\n  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;\n  if (transformFeedbackVaryings) {\n    if (typeof gl.transformFeedbackVaryings !== "function") {\n      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n    } else {\n      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);\n    }\n  }\n  gl.linkProgram(webGLProgram);\n  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {\n    logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n  }\n  program.attributeData = getAttributeData(webGLProgram, gl);\n  program.uniformData = getUniformData(webGLProgram, gl);\n  if (!/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertexSrc)) {\n    const keys = Object.keys(program.attributeData);\n    keys.sort((a, b) => a > b ? 1 : -1);\n    for (let i = 0; i < keys.length; i++) {\n      program.attributeData[keys[i]].location = i;\n      gl.bindAttribLocation(webGLProgram, i, keys[i]);\n    }\n    gl.linkProgram(webGLProgram);\n  }\n  gl.deleteShader(glVertShader);\n  gl.deleteShader(glFragShader);\n  const uniformData = {};\n  for (const i in program.uniformData) {\n    const data = program.uniformData[i];\n    uniformData[i] = {\n      location: gl.getUniformLocation(webGLProgram, i),\n      value: defaultValue(data.type, data.size)\n    };\n  }\n  const glProgram = new GLProgram(webGLProgram, uniformData);\n  return glProgram;\n}\n\n\n//# sourceMappingURL=generateProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs\n\n\n\n\nfunction uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {\n  _renderer.buffer.update(buffer);\n}\nconst UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n};\nconst GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    dataLen: 0,\n    dirty: 0\n  }));\n  let size = 0;\n  let chunkSize = 0;\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.dataLen = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      const lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset = Math.ceil(offset / 16) * 16;\n      uboElement.offset = offset;\n      offset += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset;\n      chunkSize += size;\n      offset += size;\n    }\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\nfunction getUBOData(uniforms, uniformData) {\n  const usedUniformDatas = [];\n  for (const i in uniforms) {\n    if (uniformData[i]) {\n      usedUniformDatas.push(uniformData[i]);\n    }\n  }\n  usedUniformDatas.sort((a, b) => a.index - b.index);\n  return usedUniformDatas;\n}\nfunction generateUniformBufferSync(group, uniformData) {\n  if (!group.autoManage) {\n    return { size: 0, syncFunc: uboUpdate };\n  }\n  const usedUniformDatas = getUBOData(group.uniforms, uniformData);\n  const { uboElements, size } = createUBOElements(usedUniformDatas);\n  const funcFragments = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `];\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const uniform = group.uniforms[uboElement.data.name];\n    const name = uboElement.data.name;\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {\n        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j].codeUbo(uboElement.data.name, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        const size2 = mapSize(uboElement.data.type);\n        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n        const elementSize = size2 / rowSize;\n        const remainder = (4 - elementSize % 4) % 4;\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `);\n      } else {\n        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n                ${template};\n                `);\n      }\n    }\n  }\n  funcFragments.push(`\n       renderer.buffer.update(buffer);\n    `);\n  return {\n    size,\n    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\\n"))\n  };\n}\n\n\n//# sourceMappingURL=generateUniformBufferSync.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === "boolean") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");\n    unsafeEval = func({ a: "b" }, "a", "b") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\n\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/ShaderSystem.mjs\n\n\n\n\n\n\n\nlet ShaderSystem_UID = 0;\nconst defaultSyncData = { textureCount: 0, uboCount: 0 };\nclass ShaderSystem {\n  constructor(renderer) {\n    this.destroyed = false;\n    this.renderer = renderer;\n    this.systemCheck();\n    this.gl = null;\n    this.shader = null;\n    this.program = null;\n    this.cache = {};\n    this._uboCache = {};\n    this.id = ShaderSystem_UID++;\n  }\n  systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");\n    }\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.reset();\n  }\n  bind(shader, dontSync) {\n    shader.disposeRunner.add(this);\n    shader.uniforms.globals = this.renderer.globalUniforms;\n    const program = shader.program;\n    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);\n    this.shader = shader;\n    if (this.program !== program) {\n      this.program = program;\n      this.gl.useProgram(glProgram.program);\n    }\n    if (!dontSync) {\n      defaultSyncData.textureCount = 0;\n      defaultSyncData.uboCount = 0;\n      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);\n    }\n    return glProgram;\n  }\n  setUniforms(uniforms) {\n    const shader = this.shader.program;\n    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];\n    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);\n  }\n  syncUniformGroup(group, syncData) {\n    const glProgram = this.getGlProgram();\n    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {\n      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;\n      this.syncUniforms(group, glProgram, syncData);\n    }\n  }\n  syncUniforms(group, glProgram, syncData) {\n    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);\n    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);\n  }\n  createSyncGroups(group) {\n    const id = this.getSignature(group, this.shader.program.uniformData, "u");\n    if (!this.cache[id]) {\n      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);\n    }\n    group.syncUniforms[this.shader.program.id] = this.cache[id];\n    return group.syncUniforms[this.shader.program.id];\n  }\n  syncUniformBufferGroup(group, name) {\n    const glProgram = this.getGlProgram();\n    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {\n      group.dirtyId = 0;\n      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);\n      group.buffer.update();\n      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);\n    }\n    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);\n  }\n  createSyncBufferGroup(group, glProgram, name) {\n    const { gl } = this.renderer;\n    this.renderer.buffer.bind(group.buffer);\n    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);\n    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;\n    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);\n    this.shader.uniformBindCount++;\n    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");\n    let uboData = this._uboCache[id];\n    if (!uboData) {\n      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);\n    }\n    if (group.autoManage) {\n      const data = new Float32Array(uboData.size / 4);\n      group.buffer.update(data);\n    }\n    glProgram.uniformGroups[group.id] = uboData.syncFunc;\n    return glProgram.uniformGroups[group.id];\n  }\n  getSignature(group, uniformData, preFix) {\n    const uniforms = group.uniforms;\n    const strings = [`${preFix}-`];\n    for (const i in uniforms) {\n      strings.push(i);\n      if (uniformData[i]) {\n        strings.push(uniformData[i].type);\n      }\n    }\n    return strings.join("-");\n  }\n  getGlProgram() {\n    if (this.shader) {\n      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];\n    }\n    return null;\n  }\n  generateProgram(shader) {\n    const gl = this.gl;\n    const program = shader.program;\n    const glProgram = generateProgram(gl, program);\n    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;\n    return glProgram;\n  }\n  reset() {\n    this.program = null;\n    this.shader = null;\n  }\n  disposeShader(shader) {\n    if (this.shader === shader) {\n      this.shader = null;\n    }\n  }\n  destroy() {\n    this.renderer = null;\n    this.destroyed = true;\n  }\n}\nShaderSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "shader"\n};\nextensions.add(ShaderSystem);\n\n\n//# sourceMappingURL=ShaderSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/startup/StartupSystem.mjs\n\n\nclass StartupSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  run(options) {\n    const { renderer } = this;\n    renderer.runners.init.emit(renderer.options);\n    if (options.hello) {\n      console.log(`PixiJS ${"7.2.3"} - ${renderer.rendererLogId} - https://pixijs.com`);\n    }\n    renderer.resize(renderer.screen.width, renderer.screen.height);\n  }\n  destroy() {\n  }\n}\nStartupSystem.defaultOptions = {\n  hello: false\n};\nStartupSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "startup"\n};\nextensions.add(StartupSystem);\n\n\n//# sourceMappingURL=StartupSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs\n\n\nfunction mapWebGLBlendModesToPixi(gl, array = []) {\n  array[lib/* BLEND_MODES.NORMAL */.T$.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.ADD */.T$.ADD] = [gl.ONE, gl.ONE];\n  array[lib/* BLEND_MODES.MULTIPLY */.T$.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.SCREEN */.T$.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.OVERLAY */.T$.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.DARKEN */.T$.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.LIGHTEN */.T$.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.COLOR_DODGE */.T$.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.COLOR_BURN */.T$.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.HARD_LIGHT */.T$.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.SOFT_LIGHT */.T$.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.DIFFERENCE */.T$.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.EXCLUSION */.T$.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.HUE */.T$.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.SATURATION */.T$.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.COLOR */.T$.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.LUMINOSITY */.T$.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.NONE */.T$.NONE] = [0, 0];\n  array[lib/* BLEND_MODES.NORMAL_NPM */.T$.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.ADD_NPM */.T$.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n  array[lib/* BLEND_MODES.SCREEN_NPM */.T$.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.SRC_IN */.T$.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n  array[lib/* BLEND_MODES.SRC_OUT */.T$.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n  array[lib/* BLEND_MODES.SRC_ATOP */.T$.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.DST_OVER */.T$.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n  array[lib/* BLEND_MODES.DST_IN */.T$.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n  array[lib/* BLEND_MODES.DST_OUT */.T$.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.DST_ATOP */.T$.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n  array[lib/* BLEND_MODES.XOR */.T$.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES.SUBTRACT */.T$.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n  return array;\n}\n\n\n//# sourceMappingURL=mapWebGLBlendModesToPixi.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/StateSystem.mjs\n\n\n\n\n\nconst StateSystem_BLEND = 0;\nconst StateSystem_OFFSET = 1;\nconst StateSystem_CULLING = 2;\nconst StateSystem_DEPTH_TEST = 3;\nconst StateSystem_WINDING = 4;\nconst StateSystem_DEPTH_MASK = 5;\nconst _StateSystem = class {\n  constructor() {\n    this.gl = null;\n    this.stateId = 0;\n    this.polygonOffset = 0;\n    this.blendMode = lib/* BLEND_MODES.NONE */.T$.NONE;\n    this._blendEq = false;\n    this.map = [];\n    this.map[StateSystem_BLEND] = this.setBlend;\n    this.map[StateSystem_OFFSET] = this.setOffset;\n    this.map[StateSystem_CULLING] = this.setCullFace;\n    this.map[StateSystem_DEPTH_TEST] = this.setDepthTest;\n    this.map[StateSystem_WINDING] = this.setFrontFace;\n    this.map[StateSystem_DEPTH_MASK] = this.setDepthMask;\n    this.checks = [];\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.blendModes = mapWebGLBlendModesToPixi(gl);\n    this.set(this.defaultState);\n    this.reset();\n  }\n  set(state) {\n    state = state || this.defaultState;\n    if (this.stateId !== state.data) {\n      let diff = this.stateId ^ state.data;\n      let i = 0;\n      while (diff) {\n        if (diff & 1) {\n          this.map[i].call(this, !!(state.data & 1 << i));\n        }\n        diff = diff >> 1;\n        i++;\n      }\n      this.stateId = state.data;\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n  }\n  forceState(state) {\n    state = state || this.defaultState;\n    for (let i = 0; i < this.map.length; i++) {\n      this.map[i].call(this, !!(state.data & 1 << i));\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n    this.stateId = state.data;\n  }\n  setBlend(value) {\n    this.updateCheck(_StateSystem.checkBlendMode, value);\n    this.gl[value ? "enable" : "disable"](this.gl.BLEND);\n  }\n  setOffset(value) {\n    this.updateCheck(_StateSystem.checkPolygonOffset, value);\n    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);\n  }\n  setDepthTest(value) {\n    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);\n  }\n  setDepthMask(value) {\n    this.gl.depthMask(value);\n  }\n  setCullFace(value) {\n    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);\n  }\n  setFrontFace(value) {\n    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);\n  }\n  setBlendMode(value) {\n    if (value === this.blendMode) {\n      return;\n    }\n    this.blendMode = value;\n    const mode = this.blendModes[value];\n    const gl = this.gl;\n    if (mode.length === 2) {\n      gl.blendFunc(mode[0], mode[1]);\n    } else {\n      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n    }\n    if (mode.length === 6) {\n      this._blendEq = true;\n      gl.blendEquationSeparate(mode[4], mode[5]);\n    } else if (this._blendEq) {\n      this._blendEq = false;\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n    }\n  }\n  setPolygonOffset(value, scale) {\n    this.gl.polygonOffset(value, scale);\n  }\n  reset() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this.forceState(this.defaultState);\n    this._blendEq = true;\n    this.blendMode = -1;\n    this.setBlendMode(0);\n  }\n  updateCheck(func, value) {\n    const index = this.checks.indexOf(func);\n    if (value && index === -1) {\n      this.checks.push(func);\n    } else if (!value && index !== -1) {\n      this.checks.splice(index, 1);\n    }\n  }\n  static checkBlendMode(system, state) {\n    system.setBlendMode(state.blendMode);\n  }\n  static checkPolygonOffset(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  }\n  destroy() {\n    this.gl = null;\n  }\n};\nlet StateSystem = _StateSystem;\nStateSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "state"\n};\nextensions.add(StateSystem);\n\n\n//# sourceMappingURL=StateSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/system/SystemManager.mjs\n\n\n\nclass SystemManager extends utils_lib.EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.runners = {};\n    this._systemsHash = {};\n  }\n  setup(config) {\n    this.addRunners(...config.runners);\n    const priority = (config.priority ?? []).filter((key) => config.systems[key]);\n    const orderByPriority = [\n      ...priority,\n      ...Object.keys(config.systems).filter((key) => !priority.includes(key))\n    ];\n    for (const i of orderByPriority) {\n      this.addSystem(config.systems[i], i);\n    }\n  }\n  addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new Runner_Runner(runnerId);\n    });\n  }\n  addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name "${name}" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  emitWithCustomOptions(runner, options) {\n    const systemHashKeys = Object.keys(this._systemsHash);\n    runner.items.forEach((system) => {\n      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);\n      system[runner.name](options[systemName]);\n    });\n  }\n  destroy() {\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = {};\n  }\n}\n\n\n//# sourceMappingURL=SystemManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs\n\n\n\nconst _TextureGCSystem = class {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n    this.maxIdle = _TextureGCSystem.defaultMaxIdle;\n    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;\n    this.mode = _TextureGCSystem.defaultMode;\n  }\n  postrender() {\n    if (!this.renderer.objectRenderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (this.mode === lib/* GC_MODES.MANUAL */.UN.MANUAL) {\n      return;\n    }\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  run() {\n    const tm = this.renderer.texture;\n    const managedTextures = tm.managedTextures;\n    let wasRemoved = false;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {\n        tm.destroyTexture(texture, true);\n        managedTextures[i] = null;\n        wasRemoved = true;\n      }\n    }\n    if (wasRemoved) {\n      let j = 0;\n      for (let i = 0; i < managedTextures.length; i++) {\n        if (managedTextures[i] !== null) {\n          managedTextures[j++] = managedTextures[i];\n        }\n      }\n      managedTextures.length = j;\n    }\n  }\n  unload(displayObject) {\n    const tm = this.renderer.texture;\n    const texture = displayObject._texture;\n    if (texture && !texture.framebuffer) {\n      tm.destroyTexture(texture);\n    }\n    for (let i = displayObject.children.length - 1; i >= 0; i--) {\n      this.unload(displayObject.children[i]);\n    }\n  }\n  destroy() {\n    this.renderer = null;\n  }\n};\nlet TextureGCSystem = _TextureGCSystem;\nTextureGCSystem.defaultMode = lib/* GC_MODES.AUTO */.UN.AUTO;\nTextureGCSystem.defaultMaxIdle = 60 * 60;\nTextureGCSystem.defaultCheckCountMax = 60 * 10;\nTextureGCSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "textureGC"\n};\nextensions.add(TextureGCSystem);\n\n\n//# sourceMappingURL=TextureGCSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/GLTexture.mjs\n\n\nclass GLTexture {\n  constructor(texture) {\n    this.texture = texture;\n    this.width = -1;\n    this.height = -1;\n    this.dirtyId = -1;\n    this.dirtyStyleId = -1;\n    this.mipmap = false;\n    this.wrapMode = 33071;\n    this.type = lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE;\n    this.internalFormat = lib/* FORMATS.RGBA */.I2.RGBA;\n    this.samplerType = 0;\n  }\n}\n\n\n//# sourceMappingURL=GLTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs\n\n\nfunction mapTypeAndFormatToInternalFormat(gl) {\n  let table;\n  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {\n    table = {\n      [lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGBA8,\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.RGB8,\n        [lib/* FORMATS.RG */.I2.RG]: gl.RG8,\n        [lib/* FORMATS.RED */.I2.RED]: gl.R8,\n        [lib/* FORMATS.RGBA_INTEGER */.I2.RGBA_INTEGER]: gl.RGBA8UI,\n        [lib/* FORMATS.RGB_INTEGER */.I2.RGB_INTEGER]: gl.RGB8UI,\n        [lib/* FORMATS.RG_INTEGER */.I2.RG_INTEGER]: gl.RG8UI,\n        [lib/* FORMATS.RED_INTEGER */.I2.RED_INTEGER]: gl.R8UI,\n        [lib/* FORMATS.ALPHA */.I2.ALPHA]: gl.ALPHA,\n        [lib/* FORMATS.LUMINANCE */.I2.LUMINANCE]: gl.LUMINANCE,\n        [lib/* FORMATS.LUMINANCE_ALPHA */.I2.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA\n      },\n      [lib/* TYPES.BYTE */.vK.BYTE]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGBA8_SNORM,\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.RGB8_SNORM,\n        [lib/* FORMATS.RG */.I2.RG]: gl.RG8_SNORM,\n        [lib/* FORMATS.RED */.I2.RED]: gl.R8_SNORM,\n        [lib/* FORMATS.RGBA_INTEGER */.I2.RGBA_INTEGER]: gl.RGBA8I,\n        [lib/* FORMATS.RGB_INTEGER */.I2.RGB_INTEGER]: gl.RGB8I,\n        [lib/* FORMATS.RG_INTEGER */.I2.RG_INTEGER]: gl.RG8I,\n        [lib/* FORMATS.RED_INTEGER */.I2.RED_INTEGER]: gl.R8I\n      },\n      [lib/* TYPES.UNSIGNED_SHORT */.vK.UNSIGNED_SHORT]: {\n        [lib/* FORMATS.RGBA_INTEGER */.I2.RGBA_INTEGER]: gl.RGBA16UI,\n        [lib/* FORMATS.RGB_INTEGER */.I2.RGB_INTEGER]: gl.RGB16UI,\n        [lib/* FORMATS.RG_INTEGER */.I2.RG_INTEGER]: gl.RG16UI,\n        [lib/* FORMATS.RED_INTEGER */.I2.RED_INTEGER]: gl.R16UI,\n        [lib/* FORMATS.DEPTH_COMPONENT */.I2.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16\n      },\n      [lib/* TYPES.SHORT */.vK.SHORT]: {\n        [lib/* FORMATS.RGBA_INTEGER */.I2.RGBA_INTEGER]: gl.RGBA16I,\n        [lib/* FORMATS.RGB_INTEGER */.I2.RGB_INTEGER]: gl.RGB16I,\n        [lib/* FORMATS.RG_INTEGER */.I2.RG_INTEGER]: gl.RG16I,\n        [lib/* FORMATS.RED_INTEGER */.I2.RED_INTEGER]: gl.R16I\n      },\n      [lib/* TYPES.UNSIGNED_INT */.vK.UNSIGNED_INT]: {\n        [lib/* FORMATS.RGBA_INTEGER */.I2.RGBA_INTEGER]: gl.RGBA32UI,\n        [lib/* FORMATS.RGB_INTEGER */.I2.RGB_INTEGER]: gl.RGB32UI,\n        [lib/* FORMATS.RG_INTEGER */.I2.RG_INTEGER]: gl.RG32UI,\n        [lib/* FORMATS.RED_INTEGER */.I2.RED_INTEGER]: gl.R32UI,\n        [lib/* FORMATS.DEPTH_COMPONENT */.I2.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24\n      },\n      [lib/* TYPES.INT */.vK.INT]: {\n        [lib/* FORMATS.RGBA_INTEGER */.I2.RGBA_INTEGER]: gl.RGBA32I,\n        [lib/* FORMATS.RGB_INTEGER */.I2.RGB_INTEGER]: gl.RGB32I,\n        [lib/* FORMATS.RG_INTEGER */.I2.RG_INTEGER]: gl.RG32I,\n        [lib/* FORMATS.RED_INTEGER */.I2.RED_INTEGER]: gl.R32I\n      },\n      [lib/* TYPES.FLOAT */.vK.FLOAT]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGBA32F,\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.RGB32F,\n        [lib/* FORMATS.RG */.I2.RG]: gl.RG32F,\n        [lib/* FORMATS.RED */.I2.RED]: gl.R32F,\n        [lib/* FORMATS.DEPTH_COMPONENT */.I2.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F\n      },\n      [lib/* TYPES.HALF_FLOAT */.vK.HALF_FLOAT]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGBA16F,\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.RGB16F,\n        [lib/* FORMATS.RG */.I2.RG]: gl.RG16F,\n        [lib/* FORMATS.RED */.I2.RED]: gl.R16F\n      },\n      [lib/* TYPES.UNSIGNED_SHORT_5_6_5 */.vK.UNSIGNED_SHORT_5_6_5]: {\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.RGB565\n      },\n      [lib/* TYPES.UNSIGNED_SHORT_4_4_4_4 */.vK.UNSIGNED_SHORT_4_4_4_4]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGBA4\n      },\n      [lib/* TYPES.UNSIGNED_SHORT_5_5_5_1 */.vK.UNSIGNED_SHORT_5_5_5_1]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGB5_A1\n      },\n      [lib/* TYPES.UNSIGNED_INT_2_10_10_10_REV */.vK.UNSIGNED_INT_2_10_10_10_REV]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGB10_A2,\n        [lib/* FORMATS.RGBA_INTEGER */.I2.RGBA_INTEGER]: gl.RGB10_A2UI\n      },\n      [lib/* TYPES.UNSIGNED_INT_10F_11F_11F_REV */.vK.UNSIGNED_INT_10F_11F_11F_REV]: {\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.R11F_G11F_B10F\n      },\n      [lib/* TYPES.UNSIGNED_INT_5_9_9_9_REV */.vK.UNSIGNED_INT_5_9_9_9_REV]: {\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.RGB9_E5\n      },\n      [lib/* TYPES.UNSIGNED_INT_24_8 */.vK.UNSIGNED_INT_24_8]: {\n        [lib/* FORMATS.DEPTH_STENCIL */.I2.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8\n      },\n      [lib/* TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV */.vK.FLOAT_32_UNSIGNED_INT_24_8_REV]: {\n        [lib/* FORMATS.DEPTH_STENCIL */.I2.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8\n      }\n    };\n  } else {\n    table = {\n      [lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGBA,\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.RGB,\n        [lib/* FORMATS.ALPHA */.I2.ALPHA]: gl.ALPHA,\n        [lib/* FORMATS.LUMINANCE */.I2.LUMINANCE]: gl.LUMINANCE,\n        [lib/* FORMATS.LUMINANCE_ALPHA */.I2.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA\n      },\n      [lib/* TYPES.UNSIGNED_SHORT_5_6_5 */.vK.UNSIGNED_SHORT_5_6_5]: {\n        [lib/* FORMATS.RGB */.I2.RGB]: gl.RGB\n      },\n      [lib/* TYPES.UNSIGNED_SHORT_4_4_4_4 */.vK.UNSIGNED_SHORT_4_4_4_4]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGBA\n      },\n      [lib/* TYPES.UNSIGNED_SHORT_5_5_5_1 */.vK.UNSIGNED_SHORT_5_5_5_1]: {\n        [lib/* FORMATS.RGBA */.I2.RGBA]: gl.RGBA\n      }\n    };\n  }\n  return table;\n}\n\n\n//# sourceMappingURL=mapTypeAndFormatToInternalFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureSystem.mjs\n\n\n\n\n\n\n\nclass TextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.boundTextures = [];\n    this.currentLocation = -1;\n    this.managedTextures = [];\n    this._unknownBoundTextures = false;\n    this.unknownTexture = new BaseTexture();\n    this.hasIntegerTextures = false;\n  }\n  contextChange() {\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.webGLVersion = this.renderer.context.webGLVersion;\n    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = maxTextures;\n    for (let i = 0; i < maxTextures; i++) {\n      this.boundTextures[i] = null;\n    }\n    this.emptyTextures = {};\n    const emptyTexture2D = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n    for (let i = 0; i < 6; i++) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    for (let i = 0; i < this.boundTextures.length; i++) {\n      this.bind(null, i);\n    }\n  }\n  bind(texture, location = 0) {\n    const { gl } = this;\n    texture = texture?.castToBaseTexture();\n    if (texture?.valid && !texture.parentTextureArray) {\n      texture.touched = this.renderer.textureGC.count;\n      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n      if (this.boundTextures[location] !== texture) {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        gl.bindTexture(texture.target, glTexture.texture);\n      }\n      if (glTexture.dirtyId !== texture.dirtyId) {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        this.updateTexture(texture);\n      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {\n        this.updateTextureStyle(texture);\n      }\n      this.boundTextures[location] = texture;\n    } else {\n      if (this.currentLocation !== location) {\n        this.currentLocation = location;\n        gl.activeTexture(gl.TEXTURE0 + location);\n      }\n      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n      this.boundTextures[location] = null;\n    }\n  }\n  reset() {\n    this._unknownBoundTextures = true;\n    this.hasIntegerTextures = false;\n    this.currentLocation = -1;\n    for (let i = 0; i < this.boundTextures.length; i++) {\n      this.boundTextures[i] = this.unknownTexture;\n    }\n  }\n  unbind(texture) {\n    const { gl, boundTextures } = this;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = false;\n      for (let i = 0; i < boundTextures.length; i++) {\n        if (boundTextures[i] === this.unknownTexture) {\n          this.bind(null, i);\n        }\n      }\n    }\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === texture) {\n        if (this.currentLocation !== i) {\n          gl.activeTexture(gl.TEXTURE0 + i);\n          this.currentLocation = i;\n        }\n        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  ensureSamplerType(maxTextures) {\n    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;\n    if (!hasIntegerTextures) {\n      return;\n    }\n    for (let i = maxTextures - 1; i >= 0; --i) {\n      const tex = boundTextures[i];\n      if (tex) {\n        const glTexture = tex._glTextures[CONTEXT_UID];\n        if (glTexture.samplerType !== lib/* SAMPLER_TYPES.FLOAT */.oT.FLOAT) {\n          this.renderer.texture.unbind(tex);\n        }\n      }\n    }\n  }\n  initTexture(texture) {\n    const glTexture = new GLTexture(this.gl.createTexture());\n    glTexture.dirtyId = -1;\n    texture._glTextures[this.CONTEXT_UID] = glTexture;\n    this.managedTextures.push(texture);\n    texture.on("dispose", this.destroyTexture, this);\n    return glTexture;\n  }\n  initTextureType(texture, glTexture) {\n    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;\n    if (this.webGLVersion === 2 && texture.type === lib/* TYPES.HALF_FLOAT */.vK.HALF_FLOAT) {\n      glTexture.type = this.gl.HALF_FLOAT;\n    } else {\n      glTexture.type = texture.type;\n    }\n  }\n  updateTexture(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    const renderer = this.renderer;\n    this.initTextureType(texture, glTexture);\n    if (texture.resource?.upload(renderer, texture, glTexture)) {\n      if (glTexture.samplerType !== lib/* SAMPLER_TYPES.FLOAT */.oT.FLOAT) {\n        this.hasIntegerTextures = true;\n      }\n    } else {\n      const width = texture.realWidth;\n      const height = texture.realHeight;\n      const gl = renderer.gl;\n      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {\n        glTexture.width = width;\n        glTexture.height = height;\n        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);\n      }\n    }\n    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {\n      this.updateTextureStyle(texture);\n    }\n    glTexture.dirtyId = texture.dirtyId;\n  }\n  destroyTexture(texture, skipRemove) {\n    const { gl } = this;\n    texture = texture.castToBaseTexture();\n    if (texture._glTextures[this.CONTEXT_UID]) {\n      this.unbind(texture);\n      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n      texture.off("dispose", this.destroyTexture, this);\n      delete texture._glTextures[this.CONTEXT_UID];\n      if (!skipRemove) {\n        const i = this.managedTextures.indexOf(texture);\n        if (i !== -1) {\n          (0,utils_lib.removeItems)(this.managedTextures, i, 1);\n        }\n      }\n    }\n  }\n  updateTextureStyle(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    if ((texture.mipmap === lib/* MIPMAP_MODES.POW2 */.WB.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {\n      glTexture.mipmap = false;\n    } else {\n      glTexture.mipmap = texture.mipmap >= 1;\n    }\n    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {\n      glTexture.wrapMode = lib/* WRAP_MODES.CLAMP */.Nt.CLAMP;\n    } else {\n      glTexture.wrapMode = texture.wrapMode;\n    }\n    if (texture.resource?.style(this.renderer, texture, glTexture)) {\n    } else {\n      this.setStyle(texture, glTexture);\n    }\n    glTexture.dirtyStyleId = texture.dirtyStyleId;\n  }\n  setStyle(texture, glTexture) {\n    const gl = this.gl;\n    if (glTexture.mipmap && texture.mipmap !== lib/* MIPMAP_MODES.ON_MANUAL */.WB.ON_MANUAL) {\n      gl.generateMipmap(texture.target);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n    if (glTexture.mipmap) {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === lib/* SCALE_MODES.LINEAR */.aH.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === lib/* SCALE_MODES.LINEAR */.aH.LINEAR) {\n        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n      }\n    } else {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === lib/* SCALE_MODES.LINEAR */.aH.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === lib/* SCALE_MODES.LINEAR */.aH.LINEAR ? gl.LINEAR : gl.NEAREST);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "texture"\n};\nextensions.add(TextureSystem);\n\n\n//# sourceMappingURL=TextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs\n\n\nclass TransformFeedbackSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  contextChange() {\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  bind(transformFeedback) {\n    const { gl, CONTEXT_UID } = this;\n    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);\n  }\n  unbind() {\n    const { gl } = this;\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n  }\n  beginTransformFeedback(drawMode, shader) {\n    const { gl, renderer } = this;\n    if (shader) {\n      renderer.shader.bind(shader);\n    }\n    gl.beginTransformFeedback(drawMode);\n  }\n  endTransformFeedback() {\n    const { gl } = this;\n    gl.endTransformFeedback();\n  }\n  createGLTransformFeedback(tf) {\n    const { gl, renderer, CONTEXT_UID } = this;\n    const glTransformFeedback = gl.createTransformFeedback();\n    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);\n    for (let i = 0; i < tf.buffers.length; i++) {\n      const buffer = tf.buffers[i];\n      if (!buffer)\n        continue;\n      renderer.buffer.update(buffer);\n      buffer._glBuffers[CONTEXT_UID].refCount++;\n      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null);\n    }\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    tf.disposeRunner.add(this);\n    return glTransformFeedback;\n  }\n  disposeTransformFeedback(tf, contextLost) {\n    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];\n    const gl = this.gl;\n    tf.disposeRunner.remove(this);\n    const bufferSystem = this.renderer.buffer;\n    if (bufferSystem) {\n      for (let i = 0; i < tf.buffers.length; i++) {\n        const buffer = tf.buffers[i];\n        if (!buffer)\n          continue;\n        const buf = buffer._glBuffers[this.CONTEXT_UID];\n        if (buf) {\n          buf.refCount--;\n          if (buf.refCount === 0 && !contextLost) {\n            bufferSystem.dispose(buffer, contextLost);\n          }\n        }\n      }\n    }\n    if (!glTF) {\n      return;\n    }\n    if (!contextLost) {\n      gl.deleteTransformFeedback(glTF);\n    }\n    delete tf._glTransformFeedbacks[this.CONTEXT_UID];\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTransformFeedbackSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "transformFeedback"\n};\nextensions.add(TransformFeedbackSystem);\n\n\n//# sourceMappingURL=TransformFeedbackSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/view/ViewSystem.mjs\n\n\n\n\nclass ViewSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  init(options) {\n    this.screen = new math_lib/* Rectangle */.Ae(0, 0, options.width, options.height);\n    this.element = options.view || settings_lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n    this.resolution = options.resolution || settings_lib/* settings.RESOLUTION */.Xd.RESOLUTION;\n    this.autoDensity = !!options.autoDensity;\n  }\n  resizeView(desiredScreenWidth, desiredScreenHeight) {\n    this.element.width = Math.round(desiredScreenWidth * this.resolution);\n    this.element.height = Math.round(desiredScreenHeight * this.resolution);\n    const screenWidth = this.element.width / this.resolution;\n    const screenHeight = this.element.height / this.resolution;\n    this.screen.width = screenWidth;\n    this.screen.height = screenHeight;\n    if (this.autoDensity) {\n      this.element.style.width = `${screenWidth}px`;\n      this.element.style.height = `${screenHeight}px`;\n    }\n    this.renderer.emit("resize", screenWidth, screenHeight);\n    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);\n  }\n  destroy(removeView) {\n    if (removeView) {\n      this.element.parentNode?.removeChild(this.element);\n    }\n    this.renderer = null;\n    this.element = null;\n    this.screen = null;\n  }\n}\nViewSystem.defaultOptions = {\n  width: 800,\n  height: 600,\n  resolution: settings_lib/* settings.RESOLUTION */.Xd.RESOLUTION,\n  autoDensity: false\n};\nViewSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "_view"\n};\nextensions.add(ViewSystem);\n\n\n//# sourceMappingURL=ViewSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/systems.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=systems.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/settings.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsettings_lib/* settings.PREFER_ENV */.Xd.PREFER_ENV = lib/* ENV.WEBGL2 */.Vi.WEBGL2;\nsettings_lib/* settings.STRICT_TEXTURE_CACHE */.Xd.STRICT_TEXTURE_CACHE = false;\nsettings_lib/* settings.RENDER_OPTIONS */.Xd.RENDER_OPTIONS = {\n  ...ContextSystem.defaultOptions,\n  ...BackgroundSystem.defaultOptions,\n  ...ViewSystem.defaultOptions,\n  ...StartupSystem.defaultOptions\n};\nObject.defineProperties(settings_lib/* settings */.Xd, {\n  WRAP_MODE: {\n    get() {\n      return BaseTexture.defaultOptions.wrapMode;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");\n      BaseTexture.defaultOptions.wrapMode = value;\n    }\n  },\n  SCALE_MODE: {\n    get() {\n      return BaseTexture.defaultOptions.scaleMode;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");\n      BaseTexture.defaultOptions.scaleMode = value;\n    }\n  },\n  MIPMAP_TEXTURES: {\n    get() {\n      return BaseTexture.defaultOptions.mipmap;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");\n      BaseTexture.defaultOptions.mipmap = value;\n    }\n  },\n  ANISOTROPIC_LEVEL: {\n    get() {\n      return BaseTexture.defaultOptions.anisotropicLevel;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");\n      BaseTexture.defaultOptions.anisotropicLevel = value;\n    }\n  },\n  FILTER_RESOLUTION: {\n    get() {\n      (0,utils_lib.deprecation)("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");\n      return Filter.defaultResolution;\n    },\n    set(value) {\n      Filter.defaultResolution = value;\n    }\n  },\n  FILTER_MULTISAMPLE: {\n    get() {\n      (0,utils_lib.deprecation)("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");\n      return Filter.defaultMultisample;\n    },\n    set(value) {\n      Filter.defaultMultisample = value;\n    }\n  },\n  SPRITE_MAX_TEXTURES: {\n    get() {\n      return BatchRenderer.defaultMaxTextures;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");\n      BatchRenderer.defaultMaxTextures = value;\n    }\n  },\n  SPRITE_BATCH_SIZE: {\n    get() {\n      return BatchRenderer.defaultBatchSize;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");\n      BatchRenderer.defaultBatchSize = value;\n    }\n  },\n  CAN_UPLOAD_SAME_BUFFER: {\n    get() {\n      return BatchRenderer.canUploadSameBuffer;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");\n      BatchRenderer.canUploadSameBuffer = value;\n    }\n  },\n  GC_MODE: {\n    get() {\n      return TextureGCSystem.defaultMode;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");\n      TextureGCSystem.defaultMode = value;\n    }\n  },\n  GC_MAX_IDLE: {\n    get() {\n      return TextureGCSystem.defaultMaxIdle;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");\n      TextureGCSystem.defaultMaxIdle = value;\n    }\n  },\n  GC_MAX_CHECK_COUNT: {\n    get() {\n      return TextureGCSystem.defaultCheckCountMax;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");\n      TextureGCSystem.defaultCheckCountMax = value;\n    }\n  },\n  PRECISION_VERTEX: {\n    get() {\n      return Program.defaultVertexPrecision;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");\n      Program.defaultVertexPrecision = value;\n    }\n  },\n  PRECISION_FRAGMENT: {\n    get() {\n      return Program.defaultFragmentPrecision;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");\n      Program.defaultFragmentPrecision = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/const.mjs\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/TickerListener.mjs\nclass TickerListener {\n  constructor(fn, context = null, priority = 0, once = false) {\n    this.next = null;\n    this.previous = null;\n    this._destroyed = false;\n    this.fn = fn;\n    this.context = context;\n    this.priority = priority;\n    this.once = once;\n  }\n  match(fn, context = null) {\n    return this.fn === fn && this.context === context;\n  }\n  emit(deltaTime) {\n    if (this.fn) {\n      if (this.context) {\n        this.fn.call(this.context, deltaTime);\n      } else {\n        this.fn(deltaTime);\n      }\n    }\n    const redirect = this.next;\n    if (this.once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  destroy(hard = false) {\n    this._destroyed = true;\n    this.fn = null;\n    this.context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\n\n//# sourceMappingURL=TickerListener.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/Ticker.mjs\n\n\n\nconst _Ticker = class {\n  constructor() {\n    this.autoStart = false;\n    this.deltaTime = 1;\n    this.lastTime = -1;\n    this.speed = 1;\n    this.started = false;\n    this._requestId = null;\n    this._maxElapsedMS = 100;\n    this._minElapsedMS = 0;\n    this._protected = false;\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this.deltaTime);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\nlet Ticker = _Ticker;\nTicker.targetFPMS = 0.06;\n\n\n//# sourceMappingURL=Ticker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/settings.mjs\n\n\n\n\n\nObject.defineProperties(settings_lib/* settings */.Xd, {\n  TARGET_FPMS: {\n    get() {\n      return Ticker.targetFPMS;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");\n      Ticker.targetFPMS = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/TickerPlugin.mjs\n\n\n\n\nclass TickerPlugin {\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(this, "ticker", {\n      set(ticker) {\n        if (this._ticker) {\n          this._ticker.remove(this.render, this);\n        }\n        this._ticker = ticker;\n        if (ticker) {\n          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n        }\n      },\n      get() {\n        return this._ticker;\n      }\n    });\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\nTickerPlugin.extension = ExtensionType.Application;\nextensions.add(TickerPlugin);\n\n\n//# sourceMappingURL=TickerPlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/autoDetectRenderer.mjs\n\n\nconst renderers = [];\nextensions.handleByList(ExtensionType.Renderer, renderers);\nfunction autoDetectRenderer(options) {\n  for (const RendererType of renderers) {\n    if (RendererType.test(options)) {\n      return new RendererType(options);\n    }\n  }\n  throw new Error("Unable to auto-detect a suitable renderer.");\n}\n\n\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/default.mjs\nvar $defaultVertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}";\n\n\n//# sourceMappingURL=default.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/defaultFilter.mjs\nvar $defaultFilterVertex = "attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n";\n\n\n//# sourceMappingURL=defaultFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/index.mjs\n\n\n\nconst fragments_defaultVertex = $defaultVertex;\nconst defaultFilterVertex = $defaultFilterVertex;\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs\n\n\n\nclass MultisampleSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  contextChange(gl) {\n    let samples;\n    if (this.renderer.context.webGLVersion === 1) {\n      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      samples = gl.getParameter(gl.SAMPLES);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    } else {\n      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n      samples = gl.getParameter(gl.SAMPLES);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);\n    }\n    if (samples >= lib/* MSAA_QUALITY.HIGH */.G5.HIGH) {\n      this.multisample = lib/* MSAA_QUALITY.HIGH */.G5.HIGH;\n    } else if (samples >= lib/* MSAA_QUALITY.MEDIUM */.G5.MEDIUM) {\n      this.multisample = lib/* MSAA_QUALITY.MEDIUM */.G5.MEDIUM;\n    } else if (samples >= lib/* MSAA_QUALITY.LOW */.G5.LOW) {\n      this.multisample = lib/* MSAA_QUALITY.LOW */.G5.LOW;\n    } else {\n      this.multisample = lib/* MSAA_QUALITY.NONE */.G5.NONE;\n    }\n  }\n  destroy() {\n  }\n}\nMultisampleSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "_multisample"\n};\nextensions.add(MultisampleSystem);\n\n\n//# sourceMappingURL=MultisampleSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/GLBuffer.mjs\nclass GLBuffer {\n  constructor(buffer) {\n    this.buffer = buffer || null;\n    this.updateID = -1;\n    this.byteLength = -1;\n    this.refCount = 0;\n  }\n}\n\n\n//# sourceMappingURL=GLBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/BufferSystem.mjs\n\n\n\nclass BufferSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.managedBuffers = {};\n    this.boundBufferBases = {};\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  contextChange() {\n    this.disposeAll(true);\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  bind(buffer) {\n    const { gl, CONTEXT_UID } = this;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n  }\n  unbind(type) {\n    const { gl } = this;\n    gl.bindBuffer(type, null);\n  }\n  bindBufferBase(buffer, index) {\n    const { gl, CONTEXT_UID } = this;\n    if (this.boundBufferBases[index] !== buffer) {\n      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      this.boundBufferBases[index] = buffer;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  bindBufferRange(buffer, index, offset) {\n    const { gl, CONTEXT_UID } = this;\n    offset = offset || 0;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  update(buffer) {\n    const { gl, CONTEXT_UID } = this;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n    if (glBuffer.byteLength >= buffer.data.byteLength) {\n      gl.bufferSubData(buffer.type, 0, buffer.data);\n    } else {\n      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n      glBuffer.byteLength = buffer.data.byteLength;\n      gl.bufferData(buffer.type, buffer.data, drawType);\n    }\n  }\n  dispose(buffer, contextLost) {\n    if (!this.managedBuffers[buffer.id]) {\n      return;\n    }\n    delete this.managedBuffers[buffer.id];\n    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n    const gl = this.gl;\n    buffer.disposeRunner.remove(this);\n    if (!glBuffer) {\n      return;\n    }\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    delete buffer._glBuffers[this.CONTEXT_UID];\n  }\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedBuffers);\n    for (let i = 0; i < all.length; i++) {\n      this.dispose(this.managedBuffers[all[i]], contextLost);\n    }\n  }\n  createGLBuffer(buffer) {\n    const { CONTEXT_UID, gl } = this;\n    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n    this.managedBuffers[buffer.id] = buffer;\n    buffer.disposeRunner.add(this);\n    return buffer._glBuffers[CONTEXT_UID];\n  }\n}\nBufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "buffer"\n};\nextensions.add(BufferSystem);\n\n\n//# sourceMappingURL=BufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs\n\n\nclass ObjectRendererSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  render(displayObject, options) {\n    const renderer = this.renderer;\n    let renderTexture;\n    let clear;\n    let transform;\n    let skipUpdateTransform;\n    if (options) {\n      renderTexture = options.renderTexture;\n      clear = options.clear;\n      transform = options.transform;\n      skipUpdateTransform = options.skipUpdateTransform;\n    }\n    this.renderingToScreen = !renderTexture;\n    renderer.runners.prerender.emit();\n    renderer.emit("prerender");\n    renderer.projection.transform = transform;\n    if (renderer.context.isLost) {\n      return;\n    }\n    if (!renderTexture) {\n      this.lastObjectRendered = displayObject;\n    }\n    if (!skipUpdateTransform) {\n      const cacheParent = displayObject.enableTempParent();\n      displayObject.updateTransform();\n      displayObject.disableTempParent(cacheParent);\n    }\n    renderer.renderTexture.bind(renderTexture);\n    renderer.batch.currentRenderer.start();\n    if (clear ?? renderer.background.clearBeforeRender) {\n      renderer.renderTexture.clear();\n    }\n    displayObject.render(renderer);\n    renderer.batch.currentRenderer.flush();\n    if (renderTexture) {\n      if (options.blit) {\n        renderer.framebuffer.blit();\n      }\n      renderTexture.baseTexture.update();\n    }\n    renderer.runners.postrender.emit();\n    renderer.projection.transform = null;\n    renderer.emit("postrender");\n  }\n  destroy() {\n    this.renderer = null;\n    this.lastObjectRendered = null;\n  }\n}\nObjectRendererSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "objectRenderer"\n};\nextensions.add(ObjectRendererSystem);\n\n\n//# sourceMappingURL=ObjectRendererSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/Renderer.mjs\n\n\n\n\n\n\n\n\nconst _Renderer = class extends SystemManager {\n  constructor(options) {\n    super();\n    this.type = lib/* RENDERER_TYPE.WEBGL */.N3.WEBGL;\n    options = Object.assign({}, settings_lib/* settings.RENDER_OPTIONS */.Xd.RENDER_OPTIONS, options);\n    this.gl = null;\n    this.CONTEXT_UID = 0;\n    this.globalUniforms = new UniformGroup({\n      projectionMatrix: new math_lib/* Matrix */.y3()\n    }, true);\n    const systemConfig = {\n      runners: [\n        "init",\n        "destroy",\n        "contextChange",\n        "resolutionChange",\n        "reset",\n        "update",\n        "postrender",\n        "prerender",\n        "resize"\n      ],\n      systems: _Renderer.__systems,\n      priority: [\n        "_view",\n        "textureGenerator",\n        "background",\n        "_plugin",\n        "startup",\n        "context",\n        "state",\n        "texture",\n        "buffer",\n        "geometry",\n        "framebuffer",\n        "transformFeedback",\n        "mask",\n        "scissor",\n        "stencil",\n        "projection",\n        "textureGC",\n        "filter",\n        "renderTexture",\n        "batch",\n        "objectRenderer",\n        "_multisample"\n      ]\n    };\n    this.setup(systemConfig);\n    if ("useContextAlpha" in options) {\n      (0,utils_lib.deprecation)("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");\n      options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";\n      options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;\n    }\n    this._plugin.rendererPlugins = _Renderer.__plugins;\n    this.options = options;\n    this.startup.run(this.options);\n  }\n  static test(options) {\n    if (options?.forceCanvas) {\n      return false;\n    }\n    return (0,utils_lib.isWebGLSupported)();\n  }\n  render(displayObject, options) {\n    this.objectRenderer.render(displayObject, options);\n  }\n  resize(desiredScreenWidth, desiredScreenHeight) {\n    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);\n  }\n  reset() {\n    this.runners.reset.emit();\n    return this;\n  }\n  clear() {\n    this.renderTexture.bind();\n    this.renderTexture.clear();\n  }\n  destroy(removeView = false) {\n    this.runners.destroy.items.reverse();\n    this.emitWithCustomOptions(this.runners.destroy, {\n      _view: removeView\n    });\n    super.destroy();\n  }\n  get plugins() {\n    return this._plugin.plugins;\n  }\n  get multisample() {\n    return this._multisample.multisample;\n  }\n  get width() {\n    return this._view.element.width;\n  }\n  get height() {\n    return this._view.element.height;\n  }\n  get resolution() {\n    return this._view.resolution;\n  }\n  set resolution(value) {\n    this._view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  get autoDensity() {\n    return this._view.autoDensity;\n  }\n  get view() {\n    return this._view.element;\n  }\n  get screen() {\n    return this._view.screen;\n  }\n  get lastObjectRendered() {\n    return this.objectRenderer.lastObjectRendered;\n  }\n  get renderingToScreen() {\n    return this.objectRenderer.renderingToScreen;\n  }\n  get rendererLogId() {\n    return `WebGL ${this.context.webGLVersion}`;\n  }\n  get clearBeforeRender() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");\n    return this.background.clearBeforeRender;\n  }\n  get useContextAlpha() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");\n    return this.context.useContextAlpha;\n  }\n  get preserveDrawingBuffer() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");\n    return this.context.preserveDrawingBuffer;\n  }\n  get backgroundColor() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");\n    return this.background.color;\n  }\n  set backgroundColor(value) {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");\n    this.background.color = value;\n  }\n  get backgroundAlpha() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");\n    return this.background.alpha;\n  }\n  set backgroundAlpha(value) {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");\n    this.background.alpha = value;\n  }\n  get powerPreference() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");\n    return this.context.powerPreference;\n  }\n  generateTexture(displayObject, options) {\n    return this.textureGenerator.generateTexture(displayObject, options);\n  }\n};\nlet Renderer = _Renderer;\nRenderer.extension = {\n  type: ExtensionType.Renderer,\n  priority: 1\n};\nRenderer.__plugins = {};\nRenderer.__systems = {};\nextensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);\nextensions.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);\nextensions.add(Renderer);\n\n\n//# sourceMappingURL=Renderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs\n\n\n\n\nclass AbstractMultiResource extends Resource {\n  constructor(length, options) {\n    const { width, height } = options || {};\n    super(width, height);\n    this.items = [];\n    this.itemDirtyIds = [];\n    for (let i = 0; i < length; i++) {\n      const partTexture = new BaseTexture();\n      this.items.push(partTexture);\n      this.itemDirtyIds.push(-2);\n    }\n    this.length = length;\n    this._load = null;\n    this.baseTexture = null;\n  }\n  initFromArray(resources, options) {\n    for (let i = 0; i < this.length; i++) {\n      if (!resources[i]) {\n        continue;\n      }\n      if (resources[i].castToBaseTexture) {\n        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n      } else if (resources[i] instanceof Resource) {\n        this.addResourceAt(resources[i], i);\n      } else {\n        this.addResourceAt(autoDetectResource(resources[i], options), i);\n      }\n    }\n  }\n  dispose() {\n    for (let i = 0, len = this.length; i < len; i++) {\n      this.items[i].destroy();\n    }\n    this.items = null;\n    this.itemDirtyIds = null;\n    this._load = null;\n  }\n  addResourceAt(resource, index) {\n    if (!this.items[index]) {\n      throw new Error(`Index ${index} is out of bounds`);\n    }\n    if (resource.valid && !this.valid) {\n      this.resize(resource.width, resource.height);\n    }\n    this.items[index].setResource(resource);\n    return this;\n  }\n  bind(baseTexture) {\n    if (this.baseTexture !== null) {\n      throw new Error("Only one base texture per TextureArray is allowed");\n    }\n    super.bind(baseTexture);\n    for (let i = 0; i < this.length; i++) {\n      this.items[i].parentTextureArray = baseTexture;\n      this.items[i].on("update", baseTexture.update, baseTexture);\n    }\n  }\n  unbind(baseTexture) {\n    super.unbind(baseTexture);\n    for (let i = 0; i < this.length; i++) {\n      this.items[i].parentTextureArray = null;\n      this.items[i].off("update", baseTexture.update, baseTexture);\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    const resources = this.items.map((item) => item.resource).filter((item) => item);\n    const promises = resources.map((item) => item.load());\n    this._load = Promise.all(promises).then(() => {\n      const { realWidth, realHeight } = this.items[0];\n      this.resize(realWidth, realHeight);\n      return Promise.resolve(this);\n    });\n    return this._load;\n  }\n}\n\n\n//# sourceMappingURL=AbstractMultiResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs\n\n\n\nclass ArrayResource extends AbstractMultiResource {\n  constructor(source, options) {\n    const { width, height } = options || {};\n    let urls;\n    let length;\n    if (Array.isArray(source)) {\n      urls = source;\n      length = source.length;\n    } else {\n      length = source;\n    }\n    super(length, { width, height });\n    if (urls) {\n      this.initFromArray(urls, options);\n    }\n  }\n  addBaseTextureAt(baseTexture, index) {\n    if (baseTexture.resource) {\n      this.addResourceAt(baseTexture.resource, index);\n    } else {\n      throw new Error("ArrayResource does not support RenderTexture");\n    }\n    return this;\n  }\n  bind(baseTexture) {\n    super.bind(baseTexture);\n    baseTexture.target = lib/* TARGETS.TEXTURE_2D_ARRAY */.sp.TEXTURE_2D_ARRAY;\n  }\n  upload(renderer, texture, glTexture) {\n    const { length, itemDirtyIds, items } = this;\n    const { gl } = renderer;\n    if (glTexture.dirtyId < 0) {\n      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);\n    }\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n      if (itemDirtyIds[i] < item.dirtyId) {\n        itemDirtyIds[i] = item.dirtyId;\n        if (item.valid) {\n          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);\n        }\n      }\n    }\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=ArrayResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs\n\n\nclass CanvasResource extends BaseImageResource {\n  constructor(source) {\n    super(source);\n  }\n  static test(source) {\n    const { OffscreenCanvas } = globalThis;\n    if (OffscreenCanvas && source instanceof OffscreenCanvas) {\n      return true;\n    }\n    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;\n  }\n}\n\n\n//# sourceMappingURL=CanvasResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs\n\n\n\nconst _CubeResource = class extends AbstractMultiResource {\n  constructor(source, options) {\n    const { width, height, autoLoad, linkBaseTexture } = options || {};\n    if (source && source.length !== _CubeResource.SIDES) {\n      throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n    }\n    super(6, { width, height });\n    for (let i = 0; i < _CubeResource.SIDES; i++) {\n      this.items[i].target = lib/* TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X */.sp.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    }\n    this.linkBaseTexture = linkBaseTexture !== false;\n    if (source) {\n      this.initFromArray(source, options);\n    }\n    if (autoLoad !== false) {\n      this.load();\n    }\n  }\n  bind(baseTexture) {\n    super.bind(baseTexture);\n    baseTexture.target = lib/* TARGETS.TEXTURE_CUBE_MAP */.sp.TEXTURE_CUBE_MAP;\n  }\n  addBaseTextureAt(baseTexture, index, linkBaseTexture) {\n    if (linkBaseTexture === void 0) {\n      linkBaseTexture = this.linkBaseTexture;\n    }\n    if (!this.items[index]) {\n      throw new Error(`Index ${index} is out of bounds`);\n    }\n    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {\n      if (baseTexture.resource) {\n        this.addResourceAt(baseTexture.resource, index);\n      } else {\n        throw new Error(`CubeResource does not support copying of renderTexture.`);\n      }\n    } else {\n      baseTexture.target = lib/* TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X */.sp.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n      baseTexture.parentTextureArray = this.baseTexture;\n      this.items[index] = baseTexture;\n    }\n    if (baseTexture.valid && !this.valid) {\n      this.resize(baseTexture.realWidth, baseTexture.realHeight);\n    }\n    this.items[index] = baseTexture;\n    return this;\n  }\n  upload(renderer, _baseTexture, glTexture) {\n    const dirty = this.itemDirtyIds;\n    for (let i = 0; i < _CubeResource.SIDES; i++) {\n      const side = this.items[i];\n      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {\n        if (side.valid && side.resource) {\n          side.resource.upload(renderer, side, glTexture);\n          dirty[i] = side.dirtyId;\n        } else if (dirty[i] < -1) {\n          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);\n          dirty[i] = -1;\n        }\n      }\n    }\n    return true;\n  }\n  static test(source) {\n    return Array.isArray(source) && source.length === _CubeResource.SIDES;\n  }\n};\nlet CubeResource = _CubeResource;\nCubeResource.SIDES = 6;\n\n\n//# sourceMappingURL=CubeResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs\n\n\n\n\nclass ImageBitmapResource extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    let baseSource;\n    let url;\n    if (typeof source === "string") {\n      baseSource = ImageBitmapResource.EMPTY;\n      url = source;\n    } else {\n      baseSource = source;\n      url = null;\n    }\n    super(baseSource);\n    this.url = url;\n    this.crossOrigin = options.crossOrigin ?? true;\n    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise(async (resolve, reject) => {\n      if (this.url === null) {\n        resolve(this);\n        return;\n      }\n      try {\n        const response = await settings_lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(this.url, {\n          mode: this.crossOrigin ? "cors" : "no-cors"\n        });\n        if (this.destroyed)\n          return;\n        const imageBlob = await response.blob();\n        if (this.destroyed)\n          return;\n        const imageBitmap = await createImageBitmap(imageBlob, {\n          premultiplyAlpha: this.alphaMode === null || this.alphaMode === lib/* ALPHA_MODES.UNPACK */.iw.UNPACK ? "premultiply" : "none"\n        });\n        if (this.destroyed)\n          return;\n        this.source = imageBitmap;\n        this.update();\n        resolve(this);\n      } catch (e) {\n        if (this.destroyed)\n          return;\n        reject(e);\n        this.onError.emit(e);\n      }\n    });\n    return this._load;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    if (!(this.source instanceof ImageBitmap)) {\n      this.load();\n      return false;\n    }\n    if (typeof this.alphaMode === "number") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    return super.upload(renderer, baseTexture, glTexture);\n  }\n  dispose() {\n    if (this.source instanceof ImageBitmap) {\n      this.source.close();\n    }\n    super.dispose();\n    this._load = null;\n  }\n  static test(source) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);\n  }\n  static get EMPTY() {\n    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings_lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas(0, 0);\n    return ImageBitmapResource._EMPTY;\n  }\n}\n\n\n//# sourceMappingURL=ImageBitmapResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs\n\n\n\n\nconst _SVGResource = class extends BaseImageResource {\n  constructor(sourceBase64, options) {\n    options = options || {};\n    super(settings_lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas());\n    this._width = 0;\n    this._height = 0;\n    this.svg = sourceBase64;\n    this.scale = options.scale || 1;\n    this._overrideWidth = options.width;\n    this._overrideHeight = options.height;\n    this._resolve = null;\n    this._crossorigin = options.crossorigin;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise((resolve) => {\n      this._resolve = () => {\n        this.resize(this.source.width, this.source.height);\n        resolve(this);\n      };\n      if (_SVGResource.SVG_XML.test(this.svg.trim())) {\n        if (!btoa) {\n          throw new Error("Your browser doesn\'t support base64 conversions.");\n        }\n        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n      }\n      this._loadSvg();\n    });\n    return this._load;\n  }\n  _loadSvg() {\n    const tempImage = new Image();\n    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n    tempImage.src = this.svg;\n    tempImage.onerror = (event) => {\n      if (!this._resolve) {\n        return;\n      }\n      tempImage.onerror = null;\n      this.onError.emit(event);\n    };\n    tempImage.onload = () => {\n      if (!this._resolve) {\n        return;\n      }\n      const svgWidth = tempImage.width;\n      const svgHeight = tempImage.height;\n      if (!svgWidth || !svgHeight) {\n        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");\n      }\n      let width = svgWidth * this.scale;\n      let height = svgHeight * this.scale;\n      if (this._overrideWidth || this._overrideHeight) {\n        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;\n        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;\n      }\n      width = Math.round(width);\n      height = Math.round(height);\n      const canvas = this.source;\n      canvas.width = width;\n      canvas.height = height;\n      canvas._pixiId = `canvas_${(0,utils_lib.uid)()}`;\n      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n      this._resolve();\n      this._resolve = null;\n    };\n  }\n  static getSize(svgString) {\n    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);\n    const size = {};\n    if (sizeMatch) {\n      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n    }\n    return size;\n  }\n  dispose() {\n    super.dispose();\n    this._resolve = null;\n    this._crossorigin = null;\n  }\n  static test(source, extension) {\n    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);\n  }\n};\nlet SVGResource = _SVGResource;\nSVGResource.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(\x3c!--[^(--\x3e)]*--\x3e)?\\s*\\<svg/m;\nSVGResource.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=(\'|")(\\d*(?:\\.\\d+)?)(?:px)?(\'|"))[^>]*(?:\\s(width|height)=(\'|")(\\d*(?:\\.\\d+)?)(?:px)?(\'|"))[^>]*>/i;\n\n\n//# sourceMappingURL=SVGResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs\n\n\n\nconst _VideoResource = class extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    if (!(source instanceof HTMLVideoElement)) {\n      const videoElement = document.createElement("video");\n      videoElement.setAttribute("preload", "auto");\n      videoElement.setAttribute("webkit-playsinline", "");\n      videoElement.setAttribute("playsinline", "");\n      if (typeof source === "string") {\n        source = [source];\n      }\n      const firstSrc = source[0].src || source[0];\n      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (let i = 0; i < source.length; ++i) {\n        const sourceElement = document.createElement("source");\n        let { src, mime } = source[i];\n        src = src || source[i];\n        const baseSrc = src.split("?").shift().toLowerCase();\n        const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);\n        mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;\n        sourceElement.src = src;\n        sourceElement.type = mime;\n        videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    super(source);\n    this.noSubImage = true;\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this._load = null;\n    this._resolve = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onError = this._onError.bind(this);\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  update(_deltaTime = 0) {\n    if (!this.destroyed) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n      if (!this._updateFPS || this._msToNextUpdate <= 0) {\n        super.update();\n        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n      }\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.source;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener("play", this._onPlayStart.bind(this));\n    source.addEventListener("pause", this._onPlayStop.bind(this));\n    if (!this._isSourceReady()) {\n      source.addEventListener("canplay", this._onCanPlay);\n      source.addEventListener("canplaythrough", this._onCanPlay);\n      source.addEventListener("error", this._onError, true);\n    } else {\n      this._onCanPlay();\n    }\n    this._load = new Promise((resolve) => {\n      if (this.valid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  _onError(event) {\n    this.source.removeEventListener("error", this._onError, true);\n    this.onError.emit(event);\n  }\n  _isSourcePlaying() {\n    const source = this.source;\n    return !source.paused && !source.ended && this._isSourceReady();\n  }\n  _isSourceReady() {\n    const source = this.source;\n    return source.readyState > 2;\n  }\n  _onPlayStart() {\n    if (!this.valid) {\n      this._onCanPlay();\n    }\n    if (this.autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this);\n      this._isConnectedToTicker = true;\n    }\n  }\n  _onPlayStop() {\n    if (this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  _onCanPlay() {\n    const source = this.source;\n    source.removeEventListener("canplay", this._onCanPlay);\n    source.removeEventListener("canplaythrough", this._onCanPlay);\n    const valid = this.valid;\n    this.resize(source.videoWidth, source.videoHeight);\n    if (!valid && this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      source.play();\n    }\n  }\n  dispose() {\n    if (this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n    const source = this.source;\n    if (source) {\n      source.removeEventListener("error", this._onError, true);\n      source.pause();\n      source.src = "";\n      source.load();\n    }\n    super.dispose();\n  }\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n    }\n  }\n  static test(source, extension) {\n    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);\n  }\n};\nlet VideoResource = _VideoResource;\nVideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];\nVideoResource.MIME_TYPES = {\n  ogv: "video/ogg",\n  mov: "video/quicktime",\n  m4v: "video/mp4"\n};\n\n\n//# sourceMappingURL=VideoResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nINSTALLED.push(ImageBitmapResource, ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs\n\n\nclass TransformFeedback {\n  constructor() {\n    this._glTransformFeedbacks = {};\n    this.buffers = [];\n    this.disposeRunner = new Runner("disposeTransformFeedback");\n  }\n  bindBuffer(index, buffer) {\n    this.buffers[index] = buffer;\n  }\n  destroy() {\n    this.disposeRunner.emit(this, false);\n  }\n}\n\n\n//# sourceMappingURL=TransformFeedback.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = "7.2.3";\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQSxRQUFRLDRCQUE0QjtBQUNwQztBQUNBO0FBQ0EsY0FBYzs7QUFFUztBQUN2Qjs7O0FDbEVzQztBQUN1QjtBQUNuQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQW1CLElBQUksNkJBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QjtBQUNQO0FBQ2tDO0FBQ0o7QUFDYjtBQUNTO0FBQ2dCO0FBQ0o7QUFDQTtBQUNOO0FBQ3VCO0FBQ1k7QUFDbEQ7QUFDSTtBQUNPO0FBQ1E7QUFDb0I7QUFDbEI7QUFDMEI7QUFDaEI7QUFDcUI7QUFDbkI7QUFDQTtBQUNKO0FBQ2M7QUFDWjtBQUNKO0FBQ0k7O0FBRXZFOztBQUVtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9leHRlbnNpb25zL2xpYi9pbmRleC5tanM/MDJjYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvVmlld2FibGVCdWZmZXIubWpzPzcyNTkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9jaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLm1qcz8zNmE3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGF0ZS9TdGF0ZS5tanM/NDdmZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5tanM/OTFjNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvcnVubmVyL2xpYi9SdW5uZXIubWpzPzBjYWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3J1bm5lci9saWIvaW5kZXgubWpzP2UzYWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9SZXNvdXJjZS5tanM/NDViYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0J1ZmZlclJlc291cmNlLm1qcz9lMjY1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5tanM/MDVjMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hEcmF3Q2FsbC5tanM/YjQ4ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvQnVmZmVyLm1qcz8yNDVhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9BdHRyaWJ1dGUubWpzP2QxNjAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2dlb21ldHJ5L3V0aWxzL2ludGVybGVhdmVUeXBlZEFycmF5cy5tanM/NGM5ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvR2VvbWV0cnkubWpzPzY4MzAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoR2VvbWV0cnkubWpzPzUxMDkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9kZWZhdWx0UHJvZ3JhbS5tanM/ZGEyMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL2RlZmF1bHRQcm9ncmFtMi5tanM/MzllYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL3VuaWZvcm1QYXJzZXJzLm1qcz84MzkyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVVbmlmb3Jtc1N5bmMubWpzPzZhN2IiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRUZXN0Q29udGV4dC5tanM/ZWEzMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dldE1heEZyYWdtZW50UHJlY2lzaW9uLm1qcz9kYmIzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvbWFwU2l6ZS5tanM/YTA2NSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL21hcFR5cGUubWpzP2JjNGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9zZXRQcmVjaXNpb24ubWpzP2FiY2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9pbmRleC5tanM/MTIyYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL1Byb2dyYW0ubWpzP2U3MmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzPzE5NTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9TaGFkZXIubWpzP2QwYzAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoU2hhZGVyR2VuZXJhdG9yLm1qcz80MWE0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFRleHR1cmVBcnJheS5tanM/Yjg0YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvY2FuVXBsb2FkU2FtZUJ1ZmZlci5tanM/OWQzMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanM/ZThmNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvT2JqZWN0UmVuZGVyZXIubWpzP2U3NTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL3RleHR1cmUubWpzPzlmZGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL3RleHR1cmUyLm1qcz9hNzc2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFJlbmRlcmVyLm1qcz80MjE3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL2RlZmF1bHRGaWx0ZXIubWpzP2FjNGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvZGVmYXVsdEZpbHRlcjIubWpzPzhhZjIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyLm1qcz83MTI4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzP2U5YWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoU3lzdGVtLm1qcz8wMjU3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9jb250ZXh0L0NvbnRleHRTeXN0ZW0ubWpzPzJkNjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9EZXB0aFJlc291cmNlLm1qcz9iZmQ0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlci5tanM/ZGUzZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyVGV4dHVyZS9CYXNlUmVuZGVyVGV4dHVyZS5tanM/MTc0ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0Jhc2VJbWFnZVJlc291cmNlLm1qcz8wYmYzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvSW1hZ2VSZXNvdXJjZS5tanM/OTgyZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZVV2cy5tanM/YjNiNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZS5tanM/NTc2ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlLm1qcz9jOWJkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVQb29sLm1qcz9jMDFmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi91dGlscy9RdWFkLm1qcz81MmUwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi91dGlscy9RdWFkVXYubWpzPzExNTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyU3RhdGUubWpzP2M4MDkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcz84ZDNhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9HTEZyYW1lYnVmZmVyLm1qcz81ZGM3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlclN5c3RlbS5tanM/NTcyYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvR2VvbWV0cnlTeXN0ZW0ubWpzPzdkNzciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL1RleHR1cmVNYXRyaXgubWpzPzNhOTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvc3ByaXRlTWFzay9zcHJpdGVNYXNrRmlsdGVyMi5tanM/ODNiYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9zcHJpdGVNYXNrL3Nwcml0ZU1hc2tGaWx0ZXIzLm1qcz81MzkxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL3Nwcml0ZU1hc2svU3ByaXRlTWFza0ZpbHRlci5tanM/MWFiNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9NYXNrRGF0YS5tanM/ZmQxOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9NYXNrU3lzdGVtLm1qcz8zNDE1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9tYXNrL0Fic3RyYWN0TWFza1N5c3RlbS5tanM/NDg4MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9TY2lzc29yU3lzdGVtLm1qcz85MmM5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9tYXNrL1N0ZW5jaWxTeXN0ZW0ubWpzPzYwNDAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3BsdWdpbi9QbHVnaW5TeXN0ZW0ubWpzP2UxNmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5tanM/YTIwYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyVGV4dHVyZS9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzPzYwMDEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVN5c3RlbS5tanM/MjE5ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL0dMUHJvZ3JhbS5tanM/YTI3OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2NvbXBpbGVTaGFkZXIubWpzPzY1M2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9kZWZhdWx0VmFsdWUubWpzP2ZjODgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRBdHRyaWJ1dGVEYXRhLm1qcz85MWRjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZ2V0VW5pZm9ybURhdGEubWpzPzViYWEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9sb2dQcm9ncmFtRXJyb3IubWpzPzZlMjYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZW5lcmF0ZVByb2dyYW0ubWpzP2JmY2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLm1qcz80YmE2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvdW5zYWZlRXZhbFN1cHBvcnRlZC5tanM/MDg0MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL1NoYWRlclN5c3RlbS5tanM/NzUyZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3RhcnR1cC9TdGFydHVwU3lzdGVtLm1qcz80NDJlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGF0ZS91dGlscy9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzPzg2N2YiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3N0YXRlL1N0YXRlU3lzdGVtLm1qcz81YWFjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zeXN0ZW0vU3lzdGVtTWFuYWdlci5tanM/Y2QyMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZUdDU3lzdGVtLm1qcz83YjVkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9HTFRleHR1cmUubWpzPzkwOGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3V0aWxzL21hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0Lm1qcz8zY2EzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9UZXh0dXJlU3lzdGVtLm1qcz8wZjA1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5tanM/OTI2NSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdmlldy9WaWV3U3lzdGVtLm1qcz83NmYxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zeXN0ZW1zLm1qcz8wMzg2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zZXR0aW5ncy5tanM/ZjdhNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9jb25zdC5tanM/OTllOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9UaWNrZXJMaXN0ZW5lci5tanM/ZmViYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9UaWNrZXIubWpzP2MzOGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvc2V0dGluZ3MubWpzPzg3ZmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvVGlja2VyUGx1Z2luLm1qcz80NWJkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90aWNrZXIvbGliL2luZGV4Lm1qcz9jOTlkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzP2NkOWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZyYWdtZW50cy9kZWZhdWx0Lm1qcz9mNjlkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFnbWVudHMvZGVmYXVsdEZpbHRlci5tanM/ODFkMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhZ21lbnRzL2luZGV4Lm1qcz80Y2Y0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9NdWx0aXNhbXBsZVN5c3RlbS5tanM/MmUxMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvR0xCdWZmZXIubWpzPzA3MTAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2dlb21ldHJ5L0J1ZmZlclN5c3RlbS5tanM/NmY3OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyL09iamVjdFJlbmRlcmVyU3lzdGVtLm1qcz80Nzc3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9SZW5kZXJlci5tanM/Zjc2ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5tanM/ZTZlYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0FycmF5UmVzb3VyY2UubWpzPzczYTAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9DYW52YXNSZXNvdXJjZS5tanM/YTc1ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0N1YmVSZXNvdXJjZS5tanM/N2RiMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0ltYWdlQml0bWFwUmVzb3VyY2UubWpzP2ExODYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9TVkdSZXNvdXJjZS5tanM/ZWE2ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL1ZpZGVvUmVzb3VyY2UubWpzP2EyNzMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9pbmRleC5tanM/ZmViMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdHJhbnNmb3JtRmVlZGJhY2svVHJhbnNmb3JtRmVlZGJhY2subWpzPzdhNDIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2luZGV4Lm1qcz9hODI2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBFeHRlbnNpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoRXh0ZW5zaW9uVHlwZTIpID0+IHtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJSZW5kZXJlclwiXSA9IFwicmVuZGVyZXJcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJBcHBsaWNhdGlvblwiXSA9IFwiYXBwbGljYXRpb25cIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJSZW5kZXJlclN5c3RlbVwiXSA9IFwicmVuZGVyZXItd2ViZ2wtc3lzdGVtXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiUmVuZGVyZXJQbHVnaW5cIl0gPSBcInJlbmRlcmVyLXdlYmdsLXBsdWdpblwiO1xuICBFeHRlbnNpb25UeXBlMltcIkNhbnZhc1JlbmRlcmVyU3lzdGVtXCJdID0gXCJyZW5kZXJlci1jYW52YXMtc3lzdGVtXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FudmFzUmVuZGVyZXJQbHVnaW5cIl0gPSBcInJlbmRlcmVyLWNhbnZhcy1wbHVnaW5cIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJBc3NldFwiXSA9IFwiYXNzZXRcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJMb2FkUGFyc2VyXCJdID0gXCJsb2FkLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIlJlc29sdmVQYXJzZXJcIl0gPSBcInJlc29sdmUtcGFyc2VyXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FjaGVQYXJzZXJcIl0gPSBcImNhY2hlLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkRldGVjdGlvblBhcnNlclwiXSA9IFwiZGV0ZWN0aW9uLXBhcnNlclwiO1xuICByZXR1cm4gRXh0ZW5zaW9uVHlwZTI7XG59KShFeHRlbnNpb25UeXBlIHx8IHt9KTtcbmNvbnN0IG5vcm1hbGl6ZUV4dGVuc2lvbiA9IChleHQpID0+IHtcbiAgaWYgKHR5cGVvZiBleHQgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZXh0ID09PSBcIm9iamVjdFwiICYmIGV4dC5leHRlbnNpb24pIHtcbiAgICBpZiAoIWV4dC5leHRlbnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4dGVuc2lvbiBjbGFzcyBtdXN0IGhhdmUgYW4gZXh0ZW5zaW9uIG9iamVjdFwiKTtcbiAgICB9XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0eXBlb2YgZXh0LmV4dGVuc2lvbiAhPT0gXCJvYmplY3RcIiA/IHsgdHlwZTogZXh0LmV4dGVuc2lvbiB9IDogZXh0LmV4dGVuc2lvbjtcbiAgICBleHQgPSB7IC4uLm1ldGFkYXRhLCByZWY6IGV4dCB9O1xuICB9XG4gIGlmICh0eXBlb2YgZXh0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgZXh0ID0geyAuLi5leHQgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGV4dGVuc2lvbiB0eXBlXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZXh0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBleHQudHlwZSA9IFtleHQudHlwZV07XG4gIH1cbiAgcmV0dXJuIGV4dDtcbn07XG5jb25zdCBub3JtYWxpemVQcmlvcml0eSA9IChleHQsIGRlZmF1bHRQcmlvcml0eSkgPT4gbm9ybWFsaXplRXh0ZW5zaW9uKGV4dCkucHJpb3JpdHkgPz8gZGVmYXVsdFByaW9yaXR5O1xuY29uc3QgZXh0ZW5zaW9ucyA9IHtcbiAgX2FkZEhhbmRsZXJzOiB7fSxcbiAgX3JlbW92ZUhhbmRsZXJzOiB7fSxcbiAgX3F1ZXVlOiB7fSxcbiAgcmVtb3ZlKC4uLmV4dGVuc2lvbnMyKSB7XG4gICAgZXh0ZW5zaW9uczIubWFwKG5vcm1hbGl6ZUV4dGVuc2lvbikuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICBleHQudHlwZS5mb3JFYWNoKCh0eXBlKSA9PiB0aGlzLl9yZW1vdmVIYW5kbGVyc1t0eXBlXT8uKGV4dCkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGQoLi4uZXh0ZW5zaW9uczIpIHtcbiAgICBleHRlbnNpb25zMi5tYXAobm9ybWFsaXplRXh0ZW5zaW9uKS5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgIGV4dC50eXBlLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLl9hZGRIYW5kbGVycztcbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICAgICAgaWYgKCFoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgIHF1ZXVlW3R5cGVdID0gcXVldWVbdHlwZV0gfHwgW107XG4gICAgICAgICAgcXVldWVbdHlwZV0ucHVzaChleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzW3R5cGVdKGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBoYW5kbGUodHlwZSwgb25BZGQsIG9uUmVtb3ZlKSB7XG4gICAgY29uc3QgYWRkSGFuZGxlcnMgPSB0aGlzLl9hZGRIYW5kbGVycztcbiAgICBjb25zdCByZW1vdmVIYW5kbGVycyA9IHRoaXMuX3JlbW92ZUhhbmRsZXJzO1xuICAgIGlmIChhZGRIYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVIYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHRlbnNpb24gdHlwZSAke3R5cGV9IGFscmVhZHkgaGFzIGEgaGFuZGxlcmApO1xuICAgIH1cbiAgICBhZGRIYW5kbGVyc1t0eXBlXSA9IG9uQWRkO1xuICAgIHJlbW92ZUhhbmRsZXJzW3R5cGVdID0gb25SZW1vdmU7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICBpZiAocXVldWVbdHlwZV0pIHtcbiAgICAgIHF1ZXVlW3R5cGVdLmZvckVhY2goKGV4dCkgPT4gb25BZGQoZXh0KSk7XG4gICAgICBkZWxldGUgcXVldWVbdHlwZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBoYW5kbGVCeU1hcCh0eXBlLCBtYXApIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGUodHlwZSwgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbWFwW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5yZWY7XG4gICAgfSwgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgZGVsZXRlIG1hcFtleHRlbnNpb24ubmFtZV07XG4gICAgfSk7XG4gIH0sXG4gIGhhbmRsZUJ5TGlzdCh0eXBlLCBsaXN0LCBkZWZhdWx0UHJpb3JpdHkgPSAtMSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZSh0eXBlLCAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBpZiAobGlzdC5pbmNsdWRlcyhleHRlbnNpb24ucmVmKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goZXh0ZW5zaW9uLnJlZik7XG4gICAgICBsaXN0LnNvcnQoKGEsIGIpID0+IG5vcm1hbGl6ZVByaW9yaXR5KGIsIGRlZmF1bHRQcmlvcml0eSkgLSBub3JtYWxpemVQcmlvcml0eShhLCBkZWZhdWx0UHJpb3JpdHkpKTtcbiAgICB9LCAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGxpc3QuaW5kZXhPZihleHRlbnNpb24ucmVmKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjbGFzcyBWaWV3YWJsZUJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKHNpemVPckJ1ZmZlcikge1xuICAgIGlmICh0eXBlb2Ygc2l6ZU9yQnVmZmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZU9yQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHNpemVPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlci5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgfVxuICBnZXQgaW50OFZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnQ4Vmlldykge1xuICAgICAgdGhpcy5faW50OFZpZXcgPSBuZXcgSW50OEFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnQ4VmlldztcbiAgfVxuICBnZXQgdWludDhWaWV3KCkge1xuICAgIGlmICghdGhpcy5fdWludDhWaWV3KSB7XG4gICAgICB0aGlzLl91aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdWludDhWaWV3O1xuICB9XG4gIGdldCBpbnQxNlZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnQxNlZpZXcpIHtcbiAgICAgIHRoaXMuX2ludDE2VmlldyA9IG5ldyBJbnQxNkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnQxNlZpZXc7XG4gIH1cbiAgZ2V0IHVpbnQxNlZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl91aW50MTZWaWV3KSB7XG4gICAgICB0aGlzLl91aW50MTZWaWV3ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91aW50MTZWaWV3O1xuICB9XG4gIGdldCBpbnQzMlZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnQzMlZpZXcpIHtcbiAgICAgIHRoaXMuX2ludDMyVmlldyA9IG5ldyBJbnQzMkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnQzMlZpZXc7XG4gIH1cbiAgdmlldyh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXNbYCR7dHlwZX1WaWV3YF07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBudWxsO1xuICAgIHRoaXMuX2ludDhWaWV3ID0gbnVsbDtcbiAgICB0aGlzLl91aW50OFZpZXcgPSBudWxsO1xuICAgIHRoaXMuX2ludDE2VmlldyA9IG51bGw7XG4gICAgdGhpcy5fdWludDE2VmlldyA9IG51bGw7XG4gICAgdGhpcy5faW50MzJWaWV3ID0gbnVsbDtcbiAgICB0aGlzLnVpbnQzMlZpZXcgPSBudWxsO1xuICAgIHRoaXMuZmxvYXQzMlZpZXcgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBzaXplT2YodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImludDhcIjpcbiAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgY2FzZSBcImZsb2F0MzJcIjpcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZX0gaXNuJ3QgYSB2YWxpZCB2aWV3IHR5cGVgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgVmlld2FibGVCdWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXdhYmxlQnVmZmVyLm1qcy5tYXBcbiIsImNvbnN0IGZyYWdUZW1wbGF0ZSA9IFtcbiAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIixcbiAgXCJ2b2lkIG1haW4odm9pZCl7XCIsXG4gIFwiZmxvYXQgdGVzdCA9IDAuMTtcIixcbiAgXCIlZm9ybG9vcCVcIixcbiAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7XCIsXG4gIFwifVwiXG5dLmpvaW4oXCJcXG5cIik7XG5mdW5jdGlvbiBnZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpIHtcbiAgbGV0IHNyYyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4SWZzOyArK2kpIHtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIHNyYyArPSBcIlxcbmVsc2UgXCI7XG4gICAgfVxuICAgIGlmIChpIDwgbWF4SWZzIC0gMSkge1xuICAgICAgc3JjICs9IGBpZih0ZXN0ID09ICR7aX0uMCl7fWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcmM7XG59XG5mdW5jdGlvbiBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyKG1heElmcywgZ2wpIHtcbiAgaWYgKG1heElmcyA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgb2YgYDBgIHBhc3NlZCB0byBgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcmBcIik7XG4gIH1cbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgZnJhZ21lbnRTcmMgPSBmcmFnVGVtcGxhdGUucmVwbGFjZSgvJWZvcmxvb3AlL2dpLCBnZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpKTtcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBmcmFnbWVudFNyYyk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICBtYXhJZnMgPSBtYXhJZnMgLyAyIHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXhJZnM7XG59XG5cbmV4cG9ydCB7IGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQkxFTkRfTU9ERVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuXG5jb25zdCBCTEVORCA9IDA7XG5jb25zdCBPRkZTRVQgPSAxO1xuY29uc3QgQ1VMTElORyA9IDI7XG5jb25zdCBERVBUSF9URVNUID0gMztcbmNvbnN0IFdJTkRJTkcgPSA0O1xuY29uc3QgREVQVEhfTUFTSyA9IDU7XG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGF0YSA9IDA7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmJsZW5kID0gdHJ1ZTtcbiAgICB0aGlzLmRlcHRoTWFzayA9IHRydWU7XG4gIH1cbiAgZ2V0IGJsZW5kKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IEJMRU5EKTtcbiAgfVxuICBzZXQgYmxlbmQodmFsdWUpIHtcbiAgICBpZiAoISEodGhpcy5kYXRhICYgMSA8PCBCTEVORCkgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBCTEVORDtcbiAgICB9XG4gIH1cbiAgZ2V0IG9mZnNldHMoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmIDEgPDwgT0ZGU0VUKTtcbiAgfVxuICBzZXQgb2Zmc2V0cyh2YWx1ZSkge1xuICAgIGlmICghISh0aGlzLmRhdGEgJiAxIDw8IE9GRlNFVCkgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBPRkZTRVQ7XG4gICAgfVxuICB9XG4gIGdldCBjdWxsaW5nKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IENVTExJTkcpO1xuICB9XG4gIHNldCBjdWxsaW5nKHZhbHVlKSB7XG4gICAgaWYgKCEhKHRoaXMuZGF0YSAmIDEgPDwgQ1VMTElORykgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBDVUxMSU5HO1xuICAgIH1cbiAgfVxuICBnZXQgZGVwdGhUZXN0KCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX1RFU1QpO1xuICB9XG4gIHNldCBkZXB0aFRlc3QodmFsdWUpIHtcbiAgICBpZiAoISEodGhpcy5kYXRhICYgMSA8PCBERVBUSF9URVNUKSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZGF0YSBePSAxIDw8IERFUFRIX1RFU1Q7XG4gICAgfVxuICB9XG4gIGdldCBkZXB0aE1hc2soKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmIDEgPDwgREVQVEhfTUFTSyk7XG4gIH1cbiAgc2V0IGRlcHRoTWFzayh2YWx1ZSkge1xuICAgIGlmICghISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX01BU0spICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kYXRhIF49IDEgPDwgREVQVEhfTUFTSztcbiAgICB9XG4gIH1cbiAgZ2V0IGNsb2Nrd2lzZUZyb250RmFjZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBXSU5ESU5HKTtcbiAgfVxuICBzZXQgY2xvY2t3aXNlRnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgaWYgKCEhKHRoaXMuZGF0YSAmIDEgPDwgV0lORElORykgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBXSU5ESU5HO1xuICAgIH1cbiAgfVxuICBnZXQgYmxlbmRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuYmxlbmQgPSB2YWx1ZSAhPT0gQkxFTkRfTU9ERVMuTk9ORTtcbiAgICB0aGlzLl9ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcG9seWdvbk9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9seWdvbk9mZnNldDtcbiAgfVxuICBzZXQgcG9seWdvbk9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMub2Zmc2V0cyA9ICEhdmFsdWU7XG4gICAgdGhpcy5fcG9seWdvbk9mZnNldCA9IHZhbHVlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW0BwaXhpL2NvcmU6U3RhdGUgYmxlbmRNb2RlPSR7dGhpcy5ibGVuZE1vZGV9IGNsb2Nrd2lzZUZyb250RmFjZT0ke3RoaXMuY2xvY2t3aXNlRnJvbnRGYWNlfSBjdWxsaW5nPSR7dGhpcy5jdWxsaW5nfSBkZXB0aE1hc2s9JHt0aGlzLmRlcHRoTWFza30gcG9seWdvbk9mZnNldD0ke3RoaXMucG9seWdvbk9mZnNldH1dYDtcbiAgfVxuICBzdGF0aWMgZm9yMmQoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICBzdGF0ZS5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgICBzdGF0ZS5ibGVuZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCB7IFN0YXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZS5tanMubWFwXG4iLCJjb25zdCBJTlNUQUxMRUQgPSBbXTtcbmZ1bmN0aW9uIGF1dG9EZXRlY3RSZXNvdXJjZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgZXh0ZW5zaW9uID0gXCJcIjtcbiAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvXFwuKFxcd3szLDR9KSg/OiR8XFw/fCMpL2kuZXhlYyhzb3VyY2UpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGV4dGVuc2lvbiA9IHJlc3VsdFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gSU5TVEFMTEVELmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgUmVzb3VyY2VQbHVnaW4gPSBJTlNUQUxMRURbaV07XG4gICAgaWYgKFJlc291cmNlUGx1Z2luLnRlc3QgJiYgUmVzb3VyY2VQbHVnaW4udGVzdChzb3VyY2UsIGV4dGVuc2lvbikpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQbHVnaW4oc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHNvdXJjZSB0eXBlIHRvIGF1dG8tZGV0ZWN0IFJlc291cmNlXCIpO1xufVxuXG5leHBvcnQgeyBJTlNUQUxMRUQsIGF1dG9EZXRlY3RSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b0RldGVjdFJlc291cmNlLm1qcy5tYXBcbiIsImNsYXNzIFJ1bm5lciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLml0ZW1zID0gW107XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fYWxpYXNDb3VudCA9IDA7XG4gIH1cbiAgZW1pdChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1heCBhcmd1bWVudHMgcmVhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBuYW1lLCBpdGVtcyB9ID0gdGhpcztcbiAgICB0aGlzLl9hbGlhc0NvdW50Kys7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtc1tpXVtuYW1lXShhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IHRoaXMuaXRlbXMpIHtcbiAgICAgIHRoaXMuX2FsaWFzQ291bnQtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5zdXJlTm9uQWxpYXNlZEl0ZW1zKCkge1xuICAgIGlmICh0aGlzLl9hbGlhc0NvdW50ID4gMCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX2FsaWFzQ291bnQgPSAwO1xuICAgICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCk7XG4gICAgfVxuICB9XG4gIGFkZChpdGVtKSB7XG4gICAgaWYgKGl0ZW1bdGhpcy5fbmFtZV0pIHtcbiAgICAgIHRoaXMuZW5zdXJlTm9uQWxpYXNlZEl0ZW1zKCk7XG4gICAgICB0aGlzLnJlbW92ZShpdGVtKTtcbiAgICAgIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmVuc3VyZU5vbkFsaWFzZWRJdGVtcygpO1xuICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb250YWlucyhpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuaW5jbHVkZXMoaXRlbSk7XG4gIH1cbiAgcmVtb3ZlQWxsKCkge1xuICAgIHRoaXMuZW5zdXJlTm9uQWxpYXNlZEl0ZW1zKCk7XG4gICAgdGhpcy5pdGVtcy5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLml0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9uYW1lID0gbnVsbDtcbiAgfVxuICBnZXQgZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID09PSAwO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSdW5uZXIucHJvdG90eXBlLCB7XG4gIGRpc3BhdGNoOiB7IHZhbHVlOiBSdW5uZXIucHJvdG90eXBlLmVtaXQgfSxcbiAgcnVuOiB7IHZhbHVlOiBSdW5uZXIucHJvdG90eXBlLmVtaXQgfVxufSk7XG5cbmV4cG9ydCB7IFJ1bm5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UnVubmVyLm1qcy5tYXBcbiIsImV4cG9ydCB7IFJ1bm5lciB9IGZyb20gJy4vUnVubmVyLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBSdW5uZXIgfSBmcm9tICdAcGl4aS9ydW5uZXInO1xuXG5jbGFzcyBSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcm5hbCA9IGZhbHNlO1xuICAgIHRoaXMub25SZXNpemUgPSBuZXcgUnVubmVyKFwic2V0UmVhbFNpemVcIik7XG4gICAgdGhpcy5vblVwZGF0ZSA9IG5ldyBSdW5uZXIoXCJ1cGRhdGVcIik7XG4gICAgdGhpcy5vbkVycm9yID0gbmV3IFJ1bm5lcihcIm9uRXJyb3JcIik7XG4gIH1cbiAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgIHRoaXMub25SZXNpemUuYWRkKGJhc2VUZXh0dXJlKTtcbiAgICB0aGlzLm9uVXBkYXRlLmFkZChiYXNlVGV4dHVyZSk7XG4gICAgdGhpcy5vbkVycm9yLmFkZChiYXNlVGV4dHVyZSk7XG4gICAgaWYgKHRoaXMuX3dpZHRoIHx8IHRoaXMuX2hlaWdodCkge1xuICAgICAgdGhpcy5vblJlc2l6ZS5lbWl0KHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIH1cbiAgfVxuICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICB0aGlzLm9uUmVzaXplLnJlbW92ZShiYXNlVGV4dHVyZSk7XG4gICAgdGhpcy5vblVwZGF0ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xuICAgIHRoaXMub25FcnJvci5yZW1vdmUoYmFzZVRleHR1cmUpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLl93aWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuX2hlaWdodCkge1xuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMub25SZXNpemUuZW1pdCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3dpZHRoICYmICEhdGhpcy5faGVpZ2h0O1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlLmVtaXQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZCgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9XG4gIHN0eWxlKF9yZW5kZXJlciwgX2Jhc2VUZXh0dXJlLCBfZ2xUZXh0dXJlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMub25FcnJvci5yZW1vdmVBbGwoKTtcbiAgICAgIHRoaXMub25FcnJvciA9IG51bGw7XG4gICAgICB0aGlzLm9uUmVzaXplLnJlbW92ZUFsbCgpO1xuICAgICAgdGhpcy5vblJlc2l6ZSA9IG51bGw7XG4gICAgICB0aGlzLm9uVXBkYXRlLnJlbW92ZUFsbCgpO1xuICAgICAgdGhpcy5vblVwZGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB0ZXN0KF9zb3VyY2UsIF9leHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IEFMUEhBX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSAnLi9SZXNvdXJjZS5tanMnO1xuXG5jbGFzcyBCdWZmZXJSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyUmVzb3VyY2Ugd2lkdGggb3IgaGVpZ2h0IGludmFsaWRcIik7XG4gICAgfVxuICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuZGF0YSA9IHNvdXJjZTtcbiAgfVxuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUuYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5VTlBBQ0spO1xuICAgIGNvbnN0IHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQ7XG4gICAgaWYgKGdsVGV4dHVyZS53aWR0aCA9PT0gd2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50MzJBcnJheTtcbiAgfVxufVxuXG5leHBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgU0NBTEVfTU9ERVMsIEZPUk1BVFMsIEFMUEhBX01PREVTLCBUWVBFUywgTUlQTUFQX01PREVTLCBXUkFQX01PREVTLCBUQVJHRVRTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCB1aWQsIGlzUG93MiwgQmFzZVRleHR1cmVDYWNoZSwgVGV4dHVyZUNhY2hlIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgYXV0b0RldGVjdFJlc291cmNlIH0gZnJvbSAnLi9yZXNvdXJjZXMvYXV0b0RldGVjdFJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9IGZyb20gJy4vcmVzb3VyY2VzL0J1ZmZlclJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4vcmVzb3VyY2VzL1Jlc291cmNlLm1qcyc7XG5cbmNvbnN0IGRlZmF1bHRCdWZmZXJPcHRpb25zID0ge1xuICBzY2FsZU1vZGU6IFNDQUxFX01PREVTLk5FQVJFU1QsXG4gIGZvcm1hdDogRk9STUFUUy5SR0JBLFxuICBhbHBoYU1vZGU6IEFMUEhBX01PREVTLk5QTVxufTtcbmNvbnN0IF9CYXNlVGV4dHVyZSA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IocmVzb3VyY2UgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xuICAgIHN1cGVyKCk7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIF9CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgYWxwaGFNb2RlLFxuICAgICAgbWlwbWFwLFxuICAgICAgYW5pc290cm9waWNMZXZlbCxcbiAgICAgIHNjYWxlTW9kZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgd3JhcE1vZGUsXG4gICAgICBmb3JtYXQsXG4gICAgICB0eXBlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHJlc291cmNlT3B0aW9uc1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmIChyZXNvdXJjZSAmJiAhKHJlc291cmNlIGluc3RhbmNlb2YgUmVzb3VyY2UpKSB7XG4gICAgICByZXNvdXJjZSA9IGF1dG9EZXRlY3RSZXNvdXJjZShyZXNvdXJjZSwgcmVzb3VyY2VPcHRpb25zKTtcbiAgICAgIHJlc291cmNlLmludGVybmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLnJvdW5kKCh3aWR0aCB8fCAwKSAqIHRoaXMucmVzb2x1dGlvbikgLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLnJvdW5kKChoZWlnaHQgfHwgMCkgKiB0aGlzLnJlc29sdXRpb24pIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuX21pcG1hcCA9IG1pcG1hcDtcbiAgICB0aGlzLmFuaXNvdHJvcGljTGV2ZWwgPSBhbmlzb3Ryb3BpY0xldmVsO1xuICAgIHRoaXMuX3dyYXBNb2RlID0gd3JhcE1vZGU7XG4gICAgdGhpcy5fc2NhbGVNb2RlID0gc2NhbGVNb2RlO1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5hbHBoYU1vZGUgPSBhbHBoYU1vZGU7XG4gICAgdGhpcy51aWQgPSB1aWQoKTtcbiAgICB0aGlzLnRvdWNoZWQgPSAwO1xuICAgIHRoaXMuaXNQb3dlck9mVHdvID0gZmFsc2U7XG4gICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICAgIHRoaXMuX2dsVGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLmRpcnR5SWQgPSAwO1xuICAgIHRoaXMuZGlydHlTdHlsZUlkID0gMDtcbiAgICB0aGlzLmNhY2hlSWQgPSBudWxsO1xuICAgIHRoaXMudmFsaWQgPSB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMDtcbiAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IFtdO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5yZXNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fYmF0Y2hFbmFibGVkID0gMDtcbiAgICB0aGlzLl9iYXRjaExvY2F0aW9uID0gMDtcbiAgICB0aGlzLnBhcmVudFRleHR1cmVBcnJheSA9IG51bGw7XG4gICAgdGhpcy5zZXRSZXNvdXJjZShyZXNvdXJjZSk7XG4gIH1cbiAgZ2V0IHJlYWxXaWR0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogdGhpcy5yZXNvbHV0aW9uKTtcbiAgfVxuICBnZXQgcmVhbEhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gIH1cbiAgZ2V0IG1pcG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWlwbWFwO1xuICB9XG4gIHNldCBtaXBtYXAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fbWlwbWFwICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fbWlwbWFwID0gdmFsdWU7XG4gICAgICB0aGlzLmRpcnR5U3R5bGVJZCsrO1xuICAgIH1cbiAgfVxuICBnZXQgc2NhbGVNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2FsZU1vZGU7XG4gIH1cbiAgc2V0IHNjYWxlTW9kZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zY2FsZU1vZGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9zY2FsZU1vZGUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XG4gICAgfVxuICB9XG4gIGdldCB3cmFwTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcE1vZGU7XG4gIH1cbiAgc2V0IHdyYXBNb2RlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3dyYXBNb2RlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fd3JhcE1vZGUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKHNjYWxlTW9kZSwgbWlwbWFwKSB7XG4gICAgbGV0IGRpcnR5O1xuICAgIGlmIChzY2FsZU1vZGUgIT09IHZvaWQgMCAmJiBzY2FsZU1vZGUgIT09IHRoaXMuc2NhbGVNb2RlKSB7XG4gICAgICB0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZTtcbiAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1pcG1hcCAhPT0gdm9pZCAwICYmIG1pcG1hcCAhPT0gdGhpcy5taXBtYXApIHtcbiAgICAgIHRoaXMubWlwbWFwID0gbWlwbWFwO1xuICAgICAgZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGlydHkpIHtcbiAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFNpemUoZGVzaXJlZFdpZHRoLCBkZXNpcmVkSGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJldHVybiB0aGlzLnNldFJlYWxTaXplKGRlc2lyZWRXaWR0aCAqIHJlc29sdXRpb24sIGRlc2lyZWRIZWlnaHQgKiByZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgfVxuICBzZXRSZWFsU2l6ZShyZWFsV2lkdGgsIHJlYWxIZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5yb3VuZChyZWFsV2lkdGgpIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5yb3VuZChyZWFsSGVpZ2h0KSAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfcmVmcmVzaFBPVCgpIHtcbiAgICB0aGlzLmlzUG93ZXJPZlR3byA9IGlzUG93Mih0aGlzLnJlYWxXaWR0aCkgJiYgaXNQb3cyKHRoaXMucmVhbEhlaWdodCk7XG4gIH1cbiAgc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKSB7XG4gICAgY29uc3Qgb2xkUmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICBpZiAob2xkUmVzb2x1dGlvbiA9PT0gcmVzb2x1dGlvbikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgaWYgKHRoaXMudmFsaWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiBvbGRSZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgICB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBvbGRSZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRSZXNvdXJjZShyZXNvdXJjZSkge1xuICAgIGlmICh0aGlzLnJlc291cmNlID09PSByZXNvdXJjZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNvdXJjZSBjYW4gYmUgc2V0IG9ubHkgb25jZVwiKTtcbiAgICB9XG4gICAgcmVzb3VyY2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgaWYgKHRoaXMud2lkdGggPiAwICYmIHRoaXMuaGVpZ2h0ID4gMCkge1xuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwibG9hZGVkXCIsIHRoaXMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlydHlJZCsrO1xuICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQrKztcbiAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25FcnJvcihldmVudCkge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHRoaXMsIGV2ZW50KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnJlc291cmNlKSB7XG4gICAgICB0aGlzLnJlc291cmNlLnVuYmluZCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLnJlc291cmNlLmludGVybmFsKSB7XG4gICAgICAgIHRoaXMucmVzb3VyY2UuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNvdXJjZSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhY2hlSWQpIHtcbiAgICAgIGRlbGV0ZSBCYXNlVGV4dHVyZUNhY2hlW3RoaXMuY2FjaGVJZF07XG4gICAgICBkZWxldGUgVGV4dHVyZUNhY2hlW3RoaXMuY2FjaGVJZF07XG4gICAgICB0aGlzLmNhY2hlSWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICBfQmFzZVRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMpO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmVtaXQoXCJkaXNwb3NlXCIsIHRoaXMpO1xuICB9XG4gIGNhc3RUb0Jhc2VUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucywgc3RyaWN0ID0gc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEUpIHtcbiAgICBjb25zdCBpc0ZyYW1lID0gdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIjtcbiAgICBsZXQgY2FjaGVJZCA9IG51bGw7XG4gICAgaWYgKGlzRnJhbWUpIHtcbiAgICAgIGNhY2hlSWQgPSBzb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc291cmNlLl9waXhpSWQpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gb3B0aW9ucz8ucGl4aUlkUHJlZml4IHx8IFwicGl4aWlkXCI7XG4gICAgICAgIHNvdXJjZS5fcGl4aUlkID0gYCR7cHJlZml4fV8ke3VpZCgpfWA7XG4gICAgICB9XG4gICAgICBjYWNoZUlkID0gc291cmNlLl9waXhpSWQ7XG4gICAgfVxuICAgIGxldCBiYXNlVGV4dHVyZSA9IEJhc2VUZXh0dXJlQ2FjaGVbY2FjaGVJZF07XG4gICAgaWYgKGlzRnJhbWUgJiYgc3RyaWN0ICYmICFiYXNlVGV4dHVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY2FjaGVJZCBcIiR7Y2FjaGVJZH1cIiBkb2VzIG5vdCBleGlzdCBpbiBCYXNlVGV4dHVyZUNhY2hlLmApO1xuICAgIH1cbiAgICBpZiAoIWJhc2VUZXh0dXJlKSB7XG4gICAgICBiYXNlVGV4dHVyZSA9IG5ldyBfQmFzZVRleHR1cmUoc291cmNlLCBvcHRpb25zKTtcbiAgICAgIGJhc2VUZXh0dXJlLmNhY2hlSWQgPSBjYWNoZUlkO1xuICAgICAgX0Jhc2VUZXh0dXJlLmFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGNhY2hlSWQpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVRleHR1cmU7XG4gIH1cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBCdWZmZXJSZXNvdXJjZShidWZmZXIsIHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICBjb25zdCB0eXBlID0gYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gVFlQRVMuRkxPQVQgOiBUWVBFUy5VTlNJR05FRF9CWVRFO1xuICAgIHJldHVybiBuZXcgX0Jhc2VUZXh0dXJlKHJlc291cmNlLCBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0QnVmZmVyT3B0aW9ucywgb3B0aW9ucyB8fCB7IHdpZHRoLCBoZWlnaHQsIHR5cGUgfSkpO1xuICB9XG4gIHN0YXRpYyBhZGRUb0NhY2hlKGJhc2VUZXh0dXJlLCBpZCkge1xuICAgIGlmIChpZCkge1xuICAgICAgaWYgKCFiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgIGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICAgIGlmIChCYXNlVGV4dHVyZUNhY2hlW2lkXSAmJiBCYXNlVGV4dHVyZUNhY2hlW2lkXSAhPT0gYmFzZVRleHR1cmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBCYXNlVGV4dHVyZSBhZGRlZCB0byB0aGUgY2FjaGUgd2l0aCBhbiBpZCBbJHtpZH1dIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlgKTtcbiAgICAgIH1cbiAgICAgIEJhc2VUZXh0dXJlQ2FjaGVbaWRdID0gYmFzZVRleHR1cmU7XG4gICAgfVxuICB9XG4gIHN0YXRpYyByZW1vdmVGcm9tQ2FjaGUoYmFzZVRleHR1cmUpIHtcbiAgICBpZiAodHlwZW9mIGJhc2VUZXh0dXJlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBiYXNlVGV4dHVyZUZyb21DYWNoZSA9IEJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVdO1xuICAgICAgaWYgKGJhc2VUZXh0dXJlRnJvbUNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYmFzZVRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoYmFzZVRleHR1cmUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIGJhc2VUZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBCYXNlVGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlXTtcbiAgICAgICAgcmV0dXJuIGJhc2VUZXh0dXJlRnJvbUNhY2hlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYmFzZVRleHR1cmU/LnRleHR1cmVDYWNoZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIEJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgIH1cbiAgICAgIGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwO1xuICAgICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbmxldCBCYXNlVGV4dHVyZSA9IF9CYXNlVGV4dHVyZTtcbkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zID0ge1xuICBtaXBtYXA6IE1JUE1BUF9NT0RFUy5QT1cyLFxuICBhbmlzb3Ryb3BpY0xldmVsOiAwLFxuICBzY2FsZU1vZGU6IFNDQUxFX01PREVTLkxJTkVBUixcbiAgd3JhcE1vZGU6IFdSQVBfTU9ERVMuQ0xBTVAsXG4gIGFscGhhTW9kZTogQUxQSEFfTU9ERVMuVU5QQUNLLFxuICB0YXJnZXQ6IFRBUkdFVFMuVEVYVFVSRV8yRCxcbiAgZm9ybWF0OiBGT1JNQVRTLlJHQkEsXG4gIHR5cGU6IFRZUEVTLlVOU0lHTkVEX0JZVEVcbn07XG5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2ggPSAwO1xuXG5leHBvcnQgeyBCYXNlVGV4dHVyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRFJBV19NT0RFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5cbmNsYXNzIEJhdGNoRHJhd0NhbGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRleEFycmF5ID0gbnVsbDtcbiAgICB0aGlzLmJsZW5kID0gMDtcbiAgICB0aGlzLnR5cGUgPSBEUkFXX01PREVTLlRSSUFOR0xFUztcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hEcmF3Q2FsbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hEcmF3Q2FsbC5tanMubWFwXG4iLCJpbXBvcnQgeyBCVUZGRVJfVFlQRSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBSdW5uZXIgfSBmcm9tICdAcGl4aS9ydW5uZXInO1xuXG5sZXQgVUlEID0gMDtcbmNsYXNzIEJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIF9zdGF0aWMgPSB0cnVlLCBpbmRleCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICAgIHRoaXMuX2dsQnVmZmVycyA9IHt9O1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5zdGF0aWMgPSBfc3RhdGljO1xuICAgIHRoaXMuaWQgPSBVSUQrKztcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKFwiZGlzcG9zZUJ1ZmZlclwiKTtcbiAgfVxuICB1cGRhdGUoZGF0YSkge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHRoaXMuZGF0YTtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcywgZmFsc2UpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxuICBzZXQgaW5kZXgodmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZSA/IEJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogQlVGRkVSX1RZUEUuQVJSQVlfQlVGRkVSO1xuICB9XG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBCVUZGRVJfVFlQRS5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgfVxuICBzdGF0aWMgZnJvbShkYXRhKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJ1ZmZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IFRZUEVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcblxuY2xhc3MgQXR0cmlidXRlIHtcbiAgY29uc3RydWN0b3IoYnVmZmVyLCBzaXplID0gMCwgbm9ybWFsaXplZCA9IGZhbHNlLCB0eXBlID0gVFlQRVMuRkxPQVQsIHN0cmlkZSwgc3RhcnQsIGluc3RhbmNlLCBkaXZpc29yID0gMSkge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgdGhpcy5kaXZpc29yID0gZGl2aXNvcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgZnJvbShidWZmZXIsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUsIHN0cmlkZSkge1xuICAgIHJldHVybiBuZXcgQXR0cmlidXRlKGJ1ZmZlciwgc2l6ZSwgbm9ybWFsaXplZCwgdHlwZSwgc3RyaWRlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBBdHRyaWJ1dGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0ZS5tanMubWFwXG4iLCJpbXBvcnQgeyBnZXRCdWZmZXJUeXBlIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuXG5jb25zdCBtYXAgPSB7XG4gIEZsb2F0MzJBcnJheSxcbiAgVWludDMyQXJyYXksXG4gIEludDMyQXJyYXksXG4gIFVpbnQ4QXJyYXlcbn07XG5mdW5jdGlvbiBpbnRlcmxlYXZlVHlwZWRBcnJheXMoYXJyYXlzLCBzaXplcykge1xuICBsZXQgb3V0U2l6ZSA9IDA7XG4gIGxldCBzdHJpZGUgPSAwO1xuICBjb25zdCB2aWV3cyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIHN0cmlkZSArPSBzaXplc1tpXTtcbiAgICBvdXRTaXplICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG91dFNpemUgKiA0KTtcbiAgbGV0IG91dCA9IG51bGw7XG4gIGxldCBsaXR0bGVPZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNpemUgPSBzaXplc1tpXTtcbiAgICBjb25zdCBhcnJheSA9IGFycmF5c1tpXTtcbiAgICBjb25zdCB0eXBlID0gZ2V0QnVmZmVyVHlwZShhcnJheSk7XG4gICAgaWYgKCF2aWV3c1t0eXBlXSkge1xuICAgICAgdmlld3NbdHlwZV0gPSBuZXcgbWFwW3R5cGVdKGJ1ZmZlcik7XG4gICAgfVxuICAgIG91dCA9IHZpZXdzW3R5cGVdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSAoaiAvIHNpemUgfCAwKSAqIHN0cmlkZSArIGxpdHRsZU9mZnNldDtcbiAgICAgIGNvbnN0IGluZGV4ID0gaiAlIHNpemU7XG4gICAgICBvdXRbaW5kZXhTdGFydCArIGluZGV4XSA9IGFycmF5W2pdO1xuICAgIH1cbiAgICBsaXR0bGVPZmZzZXQgKz0gc2l6ZTtcbiAgfVxuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xufVxuXG5leHBvcnQgeyBpbnRlcmxlYXZlVHlwZWRBcnJheXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybGVhdmVUeXBlZEFycmF5cy5tanMubWFwXG4iLCJpbXBvcnQgeyBCVUZGRVJfVFlQRSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBSdW5uZXIgfSBmcm9tICdAcGl4aS9ydW5uZXInO1xuaW1wb3J0IHsgZ2V0QnVmZmVyVHlwZSB9IGZyb20gJ0BwaXhpL3V0aWxzJztcbmltcG9ydCB7IEF0dHJpYnV0ZSB9IGZyb20gJy4vQXR0cmlidXRlLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuL0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgaW50ZXJsZWF2ZVR5cGVkQXJyYXlzIH0gZnJvbSAnLi91dGlscy9pbnRlcmxlYXZlVHlwZWRBcnJheXMubWpzJztcblxuY29uc3QgYnl0ZVNpemVNYXAgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcbmxldCBVSUQgPSAwO1xuY29uc3QgbWFwID0ge1xuICBGbG9hdDMyQXJyYXksXG4gIFVpbnQzMkFycmF5LFxuICBJbnQzMkFycmF5LFxuICBVaW50OEFycmF5LFxuICBVaW50MTZBcnJheVxufTtcbmNsYXNzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoYnVmZmVycyA9IFtdLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5nbFZlcnRleEFycmF5T2JqZWN0cyA9IHt9O1xuICAgIHRoaXMuaWQgPSBVSUQrKztcbiAgICB0aGlzLmluc3RhbmNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IDE7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcihcImRpc3Bvc2VHZW9tZXRyeVwiKTtcbiAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgfVxuICBhZGRBdHRyaWJ1dGUoaWQsIGJ1ZmZlciwgc2l6ZSA9IDAsIG5vcm1hbGl6ZWQgPSBmYWxzZSwgdHlwZSwgc3RyaWRlLCBzdGFydCwgaW5zdGFuY2UgPSBmYWxzZSkge1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgYnVmZmVyIHdoZW4gY3JlYXRpbmcgYW4gYXR0cmlidXRlXCIpO1xuICAgIH1cbiAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgfVxuICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIpO1xuICAgIH1cbiAgICBjb25zdCBpZHMgPSBpZC5zcGxpdChcInxcIik7XG4gICAgaWYgKGlkcy5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShpZHNbaV0sIGJ1ZmZlciwgc2l6ZSwgbm9ybWFsaXplZCwgdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGV0IGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYnVmZmVyKTtcbiAgICBpZiAoYnVmZmVySW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgYnVmZmVySW5kZXggPSB0aGlzLmJ1ZmZlcnMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2lkXSA9IG5ldyBBdHRyaWJ1dGUoYnVmZmVySW5kZXgsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUsIHN0cmlkZSwgc3RhcnQsIGluc3RhbmNlKTtcbiAgICB0aGlzLmluc3RhbmNlZCA9IHRoaXMuaW5zdGFuY2VkIHx8IGluc3RhbmNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldEF0dHJpYnV0ZShpZCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbaWRdO1xuICB9XG4gIGdldEJ1ZmZlcihpZCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbdGhpcy5nZXRBdHRyaWJ1dGUoaWQpLmJ1ZmZlcl07XG4gIH1cbiAgYWRkSW5kZXgoYnVmZmVyKSB7XG4gICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICAgICAgfVxuICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIpO1xuICAgIH1cbiAgICBidWZmZXIudHlwZSA9IEJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBidWZmZXI7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlcnMuaW5jbHVkZXMoYnVmZmVyKSkge1xuICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXI7XG4gIH1cbiAgaW50ZXJsZWF2ZSgpIHtcbiAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMSB8fCB0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSAyICYmIHRoaXMuaW5kZXhCdWZmZXIpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBhcnJheXMgPSBbXTtcbiAgICBjb25zdCBzaXplcyA9IFtdO1xuICAgIGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEJ1ZmZlcigpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tpXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1thdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgIGFycmF5cy5wdXNoKGJ1ZmZlci5kYXRhKTtcbiAgICAgIHNpemVzLnB1c2goYXR0cmlidXRlLnNpemUgKiBieXRlU2l6ZU1hcFthdHRyaWJ1dGUudHlwZV0gLyA0KTtcbiAgICAgIGF0dHJpYnV0ZS5idWZmZXIgPSAwO1xuICAgIH1cbiAgICBpbnRlcmxlYXZlZEJ1ZmZlci5kYXRhID0gaW50ZXJsZWF2ZVR5cGVkQXJyYXlzKGFycmF5cywgc2l6ZXMpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcnNbaV0gIT09IHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5idWZmZXJzID0gW2ludGVybGVhdmVkQnVmZmVyXTtcbiAgICBpZiAodGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXJzLnB1c2godGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFNpemUoKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgcmV0dXJuIGJ1ZmZlci5kYXRhLmxlbmd0aCAvIChhdHRyaWJ1dGUuc3RyaWRlIC8gNCB8fCBhdHRyaWJ1dGUuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcywgZmFsc2UpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5idWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5LmJ1ZmZlcnNbaV0gPSBuZXcgQnVmZmVyKHRoaXMuYnVmZmVyc1tpXS5kYXRhLnNsaWNlKDApKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmliID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlc1tpXSA9IG5ldyBBdHRyaWJ1dGUoYXR0cmliLmJ1ZmZlciwgYXR0cmliLnNpemUsIGF0dHJpYi5ub3JtYWxpemVkLCBhdHRyaWIudHlwZSwgYXR0cmliLnN0cmlkZSwgYXR0cmliLnN0YXJ0LCBhdHRyaWIuaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgZ2VvbWV0cnkuaW5kZXhCdWZmZXIgPSBnZW9tZXRyeS5idWZmZXJzW3RoaXMuYnVmZmVycy5pbmRleE9mKHRoaXMuaW5kZXhCdWZmZXIpXTtcbiAgICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyLnR5cGUgPSBCVUZGRVJfVFlQRS5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIHN0YXRpYyBtZXJnZShnZW9tZXRyaWVzKSB7XG4gICAgY29uc3QgZ2VvbWV0cnlPdXQgPSBuZXcgR2VvbWV0cnkoKTtcbiAgICBjb25zdCBhcnJheXMgPSBbXTtcbiAgICBjb25zdCBzaXplcyA9IFtdO1xuICAgIGNvbnN0IG9mZnNldHMgPSBbXTtcbiAgICBsZXQgZ2VvbWV0cnk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2l6ZXNbal0gPSBzaXplc1tqXSB8fCAwO1xuICAgICAgICBzaXplc1tqXSArPSBnZW9tZXRyeS5idWZmZXJzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgICBvZmZzZXRzW2pdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheXNbaV0gPSBuZXcgbWFwW2dldEJ1ZmZlclR5cGUoZ2VvbWV0cnkuYnVmZmVyc1tpXS5kYXRhKV0oc2l6ZXNbaV0pO1xuICAgICAgZ2VvbWV0cnlPdXQuYnVmZmVyc1tpXSA9IG5ldyBCdWZmZXIoYXJyYXlzW2ldKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgYXJyYXlzW2pdLnNldChnZW9tZXRyeS5idWZmZXJzW2pdLmRhdGEsIG9mZnNldHNbal0pO1xuICAgICAgICBvZmZzZXRzW2pdICs9IGdlb21ldHJ5LmJ1ZmZlcnNbal0uZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGdlb21ldHJ5T3V0LmF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIgPSBnZW9tZXRyeU91dC5idWZmZXJzW2dlb21ldHJ5LmJ1ZmZlcnMuaW5kZXhPZihnZW9tZXRyeS5pbmRleEJ1ZmZlcildO1xuICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIudHlwZSA9IEJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBsZXQgc3RyaWRlID0gMDtcbiAgICAgIGxldCBvZmZzZXQyID0gMDtcbiAgICAgIGxldCBidWZmZXJJbmRleFRvQ291bnQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChnZW9tZXRyeS5idWZmZXJzW2ldICE9PSBnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlckluZGV4VG9Db3VudCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIGlmICgoYXR0cmlidXRlLmJ1ZmZlciB8IDApID09PSBidWZmZXJJbmRleFRvQ291bnQpIHtcbiAgICAgICAgICBzdHJpZGUgKz0gYXR0cmlidXRlLnNpemUgKiBieXRlU2l6ZU1hcFthdHRyaWJ1dGUudHlwZV0gLyA0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXJEYXRhID0gZ2VvbWV0cmllc1tpXS5pbmRleEJ1ZmZlci5kYXRhO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGV4QnVmZmVyRGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGdlb21ldHJ5T3V0LmluZGV4QnVmZmVyLmRhdGFbaiArIG9mZnNldDJdICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gZ2VvbWV0cmllc1tpXS5idWZmZXJzW2J1ZmZlckluZGV4VG9Db3VudF0uZGF0YS5sZW5ndGggLyBzdHJpZGU7XG4gICAgICAgIG9mZnNldDIgKz0gaW5kZXhCdWZmZXJEYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5T3V0O1xuICB9XG59XG5cbmV4cG9ydCB7IEdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW9tZXRyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBUWVBFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi9nZW9tZXRyeS9CdWZmZXIubWpzJztcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi4vZ2VvbWV0cnkvR2VvbWV0cnkubWpzJztcblxuY2xhc3MgQmF0Y2hHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoX3N0YXRpYyA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyKG51bGwsIF9zdGF0aWMsIGZhbHNlKTtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIobnVsbCwgX3N0YXRpYywgdHJ1ZSk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhVmVydGV4UG9zaXRpb25cIiwgdGhpcy5fYnVmZmVyLCAyLCBmYWxzZSwgVFlQRVMuRkxPQVQpLmFkZEF0dHJpYnV0ZShcImFUZXh0dXJlQ29vcmRcIiwgdGhpcy5fYnVmZmVyLCAyLCBmYWxzZSwgVFlQRVMuRkxPQVQpLmFkZEF0dHJpYnV0ZShcImFDb2xvclwiLCB0aGlzLl9idWZmZXIsIDQsIHRydWUsIFRZUEVTLlVOU0lHTkVEX0JZVEUpLmFkZEF0dHJpYnV0ZShcImFUZXh0dXJlSWRcIiwgdGhpcy5fYnVmZmVyLCAxLCB0cnVlLCBUWVBFUy5GTE9BVCkuYWRkSW5kZXgodGhpcy5faW5kZXhCdWZmZXIpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoR2VvbWV0cnkubWpzLm1hcFxuIiwidmFyIGRlZmF1bHRGcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgIGdsX0ZyYWdDb2xvciAqPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbn1cIjtcblxuZXhwb3J0IHsgZGVmYXVsdEZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRQcm9ncmFtLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxufVxcblwiO1xuXG5leHBvcnQgeyBkZWZhdWx0VmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRQcm9ncmFtMi5tanMubWFwXG4iLCJjb25zdCB1bmlmb3JtUGFyc2VycyA9IFtcbiAge1xuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwiZmxvYXRcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgaWYodXZbXCIke25hbWV9XCJdICE9PSB1ZFtcIiR7bmFtZX1cIl0udmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdWRbXCIke25hbWV9XCJdLnZhbHVlID0gdXZbXCIke25hbWV9XCJdXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdXZbXCIke25hbWV9XCJdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IChkYXRhLnR5cGUgPT09IFwic2FtcGxlcjJEXCIgfHwgZGF0YS50eXBlID09PSBcInNhbXBsZXJDdWJlXCIgfHwgZGF0YS50eXBlID09PSBcInNhbXBsZXIyREFycmF5XCIpICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmICh1bmlmb3JtID09IG51bGwgfHwgdW5pZm9ybS5jYXN0VG9CYXNlVGV4dHVyZSAhPT0gdm9pZCAwKSxcbiAgICBjb2RlOiAobmFtZSkgPT4gYHQgPSBzeW5jRGF0YS50ZXh0dXJlQ291bnQrKztcblxuICAgICAgICAgICAgcmVuZGVyZXIudGV4dHVyZS5iaW5kKHV2W1wiJHtuYW1lfVwiXSwgdCk7XG5cbiAgICAgICAgICAgIGlmKHVkW1wiJHtuYW1lfVwiXS52YWx1ZSAhPT0gdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1ZFtcIiR7bmFtZX1cIl0udmFsdWUgPSB0O1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHQpO1xuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgICAgICAgICAgIH1gXG4gIH0sXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gZGF0YS50eXBlID09PSBcIm1hdDNcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiB1bmlmb3JtLmEgIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIGZhbHNlLCB1dltcIiR7bmFtZX1cIl0udG9BcnJheSh0cnVlKSk7XG4gICAgICAgICAgICBgLFxuICAgIGNvZGVVYm86IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgdmFyICR7bmFtZX1fbWF0cml4ID0gdXYuJHtuYW1lfS50b0FycmF5KHRydWUpO1xuXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gJHtuYW1lfV9tYXRyaXhbMF07XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSAke25hbWV9X21hdHJpeFsxXTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9ICR7bmFtZX1fbWF0cml4WzJdO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDRdID0gJHtuYW1lfV9tYXRyaXhbM107XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA1XSA9ICR7bmFtZX1fbWF0cml4WzRdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgNl0gPSAke25hbWV9X21hdHJpeFs1XTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA4XSA9ICR7bmFtZX1fbWF0cml4WzZdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOV0gPSAke25hbWV9X21hdHJpeFs3XTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDEwXSA9ICR7bmFtZX1fbWF0cml4WzhdO1xuICAgICAgICAgICAgYFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWMyXCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgJiYgdW5pZm9ybS54ICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYueCB8fCBjdlsxXSAhPT0gdi55KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi55O1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB2LngsIHYueSk7XG4gICAgICAgICAgICAgICAgfWAsXG4gICAgY29kZVVibzogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcblxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHYueDtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsxXSA9IHYueTtcbiAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjMlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5LFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjNFwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0ud2lkdGggIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIGN2ID0gdWRbXCIke25hbWV9XCJdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1dltcIiR7bmFtZX1cIl07XG5cbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi54IHx8IGN2WzFdICE9PSB2LnkgfHwgY3ZbMl0gIT09IHYud2lkdGggfHwgY3ZbM10gIT09IHYuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi55O1xuICAgICAgICAgICAgICAgICAgICBjdlsyXSA9IHYud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGN2WzNdID0gdi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHYueCwgdi55LCB2LndpZHRoLCB2LmhlaWdodClcbiAgICAgICAgICAgICAgICB9YCxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdi55O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9IHYud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzNdID0gdi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWM0XCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgJiYgdW5pZm9ybS5yZWQgIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIGN2ID0gdWRbXCIke25hbWV9XCJdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1dltcIiR7bmFtZX1cIl07XG5cbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi5yZWQgfHwgY3ZbMV0gIT09IHYuZ3JlZW4gfHwgY3ZbMl0gIT09IHYuYmx1ZSB8fCBjdlszXSAhPT0gdi5hbHBoYSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICAgICAgICAgIGN2WzNdID0gdi5hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdi5yZWQsIHYuZ3JlZW4sIHYuYmx1ZSwgdi5hbHBoYSlcbiAgICAgICAgICAgICAgICB9YCxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2LnJlZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2LmdyZWVuO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9IHYuYmx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrM10gPSB2LmFscGhhO1xuICAgICAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjM1wiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0ucmVkICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYucmVkIHx8IGN2WzFdICE9PSB2LmdyZWVuIHx8IGN2WzJdICE9PSB2LmJsdWUgfHwgY3ZbM10gIT09IHYuYSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2LmJsdWU7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHYucmVkLCB2LmdyZWVuLCB2LmJsdWUpXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgY29kZVVibzogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICAgICAgYFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEpID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWM0XCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXksXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSlcbiAgICAgICAgICAgICAgICB9YFxuICB9XG5dO1xuXG5leHBvcnQgeyB1bmlmb3JtUGFyc2VycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pZm9ybVBhcnNlcnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgdW5pZm9ybVBhcnNlcnMgfSBmcm9tICcuL3VuaWZvcm1QYXJzZXJzLm1qcyc7XG5cbmNvbnN0IEdMU0xfVE9fU0lOR0xFX1NFVFRFUlNfQ0FDSEVEID0ge1xuICBmbG9hdDogYFxuICAgIGlmIChjdiAhPT0gdilcbiAgICB7XG4gICAgICAgIGN1LnZhbHVlID0gdjtcbiAgICAgICAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2KTtcbiAgICB9YCxcbiAgdmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZihsb2NhdGlvbiwgdlswXSwgdlsxXSlcbiAgICB9YCxcbiAgdmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKVxuICAgIH1gLFxuICB2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00Zihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gICAgfWAsXG4gIGludDogYFxuICAgIGlmIChjdiAhPT0gdilcbiAgICB7XG4gICAgICAgIGN1LnZhbHVlID0gdjtcblxuICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICBpdmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSk7XG4gICAgfWAsXG4gIGl2ZWMzOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcblxuICAgICAgICBnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgIH1gLFxuICBpdmVjNDogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSB8fCBjdlszXSAhPT0gdlszXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgIGN2WzNdID0gdlszXTtcblxuICAgICAgICBnbC51bmlmb3JtNGkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICB1aW50OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xdWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICB1dmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0ydWkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgIH1gLFxuICB1dmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTN1aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSk7XG4gICAgfWAsXG4gIHV2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00dWkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICBib29sOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICBidmVjMjogYFxuICAgIGlmIChjdlswXSAhPSB2WzBdIHx8IGN2WzFdICE9IHZbMV0pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcblxuICAgICAgICBnbC51bmlmb3JtMmkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgIH1gLFxuICBidmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKTtcbiAgICB9YCxcbiAgYnZlYzQ6IGBcbiAgICBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKTtcbiAgICB9YCxcbiAgbWF0MjogXCJnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MzogXCJnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0NDogXCJnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgc2FtcGxlcjJEOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHNhbXBsZXJDdWJlOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHNhbXBsZXIyREFycmF5OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWBcbn07XG5jb25zdCBHTFNMX1RPX0FSUkFZX1NFVFRFUlMgPSB7XG4gIGZsb2F0OiBgZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdilgLFxuICB2ZWMyOiBgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdilgLFxuICB2ZWMzOiBgZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdilgLFxuICB2ZWM0OiBcImdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHYpXCIsXG4gIG1hdDQ6IFwiZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpXCIsXG4gIG1hdDM6IFwiZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpXCIsXG4gIG1hdDI6IFwiZ2wudW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgZmFsc2UsIHYpXCIsXG4gIGludDogXCJnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KVwiLFxuICBpdmVjMjogXCJnbC51bmlmb3JtMml2KGxvY2F0aW9uLCB2KVwiLFxuICBpdmVjMzogXCJnbC51bmlmb3JtM2l2KGxvY2F0aW9uLCB2KVwiLFxuICBpdmVjNDogXCJnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KVwiLFxuICB1aW50OiBcImdsLnVuaWZvcm0xdWl2KGxvY2F0aW9uLCB2KVwiLFxuICB1dmVjMjogXCJnbC51bmlmb3JtMnVpdihsb2NhdGlvbiwgdilcIixcbiAgdXZlYzM6IFwiZ2wudW5pZm9ybTN1aXYobG9jYXRpb24sIHYpXCIsXG4gIHV2ZWM0OiBcImdsLnVuaWZvcm00dWl2KGxvY2F0aW9uLCB2KVwiLFxuICBib29sOiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIGJ2ZWMyOiBcImdsLnVuaWZvcm0yaXYobG9jYXRpb24sIHYpXCIsXG4gIGJ2ZWMzOiBcImdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpXCIsXG4gIGJ2ZWM0OiBcImdsLnVuaWZvcm00aXYobG9jYXRpb24sIHYpXCIsXG4gIHNhbXBsZXIyRDogXCJnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KVwiLFxuICBzYW1wbGVyQ3ViZTogXCJnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KVwiLFxuICBzYW1wbGVyMkRBcnJheTogXCJnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KVwiXG59O1xuZnVuY3Rpb24gZ2VuZXJhdGVVbmlmb3Jtc1N5bmMoZ3JvdXAsIHVuaWZvcm1EYXRhKSB7XG4gIGNvbnN0IGZ1bmNGcmFnbWVudHMgPSBbYFxuICAgICAgICB2YXIgdiA9IG51bGw7XG4gICAgICAgIHZhciBjdiA9IG51bGw7XG4gICAgICAgIHZhciBjdSA9IG51bGw7XG4gICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgYF07XG4gIGZvciAoY29uc3QgaSBpbiBncm91cC51bmlmb3Jtcykge1xuICAgIGNvbnN0IGRhdGEgPSB1bmlmb3JtRGF0YVtpXTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGlmIChncm91cC51bmlmb3Jtc1tpXT8uZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldLnVibykge1xuICAgICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1CdWZmZXJHcm91cCh1di4ke2l9LCAnJHtpfScpO1xuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyLnN5bmNVbmlmb3JtR3JvdXAodXYuJHtpfSwgc3luY0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm0gPSBncm91cC51bmlmb3Jtc1tpXTtcbiAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlmb3JtUGFyc2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHVuaWZvcm1QYXJzZXJzW2pdLnRlc3QoZGF0YSwgdW5pZm9ybSkpIHtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKHVuaWZvcm1QYXJzZXJzW2pdLmNvZGUoaSwgdW5pZm9ybSkpO1xuICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlVHlwZSA9IGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ID8gR0xTTF9UT19TSU5HTEVfU0VUVEVSU19DQUNIRUQgOiBHTFNMX1RPX0FSUkFZX1NFVFRFUlM7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlVHlwZVtkYXRhLnR5cGVdLnJlcGxhY2UoXCJsb2NhdGlvblwiLCBgdWRbXCIke2l9XCJdLmxvY2F0aW9uYCk7XG4gICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgY3UgPSB1ZFtcIiR7aX1cIl07XG4gICAgICAgICAgICBjdiA9IGN1LnZhbHVlO1xuICAgICAgICAgICAgdiA9IHV2W1wiJHtpfVwiXTtcbiAgICAgICAgICAgICR7dGVtcGxhdGV9O2ApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidWRcIiwgXCJ1dlwiLCBcInJlbmRlcmVyXCIsIFwic3luY0RhdGFcIiwgZnVuY0ZyYWdtZW50cy5qb2luKFwiXFxuXCIpKTtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVVbmlmb3Jtc1N5bmMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlVW5pZm9ybXNTeW5jLm1qcy5tYXBcbiIsImltcG9ydCB7IEVOViB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcblxuY29uc3QgdW5rbm93bkNvbnRleHQgPSB7fTtcbmxldCBjb250ZXh0ID0gdW5rbm93bkNvbnRleHQ7XG5mdW5jdGlvbiBnZXRUZXN0Q29udGV4dCgpIHtcbiAgaWYgKGNvbnRleHQgPT09IHVua25vd25Db250ZXh0IHx8IGNvbnRleHQ/LmlzQ29udGV4dExvc3QoKSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgbGV0IGdsO1xuICAgIGlmIChzZXR0aW5ncy5QUkVGRVJfRU5WID49IEVOVi5XRUJHTDIpIHtcbiAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwge30pO1xuICAgIH1cbiAgICBpZiAoIWdsKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwge30pIHx8IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIHt9KTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgZ2wgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZHJhd19idWZmZXJzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0ID0gZ2w7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCB7IGdldFRlc3RDb250ZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRUZXN0Q29udGV4dC5tanMubWFwXG4iLCJpbXBvcnQgeyBQUkVDSVNJT04gfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0VGVzdENvbnRleHQgfSBmcm9tICcuL2dldFRlc3RDb250ZXh0Lm1qcyc7XG5cbmxldCBtYXhGcmFnbWVudFByZWNpc2lvbjtcbmZ1bmN0aW9uIGdldE1heEZyYWdtZW50UHJlY2lzaW9uKCkge1xuICBpZiAoIW1heEZyYWdtZW50UHJlY2lzaW9uKSB7XG4gICAgbWF4RnJhZ21lbnRQcmVjaXNpb24gPSBQUkVDSVNJT04uTUVESVVNO1xuICAgIGNvbnN0IGdsID0gZ2V0VGVzdENvbnRleHQoKTtcbiAgICBpZiAoZ2wpIHtcbiAgICAgIGlmIChnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQpIHtcbiAgICAgICAgY29uc3Qgc2hhZGVyRnJhZ21lbnQgPSBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKTtcbiAgICAgICAgbWF4RnJhZ21lbnRQcmVjaXNpb24gPSBzaGFkZXJGcmFnbWVudC5wcmVjaXNpb24gPyBQUkVDSVNJT04uSElHSCA6IFBSRUNJU0lPTi5NRURJVU07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXhGcmFnbWVudFByZWNpc2lvbjtcbn1cblxuZXhwb3J0IHsgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE1heEZyYWdtZW50UHJlY2lzaW9uLm1qcy5tYXBcbiIsImNvbnN0IEdMU0xfVE9fU0laRSA9IHtcbiAgZmxvYXQ6IDEsXG4gIHZlYzI6IDIsXG4gIHZlYzM6IDMsXG4gIHZlYzQ6IDQsXG4gIGludDogMSxcbiAgaXZlYzI6IDIsXG4gIGl2ZWMzOiAzLFxuICBpdmVjNDogNCxcbiAgdWludDogMSxcbiAgdXZlYzI6IDIsXG4gIHV2ZWMzOiAzLFxuICB1dmVjNDogNCxcbiAgYm9vbDogMSxcbiAgYnZlYzI6IDIsXG4gIGJ2ZWMzOiAzLFxuICBidmVjNDogNCxcbiAgbWF0MjogNCxcbiAgbWF0MzogOSxcbiAgbWF0NDogMTYsXG4gIHNhbXBsZXIyRDogMVxufTtcbmZ1bmN0aW9uIG1hcFNpemUodHlwZSkge1xuICByZXR1cm4gR0xTTF9UT19TSVpFW3R5cGVdO1xufVxuXG5leHBvcnQgeyBtYXBTaXplIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBTaXplLm1qcy5tYXBcbiIsImxldCBHTF9UQUJMRSA9IG51bGw7XG5jb25zdCBHTF9UT19HTFNMX1RZUEVTID0ge1xuICBGTE9BVDogXCJmbG9hdFwiLFxuICBGTE9BVF9WRUMyOiBcInZlYzJcIixcbiAgRkxPQVRfVkVDMzogXCJ2ZWMzXCIsXG4gIEZMT0FUX1ZFQzQ6IFwidmVjNFwiLFxuICBJTlQ6IFwiaW50XCIsXG4gIElOVF9WRUMyOiBcIml2ZWMyXCIsXG4gIElOVF9WRUMzOiBcIml2ZWMzXCIsXG4gIElOVF9WRUM0OiBcIml2ZWM0XCIsXG4gIFVOU0lHTkVEX0lOVDogXCJ1aW50XCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMyOiBcInV2ZWMyXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMzOiBcInV2ZWMzXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUM0OiBcInV2ZWM0XCIsXG4gIEJPT0w6IFwiYm9vbFwiLFxuICBCT09MX1ZFQzI6IFwiYnZlYzJcIixcbiAgQk9PTF9WRUMzOiBcImJ2ZWMzXCIsXG4gIEJPT0xfVkVDNDogXCJidmVjNFwiLFxuICBGTE9BVF9NQVQyOiBcIm1hdDJcIixcbiAgRkxPQVRfTUFUMzogXCJtYXQzXCIsXG4gIEZMT0FUX01BVDQ6IFwibWF0NFwiLFxuICBTQU1QTEVSXzJEOiBcInNhbXBsZXIyRFwiLFxuICBJTlRfU0FNUExFUl8yRDogXCJzYW1wbGVyMkRcIixcbiAgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQ6IFwic2FtcGxlcjJEXCIsXG4gIFNBTVBMRVJfQ1VCRTogXCJzYW1wbGVyQ3ViZVwiLFxuICBJTlRfU0FNUExFUl9DVUJFOiBcInNhbXBsZXJDdWJlXCIsXG4gIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkU6IFwic2FtcGxlckN1YmVcIixcbiAgU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBJTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiXG59O1xuZnVuY3Rpb24gbWFwVHlwZShnbCwgdHlwZSkge1xuICBpZiAoIUdMX1RBQkxFKSB7XG4gICAgY29uc3QgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoR0xfVE9fR0xTTF9UWVBFUyk7XG4gICAgR0xfVEFCTEUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdG4gPSB0eXBlTmFtZXNbaV07XG4gICAgICBHTF9UQUJMRVtnbFt0bl1dID0gR0xfVE9fR0xTTF9UWVBFU1t0bl07XG4gICAgfVxuICB9XG4gIHJldHVybiBHTF9UQUJMRVt0eXBlXTtcbn1cblxuZXhwb3J0IHsgbWFwVHlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwVHlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBQUkVDSVNJT04gfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBzZXRQcmVjaXNpb24oc3JjLCByZXF1ZXN0ZWRQcmVjaXNpb24sIG1heFN1cHBvcnRlZFByZWNpc2lvbikge1xuICBpZiAoc3JjLnN1YnN0cmluZygwLCA5KSAhPT0gXCJwcmVjaXNpb25cIikge1xuICAgIGxldCBwcmVjaXNpb24gPSByZXF1ZXN0ZWRQcmVjaXNpb247XG4gICAgaWYgKHJlcXVlc3RlZFByZWNpc2lvbiA9PT0gUFJFQ0lTSU9OLkhJR0ggJiYgbWF4U3VwcG9ydGVkUHJlY2lzaW9uICE9PSBQUkVDSVNJT04uSElHSCkge1xuICAgICAgcHJlY2lzaW9uID0gUFJFQ0lTSU9OLk1FRElVTTtcbiAgICB9XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHtwcmVjaXNpb259IGZsb2F0O1xuJHtzcmN9YDtcbiAgfSBlbHNlIGlmIChtYXhTdXBwb3J0ZWRQcmVjaXNpb24gIT09IFBSRUNJU0lPTi5ISUdIICYmIHNyYy5zdWJzdHJpbmcoMCwgMTUpID09PSBcInByZWNpc2lvbiBoaWdocFwiKSB7XG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKFwicHJlY2lzaW9uIGhpZ2hwXCIsIFwicHJlY2lzaW9uIG1lZGl1bXBcIik7XG4gIH1cbiAgcmV0dXJuIHNyYztcbn1cblxuZXhwb3J0IHsgc2V0UHJlY2lzaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXRQcmVjaXNpb24ubWpzLm1hcFxuIiwiZXhwb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9IGZyb20gJy4vY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5tanMnO1xuZXhwb3J0IHsgY29tcGlsZVNoYWRlciB9IGZyb20gJy4vY29tcGlsZVNoYWRlci5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdFZhbHVlIH0gZnJvbSAnLi9kZWZhdWx0VmFsdWUubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlVW5pZm9ybXNTeW5jIH0gZnJvbSAnLi9nZW5lcmF0ZVVuaWZvcm1zU3luYy5tanMnO1xuZXhwb3J0IHsgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gfSBmcm9tICcuL2dldE1heEZyYWdtZW50UHJlY2lzaW9uLm1qcyc7XG5leHBvcnQgeyBnZXRUZXN0Q29udGV4dCB9IGZyb20gJy4vZ2V0VGVzdENvbnRleHQubWpzJztcbmV4cG9ydCB7IGxvZ1Byb2dyYW1FcnJvciB9IGZyb20gJy4vbG9nUHJvZ3JhbUVycm9yLm1qcyc7XG5leHBvcnQgeyBtYXBTaXplIH0gZnJvbSAnLi9tYXBTaXplLm1qcyc7XG5leHBvcnQgeyBtYXBUeXBlIH0gZnJvbSAnLi9tYXBUeXBlLm1qcyc7XG5leHBvcnQgeyBzZXRQcmVjaXNpb24gfSBmcm9tICcuL3NldFByZWNpc2lvbi5tanMnO1xuZXhwb3J0IHsgdW5pZm9ybVBhcnNlcnMgfSBmcm9tICcuL3VuaWZvcm1QYXJzZXJzLm1qcyc7XG5leHBvcnQgeyB1bnNhZmVFdmFsU3VwcG9ydGVkIH0gZnJvbSAnLi91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBQUkVDSVNJT04gfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgUHJvZ3JhbUNhY2hlLCBpc01vYmlsZSB9IGZyb20gJ0BwaXhpL3V0aWxzJztcbmltcG9ydCBkZWZhdWx0RnJhZ21lbnQgZnJvbSAnLi9kZWZhdWx0UHJvZ3JhbS5tanMnO1xuaW1wb3J0IGRlZmF1bHRWZXJ0ZXggZnJvbSAnLi9kZWZhdWx0UHJvZ3JhbTIubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgc2V0UHJlY2lzaW9uIH0gZnJvbSAnLi91dGlscy9zZXRQcmVjaXNpb24ubWpzJztcbmltcG9ydCB7IGdldE1heEZyYWdtZW50UHJlY2lzaW9uIH0gZnJvbSAnLi91dGlscy9nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5tanMnO1xuXG5sZXQgVUlEID0gMDtcbmNvbnN0IG5hbWVDYWNoZSA9IHt9O1xuY29uc3QgX1Byb2dyYW0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIG5hbWUgPSBcInBpeGktc2hhZGVyXCIsIGV4dHJhID0ge30pIHtcbiAgICB0aGlzLmV4dHJhID0ge307XG4gICAgdGhpcy5pZCA9IFVJRCsrO1xuICAgIHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjIHx8IF9Qcm9ncmFtLmRlZmF1bHRWZXJ0ZXhTcmM7XG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IF9Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFNyYztcbiAgICB0aGlzLnZlcnRleFNyYyA9IHRoaXMudmVydGV4U3JjLnRyaW0oKTtcbiAgICB0aGlzLmZyYWdtZW50U3JjID0gdGhpcy5mcmFnbWVudFNyYy50cmltKCk7XG4gICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgIGlmICh0aGlzLnZlcnRleFNyYy5zdWJzdHJpbmcoMCwgOCkgIT09IFwiI3ZlcnNpb25cIikge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxzKy9nLCBcIi1cIik7XG4gICAgICBpZiAobmFtZUNhY2hlW25hbWVdKSB7XG4gICAgICAgIG5hbWVDYWNoZVtuYW1lXSsrO1xuICAgICAgICBuYW1lICs9IGAtJHtuYW1lQ2FjaGVbbmFtZV19YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVDYWNoZVtuYW1lXSA9IDE7XG4gICAgICB9XG4gICAgICB0aGlzLnZlcnRleFNyYyA9IGAjZGVmaW5lIFNIQURFUl9OQU1FICR7bmFtZX1cbiR7dGhpcy52ZXJ0ZXhTcmN9YDtcbiAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBgI2RlZmluZSBTSEFERVJfTkFNRSAke25hbWV9XG4ke3RoaXMuZnJhZ21lbnRTcmN9YDtcbiAgICAgIHRoaXMudmVydGV4U3JjID0gc2V0UHJlY2lzaW9uKHRoaXMudmVydGV4U3JjLCBfUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uLCBQUkVDSVNJT04uSElHSCk7XG4gICAgICB0aGlzLmZyYWdtZW50U3JjID0gc2V0UHJlY2lzaW9uKHRoaXMuZnJhZ21lbnRTcmMsIF9Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvbiwgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuZ2xQcm9ncmFtcyA9IHt9O1xuICAgIHRoaXMuc3luY1VuaWZvcm1zID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRWZXJ0ZXhTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWZXJ0ZXg7XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGcmFnbWVudDtcbiAgfVxuICBzdGF0aWMgZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKSB7XG4gICAgY29uc3Qga2V5ID0gdmVydGV4U3JjICsgZnJhZ21lbnRTcmM7XG4gICAgbGV0IHByb2dyYW0gPSBQcm9ncmFtQ2FjaGVba2V5XTtcbiAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgIFByb2dyYW1DYWNoZVtrZXldID0gcHJvZ3JhbSA9IG5ldyBfUHJvZ3JhbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbn07XG5sZXQgUHJvZ3JhbSA9IF9Qcm9ncmFtO1xuUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uID0gUFJFQ0lTSU9OLkhJR0g7XG5Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvbiA9IGlzTW9iaWxlLmFwcGxlLmRldmljZSA/IFBSRUNJU0lPTi5ISUdIIDogUFJFQ0lTSU9OLk1FRElVTTtcblxuZXhwb3J0IHsgUHJvZ3JhbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvZ3JhbS5tanMubWFwXG4iLCJpbXBvcnQgeyBCVUZGRVJfVFlQRSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi9nZW9tZXRyeS9CdWZmZXIubWpzJztcblxubGV0IFVJRCA9IDA7XG5jbGFzcyBVbmlmb3JtR3JvdXAge1xuICBjb25zdHJ1Y3Rvcih1bmlmb3JtcywgaXNTdGF0aWMsIGlzVWJvKSB7XG4gICAgdGhpcy5ncm91cCA9IHRydWU7XG4gICAgdGhpcy5zeW5jVW5pZm9ybXMgPSB7fTtcbiAgICB0aGlzLmRpcnR5SWQgPSAwO1xuICAgIHRoaXMuaWQgPSBVSUQrKztcbiAgICB0aGlzLnN0YXRpYyA9ICEhaXNTdGF0aWM7XG4gICAgdGhpcy51Ym8gPSAhIWlzVWJvO1xuICAgIGlmICh1bmlmb3JtcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIgPSB1bmlmb3JtcztcbiAgICAgIHRoaXMuYnVmZmVyLnR5cGUgPSBCVUZGRVJfVFlQRS5VTklGT1JNX0JVRkZFUjtcbiAgICAgIHRoaXMuYXV0b01hbmFnZSA9IGZhbHNlO1xuICAgICAgdGhpcy51Ym8gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgICBpZiAodGhpcy51Ym8pIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyKG5ldyBGbG9hdDMyQXJyYXkoMSkpO1xuICAgICAgICB0aGlzLmJ1ZmZlci50eXBlID0gQlVGRkVSX1RZUEUuVU5JRk9STV9CVUZGRVI7XG4gICAgICAgIHRoaXMuYXV0b01hbmFnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmRpcnR5SWQrKztcbiAgICBpZiAoIXRoaXMuYXV0b01hbmFnZSAmJiB0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGFkZChuYW1lLCB1bmlmb3JtcywgX3N0YXRpYykge1xuICAgIGlmICghdGhpcy51Ym8pIHtcbiAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1VuaWZvcm1Hcm91cF0gdW5pZm9ybSBncm91cHMgaW4gdWJvIG1vZGUgY2Fubm90IGJlIG1vZGlmaWVkLCBvciBoYXZlIHVuaWZvcm0gZ3JvdXBzIG5lc3RlZCBpbiB0aGVtXCIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbSh1bmlmb3JtcywgX3N0YXRpYywgX3Vibykge1xuICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljLCBfdWJvKTtcbiAgfVxuICBzdGF0aWMgdWJvRnJvbSh1bmlmb3JtcywgX3N0YXRpYykge1xuICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljID8/IHRydWUsIHRydWUpO1xuICB9XG59XG5cbmV4cG9ydCB7IFVuaWZvcm1Hcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5pZm9ybUdyb3VwLm1qcy5tYXBcbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gJ0BwaXhpL3J1bm5lcic7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSAnLi9Qcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuL1VuaWZvcm1Hcm91cC5tanMnO1xuXG5jbGFzcyBTaGFkZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9ncmFtLCB1bmlmb3Jtcykge1xuICAgIHRoaXMudW5pZm9ybUJpbmRDb3VudCA9IDA7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICBpZiAodW5pZm9ybXMpIHtcbiAgICAgIGlmICh1bmlmb3JtcyBpbnN0YW5jZW9mIFVuaWZvcm1Hcm91cCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IHVuaWZvcm1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSBuZXcgVW5pZm9ybUdyb3VwKHt9KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcihcImRpc3Bvc2VTaGFkZXJcIik7XG4gIH1cbiAgY2hlY2tVbmlmb3JtRXhpc3RzKG5hbWUsIGdyb3VwKSB7XG4gICAgaWYgKGdyb3VwLnVuaWZvcm1zW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB1bmlmb3JtID0gZ3JvdXAudW5pZm9ybXNbaV07XG4gICAgICBpZiAodW5pZm9ybS5ncm91cCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja1VuaWZvcm1FeGlzdHMobmFtZSwgdW5pZm9ybSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IG51bGw7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcyk7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgdW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zO1xuICB9XG4gIHN0YXRpYyBmcm9tKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IFByb2dyYW0uZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICByZXR1cm4gbmV3IFNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaGFkZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnQHBpeGkvbWF0aCc7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSAnLi4vc2hhZGVyL1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uL3NoYWRlci9TaGFkZXIubWpzJztcbmltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcblxuY2xhc3MgQmF0Y2hTaGFkZXJHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMsIGZyYWdUZW1wbGF0ZSkge1xuICAgIHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjO1xuICAgIHRoaXMuZnJhZ1RlbXBsYXRlID0gZnJhZ1RlbXBsYXRlO1xuICAgIHRoaXMucHJvZ3JhbUNhY2hlID0ge307XG4gICAgdGhpcy5kZWZhdWx0R3JvdXBDYWNoZSA9IHt9O1xuICAgIGlmICghZnJhZ1RlbXBsYXRlLmluY2x1ZGVzKFwiJWNvdW50JVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFnbWVudCB0ZW1wbGF0ZSBtdXN0IGNvbnRhaW4gXCIlY291bnQlXCIuJyk7XG4gICAgfVxuICAgIGlmICghZnJhZ1RlbXBsYXRlLmluY2x1ZGVzKFwiJWZvcmxvb3AlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYWdtZW50IHRlbXBsYXRlIG11c3QgY29udGFpbiBcIiVmb3Jsb29wJVwiLicpO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZVNoYWRlcihtYXhUZXh0dXJlcykge1xuICAgIGlmICghdGhpcy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdKSB7XG4gICAgICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShtYXhUZXh0dXJlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gaTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVmYXVsdEdyb3VwQ2FjaGVbbWF4VGV4dHVyZXNdID0gVW5pZm9ybUdyb3VwLmZyb20oeyB1U2FtcGxlcnM6IHNhbXBsZVZhbHVlcyB9LCB0cnVlKTtcbiAgICAgIGxldCBmcmFnbWVudFNyYyA9IHRoaXMuZnJhZ1RlbXBsYXRlO1xuICAgICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lY291bnQlL2dpLCBgJHttYXhUZXh0dXJlc31gKTtcbiAgICAgIGZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMucmVwbGFjZSgvJWZvcmxvb3AlL2dpLCB0aGlzLmdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSk7XG4gICAgICB0aGlzLnByb2dyYW1DYWNoZVttYXhUZXh0dXJlc10gPSBuZXcgUHJvZ3JhbSh0aGlzLnZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHRpbnQ6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcbiAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgTWF0cml4KCksXG4gICAgICBkZWZhdWx0OiB0aGlzLmRlZmF1bHRHcm91cENhY2hlW21heFRleHR1cmVzXVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBTaGFkZXIodGhpcy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdLCB1bmlmb3Jtcyk7XG4gIH1cbiAgZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpIHtcbiAgICBsZXQgc3JjID0gXCJcIjtcbiAgICBzcmMgKz0gXCJcXG5cIjtcbiAgICBzcmMgKz0gXCJcXG5cIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBzcmMgKz0gXCJcXG5lbHNlIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBtYXhUZXh0dXJlcyAtIDEpIHtcbiAgICAgICAgc3JjICs9IGBpZih2VGV4dHVyZUlkIDwgJHtpfS41KWA7XG4gICAgICB9XG4gICAgICBzcmMgKz0gXCJcXG57XCI7XG4gICAgICBzcmMgKz0gYFxuXHRjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcnNbJHtpfV0sIHZUZXh0dXJlQ29vcmQpO2A7XG4gICAgICBzcmMgKz0gXCJcXG59XCI7XG4gICAgfVxuICAgIHNyYyArPSBcIlxcblwiO1xuICAgIHNyYyArPSBcIlxcblwiO1xuICAgIHJldHVybiBzcmM7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hTaGFkZXJHZW5lcmF0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoU2hhZGVyR2VuZXJhdG9yLm1qcy5tYXBcbiIsImNsYXNzIEJhdGNoVGV4dHVyZUFycmF5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaWRzID0gW107XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50OyBpKyspIHtcbiAgICAgIHRoaXMuZWxlbWVudHNbaV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hUZXh0dXJlQXJyYXkubWpzLm1hcFxuIiwiaW1wb3J0IHsgaXNNb2JpbGUgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5cbmZ1bmN0aW9uIGNhblVwbG9hZFNhbWVCdWZmZXIoKSB7XG4gIHJldHVybiAhaXNNb2JpbGUuYXBwbGUuZGV2aWNlO1xufVxuXG5leHBvcnQgeyBjYW5VcGxvYWRTYW1lQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5VcGxvYWRTYW1lQnVmZmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzLCBpc01vYmlsZSB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcblxuZnVuY3Rpb24gbWF4UmVjb21tZW5kZWRUZXh0dXJlcyhtYXgpIHtcbiAgbGV0IGFsbG93TWF4ID0gdHJ1ZTtcbiAgY29uc3QgbmF2aWdhdG9yID0gc2V0dGluZ3MuQURBUFRFUi5nZXROYXZpZ2F0b3IoKTtcbiAgaWYgKGlzTW9iaWxlLnRhYmxldCB8fCBpc01vYmlsZS5waG9uZSkge1xuICAgIGlmIChpc01vYmlsZS5hcHBsZS5kZXZpY2UpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKT8vKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICBpZiAobWFqb3JWZXJzaW9uIDwgMTEpIHtcbiAgICAgICAgICBhbGxvd01heCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc01vYmlsZS5hbmRyb2lkLmRldmljZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkXFxzKFswLTkuXSopLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgaWYgKG1ham9yVmVyc2lvbiA8IDcpIHtcbiAgICAgICAgICBhbGxvd01heCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGxvd01heCA/IG1heCA6IDQ7XG59XG5cbmV4cG9ydCB7IG1heFJlY29tbWVuZGVkVGV4dHVyZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzLm1hcFxuIiwiY2xhc3MgT2JqZWN0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBmbHVzaCgpIHtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG4gIHN0YXJ0KCkge1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG4gIHJlbmRlcihfb2JqZWN0KSB7XG4gIH1cbn1cblxuZXhwb3J0IHsgT2JqZWN0UmVuZGVyZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFJlbmRlcmVyLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0RnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyBmbG9hdCB2VGV4dHVyZUlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyc1slY291bnQlXTtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgICVmb3Jsb29wJVxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIHZDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHRGcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0VmVydGV4ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCBhVGV4dHVyZUlkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIHZlYzQgdGludDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2VGV4dHVyZUlkID0gYVRleHR1cmVJZDtcXG4gICAgdkNvbG9yID0gYUNvbG9yICogdGludDtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHRWZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZTIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdAcGl4aS9jb2xvcic7XG5pbXBvcnQgeyBFTlYgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgcHJlbXVsdGlwbHlCbGVuZE1vZGUsIG5leHRQb3cyLCBsb2cyIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgVmlld2FibGVCdWZmZXIgfSBmcm9tICcuLi9nZW9tZXRyeS9WaWV3YWJsZUJ1ZmZlci5tanMnO1xuaW1wb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9IGZyb20gJy4uL3NoYWRlci91dGlscy9jaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBCYXRjaERyYXdDYWxsIH0gZnJvbSAnLi9CYXRjaERyYXdDYWxsLm1qcyc7XG5pbXBvcnQgeyBCYXRjaEdlb21ldHJ5IH0gZnJvbSAnLi9CYXRjaEdlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBCYXRjaFNoYWRlckdlbmVyYXRvciB9IGZyb20gJy4vQmF0Y2hTaGFkZXJHZW5lcmF0b3IubWpzJztcbmltcG9ydCB7IEJhdGNoVGV4dHVyZUFycmF5IH0gZnJvbSAnLi9CYXRjaFRleHR1cmVBcnJheS5tanMnO1xuaW1wb3J0IHsgY2FuVXBsb2FkU2FtZUJ1ZmZlciB9IGZyb20gJy4vY2FuVXBsb2FkU2FtZUJ1ZmZlci5tanMnO1xuaW1wb3J0IHsgbWF4UmVjb21tZW5kZWRUZXh0dXJlcyB9IGZyb20gJy4vbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanMnO1xuaW1wb3J0IHsgT2JqZWN0UmVuZGVyZXIgfSBmcm9tICcuL09iamVjdFJlbmRlcmVyLm1qcyc7XG5pbXBvcnQgZGVmYXVsdEZyYWdtZW50IGZyb20gJy4vdGV4dHVyZS5tanMnO1xuaW1wb3J0IGRlZmF1bHRWZXJ0ZXggZnJvbSAnLi90ZXh0dXJlMi5tanMnO1xuXG5jb25zdCBfQmF0Y2hSZW5kZXJlciA9IGNsYXNzIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLnNldFNoYWRlckdlbmVyYXRvcigpO1xuICAgIHRoaXMuZ2VvbWV0cnlDbGFzcyA9IEJhdGNoR2VvbWV0cnk7XG4gICAgdGhpcy52ZXJ0ZXhTaXplID0gNjtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLnNpemUgPSBfQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplICogNDtcbiAgICB0aGlzLl92ZXJ0ZXhDb3VudCA9IDA7XG4gICAgdGhpcy5faW5kZXhDb3VudCA9IDA7XG4gICAgdGhpcy5fYnVmZmVyZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX2J1ZmZlcmVkVGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLl9idWZmZXJTaXplID0gMDtcbiAgICB0aGlzLl9zaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3BhY2tlZEdlb21ldHJpZXMgPSBbXTtcbiAgICB0aGlzLl9wYWNrZWRHZW9tZXRyeVBvb2xTaXplID0gMjtcbiAgICB0aGlzLl9mbHVzaElkID0gMDtcbiAgICB0aGlzLl9hQnVmZmVycyA9IHt9O1xuICAgIHRoaXMuX2lCdWZmZXJzID0ge307XG4gICAgdGhpcy5tYXhUZXh0dXJlcyA9IDE7XG4gICAgdGhpcy5yZW5kZXJlci5vbihcInByZXJlbmRlclwiLCB0aGlzLm9uUHJlcmVuZGVyLCB0aGlzKTtcbiAgICByZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpO1xuICAgIHRoaXMuX2RjSW5kZXggPSAwO1xuICAgIHRoaXMuX2FJbmRleCA9IDA7XG4gICAgdGhpcy5faUluZGV4ID0gMDtcbiAgICB0aGlzLl9hdHRyaWJ1dGVCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2luZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl90ZW1wQm91bmRUZXh0dXJlcyA9IFtdO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdE1heFRleHR1cmVzKCkge1xuICAgIHRoaXMuX2RlZmF1bHRNYXhUZXh0dXJlcyA9IHRoaXMuX2RlZmF1bHRNYXhUZXh0dXJlcyA/PyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzKDMyKTtcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdE1heFRleHR1cmVzO1xuICB9XG4gIHN0YXRpYyBzZXQgZGVmYXVsdE1heFRleHR1cmVzKHZhbHVlKSB7XG4gICAgdGhpcy5fZGVmYXVsdE1heFRleHR1cmVzID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGdldCBjYW5VcGxvYWRTYW1lQnVmZmVyKCkge1xuICAgIHRoaXMuX2NhblVwbG9hZFNhbWVCdWZmZXIgPSB0aGlzLl9jYW5VcGxvYWRTYW1lQnVmZmVyID8/IGNhblVwbG9hZFNhbWVCdWZmZXIoKTtcbiAgICByZXR1cm4gdGhpcy5fY2FuVXBsb2FkU2FtZUJ1ZmZlcjtcbiAgfVxuICBzdGF0aWMgc2V0IGNhblVwbG9hZFNhbWVCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLl9jYW5VcGxvYWRTYW1lQnVmZmVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IE1BWF9URVhUVVJFUygpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwiQmF0Y2hSZW5kZXJlciNNQVhfVEVYVFVSRVMgcmVuYW1lZCB0byBCYXRjaFJlbmRlcmVyI21heFRleHR1cmVzXCIpO1xuICAgIHJldHVybiB0aGlzLm1heFRleHR1cmVzO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFZlcnRleFNyYygpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZlcnRleDtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRGcmFnbWVudFRlbXBsYXRlKCkge1xuICAgIHJldHVybiBkZWZhdWx0RnJhZ21lbnQ7XG4gIH1cbiAgc2V0U2hhZGVyR2VuZXJhdG9yKHtcbiAgICB2ZXJ0ZXggPSBfQmF0Y2hSZW5kZXJlci5kZWZhdWx0VmVydGV4U3JjLFxuICAgIGZyYWdtZW50ID0gX0JhdGNoUmVuZGVyZXIuZGVmYXVsdEZyYWdtZW50VGVtcGxhdGVcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5zaGFkZXJHZW5lcmF0b3IgPSBuZXcgQmF0Y2hTaGFkZXJHZW5lcmF0b3IodmVydGV4LCBmcmFnbWVudCk7XG4gIH1cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgaWYgKHNldHRpbmdzLlBSRUZFUl9FTlYgPT09IEVOVi5XRUJHTF9MRUdBQ1kpIHtcbiAgICAgIHRoaXMubWF4VGV4dHVyZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1heFRleHR1cmVzID0gTWF0aC5taW4oZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSwgX0JhdGNoUmVuZGVyZXIuZGVmYXVsdE1heFRleHR1cmVzKTtcbiAgICAgIHRoaXMubWF4VGV4dHVyZXMgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyKHRoaXMubWF4VGV4dHVyZXMsIGdsKTtcbiAgICB9XG4gICAgdGhpcy5fc2hhZGVyID0gdGhpcy5zaGFkZXJHZW5lcmF0b3IuZ2VuZXJhdGVTaGFkZXIodGhpcy5tYXhUZXh0dXJlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYWNrZWRHZW9tZXRyeVBvb2xTaXplOyBpKyspIHtcbiAgICAgIHRoaXMuX3BhY2tlZEdlb21ldHJpZXNbaV0gPSBuZXcgdGhpcy5nZW9tZXRyeUNsYXNzKCk7XG4gICAgfVxuICAgIHRoaXMuaW5pdEZsdXNoQnVmZmVycygpO1xuICB9XG4gIGluaXRGbHVzaEJ1ZmZlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdDYWxsUG9vbCxcbiAgICAgIF90ZXh0dXJlQXJyYXlQb29sXG4gICAgfSA9IF9CYXRjaFJlbmRlcmVyO1xuICAgIGNvbnN0IE1BWF9TUFJJVEVTID0gdGhpcy5zaXplIC8gNDtcbiAgICBjb25zdCBNQVhfVEEgPSBNYXRoLmZsb29yKE1BWF9TUFJJVEVTIC8gdGhpcy5tYXhUZXh0dXJlcykgKyAxO1xuICAgIHdoaWxlIChfZHJhd0NhbGxQb29sLmxlbmd0aCA8IE1BWF9TUFJJVEVTKSB7XG4gICAgICBfZHJhd0NhbGxQb29sLnB1c2gobmV3IEJhdGNoRHJhd0NhbGwoKSk7XG4gICAgfVxuICAgIHdoaWxlIChfdGV4dHVyZUFycmF5UG9vbC5sZW5ndGggPCBNQVhfVEEpIHtcbiAgICAgIF90ZXh0dXJlQXJyYXlQb29sLnB1c2gobmV3IEJhdGNoVGV4dHVyZUFycmF5KCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXNbaV0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBvblByZXJlbmRlcigpIHtcbiAgICB0aGlzLl9mbHVzaElkID0gMDtcbiAgfVxuICByZW5kZXIoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5fdGV4dHVyZS52YWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdmVydGV4Q291bnQgKyBlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMiA+IHRoaXMuc2l6ZSkge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICB0aGlzLl92ZXJ0ZXhDb3VudCArPSBlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMjtcbiAgICB0aGlzLl9pbmRleENvdW50ICs9IGVsZW1lbnQuaW5kaWNlcy5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVyZWRUZXh0dXJlc1t0aGlzLl9idWZmZXJTaXplXSA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdGhpcy5fYnVmZmVyZWRFbGVtZW50c1t0aGlzLl9idWZmZXJTaXplKytdID0gZWxlbWVudDtcbiAgfVxuICBidWlsZFRleHR1cmVzQW5kRHJhd0NhbGxzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9idWZmZXJlZFRleHR1cmVzOiB0ZXh0dXJlcyxcbiAgICAgIG1heFRleHR1cmVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdGV4dHVyZUFycmF5cyA9IF9CYXRjaFJlbmRlcmVyLl90ZXh0dXJlQXJyYXlQb29sO1xuICAgIGNvbnN0IGJhdGNoID0gdGhpcy5yZW5kZXJlci5iYXRjaDtcbiAgICBjb25zdCBib3VuZFRleHR1cmVzID0gdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXM7XG4gICAgY29uc3QgdG91Y2ggPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVHQy5jb3VudDtcbiAgICBsZXQgVElDSyA9ICsrQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoO1xuICAgIGxldCBjb3VudFRleEFycmF5cyA9IDA7XG4gICAgbGV0IHRleEFycmF5ID0gdGV4dHVyZUFycmF5c1swXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGJhdGNoLmNvcHlCb3VuZFRleHR1cmVzKGJvdW5kVGV4dHVyZXMsIG1heFRleHR1cmVzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlclNpemU7ICsraSkge1xuICAgICAgY29uc3QgdGV4ID0gdGV4dHVyZXNbaV07XG4gICAgICB0ZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICBpZiAodGV4Ll9iYXRjaEVuYWJsZWQgPT09IFRJQ0spIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4QXJyYXkuY291bnQgPj0gbWF4VGV4dHVyZXMpIHtcbiAgICAgICAgYmF0Y2guYm91bmRBcnJheSh0ZXhBcnJheSwgYm91bmRUZXh0dXJlcywgVElDSywgbWF4VGV4dHVyZXMpO1xuICAgICAgICB0aGlzLmJ1aWxkRHJhd0NhbGxzKHRleEFycmF5LCBzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgdGV4QXJyYXkgPSB0ZXh0dXJlQXJyYXlzWysrY291bnRUZXhBcnJheXNdO1xuICAgICAgICArK1RJQ0s7XG4gICAgICB9XG4gICAgICB0ZXguX2JhdGNoRW5hYmxlZCA9IFRJQ0s7XG4gICAgICB0ZXgudG91Y2hlZCA9IHRvdWNoO1xuICAgICAgdGV4QXJyYXkuZWxlbWVudHNbdGV4QXJyYXkuY291bnQrK10gPSB0ZXg7XG4gICAgfVxuICAgIGlmICh0ZXhBcnJheS5jb3VudCA+IDApIHtcbiAgICAgIGJhdGNoLmJvdW5kQXJyYXkodGV4QXJyYXksIGJvdW5kVGV4dHVyZXMsIFRJQ0ssIG1heFRleHR1cmVzKTtcbiAgICAgIHRoaXMuYnVpbGREcmF3Q2FsbHModGV4QXJyYXksIHN0YXJ0LCB0aGlzLl9idWZmZXJTaXplKTtcbiAgICAgICsrY291bnRUZXhBcnJheXM7XG4gICAgICArK1RJQ0s7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIEJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IFRJQ0s7XG4gIH1cbiAgYnVpbGREcmF3Q2FsbHModGV4QXJyYXksIHN0YXJ0LCBmaW5pc2gpIHtcbiAgICBjb25zdCB7XG4gICAgICBfYnVmZmVyZWRFbGVtZW50czogZWxlbWVudHMsXG4gICAgICBfYXR0cmlidXRlQnVmZmVyLFxuICAgICAgX2luZGV4QnVmZmVyLFxuICAgICAgdmVydGV4U2l6ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRyYXdDYWxscyA9IF9CYXRjaFJlbmRlcmVyLl9kcmF3Q2FsbFBvb2w7XG4gICAgbGV0IGRjSW5kZXggPSB0aGlzLl9kY0luZGV4O1xuICAgIGxldCBhSW5kZXggPSB0aGlzLl9hSW5kZXg7XG4gICAgbGV0IGlJbmRleCA9IHRoaXMuX2lJbmRleDtcbiAgICBsZXQgZHJhd0NhbGwgPSBkcmF3Q2FsbHNbZGNJbmRleF07XG4gICAgZHJhd0NhbGwuc3RhcnQgPSB0aGlzLl9pSW5kZXg7XG4gICAgZHJhd0NhbGwudGV4QXJyYXkgPSB0ZXhBcnJheTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBmaW5pc2g7ICsraSkge1xuICAgICAgY29uc3Qgc3ByaXRlID0gZWxlbWVudHNbaV07XG4gICAgICBjb25zdCB0ZXggPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICBjb25zdCBzcHJpdGVCbGVuZE1vZGUgPSBwcmVtdWx0aXBseUJsZW5kTW9kZVt0ZXguYWxwaGFNb2RlID8gMSA6IDBdW3Nwcml0ZS5ibGVuZE1vZGVdO1xuICAgICAgZWxlbWVudHNbaV0gPSBudWxsO1xuICAgICAgaWYgKHN0YXJ0IDwgaSAmJiBkcmF3Q2FsbC5ibGVuZCAhPT0gc3ByaXRlQmxlbmRNb2RlKSB7XG4gICAgICAgIGRyYXdDYWxsLnNpemUgPSBpSW5kZXggLSBkcmF3Q2FsbC5zdGFydDtcbiAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICBkcmF3Q2FsbCA9IGRyYXdDYWxsc1srK2RjSW5kZXhdO1xuICAgICAgICBkcmF3Q2FsbC50ZXhBcnJheSA9IHRleEFycmF5O1xuICAgICAgICBkcmF3Q2FsbC5zdGFydCA9IGlJbmRleDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFja0ludGVybGVhdmVkR2VvbWV0cnkoc3ByaXRlLCBfYXR0cmlidXRlQnVmZmVyLCBfaW5kZXhCdWZmZXIsIGFJbmRleCwgaUluZGV4KTtcbiAgICAgIGFJbmRleCArPSBzcHJpdGUudmVydGV4RGF0YS5sZW5ndGggLyAyICogdmVydGV4U2l6ZTtcbiAgICAgIGlJbmRleCArPSBzcHJpdGUuaW5kaWNlcy5sZW5ndGg7XG4gICAgICBkcmF3Q2FsbC5ibGVuZCA9IHNwcml0ZUJsZW5kTW9kZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgZmluaXNoKSB7XG4gICAgICBkcmF3Q2FsbC5zaXplID0gaUluZGV4IC0gZHJhd0NhbGwuc3RhcnQ7XG4gICAgICArK2RjSW5kZXg7XG4gICAgfVxuICAgIHRoaXMuX2RjSW5kZXggPSBkY0luZGV4O1xuICAgIHRoaXMuX2FJbmRleCA9IGFJbmRleDtcbiAgICB0aGlzLl9pSW5kZXggPSBpSW5kZXg7XG4gIH1cbiAgYmluZEFuZENsZWFyVGV4QXJyYXkodGV4QXJyYXkpIHtcbiAgICBjb25zdCB0ZXh0dXJlU3lzdGVtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4QXJyYXkuY291bnQ7IGorKykge1xuICAgICAgdGV4dHVyZVN5c3RlbS5iaW5kKHRleEFycmF5LmVsZW1lbnRzW2pdLCB0ZXhBcnJheS5pZHNbal0pO1xuICAgICAgdGV4QXJyYXkuZWxlbWVudHNbal0gPSBudWxsO1xuICAgIH1cbiAgICB0ZXhBcnJheS5jb3VudCA9IDA7XG4gIH1cbiAgdXBkYXRlR2VvbWV0cnkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX3BhY2tlZEdlb21ldHJpZXM6IHBhY2tlZEdlb21ldHJpZXMsXG4gICAgICBfYXR0cmlidXRlQnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICBfaW5kZXhCdWZmZXI6IGluZGV4QnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFfQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyKSB7XG4gICAgICBpZiAodGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZSA8PSB0aGlzLl9mbHVzaElkKSB7XG4gICAgICAgIHRoaXMuX3BhY2tlZEdlb21ldHJ5UG9vbFNpemUrKztcbiAgICAgICAgcGFja2VkR2VvbWV0cmllc1t0aGlzLl9mbHVzaElkXSA9IG5ldyB0aGlzLmdlb21ldHJ5Q2xhc3MoKTtcbiAgICAgIH1cbiAgICAgIHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0uX2J1ZmZlci51cGRhdGUoYXR0cmlidXRlQnVmZmVyLnJhd0JpbmFyeURhdGEpO1xuICAgICAgcGFja2VkR2VvbWV0cmllc1t0aGlzLl9mbHVzaElkXS5faW5kZXhCdWZmZXIudXBkYXRlKGluZGV4QnVmZmVyKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZChwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkudXBkYXRlQnVmZmVycygpO1xuICAgICAgdGhpcy5fZmx1c2hJZCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdLl9idWZmZXIudXBkYXRlKGF0dHJpYnV0ZUJ1ZmZlci5yYXdCaW5hcnlEYXRhKTtcbiAgICAgIHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0uX2luZGV4QnVmZmVyLnVwZGF0ZShpbmRleEJ1ZmZlcik7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhdGNoZXMoKSB7XG4gICAgY29uc3QgZGNDb3VudCA9IHRoaXMuX2RjSW5kZXg7XG4gICAgY29uc3QgeyBnbCwgc3RhdGU6IHN0YXRlU3lzdGVtIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGRyYXdDYWxscyA9IF9CYXRjaFJlbmRlcmVyLl9kcmF3Q2FsbFBvb2w7XG4gICAgbGV0IGN1clRleEFycmF5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRjQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgeyB0ZXhBcnJheSwgdHlwZSwgc2l6ZSwgc3RhcnQsIGJsZW5kIH0gPSBkcmF3Q2FsbHNbaV07XG4gICAgICBpZiAoY3VyVGV4QXJyYXkgIT09IHRleEFycmF5KSB7XG4gICAgICAgIGN1clRleEFycmF5ID0gdGV4QXJyYXk7XG4gICAgICAgIHRoaXMuYmluZEFuZENsZWFyVGV4QXJyYXkodGV4QXJyYXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSBibGVuZDtcbiAgICAgIHN0YXRlU3lzdGVtLnNldCh0aGlzLnN0YXRlKTtcbiAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplLCBnbC5VTlNJR05FRF9TSE9SVCwgc3RhcnQgKiAyKTtcbiAgICB9XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuX3ZlcnRleENvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2F0dHJpYnV0ZUJ1ZmZlciA9IHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyKHRoaXMuX3ZlcnRleENvdW50KTtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IHRoaXMuZ2V0SW5kZXhCdWZmZXIodGhpcy5faW5kZXhDb3VudCk7XG4gICAgdGhpcy5fYUluZGV4ID0gMDtcbiAgICB0aGlzLl9pSW5kZXggPSAwO1xuICAgIHRoaXMuX2RjSW5kZXggPSAwO1xuICAgIHRoaXMuYnVpbGRUZXh0dXJlc0FuZERyYXdDYWxscygpO1xuICAgIHRoaXMudXBkYXRlR2VvbWV0cnkoKTtcbiAgICB0aGlzLmRyYXdCYXRjaGVzKCk7XG4gICAgdGhpcy5fYnVmZmVyU2l6ZSA9IDA7XG4gICAgdGhpcy5fdmVydGV4Q291bnQgPSAwO1xuICAgIHRoaXMuX2luZGV4Q291bnQgPSAwO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMucmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5lbnN1cmVTYW1wbGVyVHlwZSh0aGlzLm1heFRleHR1cmVzKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuX3NoYWRlcik7XG4gICAgaWYgKF9CYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLl9wYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhY2tlZEdlb21ldHJ5UG9vbFNpemU7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX3BhY2tlZEdlb21ldHJpZXNbaV0pIHtcbiAgICAgICAgdGhpcy5fcGFja2VkR2VvbWV0cmllc1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIub2ZmKFwicHJlcmVuZGVyXCIsIHRoaXMub25QcmVyZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuX2FCdWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLl9pQnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5fcGFja2VkR2VvbWV0cmllcyA9IG51bGw7XG4gICAgdGhpcy5fYXR0cmlidXRlQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3NoYWRlcikge1xuICAgICAgdGhpcy5fc2hhZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXRBdHRyaWJ1dGVCdWZmZXIoc2l6ZSkge1xuICAgIGNvbnN0IHJvdW5kZWRQMiA9IG5leHRQb3cyKE1hdGguY2VpbChzaXplIC8gOCkpO1xuICAgIGNvbnN0IHJvdW5kZWRTaXplSW5kZXggPSBsb2cyKHJvdW5kZWRQMik7XG4gICAgY29uc3Qgcm91bmRlZFNpemUgPSByb3VuZGVkUDIgKiA4O1xuICAgIGlmICh0aGlzLl9hQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xuICAgICAgdGhpcy5faUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDE7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9hQnVmZmVyc1tyb3VuZGVkU2l6ZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHRoaXMuX2FCdWZmZXJzW3JvdW5kZWRTaXplXSA9IGJ1ZmZlciA9IG5ldyBWaWV3YWJsZUJ1ZmZlcihyb3VuZGVkU2l6ZSAqIHRoaXMudmVydGV4U2l6ZSAqIDQpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIGdldEluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCByb3VuZGVkUDIgPSBuZXh0UG93MihNYXRoLmNlaWwoc2l6ZSAvIDEyKSk7XG4gICAgY29uc3Qgcm91bmRlZFNpemVJbmRleCA9IGxvZzIocm91bmRlZFAyKTtcbiAgICBjb25zdCByb3VuZGVkU2l6ZSA9IHJvdW5kZWRQMiAqIDEyO1xuICAgIGlmICh0aGlzLl9pQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xuICAgICAgdGhpcy5faUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDE7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9pQnVmZmVyc1tyb3VuZGVkU2l6ZUluZGV4XTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhpcy5faUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF0gPSBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkocm91bmRlZFNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHBhY2tJbnRlcmxlYXZlZEdlb21ldHJ5KGVsZW1lbnQsIGF0dHJpYnV0ZUJ1ZmZlciwgaW5kZXhCdWZmZXIsIGFJbmRleCwgaUluZGV4KSB7XG4gICAgY29uc3Qge1xuICAgICAgdWludDMyVmlldyxcbiAgICAgIGZsb2F0MzJWaWV3XG4gICAgfSA9IGF0dHJpYnV0ZUJ1ZmZlcjtcbiAgICBjb25zdCBwYWNrZWRWZXJ0aWNlcyA9IGFJbmRleCAvIHRoaXMudmVydGV4U2l6ZTtcbiAgICBjb25zdCB1dnMgPSBlbGVtZW50LnV2cztcbiAgICBjb25zdCBpbmRpY2llcyA9IGVsZW1lbnQuaW5kaWNlcztcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gZWxlbWVudC52ZXJ0ZXhEYXRhO1xuICAgIGNvbnN0IHRleHR1cmVJZCA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuX2JhdGNoTG9jYXRpb247XG4gICAgY29uc3QgYWxwaGEgPSBNYXRoLm1pbihlbGVtZW50LndvcmxkQWxwaGEsIDEpO1xuICAgIGNvbnN0IGFyZ2IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZWxlbWVudC5fdGludFJHQikudG9QcmVtdWx0aXBsaWVkKGFscGhhKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHZlcnRleERhdGFbaV07XG4gICAgICBmbG9hdDMyVmlld1thSW5kZXgrK10gPSB2ZXJ0ZXhEYXRhW2kgKyAxXTtcbiAgICAgIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHV2c1tpXTtcbiAgICAgIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHV2c1tpICsgMV07XG4gICAgICB1aW50MzJWaWV3W2FJbmRleCsrXSA9IGFyZ2I7XG4gICAgICBmbG9hdDMyVmlld1thSW5kZXgrK10gPSB0ZXh0dXJlSWQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGV4QnVmZmVyW2lJbmRleCsrXSA9IHBhY2tlZFZlcnRpY2VzICsgaW5kaWNpZXNbaV07XG4gICAgfVxuICB9XG59O1xubGV0IEJhdGNoUmVuZGVyZXIgPSBfQmF0Y2hSZW5kZXJlcjtcbkJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZSA9IDQwOTY7XG5CYXRjaFJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJiYXRjaFwiLFxuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyUGx1Z2luXG59O1xuQmF0Y2hSZW5kZXJlci5fZHJhd0NhbGxQb29sID0gW107XG5CYXRjaFJlbmRlcmVyLl90ZXh0dXJlQXJyYXlQb29sID0gW107XG5leHRlbnNpb25zLmFkZChCYXRjaFJlbmRlcmVyKTtcblxuZXhwb3J0IHsgQmF0Y2hSZW5kZXJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hSZW5kZXJlci5tanMubWFwXG4iLCJ2YXIgZGVmYXVsdEZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHRGcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0RmlsdGVyLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxuXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxue1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbn1cXG5cXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxue1xcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHRWZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdEZpbHRlcjIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTVNBQV9RVUFMSVRZIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IFByb2dyYW0gfSBmcm9tICcuLi9zaGFkZXIvUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi4vc2hhZGVyL1NoYWRlci5tanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuLi9zdGF0ZS9TdGF0ZS5tanMnO1xuaW1wb3J0IGRlZmF1bHRGcmFnbWVudCBmcm9tICcuL2RlZmF1bHRGaWx0ZXIubWpzJztcbmltcG9ydCBkZWZhdWx0VmVydGV4IGZyb20gJy4vZGVmYXVsdEZpbHRlcjIubWpzJztcblxuY29uc3QgX0ZpbHRlciA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyIHtcbiAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gUHJvZ3JhbS5mcm9tKHZlcnRleFNyYyB8fCBfRmlsdGVyLmRlZmF1bHRWZXJ0ZXhTcmMsIGZyYWdtZW50U3JjIHx8IF9GaWx0ZXIuZGVmYXVsdEZyYWdtZW50U3JjKTtcbiAgICBzdXBlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBfRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uO1xuICAgIHRoaXMubXVsdGlzYW1wbGUgPSBfRmlsdGVyLmRlZmF1bHRNdWx0aXNhbXBsZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuYXV0b0ZpdCA9IHRydWU7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICB9XG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSwgX2N1cnJlbnRTdGF0ZSkge1xuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxuICBnZXQgYmxlbmRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmJsZW5kTW9kZTtcbiAgfVxuICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRWZXJ0ZXhTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWZXJ0ZXg7XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGcmFnbWVudDtcbiAgfVxufTtcbmxldCBGaWx0ZXIgPSBfRmlsdGVyO1xuRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uID0gMTtcbkZpbHRlci5kZWZhdWx0TXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORTtcblxuZXhwb3J0IHsgRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdAcGl4aS9jb2xvcic7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5cbmNsYXNzIEJhY2tncm91bmRTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gdHJ1ZTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCk7XG4gICAgdGhpcy5hbHBoYSA9IDE7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IG9wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXI7XG4gICAgY29uc3QgeyBiYWNrZ3JvdW5kQ29sb3IsIGJhY2tncm91bmQsIGJhY2tncm91bmRBbHBoYSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjb2xvciA9IGJhY2tncm91bmQgPz8gYmFja2dyb3VuZENvbG9yO1xuICAgIGlmIChjb2xvciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIHRoaXMuYWxwaGEgPSBiYWNrZ3JvdW5kQWxwaGE7XG4gIH1cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvci5hbHBoYTtcbiAgfVxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3Iuc2V0QWxwaGEodmFsdWUpO1xuICB9XG4gIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5CYWNrZ3JvdW5kU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICBiYWNrZ3JvdW5kQWxwaGE6IDEsXG4gIGJhY2tncm91bmRDb2xvcjogMCxcbiAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWVcbn07XG5CYWNrZ3JvdW5kU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcImJhY2tncm91bmRcIlxufTtcbmV4dGVuc2lvbnMuYWRkKEJhY2tncm91bmRTeXN0ZW0pO1xuXG5leHBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYWNrZ3JvdW5kU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IE9iamVjdFJlbmRlcmVyIH0gZnJvbSAnLi9PYmplY3RSZW5kZXJlci5tanMnO1xuXG5jbGFzcyBCYXRjaFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuZW1wdHlSZW5kZXJlciA9IG5ldyBPYmplY3RSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSB0aGlzLmVtcHR5UmVuZGVyZXI7XG4gIH1cbiAgc2V0T2JqZWN0UmVuZGVyZXIob2JqZWN0UmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UmVuZGVyZXIgPT09IG9iamVjdFJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG9iamVjdFJlbmRlcmVyO1xuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgdGhpcy5zZXRPYmplY3RSZW5kZXJlcih0aGlzLmVtcHR5UmVuZGVyZXIpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5lbXB0eVJlbmRlcmVyKTtcbiAgfVxuICBjb3B5Qm91bmRUZXh0dXJlcyhhcnIsIG1heFRleHR1cmVzKSB7XG4gICAgY29uc3QgeyBib3VuZFRleHR1cmVzIH0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XG4gICAgZm9yIChsZXQgaSA9IG1heFRleHR1cmVzIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGFycltpXSA9IGJvdW5kVGV4dHVyZXNbaV0gfHwgbnVsbDtcbiAgICAgIGlmIChhcnJbaV0pIHtcbiAgICAgICAgYXJyW2ldLl9iYXRjaExvY2F0aW9uID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYm91bmRBcnJheSh0ZXhBcnJheSwgYm91bmRUZXh0dXJlcywgYmF0Y2hJZCwgbWF4VGV4dHVyZXMpIHtcbiAgICBjb25zdCB7IGVsZW1lbnRzLCBpZHMsIGNvdW50IH0gPSB0ZXhBcnJheTtcbiAgICBsZXQgaiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXggPSBlbGVtZW50c1tpXTtcbiAgICAgIGNvbnN0IGxvYyA9IHRleC5fYmF0Y2hMb2NhdGlvbjtcbiAgICAgIGlmIChsb2MgPj0gMCAmJiBsb2MgPCBtYXhUZXh0dXJlcyAmJiBib3VuZFRleHR1cmVzW2xvY10gPT09IHRleCkge1xuICAgICAgICBpZHNbaV0gPSBsb2M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGogPCBtYXhUZXh0dXJlcykge1xuICAgICAgICBjb25zdCBib3VuZCA9IGJvdW5kVGV4dHVyZXNbal07XG4gICAgICAgIGlmIChib3VuZCAmJiBib3VuZC5fYmF0Y2hFbmFibGVkID09PSBiYXRjaElkICYmIGJvdW5kLl9iYXRjaExvY2F0aW9uID09PSBqKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlkc1tpXSA9IGo7XG4gICAgICAgIHRleC5fYmF0Y2hMb2NhdGlvbiA9IGo7XG4gICAgICAgIGJvdW5kVGV4dHVyZXNbal0gPSB0ZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5CYXRjaFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiYmF0Y2hcIlxufTtcbmV4dGVuc2lvbnMuYWRkKEJhdGNoU3lzdGVtKTtcblxuZXhwb3J0IHsgQmF0Y2hTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEVOViB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcblxubGV0IENPTlRFWFRfVUlEX0NPVU5URVIgPSAwO1xuY2xhc3MgQ29udGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMTtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLnN1cHBvcnRzID0ge1xuICAgICAgdWludDMySW5kaWNlczogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ29udGV4dExvc3QgPSB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZC5iaW5kKHRoaXMpO1xuICB9XG4gIGdldCBpc0xvc3QoKSB7XG4gICAgcmV0dXJuICF0aGlzLmdsIHx8IHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5yZW5kZXJlci5nbCA9IGdsO1xuICAgIHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQgPSBDT05URVhUX1VJRF9DT1VOVEVSKys7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgdGhpcy5pbml0RnJvbUNvbnRleHQob3B0aW9ucy5jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWxwaGEgPSB0aGlzLnJlbmRlcmVyLmJhY2tncm91bmQuYWxwaGEgPCAxO1xuICAgICAgY29uc3QgcHJlbXVsdGlwbGllZEFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBsaWVkQWxwaGE7XG4gICAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xuICAgICAgdGhpcy51c2VDb250ZXh0QWxwaGEgPSBvcHRpb25zLnVzZUNvbnRleHRBbHBoYTtcbiAgICAgIHRoaXMucG93ZXJQcmVmZXJlbmNlID0gb3B0aW9ucy5wb3dlclByZWZlcmVuY2U7XG4gICAgICB0aGlzLmluaXRGcm9tT3B0aW9ucyh7XG4gICAgICAgIGFscGhhLFxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGEsXG4gICAgICAgIGFudGlhbGlhczogb3B0aW9ucy5hbnRpYWxpYXMsXG4gICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG4gICAgICAgIHBvd2VyUHJlZmVyZW5jZTogb3B0aW9ucy5wb3dlclByZWZlcmVuY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpbml0RnJvbUNvbnRleHQoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy52YWxpZGF0ZUNvbnRleHQoZ2wpO1xuICAgIHRoaXMucmVuZGVyZXIuZ2wgPSBnbDtcbiAgICB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEID0gQ09OVEVYVF9VSURfQ09VTlRFUisrO1xuICAgIHRoaXMucmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmVtaXQoZ2wpO1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLnJlbmRlcmVyLnZpZXc7XG4gICAgaWYgKHZpZXcuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdm9pZCAwKSB7XG4gICAgICB2aWV3LmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QsIGZhbHNlKTtcbiAgICAgIHZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGluaXRGcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNyZWF0ZUNvbnRleHQodGhpcy5yZW5kZXJlci52aWV3LCBvcHRpb25zKTtcbiAgICB0aGlzLmluaXRGcm9tQ29udGV4dChnbCk7XG4gIH1cbiAgY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgZ2w7XG4gICAgaWYgKHNldHRpbmdzLlBSRUZFUl9FTlYgPj0gRU5WLldFQkdMMikge1xuICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGdsKSB7XG4gICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMTtcbiAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBvcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBvcHRpb25zKTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR0wuIFRyeSB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XG4gICAgcmV0dXJuIHRoaXMuZ2w7XG4gIH1cbiAgZ2V0RXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbW1vbiA9IHtcbiAgICAgIGxvc2VDb250ZXh0OiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIiksXG4gICAgICBhbmlzb3Ryb3BpY0ZpbHRlcmluZzogZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpLFxuICAgICAgZmxvYXRUZXh0dXJlTGluZWFyOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIiksXG4gICAgICBzM3RjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSxcbiAgICAgIHMzdGNfc1JHQjogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNfc3JnYlwiKSxcbiAgICAgIGV0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Y1wiKSxcbiAgICAgIGV0YzE6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXCIpLFxuICAgICAgcHZydGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSB8fCBnbC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpLFxuICAgICAgYXRjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXCIpLFxuICAgICAgYXN0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGNcIilcbiAgICB9O1xuICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIGNvbW1vbiwge1xuICAgICAgICBkcmF3QnVmZmVyczogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZHJhd19idWZmZXJzXCIpLFxuICAgICAgICBkZXB0aFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2RlcHRoX3RleHR1cmVcIiksXG4gICAgICAgIHZlcnRleEFycmF5T2JqZWN0OiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKSB8fCBnbC5nZXRFeHRlbnNpb24oXCJNT1pfT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpLFxuICAgICAgICB1aW50MzJFbGVtZW50SW5kZXg6IGdsLmdldEV4dGVuc2lvbihcIk9FU19lbGVtZW50X2luZGV4X3VpbnRcIiksXG4gICAgICAgIGZsb2F0VGV4dHVyZTogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksXG4gICAgICAgIGZsb2F0VGV4dHVyZUxpbmVhcjogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpLFxuICAgICAgICB0ZXh0dXJlSGFsZkZsb2F0OiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpLFxuICAgICAgICB0ZXh0dXJlSGFsZkZsb2F0TGluZWFyOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhclwiKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLndlYkdMVmVyc2lvbiA9PT0gMikge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIGNvbW1vbiwge1xuICAgICAgICBjb2xvckJ1ZmZlckZsb2F0OiBnbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ29udGV4dExvc3QoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpICYmIHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dCkge1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQucmVzdG9yZUNvbnRleHQoKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfVxuICBoYW5kbGVDb250ZXh0UmVzdG9yZWQoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuZW1pdCh0aGlzLmdsKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLnJlbmRlcmVyLnZpZXc7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgaWYgKHZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lciAhPT0gdm9pZCAwKSB7XG4gICAgICB2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QpO1xuICAgICAgdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQpO1xuICAgIH1cbiAgICB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCk7XG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dCkge1xuICAgICAgdGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0Lmxvc2VDb250ZXh0KCk7XG4gICAgfVxuICB9XG4gIHBvc3RyZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIub2JqZWN0UmVuZGVyZXIucmVuZGVyaW5nVG9TY3JlZW4pIHtcbiAgICAgIHRoaXMuZ2wuZmx1c2goKTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGVDb250ZXh0KGdsKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gICAgY29uc3QgaXNXZWJHbDIgPSBcIldlYkdMMlJlbmRlcmluZ0NvbnRleHRcIiBpbiBnbG9iYWxUaGlzICYmIGdsIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgIGlmIChpc1dlYkdsMikge1xuICAgICAgdGhpcy53ZWJHTFZlcnNpb24gPSAyO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlcyAmJiAhYXR0cmlidXRlcy5zdGVuY2lsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQcm92aWRlZCBXZWJHTCBjb250ZXh0IGRvZXMgbm90IGhhdmUgYSBzdGVuY2lsIGJ1ZmZlciwgbWFza3MgbWF5IG5vdCByZW5kZXIgY29ycmVjdGx5XCIpO1xuICAgIH1cbiAgICBjb25zdCBoYXN1aW50MzIgPSBpc1dlYkdsMiB8fCAhIWdsLmdldEV4dGVuc2lvbihcIk9FU19lbGVtZW50X2luZGV4X3VpbnRcIik7XG4gICAgdGhpcy5zdXBwb3J0cy51aW50MzJJbmRpY2VzID0gaGFzdWludDMyO1xuICAgIGlmICghaGFzdWludDMyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQcm92aWRlZCBXZWJHTCBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgMzIgaW5kZXggYnVmZmVyLCBjb21wbGV4IGdyYXBoaWNzIG1heSBub3QgcmVuZGVyIGNvcnJlY3RseVwiKTtcbiAgICB9XG4gIH1cbn1cbkNvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGNvbnRleHQ6IG51bGwsXG4gIGFudGlhbGlhczogZmFsc2UsXG4gIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcbiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgcG93ZXJQcmVmZXJlbmNlOiBcImRlZmF1bHRcIlxufTtcbkNvbnRleHRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImNvbnRleHRcIlxufTtcbmV4dGVuc2lvbnMuYWRkKENvbnRleHRTeXN0ZW0pO1xuXG5leHBvcnQgeyBDb250ZXh0U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250ZXh0U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEFMUEhBX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEJ1ZmZlclJlc291cmNlIH0gZnJvbSAnLi9CdWZmZXJSZXNvdXJjZS5tanMnO1xuXG5jbGFzcyBEZXB0aFJlc291cmNlIGV4dGVuZHMgQnVmZmVyUmVzb3VyY2Uge1xuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUuYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5VTlBBQ0spO1xuICAgIGNvbnN0IHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQ7XG4gICAgaWYgKGdsVGV4dHVyZS53aWR0aCA9PT0gd2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgRGVwdGhSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVwdGhSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBNU0FBX1FVQUxJVFksIFNDQUxFX01PREVTLCBNSVBNQVBfTU9ERVMsIEZPUk1BVFMsIFRZUEVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gJ0BwaXhpL3J1bm5lcic7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBEZXB0aFJlc291cmNlIH0gZnJvbSAnLi4vdGV4dHVyZXMvcmVzb3VyY2VzL0RlcHRoUmVzb3VyY2UubWpzJztcblxuY2xhc3MgRnJhbWVidWZmZXIge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgucm91bmQod2lkdGggfHwgMTAwKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0IHx8IDEwMCk7XG4gICAgdGhpcy5zdGVuY2lsID0gZmFsc2U7XG4gICAgdGhpcy5kZXB0aCA9IGZhbHNlO1xuICAgIHRoaXMuZGlydHlJZCA9IDA7XG4gICAgdGhpcy5kaXJ0eUZvcm1hdCA9IDA7XG4gICAgdGhpcy5kaXJ0eVNpemUgPSAwO1xuICAgIHRoaXMuZGVwdGhUZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLmNvbG9yVGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLmdsRnJhbWVidWZmZXJzID0ge307XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcihcImRpc3Bvc2VGcmFtZWJ1ZmZlclwiKTtcbiAgICB0aGlzLm11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk5PTkU7XG4gIH1cbiAgZ2V0IGNvbG9yVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmVzWzBdO1xuICB9XG4gIGFkZENvbG9yVGV4dHVyZShpbmRleCA9IDAsIHRleHR1cmUpIHtcbiAgICB0aGlzLmNvbG9yVGV4dHVyZXNbaW5kZXhdID0gdGV4dHVyZSB8fCBuZXcgQmFzZVRleHR1cmUobnVsbCwge1xuICAgICAgc2NhbGVNb2RlOiBTQ0FMRV9NT0RFUy5ORUFSRVNULFxuICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgIG1pcG1hcDogTUlQTUFQX01PREVTLk9GRixcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH0pO1xuICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIHRoaXMuZGlydHlGb3JtYXQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGREZXB0aFRleHR1cmUodGV4dHVyZSkge1xuICAgIHRoaXMuZGVwdGhUZXh0dXJlID0gdGV4dHVyZSB8fCBuZXcgQmFzZVRleHR1cmUobmV3IERlcHRoUmVzb3VyY2UobnVsbCwgeyB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9KSwge1xuICAgICAgc2NhbGVNb2RlOiBTQ0FMRV9NT0RFUy5ORUFSRVNULFxuICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIG1pcG1hcDogTUlQTUFQX01PREVTLk9GRixcbiAgICAgIGZvcm1hdDogRk9STUFUUy5ERVBUSF9DT01QT05FTlQsXG4gICAgICB0eXBlOiBUWVBFUy5VTlNJR05FRF9TSE9SVFxuICAgIH0pO1xuICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIHRoaXMuZGlydHlGb3JtYXQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbmFibGVEZXB0aCgpIHtcbiAgICB0aGlzLmRlcHRoID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5SWQrKztcbiAgICB0aGlzLmRpcnR5Rm9ybWF0Kys7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5hYmxlU3RlbmNpbCgpIHtcbiAgICB0aGlzLnN0ZW5jaWwgPSB0cnVlO1xuICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIHRoaXMuZGlydHlGb3JtYXQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgIGlmICh3aWR0aCA9PT0gdGhpcy53aWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuaGVpZ2h0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmRpcnR5SWQrKztcbiAgICB0aGlzLmRpcnR5U2l6ZSsrO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xvclRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jb2xvclRleHR1cmVzW2ldO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgIHRleHR1cmUuc2V0U2l6ZSh3aWR0aCAvIHJlc29sdXRpb24sIGhlaWdodCAvIHJlc29sdXRpb24pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZXB0aFRleHR1cmUpIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmRlcHRoVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgdGhpcy5kZXB0aFRleHR1cmUuc2V0U2l6ZSh3aWR0aCAvIHJlc29sdXRpb24sIGhlaWdodCAvIHJlc29sdXRpb24pO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5lbWl0KHRoaXMsIGZhbHNlKTtcbiAgfVxuICBkZXN0cm95RGVwdGhUZXh0dXJlKCkge1xuICAgIGlmICh0aGlzLmRlcHRoVGV4dHVyZSkge1xuICAgICAgdGhpcy5kZXB0aFRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZXB0aFRleHR1cmUgPSBudWxsO1xuICAgICAgKyt0aGlzLmRpcnR5SWQ7XG4gICAgICArK3RoaXMuZGlydHlGb3JtYXQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEZyYW1lYnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GcmFtZWJ1ZmZlci5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ0BwaXhpL2NvbG9yJztcbmltcG9ydCB7IE1TQUFfUVVBTElUWSwgTUlQTUFQX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEZyYW1lYnVmZmVyIH0gZnJvbSAnLi4vZnJhbWVidWZmZXIvRnJhbWVidWZmZXIubWpzJztcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvQmFzZVRleHR1cmUubWpzJztcblxuY2xhc3MgQmFzZVJlbmRlclRleHR1cmUgZXh0ZW5kcyBCYXNlVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgd2lkdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSBhcmd1bWVudHNbMV07XG4gICAgICBjb25zdCBzY2FsZU1vZGUgPSBhcmd1bWVudHNbMl07XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gYXJndW1lbnRzWzNdO1xuICAgICAgb3B0aW9ucyA9IHsgd2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uIH07XG4gICAgfVxuICAgIG9wdGlvbnMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDEwMDtcbiAgICBvcHRpb25zLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDEwMDtcbiAgICBvcHRpb25zLm11bHRpc2FtcGxlID8/IChvcHRpb25zLm11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk5PTkUpO1xuICAgIHN1cGVyKG51bGwsIG9wdGlvbnMpO1xuICAgIHRoaXMubWlwbWFwID0gTUlQTUFQX01PREVTLk9GRjtcbiAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLl9jbGVhciA9IG5ldyBDb2xvcihbMCwgMCwgMCwgMF0pO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIodGhpcy5yZWFsV2lkdGgsIHRoaXMucmVhbEhlaWdodCkuYWRkQ29sb3JUZXh0dXJlKDAsIHRoaXMpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGUgPSBvcHRpb25zLm11bHRpc2FtcGxlO1xuICAgIHRoaXMubWFza1N0YWNrID0gW107XG4gICAgdGhpcy5maWx0ZXJTdGFjayA9IFt7fV07XG4gIH1cbiAgc2V0IGNsZWFyQ29sb3IodmFsdWUpIHtcbiAgICB0aGlzLl9jbGVhci5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IGNsZWFyQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsZWFyLnZhbHVlO1xuICB9XG4gIGdldCBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xlYXI7XG4gIH1cbiAgcmVzaXplKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCkge1xuICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKGRlc2lyZWRXaWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgZGVzaXJlZEhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gICAgdGhpcy5zZXRSZWFsU2l6ZSh0aGlzLmZyYW1lYnVmZmVyLndpZHRoLCB0aGlzLmZyYW1lYnVmZmVyLmhlaWdodCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLmRpc3Bvc2UoKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5kZXN0cm95RGVwdGhUZXh0dXJlKCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmFzZVJlbmRlclRleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VSZW5kZXJUZXh0dXJlLm1qcy5tYXBcbiIsImltcG9ydCB7IEFMUEhBX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IGRldGVybWluZUNyb3NzT3JpZ2luIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuL1Jlc291cmNlLm1qcyc7XG5cbmNsYXNzIEJhc2VJbWFnZVJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBjb25zdCBzb3VyY2VBbnkgPSBzb3VyY2U7XG4gICAgY29uc3Qgd2lkdGggPSBzb3VyY2VBbnkubmF0dXJhbFdpZHRoIHx8IHNvdXJjZUFueS52aWRlb1dpZHRoIHx8IHNvdXJjZUFueS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBzb3VyY2VBbnkubmF0dXJhbEhlaWdodCB8fCBzb3VyY2VBbnkudmlkZW9IZWlnaHQgfHwgc291cmNlQW55LmhlaWdodDtcbiAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLm5vU3ViSW1hZ2UgPSBmYWxzZTtcbiAgfVxuICBzdGF0aWMgY3Jvc3NPcmlnaW4oZWxlbWVudCwgdXJsLCBjcm9zc29yaWdpbikge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdm9pZCAwICYmICF1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICBlbGVtZW50LmNyb3NzT3JpZ2luID0gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odXJsKTtcbiAgICB9IGVsc2UgaWYgKGNyb3Nzb3JpZ2luICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5jcm9zc09yaWdpbiA9IHR5cGVvZiBjcm9zc29yaWdpbiA9PT0gXCJzdHJpbmdcIiA/IGNyb3Nzb3JpZ2luIDogXCJhbm9ueW1vdXNcIjtcbiAgICB9XG4gIH1cbiAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlLCBzb3VyY2UpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGNvbnN0IHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQ7XG4gICAgc291cmNlID0gc291cmNlIHx8IHRoaXMuc291cmNlO1xuICAgIGlmICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSB8fCBzb3VyY2UubmF0dXJhbFdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgIGlmIChzb3VyY2UucmVhZHlTdGF0ZSA8PSAxICYmIHNvdXJjZS5idWZmZXJlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLmFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuVU5QQUNLKTtcbiAgICBpZiAoIXRoaXMubm9TdWJJbWFnZSAmJiBiYXNlVGV4dHVyZS50YXJnZXQgPT09IGdsLlRFWFRVUkVfMkQgJiYgZ2xUZXh0dXJlLndpZHRoID09PSB3aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgc291cmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBjb25zdCB3aWR0aCA9IHNvdXJjZS5uYXR1cmFsV2lkdGggfHwgc291cmNlLnZpZGVvV2lkdGggfHwgc291cmNlLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHNvdXJjZS52aWRlb0hlaWdodCB8fCBzb3VyY2UuaGVpZ2h0O1xuICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHN1cGVyLnVwZGF0ZSgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlSW1hZ2VSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBBTFBIQV9NT0RFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmltcG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9CYXNlSW1hZ2VSZXNvdXJjZS5tanMnO1xuXG5jbGFzcyBJbWFnZVJlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgICBCYXNlSW1hZ2VSZXNvdXJjZS5jcm9zc09yaWdpbihpbWFnZUVsZW1lbnQsIHNvdXJjZSwgb3B0aW9ucy5jcm9zc29yaWdpbik7XG4gICAgICBpbWFnZUVsZW1lbnQuc3JjID0gc291cmNlO1xuICAgICAgc291cmNlID0gaW1hZ2VFbGVtZW50O1xuICAgIH1cbiAgICBzdXBlcihzb3VyY2UpO1xuICAgIGlmICghc291cmNlLmNvbXBsZXRlICYmICEhdGhpcy5fd2lkdGggJiYgISF0aGlzLl9oZWlnaHQpIHtcbiAgICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IDA7XG4gICAgfVxuICAgIHRoaXMudXJsID0gc291cmNlLnNyYztcbiAgICB0aGlzLl9wcm9jZXNzID0gbnVsbDtcbiAgICB0aGlzLnByZXNlcnZlQml0bWFwID0gZmFsc2U7XG4gICAgdGhpcy5jcmVhdGVCaXRtYXAgPSAob3B0aW9ucy5jcmVhdGVCaXRtYXAgPz8gc2V0dGluZ3MuQ1JFQVRFX0lNQUdFX0JJVE1BUCkgJiYgISFnbG9iYWxUaGlzLmNyZWF0ZUltYWdlQml0bWFwO1xuICAgIHRoaXMuYWxwaGFNb2RlID0gdHlwZW9mIG9wdGlvbnMuYWxwaGFNb2RlID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5hbHBoYU1vZGUgOiBudWxsO1xuICAgIHRoaXMuYml0bWFwID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgfVxuICBsb2FkKGNyZWF0ZUJpdG1hcCkge1xuICAgIGlmICh0aGlzLl9sb2FkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZUJpdG1hcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmNyZWF0ZUJpdG1hcCA9IGNyZWF0ZUJpdG1hcDtcbiAgICB9XG4gICAgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgdGhpcy51cmwgPSBzb3VyY2Uuc3JjO1xuICAgICAgY29uc3QgY29tcGxldGVkID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemUoc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNyZWF0ZUJpdG1hcCkge1xuICAgICAgICAgIHJlc29sdmUodGhpcy5wcm9jZXNzKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoc291cmNlLmNvbXBsZXRlICYmIHNvdXJjZS5zcmMpIHtcbiAgICAgICAgY29tcGxldGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2Uub25sb2FkID0gY29tcGxldGVkO1xuICAgICAgICBzb3VyY2Uub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgIHJlamVjdChldmVudCk7XG4gICAgICAgICAgdGhpcy5vbkVycm9yLmVtaXQoZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3MgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzO1xuICAgIH1cbiAgICBpZiAodGhpcy5iaXRtYXAgIT09IG51bGwgfHwgIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgfVxuICAgIGNvbnN0IGNyZWF0ZUltYWdlQml0bWFwID0gZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcDtcbiAgICBjb25zdCBjb3JzID0gIXNvdXJjZS5jcm9zc09yaWdpbiB8fCBzb3VyY2UuY3Jvc3NPcmlnaW4gPT09IFwiYW5vbnltb3VzXCI7XG4gICAgdGhpcy5fcHJvY2VzcyA9IGZldGNoKHNvdXJjZS5zcmMsIHtcbiAgICAgIG1vZGU6IGNvcnMgPyBcImNvcnNcIiA6IFwibm8tY29yc1wiXG4gICAgfSkudGhlbigocikgPT4gci5ibG9iKCkpLnRoZW4oKGJsb2IpID0+IGNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCwge1xuICAgICAgcHJlbXVsdGlwbHlBbHBoYTogdGhpcy5hbHBoYU1vZGUgPT09IG51bGwgfHwgdGhpcy5hbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLlVOUEFDSyA/IFwicHJlbXVsdGlwbHlcIiA6IFwibm9uZVwiXG4gICAgfSkpLnRoZW4oKGJpdG1hcCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5fcHJvY2VzcyA9IG51bGw7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9wcm9jZXNzO1xuICB9XG4gIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5hbHBoYU1vZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGJhc2VUZXh0dXJlLmFscGhhTW9kZSA9IHRoaXMuYWxwaGFNb2RlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY3JlYXRlQml0bWFwKSB7XG4gICAgICByZXR1cm4gc3VwZXIudXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmJpdG1hcCkge1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgICBpZiAoIXRoaXMuYml0bWFwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIudXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlLCB0aGlzLmJpdG1hcCk7XG4gICAgaWYgKCF0aGlzLnByZXNlcnZlQml0bWFwKSB7XG4gICAgICBsZXQgZmxhZyA9IHRydWU7XG4gICAgICBjb25zdCBnbFRleHR1cmVzID0gYmFzZVRleHR1cmUuX2dsVGV4dHVyZXM7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBnbFRleHR1cmVzKSB7XG4gICAgICAgIGNvbnN0IG90aGVyVGV4ID0gZ2xUZXh0dXJlc1trZXldO1xuICAgICAgICBpZiAob3RoZXJUZXggIT09IGdsVGV4dHVyZSAmJiBvdGhlclRleC5kaXJ0eUlkICE9PSBiYXNlVGV4dHVyZS5kaXJ0eUlkKSB7XG4gICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICBpZiAodGhpcy5iaXRtYXAuY2xvc2UpIHtcbiAgICAgICAgICB0aGlzLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYml0bWFwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgIHRoaXMuc291cmNlLm9uZXJyb3IgPSBudWxsO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICBpZiAodGhpcy5iaXRtYXApIHtcbiAgICAgIHRoaXMuYml0bWFwLmNsb3NlKCk7XG4gICAgICB0aGlzLmJpdG1hcCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3Byb2Nlc3MgPSBudWxsO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiB8fCBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgeyBJbWFnZVJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IGdyb3VwRDggfSBmcm9tICdAcGl4aS9tYXRoJztcblxuY2xhc3MgVGV4dHVyZVV2cyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueDAgPSAwO1xuICAgIHRoaXMueTAgPSAwO1xuICAgIHRoaXMueDEgPSAxO1xuICAgIHRoaXMueTEgPSAwO1xuICAgIHRoaXMueDIgPSAxO1xuICAgIHRoaXMueTIgPSAxO1xuICAgIHRoaXMueDMgPSAwO1xuICAgIHRoaXMueTMgPSAxO1xuICAgIHRoaXMudXZzRmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gIH1cbiAgc2V0KGZyYW1lLCBiYXNlRnJhbWUsIHJvdGF0ZSkge1xuICAgIGNvbnN0IHR3ID0gYmFzZUZyYW1lLndpZHRoO1xuICAgIGNvbnN0IHRoID0gYmFzZUZyYW1lLmhlaWdodDtcbiAgICBpZiAocm90YXRlKSB7XG4gICAgICBjb25zdCB3MiA9IGZyYW1lLndpZHRoIC8gMiAvIHR3O1xuICAgICAgY29uc3QgaDIgPSBmcmFtZS5oZWlnaHQgLyAyIC8gdGg7XG4gICAgICBjb25zdCBjWCA9IGZyYW1lLnggLyB0dyArIHcyO1xuICAgICAgY29uc3QgY1kgPSBmcmFtZS55IC8gdGggKyBoMjtcbiAgICAgIHJvdGF0ZSA9IGdyb3VwRDguYWRkKHJvdGF0ZSwgZ3JvdXBEOC5OVyk7XG4gICAgICB0aGlzLngwID0gY1ggKyB3MiAqIGdyb3VwRDgudVgocm90YXRlKTtcbiAgICAgIHRoaXMueTAgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHRoaXMueDEgPSBjWCArIHcyICogZ3JvdXBEOC51WChyb3RhdGUpO1xuICAgICAgdGhpcy55MSA9IGNZICsgaDIgKiBncm91cEQ4LnVZKHJvdGF0ZSk7XG4gICAgICByb3RhdGUgPSBncm91cEQ4LmFkZChyb3RhdGUsIDIpO1xuICAgICAgdGhpcy54MiA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB0aGlzLnkyID0gY1kgKyBoMiAqIGdyb3VwRDgudVkocm90YXRlKTtcbiAgICAgIHJvdGF0ZSA9IGdyb3VwRDguYWRkKHJvdGF0ZSwgMik7XG4gICAgICB0aGlzLngzID0gY1ggKyB3MiAqIGdyb3VwRDgudVgocm90YXRlKTtcbiAgICAgIHRoaXMueTMgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLngwID0gZnJhbWUueCAvIHR3O1xuICAgICAgdGhpcy55MCA9IGZyYW1lLnkgLyB0aDtcbiAgICAgIHRoaXMueDEgPSAoZnJhbWUueCArIGZyYW1lLndpZHRoKSAvIHR3O1xuICAgICAgdGhpcy55MSA9IGZyYW1lLnkgLyB0aDtcbiAgICAgIHRoaXMueDIgPSAoZnJhbWUueCArIGZyYW1lLndpZHRoKSAvIHR3O1xuICAgICAgdGhpcy55MiA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIHRoO1xuICAgICAgdGhpcy54MyA9IGZyYW1lLnggLyB0dztcbiAgICAgIHRoaXMueTMgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcbiAgICB9XG4gICAgdGhpcy51dnNGbG9hdDMyWzBdID0gdGhpcy54MDtcbiAgICB0aGlzLnV2c0Zsb2F0MzJbMV0gPSB0aGlzLnkwO1xuICAgIHRoaXMudXZzRmxvYXQzMlsyXSA9IHRoaXMueDE7XG4gICAgdGhpcy51dnNGbG9hdDMyWzNdID0gdGhpcy55MTtcbiAgICB0aGlzLnV2c0Zsb2F0MzJbNF0gPSB0aGlzLngyO1xuICAgIHRoaXMudXZzRmxvYXQzMls1XSA9IHRoaXMueTI7XG4gICAgdGhpcy51dnNGbG9hdDMyWzZdID0gdGhpcy54MztcbiAgICB0aGlzLnV2c0Zsb2F0MzJbN10gPSB0aGlzLnkzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW0BwaXhpL2NvcmU6VGV4dHVyZVV2cyB4MD0ke3RoaXMueDB9IHkwPSR7dGhpcy55MH0geDE9JHt0aGlzLngxfSB5MT0ke3RoaXMueTF9IHgyPSR7dGhpcy54Mn0geTI9JHt0aGlzLnkyfSB4Mz0ke3RoaXMueDN9IHkzPSR7dGhpcy55M31dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBUZXh0dXJlVXZzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlVXZzLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSwgUG9pbnQgfSBmcm9tICdAcGl4aS9tYXRoJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBUZXh0dXJlQ2FjaGUsIHVpZCwgZ2V0UmVzb2x1dGlvbk9mVXJsIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgQmFzZVRleHR1cmUgfSBmcm9tICcuL0Jhc2VUZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9yZXNvdXJjZXMvSW1hZ2VSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVV2cyB9IGZyb20gJy4vVGV4dHVyZVV2cy5tanMnO1xuXG5jb25zdCBERUZBVUxUX1VWUyA9IG5ldyBUZXh0dXJlVXZzKCk7XG5mdW5jdGlvbiByZW1vdmVBbGxIYW5kbGVycyh0ZXgpIHtcbiAgdGV4LmRlc3Ryb3kgPSBmdW5jdGlvbiBfZW1wdHlEZXN0cm95KCkge1xuICB9O1xuICB0ZXgub24gPSBmdW5jdGlvbiBfZW1wdHlPbigpIHtcbiAgfTtcbiAgdGV4Lm9uY2UgPSBmdW5jdGlvbiBfZW1wdHlPbmNlKCkge1xuICB9O1xuICB0ZXguZW1pdCA9IGZ1bmN0aW9uIF9lbXB0eUVtaXQoKSB7XG4gIH07XG59XG5jbGFzcyBUZXh0dXJlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoYmFzZVRleHR1cmUsIGZyYW1lLCBvcmlnLCB0cmltLCByb3RhdGUsIGFuY2hvciwgYm9yZGVycykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG4gICAgaWYgKCFmcmFtZSkge1xuICAgICAgdGhpcy5ub0ZyYW1lID0gdHJ1ZTtcbiAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcbiAgICB9XG4gICAgaWYgKGJhc2VUZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xuICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XG4gICAgdGhpcy50cmltID0gdHJpbTtcbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5fdXZzID0gREVGQVVMVF9VVlM7XG4gICAgdGhpcy51dk1hdHJpeCA9IG51bGw7XG4gICAgdGhpcy5vcmlnID0gb3JpZyB8fCBmcmFtZTtcbiAgICB0aGlzLl9yb3RhdGUgPSBOdW1iZXIocm90YXRlIHx8IDApO1xuICAgIGlmIChyb3RhdGUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX3JvdGF0ZSA9IDI7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9yb3RhdGUgJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0IHRvIHVzZSBkaWFtb25kLXNoYXBlZCBVVnMuIElmIHlvdSBhcmUgc3VyZSwgc2V0IHJvdGF0aW9uIG1hbnVhbGx5XCIpO1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRBbmNob3IgPSBhbmNob3IgPyBuZXcgUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSA6IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLmRlZmF1bHRCb3JkZXJzID0gYm9yZGVycztcbiAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBbXTtcbiAgICBpZiAoIWJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICBiYXNlVGV4dHVyZS5vbmNlKFwibG9hZGVkXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICBpZiAoYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZChiYXNlVGV4dHVyZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubm9GcmFtZSkge1xuICAgICAgYmFzZVRleHR1cmUub24oXCJ1cGRhdGVcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZSkge1xuICAgICAgdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZS51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgb25CYXNlVGV4dHVyZVVwZGF0ZWQoYmFzZVRleHR1cmUpIHtcbiAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZnJhbWUud2lkdGggPSBiYXNlVGV4dHVyZS53aWR0aDtcbiAgICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IGJhc2VUZXh0dXJlLmhlaWdodDtcbiAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuX2ZyYW1lO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveShkZXN0cm95QmFzZSkge1xuICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlKSB7XG4gICAgICBpZiAoZGVzdHJveUJhc2UpIHtcbiAgICAgICAgY29uc3QgeyByZXNvdXJjZSB9ID0gdGhpcy5iYXNlVGV4dHVyZTtcbiAgICAgICAgaWYgKHJlc291cmNlPy51cmwgJiYgVGV4dHVyZUNhY2hlW3Jlc291cmNlLnVybF0pIHtcbiAgICAgICAgICBUZXh0dXJlLnJlbW92ZUZyb21DYWNoZShyZXNvdXJjZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5iYXNlVGV4dHVyZS5vZmYoXCJsb2FkZWRcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9mcmFtZSA9IG51bGw7XG4gICAgdGhpcy5fdXZzID0gbnVsbDtcbiAgICB0aGlzLnRyaW0gPSBudWxsO1xuICAgIHRoaXMub3JpZyA9IG51bGw7XG4gICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMpO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZWRGcmFtZSA9IHRoaXMuX2ZyYW1lLmNsb25lKCk7XG4gICAgY29uc3QgY2xvbmVkT3JpZyA9IHRoaXMuX2ZyYW1lID09PSB0aGlzLm9yaWcgPyBjbG9uZWRGcmFtZSA6IHRoaXMub3JpZy5jbG9uZSgpO1xuICAgIGNvbnN0IGNsb25lZFRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLmJhc2VUZXh0dXJlLCAhdGhpcy5ub0ZyYW1lICYmIGNsb25lZEZyYW1lLCBjbG9uZWRPcmlnLCB0aGlzLnRyaW0/LmNsb25lKCksIHRoaXMucm90YXRlLCB0aGlzLmRlZmF1bHRBbmNob3IsIHRoaXMuZGVmYXVsdEJvcmRlcnMpO1xuICAgIGlmICh0aGlzLm5vRnJhbWUpIHtcbiAgICAgIGNsb25lZFRleHR1cmUuX2ZyYW1lID0gY2xvbmVkRnJhbWU7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRUZXh0dXJlO1xuICB9XG4gIHVwZGF0ZVV2cygpIHtcbiAgICBpZiAodGhpcy5fdXZzID09PSBERUZBVUxUX1VWUykge1xuICAgICAgdGhpcy5fdXZzID0gbmV3IFRleHR1cmVVdnMoKTtcbiAgICB9XG4gICAgdGhpcy5fdXZzLnNldCh0aGlzLl9mcmFtZSwgdGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5yb3RhdGUpO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gIH1cbiAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zID0ge30sIHN0cmljdCA9IHNldHRpbmdzLlNUUklDVF9URVhUVVJFX0NBQ0hFKSB7XG4gICAgY29uc3QgaXNGcmFtZSA9IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCI7XG4gICAgbGV0IGNhY2hlSWQgPSBudWxsO1xuICAgIGlmIChpc0ZyYW1lKSB7XG4gICAgICBjYWNoZUlkID0gc291cmNlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQmFzZVRleHR1cmUpIHtcbiAgICAgIGlmICghc291cmNlLmNhY2hlSWQpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gb3B0aW9ucz8ucGl4aUlkUHJlZml4IHx8IFwicGl4aWlkXCI7XG4gICAgICAgIHNvdXJjZS5jYWNoZUlkID0gYCR7cHJlZml4fS0ke3VpZCgpfWA7XG4gICAgICAgIEJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUoc291cmNlLCBzb3VyY2UuY2FjaGVJZCk7XG4gICAgICB9XG4gICAgICBjYWNoZUlkID0gc291cmNlLmNhY2hlSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc291cmNlLl9waXhpSWQpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gb3B0aW9ucz8ucGl4aUlkUHJlZml4IHx8IFwicGl4aWlkXCI7XG4gICAgICAgIHNvdXJjZS5fcGl4aUlkID0gYCR7cHJlZml4fV8ke3VpZCgpfWA7XG4gICAgICB9XG4gICAgICBjYWNoZUlkID0gc291cmNlLl9waXhpSWQ7XG4gICAgfVxuICAgIGxldCB0ZXh0dXJlID0gVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xuICAgIGlmIChpc0ZyYW1lICYmIHN0cmljdCAmJiAhdGV4dHVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY2FjaGVJZCBcIiR7Y2FjaGVJZH1cIiBkb2VzIG5vdCBleGlzdCBpbiBUZXh0dXJlQ2FjaGUuYCk7XG4gICAgfVxuICAgIGlmICghdGV4dHVyZSAmJiAhKHNvdXJjZSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnJlc29sdXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gZ2V0UmVzb2x1dGlvbk9mVXJsKHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUobmV3IEJhc2VUZXh0dXJlKHNvdXJjZSwgb3B0aW9ucykpO1xuICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5jYWNoZUlkID0gY2FjaGVJZDtcbiAgICAgIEJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgY2FjaGVJZCk7XG4gICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgY2FjaGVJZCk7XG4gICAgfSBlbHNlIGlmICghdGV4dHVyZSAmJiBzb3VyY2UgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZSkge1xuICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHNvdXJjZSk7XG4gICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgY2FjaGVJZCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG4gIHN0YXRpYyBmcm9tVVJMKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc291cmNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBhdXRvTG9hZDogZmFsc2UgfSwgb3B0aW9ucz8ucmVzb3VyY2VPcHRpb25zKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tKHVybCwgT2JqZWN0LmFzc2lnbih7IHJlc291cmNlT3B0aW9ucyB9LCBvcHRpb25zKSwgZmFsc2UpO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvdXJjZTtcbiAgICBpZiAodGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc291cmNlLmxvYWQoKS50aGVuKCgpID0+IFByb21pc2UucmVzb2x2ZSh0ZXh0dXJlKSk7XG4gIH1cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKEJhc2VUZXh0dXJlLmZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIGZyb21Mb2FkZXIoc291cmNlLCBpbWFnZVVybCwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKHNvdXJjZSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBzY2FsZU1vZGU6IEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLnNjYWxlTW9kZSxcbiAgICAgIHJlc29sdXRpb246IGdldFJlc29sdXRpb25PZlVybChpbWFnZVVybClcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgY29uc3QgeyByZXNvdXJjZSB9ID0gYmFzZVRleHR1cmU7XG4gICAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VSZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2UudXJsID0gaW1hZ2VVcmw7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShiYXNlVGV4dHVyZSk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBuYW1lID0gaW1hZ2VVcmw7XG4gICAgfVxuICAgIEJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgbmFtZSk7XG4gICAgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIG5hbWUpO1xuICAgIGlmIChuYW1lICE9PSBpbWFnZVVybCkge1xuICAgICAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBpbWFnZVVybCk7XG4gICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgaW1hZ2VVcmwpO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLm9uY2UoXCJsb2FkZWRcIiwgKCkgPT4gcmVzb2x2ZSh0ZXh0dXJlKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGFkZFRvQ2FjaGUodGV4dHVyZSwgaWQpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGlmICghdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgIHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgICAgaWYgKFRleHR1cmVDYWNoZVtpZF0gJiYgVGV4dHVyZUNhY2hlW2lkXSAhPT0gdGV4dHVyZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFRleHR1cmUgYWRkZWQgdG8gdGhlIGNhY2hlIHdpdGggYW4gaWQgWyR7aWR9XSB0aGF0IGFscmVhZHkgaGFkIGFuIGVudHJ5YCk7XG4gICAgICB9XG4gICAgICBUZXh0dXJlQ2FjaGVbaWRdID0gdGV4dHVyZTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbW92ZUZyb21DYWNoZSh0ZXh0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0dXJlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlRnJvbUNhY2hlID0gVGV4dHVyZUNhY2hlW3RleHR1cmVdO1xuICAgICAgaWYgKHRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0ZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKHRleHR1cmUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIFRleHR1cmVDYWNoZVt0ZXh0dXJlXTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmVGcm9tQ2FjaGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0ZXh0dXJlPy50ZXh0dXJlQ2FjaGVJZHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKFRleHR1cmVDYWNoZVt0ZXh0dXJlLnRleHR1cmVDYWNoZUlkc1tpXV0gPT09IHRleHR1cmUpIHtcbiAgICAgICAgICBkZWxldGUgVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoID0gMDtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuICB9XG4gIGdldCBmcmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJhbWU7XG4gIH1cbiAgc2V0IGZyYW1lKGZyYW1lKSB7XG4gICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGZyYW1lO1xuICAgIGNvbnN0IHhOb3RGaXQgPSB4ICsgd2lkdGggPiB0aGlzLmJhc2VUZXh0dXJlLndpZHRoO1xuICAgIGNvbnN0IHlOb3RGaXQgPSB5ICsgaGVpZ2h0ID4gdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQ7XG4gICAgaWYgKHhOb3RGaXQgfHwgeU5vdEZpdCkge1xuICAgICAgY29uc3QgcmVsYXRpb25zaGlwID0geE5vdEZpdCAmJiB5Tm90Rml0ID8gXCJhbmRcIiA6IFwib3JcIjtcbiAgICAgIGNvbnN0IGVycm9yWCA9IGBYOiAke3h9ICsgJHt3aWR0aH0gPSAke3ggKyB3aWR0aH0gPiAke3RoaXMuYmFzZVRleHR1cmUud2lkdGh9YDtcbiAgICAgIGNvbnN0IGVycm9yWSA9IGBZOiAke3l9ICsgJHtoZWlnaHR9ID0gJHt5ICsgaGVpZ2h0fSA+ICR7dGhpcy5iYXNlVGV4dHVyZS5oZWlnaHR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGV4dHVyZSBFcnJvcjogZnJhbWUgZG9lcyBub3QgZml0IGluc2lkZSB0aGUgYmFzZSBUZXh0dXJlIGRpbWVuc2lvbnM6ICR7ZXJyb3JYfSAke3JlbGF0aW9uc2hpcH0gJHtlcnJvcll9YCk7XG4gICAgfVxuICAgIHRoaXMudmFsaWQgPSB3aWR0aCAmJiBoZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS52YWxpZDtcbiAgICBpZiAoIXRoaXMudHJpbSAmJiAhdGhpcy5yb3RhdGUpIHtcbiAgICAgIHRoaXMub3JpZyA9IGZyYW1lO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJvdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm90YXRlO1xuICB9XG4gIHNldCByb3RhdGUocm90YXRlKSB7XG4gICAgdGhpcy5fcm90YXRlID0gcm90YXRlO1xuICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIH1cbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZy53aWR0aDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm9yaWcuaGVpZ2h0O1xuICB9XG4gIGNhc3RUb0Jhc2VUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VUZXh0dXJlO1xuICB9XG4gIHN0YXRpYyBnZXQgRU1QVFkoKSB7XG4gICAgaWYgKCFUZXh0dXJlLl9FTVBUWSkge1xuICAgICAgVGV4dHVyZS5fRU1QVFkgPSBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmUoKSk7XG4gICAgICByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9FTVBUWSk7XG4gICAgICByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9FTVBUWS5iYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0dXJlLl9FTVBUWTtcbiAgfVxuICBzdGF0aWMgZ2V0IFdISVRFKCkge1xuICAgIGlmICghVGV4dHVyZS5fV0hJVEUpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKDE2LCAxNik7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IDE2O1xuICAgICAgY2FudmFzLmhlaWdodCA9IDE2O1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDE2LCAxNik7XG4gICAgICBUZXh0dXJlLl9XSElURSA9IG5ldyBUZXh0dXJlKEJhc2VUZXh0dXJlLmZyb20oY2FudmFzKSk7XG4gICAgICByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9XSElURSk7XG4gICAgICByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9XSElURS5iYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0dXJlLl9XSElURTtcbiAgfVxufVxuXG5leHBvcnQgeyBUZXh0dXJlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlLm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlcy9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBCYXNlUmVuZGVyVGV4dHVyZSB9IGZyb20gJy4vQmFzZVJlbmRlclRleHR1cmUubWpzJztcblxuY2xhc3MgUmVuZGVyVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuICBjb25zdHJ1Y3RvcihiYXNlUmVuZGVyVGV4dHVyZSwgZnJhbWUpIHtcbiAgICBzdXBlcihiYXNlUmVuZGVyVGV4dHVyZSwgZnJhbWUpO1xuICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuZmlsdGVyRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyUG9vbEtleSA9IG51bGw7XG4gICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgfVxuICBnZXQgZnJhbWVidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVRleHR1cmUuZnJhbWVidWZmZXI7XG4gIH1cbiAgZ2V0IG11bHRpc2FtcGxlKCkge1xuICAgIHJldHVybiB0aGlzLmZyYW1lYnVmZmVyLm11bHRpc2FtcGxlO1xuICB9XG4gIHNldCBtdWx0aXNhbXBsZSh2YWx1ZSkge1xuICAgIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGUgPSB2YWx1ZTtcbiAgfVxuICByZXNpemUoZGVzaXJlZFdpZHRoLCBkZXNpcmVkSGVpZ2h0LCByZXNpemVCYXNlVGV4dHVyZSA9IHRydWUpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZChkZXNpcmVkV2lkdGggKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChkZXNpcmVkSGVpZ2h0ICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIHRoaXMudmFsaWQgPSB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMDtcbiAgICB0aGlzLl9mcmFtZS53aWR0aCA9IHRoaXMub3JpZy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IHRoaXMub3JpZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKHJlc2l6ZUJhc2VUZXh0dXJlKSB7XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgfVxuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICBjb25zdCB7IGJhc2VUZXh0dXJlIH0gPSB0aGlzO1xuICAgIGlmIChiYXNlVGV4dHVyZS5yZXNvbHV0aW9uID09PSByZXNvbHV0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJhc2VUZXh0dXJlLnNldFJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gICAgdGhpcy5yZXNpemUoYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgZmFsc2UpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVuZGVyVGV4dHVyZShuZXcgQmFzZVJlbmRlclRleHR1cmUob3B0aW9ucykpO1xuICB9XG59XG5cbmV4cG9ydCB7IFJlbmRlclRleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlclRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgTVNBQV9RVUFMSVRZIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IG5leHRQb3cyIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgQmFzZVJlbmRlclRleHR1cmUgfSBmcm9tICcuL0Jhc2VSZW5kZXJUZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJUZXh0dXJlIH0gZnJvbSAnLi9SZW5kZXJUZXh0dXJlLm1qcyc7XG5cbmNsYXNzIFJlbmRlclRleHR1cmVQb29sIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZU9wdGlvbnMpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sID0ge307XG4gICAgdGhpcy50ZXh0dXJlT3B0aW9ucyA9IHRleHR1cmVPcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZW5hYmxlRnVsbFNjcmVlbiA9IGZhbHNlO1xuICAgIHRoaXMuX3BpeGVsc1dpZHRoID0gMDtcbiAgICB0aGlzLl9waXhlbHNIZWlnaHQgPSAwO1xuICB9XG4gIGNyZWF0ZVRleHR1cmUocmVhbFdpZHRoLCByZWFsSGVpZ2h0LCBtdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5OT05FKSB7XG4gICAgY29uc3QgYmFzZVJlbmRlclRleHR1cmUgPSBuZXcgQmFzZVJlbmRlclRleHR1cmUoT2JqZWN0LmFzc2lnbih7XG4gICAgICB3aWR0aDogcmVhbFdpZHRoLFxuICAgICAgaGVpZ2h0OiByZWFsSGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgIG11bHRpc2FtcGxlXG4gICAgfSwgdGhpcy50ZXh0dXJlT3B0aW9ucykpO1xuICAgIHJldHVybiBuZXcgUmVuZGVyVGV4dHVyZShiYXNlUmVuZGVyVGV4dHVyZSk7XG4gIH1cbiAgZ2V0T3B0aW1hbFRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiA9IDEsIG11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk5PTkUpIHtcbiAgICBsZXQga2V5O1xuICAgIG1pbldpZHRoID0gTWF0aC5jZWlsKG1pbldpZHRoICogcmVzb2x1dGlvbiAtIDFlLTYpO1xuICAgIG1pbkhlaWdodCA9IE1hdGguY2VpbChtaW5IZWlnaHQgKiByZXNvbHV0aW9uIC0gMWUtNik7XG4gICAgaWYgKCF0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gfHwgbWluV2lkdGggIT09IHRoaXMuX3BpeGVsc1dpZHRoIHx8IG1pbkhlaWdodCAhPT0gdGhpcy5fcGl4ZWxzSGVpZ2h0KSB7XG4gICAgICBtaW5XaWR0aCA9IG5leHRQb3cyKG1pbldpZHRoKTtcbiAgICAgIG1pbkhlaWdodCA9IG5leHRQb3cyKG1pbkhlaWdodCk7XG4gICAgICBrZXkgPSAoKG1pbldpZHRoICYgNjU1MzUpIDw8IDE2IHwgbWluSGVpZ2h0ICYgNjU1MzUpID4+PiAwO1xuICAgICAgaWYgKG11bHRpc2FtcGxlID4gMSkge1xuICAgICAgICBrZXkgKz0gbXVsdGlzYW1wbGUgKiA0Mjk0OTY3Mjk2O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBtdWx0aXNhbXBsZSA+IDEgPyAtbXVsdGlzYW1wbGUgOiAtMTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRleHR1cmVQb29sW2tleV0pIHtcbiAgICAgIHRoaXMudGV4dHVyZVBvb2xba2V5XSA9IFtdO1xuICAgIH1cbiAgICBsZXQgcmVuZGVyVGV4dHVyZSA9IHRoaXMudGV4dHVyZVBvb2xba2V5XS5wb3AoKTtcbiAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcbiAgICAgIHJlbmRlclRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgbXVsdGlzYW1wbGUpO1xuICAgIH1cbiAgICByZW5kZXJUZXh0dXJlLmZpbHRlclBvb2xLZXkgPSBrZXk7XG4gICAgcmVuZGVyVGV4dHVyZS5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIHJldHVybiByZW5kZXJUZXh0dXJlO1xuICB9XG4gIGdldEZpbHRlclRleHR1cmUoaW5wdXQsIHJlc29sdXRpb24sIG11bHRpc2FtcGxlKSB7XG4gICAgY29uc3QgZmlsdGVyVGV4dHVyZSA9IHRoaXMuZ2V0T3B0aW1hbFRleHR1cmUoaW5wdXQud2lkdGgsIGlucHV0LmhlaWdodCwgcmVzb2x1dGlvbiB8fCBpbnB1dC5yZXNvbHV0aW9uLCBtdWx0aXNhbXBsZSB8fCBNU0FBX1FVQUxJVFkuTk9ORSk7XG4gICAgZmlsdGVyVGV4dHVyZS5maWx0ZXJGcmFtZSA9IGlucHV0LmZpbHRlckZyYW1lO1xuICAgIHJldHVybiBmaWx0ZXJUZXh0dXJlO1xuICB9XG4gIHJldHVyblRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgIGNvbnN0IGtleSA9IHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleTtcbiAgICByZW5kZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVQb29sW2tleV0ucHVzaChyZW5kZXJUZXh0dXJlKTtcbiAgfVxuICByZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRleHR1cmUpIHtcbiAgICB0aGlzLnJldHVyblRleHR1cmUocmVuZGVyVGV4dHVyZSk7XG4gIH1cbiAgY2xlYXIoZGVzdHJveVRleHR1cmVzKSB7XG4gICAgZGVzdHJveVRleHR1cmVzID0gZGVzdHJveVRleHR1cmVzICE9PSBmYWxzZTtcbiAgICBpZiAoZGVzdHJveVRleHR1cmVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlUG9vbCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZVBvb2xbaV07XG4gICAgICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRleHR1cmVzW2pdLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fTtcbiAgfVxuICBzZXRTY3JlZW5TaXplKHNpemUpIHtcbiAgICBpZiAoc2l6ZS53aWR0aCA9PT0gdGhpcy5fcGl4ZWxzV2lkdGggJiYgc2l6ZS5oZWlnaHQgPT09IHRoaXMuX3BpeGVsc0hlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gPSBzaXplLndpZHRoID4gMCAmJiBzaXplLmhlaWdodCA+IDA7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMudGV4dHVyZVBvb2wpIHtcbiAgICAgIGlmICghKE51bWJlcihpKSA8IDApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVQb29sW2ldO1xuICAgICAgaWYgKHRleHR1cmVzKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0ZXh0dXJlc1tqXS5kZXN0cm95KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRleHR1cmVQb29sW2ldID0gW107XG4gICAgfVxuICAgIHRoaXMuX3BpeGVsc1dpZHRoID0gc2l6ZS53aWR0aDtcbiAgICB0aGlzLl9waXhlbHNIZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgfVxufVxuUmVuZGVyVGV4dHVyZVBvb2wuU0NSRUVOX0tFWSA9IC0xO1xuXG5leHBvcnQgeyBSZW5kZXJUZXh0dXJlUG9vbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyVGV4dHVyZVBvb2wubWpzLm1hcFxuIiwiaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuXG5jbGFzcyBRdWFkIGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKFwiYVZlcnRleFBvc2l0aW9uXCIsIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICBdKSkuYWRkSW5kZXgoWzAsIDEsIDMsIDJdKTtcbiAgfVxufVxuXG5leHBvcnQgeyBRdWFkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkLm1qcy5tYXBcbiIsImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uL2dlb21ldHJ5L0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuXG5jbGFzcyBRdWFkVXYgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgLTEsXG4gICAgICAtMSxcbiAgICAgIDEsXG4gICAgICAtMSxcbiAgICAgIDEsXG4gICAgICAxLFxuICAgICAgLTEsXG4gICAgICAxXG4gICAgXSk7XG4gICAgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgXSk7XG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMudmVydGljZXMpO1xuICAgIHRoaXMudXZCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMudXZzKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZShcImFWZXJ0ZXhQb3NpdGlvblwiLCB0aGlzLnZlcnRleEJ1ZmZlcikuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVDb29yZFwiLCB0aGlzLnV2QnVmZmVyKS5hZGRJbmRleChbMCwgMSwgMiwgMCwgMiwgM10pO1xuICB9XG4gIG1hcCh0YXJnZXRUZXh0dXJlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIHRoaXMudXZzWzBdID0geDtcbiAgICB0aGlzLnV2c1sxXSA9IHk7XG4gICAgdGhpcy51dnNbMl0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcbiAgICB0aGlzLnV2c1szXSA9IHk7XG4gICAgdGhpcy51dnNbNF0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcbiAgICB0aGlzLnV2c1s1XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy51dnNbNl0gPSB4O1xuICAgIHRoaXMudXZzWzddID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodDtcbiAgICB4ID0gZGVzdGluYXRpb25GcmFtZS54O1xuICAgIHkgPSBkZXN0aW5hdGlvbkZyYW1lLnk7XG4gICAgdGhpcy52ZXJ0aWNlc1swXSA9IHg7XG4gICAgdGhpcy52ZXJ0aWNlc1sxXSA9IHk7XG4gICAgdGhpcy52ZXJ0aWNlc1syXSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgIHRoaXMudmVydGljZXNbM10gPSB5O1xuICAgIHRoaXMudmVydGljZXNbNF0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aDtcbiAgICB0aGlzLnZlcnRpY2VzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgIHRoaXMudmVydGljZXNbNl0gPSB4O1xuICAgIHRoaXMudmVydGljZXNbN10gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLnZlcnRleEJ1ZmZlci5fdXBkYXRlSUQrKztcbiAgICB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydCB7IFF1YWRVdiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVhZFV2Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1TQUFfUVVBTElUWSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICdAcGl4aS9tYXRoJztcblxuY2xhc3MgRmlsdGVyU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLmxlZ2FjeSA9IGZhbHNlO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG4gICAgdGhpcy5tdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5OT05FO1xuICAgIHRoaXMuc291cmNlRnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHRoaXMuYmluZGluZ1NvdXJjZUZyYW1lID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHRoaXMuYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLmZpbHRlcnMgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyVGV4dHVyZSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmlsdGVyU3RhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlclN0YXRlLm1qcy5tYXBcbiIsImltcG9ydCB7IENMRUFSX01PREVTLCBEUkFXX01PREVTLCBNU0FBX1FVQUxJVFkgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgUG9pbnQsIE1hdHJpeCwgUmVjdGFuZ2xlIH0gZnJvbSAnQHBpeGkvbWF0aCc7XG5pbXBvcnQgeyBSZW5kZXJUZXh0dXJlUG9vbCB9IGZyb20gJy4uL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IFF1YWQgfSBmcm9tICcuLi91dGlscy9RdWFkLm1qcyc7XG5pbXBvcnQgeyBRdWFkVXYgfSBmcm9tICcuLi91dGlscy9RdWFkVXYubWpzJztcbmltcG9ydCB7IEZpbHRlclN0YXRlIH0gZnJvbSAnLi9GaWx0ZXJTdGF0ZS5tanMnO1xuXG5jb25zdCB0ZW1wUG9pbnRzID0gW25ldyBQb2ludCgpLCBuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIG5ldyBQb2ludCgpXTtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jbGFzcyBGaWx0ZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjayA9IFt7fV07XG4gICAgdGhpcy50ZXh0dXJlUG9vbCA9IG5ldyBSZW5kZXJUZXh0dXJlUG9vbCgpO1xuICAgIHRoaXMuc3RhdGVQb29sID0gW107XG4gICAgdGhpcy5xdWFkID0gbmV3IFF1YWQoKTtcbiAgICB0aGlzLnF1YWRVdiA9IG5ldyBRdWFkVXYoKTtcbiAgICB0aGlzLnRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSB7fTtcbiAgICB0aGlzLmdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICBvdXRwdXRGcmFtZTogbmV3IFJlY3RhbmdsZSgpLFxuICAgICAgaW5wdXRTaXplOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgaW5wdXRQaXhlbDogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgIGlucHV0Q2xhbXA6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgZmlsdGVyQXJlYTogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgIGZpbHRlckNsYW1wOiBuZXcgRmxvYXQzMkFycmF5KDQpXG4gICAgfSwgdHJ1ZSk7XG4gICAgdGhpcy5mb3JjZUNsZWFyID0gZmFsc2U7XG4gICAgdGhpcy51c2VNYXhQYWRkaW5nID0gZmFsc2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLnNldFNjcmVlblNpemUodGhpcy5yZW5kZXJlci52aWV3KTtcbiAgfVxuICBwdXNoKHRhcmdldCwgZmlsdGVycykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBmaWx0ZXJTdGFjayA9IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZVBvb2wucG9wKCkgfHwgbmV3IEZpbHRlclN0YXRlKCk7XG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZVN5c3RlbSA9IHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IGZpbHRlcnNbMF0ucmVzb2x1dGlvbjtcbiAgICBsZXQgbXVsdGlzYW1wbGUgPSBmaWx0ZXJzWzBdLm11bHRpc2FtcGxlO1xuICAgIGxldCBwYWRkaW5nID0gZmlsdGVyc1swXS5wYWRkaW5nO1xuICAgIGxldCBhdXRvRml0ID0gZmlsdGVyc1swXS5hdXRvRml0O1xuICAgIGxldCBsZWdhY3kgPSBmaWx0ZXJzWzBdLmxlZ2FjeSA/PyB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyc1tpXTtcbiAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1pbihyZXNvbHV0aW9uLCBmaWx0ZXIucmVzb2x1dGlvbik7XG4gICAgICBtdWx0aXNhbXBsZSA9IE1hdGgubWluKG11bHRpc2FtcGxlLCBmaWx0ZXIubXVsdGlzYW1wbGUpO1xuICAgICAgcGFkZGluZyA9IHRoaXMudXNlTWF4UGFkZGluZyA/IE1hdGgubWF4KHBhZGRpbmcsIGZpbHRlci5wYWRkaW5nKSA6IHBhZGRpbmcgKyBmaWx0ZXIucGFkZGluZztcbiAgICAgIGF1dG9GaXQgPSBhdXRvRml0ICYmIGZpbHRlci5hdXRvRml0O1xuICAgICAgbGVnYWN5ID0gbGVnYWN5IHx8IChmaWx0ZXIubGVnYWN5ID8/IHRydWUpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyU3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1swXS5yZW5kZXJUZXh0dXJlID0gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50O1xuICAgIH1cbiAgICBmaWx0ZXJTdGFjay5wdXNoKHN0YXRlKTtcbiAgICBzdGF0ZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBzdGF0ZS5tdWx0aXNhbXBsZSA9IG11bHRpc2FtcGxlO1xuICAgIHN0YXRlLmxlZ2FjeSA9IGxlZ2FjeTtcbiAgICBzdGF0ZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgc3RhdGUuc291cmNlRnJhbWUuY29weUZyb20odGFyZ2V0LmZpbHRlckFyZWEgfHwgdGFyZ2V0LmdldEJvdW5kcyh0cnVlKSk7XG4gICAgc3RhdGUuc291cmNlRnJhbWUucGFkKHBhZGRpbmcpO1xuICAgIGNvbnN0IHNvdXJjZUZyYW1lUHJvamVjdGVkID0gdGhpcy50ZW1wUmVjdC5jb3B5RnJvbShyZW5kZXJUZXh0dXJlU3lzdGVtLnNvdXJjZUZyYW1lKTtcbiAgICBpZiAocmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtQUFCQih0ZW1wTWF0cml4LmNvcHlGcm9tKHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtKS5pbnZlcnQoKSwgc291cmNlRnJhbWVQcm9qZWN0ZWQpO1xuICAgIH1cbiAgICBpZiAoYXV0b0ZpdCkge1xuICAgICAgc3RhdGUuc291cmNlRnJhbWUuZml0KHNvdXJjZUZyYW1lUHJvamVjdGVkKTtcbiAgICAgIGlmIChzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCA8PSAwIHx8IHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCA8PSAwKSB7XG4gICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoID0gMDtcbiAgICAgICAgc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzdGF0ZS5zb3VyY2VGcmFtZS5pbnRlcnNlY3RzKHNvdXJjZUZyYW1lUHJvamVjdGVkKSkge1xuICAgICAgc3RhdGUuc291cmNlRnJhbWUud2lkdGggPSAwO1xuICAgICAgc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgdGhpcy5yb3VuZEZyYW1lKHN0YXRlLnNvdXJjZUZyYW1lLCByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQgPyByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQucmVzb2x1dGlvbiA6IHJlbmRlcmVyLnJlc29sdXRpb24sIHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUsIHJlbmRlclRleHR1cmVTeXN0ZW0uZGVzdGluYXRpb25GcmFtZSwgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pO1xuICAgIHN0YXRlLnJlbmRlclRleHR1cmUgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoLCBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQsIHJlc29sdXRpb24sIG11bHRpc2FtcGxlKTtcbiAgICBzdGF0ZS5maWx0ZXJzID0gZmlsdGVycztcbiAgICBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gc3RhdGUucmVuZGVyVGV4dHVyZS53aWR0aDtcbiAgICBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHN0YXRlLnJlbmRlclRleHR1cmUuaGVpZ2h0O1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRnJhbWUgPSB0aGlzLnRlbXBSZWN0O1xuICAgIGRlc3RpbmF0aW9uRnJhbWUueCA9IDA7XG4gICAgZGVzdGluYXRpb25GcmFtZS55ID0gMDtcbiAgICBkZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gc3RhdGUuc291cmNlRnJhbWUud2lkdGg7XG4gICAgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQ7XG4gICAgc3RhdGUucmVuZGVyVGV4dHVyZS5maWx0ZXJGcmFtZSA9IHN0YXRlLnNvdXJjZUZyYW1lO1xuICAgIHN0YXRlLmJpbmRpbmdTb3VyY2VGcmFtZS5jb3B5RnJvbShyZW5kZXJUZXh0dXJlU3lzdGVtLnNvdXJjZUZyYW1lKTtcbiAgICBzdGF0ZS5iaW5kaW5nRGVzdGluYXRpb25GcmFtZS5jb3B5RnJvbShyZW5kZXJUZXh0dXJlU3lzdGVtLmRlc3RpbmF0aW9uRnJhbWUpO1xuICAgIHN0YXRlLnRyYW5zZm9ybSA9IHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtO1xuICAgIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gbnVsbDtcbiAgICByZW5kZXJUZXh0dXJlU3lzdGVtLmJpbmQoc3RhdGUucmVuZGVyVGV4dHVyZSwgc3RhdGUuc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpO1xuICAgIHJlbmRlcmVyLmZyYW1lYnVmZmVyLmNsZWFyKDAsIDAsIDAsIDApO1xuICB9XG4gIHBvcCgpIHtcbiAgICBjb25zdCBmaWx0ZXJTdGFjayA9IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrO1xuICAgIGNvbnN0IHN0YXRlID0gZmlsdGVyU3RhY2sucG9wKCk7XG4gICAgY29uc3QgZmlsdGVycyA9IHN0YXRlLmZpbHRlcnM7XG4gICAgdGhpcy5hY3RpdmVTdGF0ZSA9IHN0YXRlO1xuICAgIGNvbnN0IGdsb2JhbFVuaWZvcm1zID0gdGhpcy5nbG9iYWxVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBnbG9iYWxVbmlmb3Jtcy5vdXRwdXRGcmFtZSA9IHN0YXRlLnNvdXJjZUZyYW1lO1xuICAgIGdsb2JhbFVuaWZvcm1zLnJlc29sdXRpb24gPSBzdGF0ZS5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGlucHV0U2l6ZSA9IGdsb2JhbFVuaWZvcm1zLmlucHV0U2l6ZTtcbiAgICBjb25zdCBpbnB1dFBpeGVsID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRQaXhlbDtcbiAgICBjb25zdCBpbnB1dENsYW1wID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRDbGFtcDtcbiAgICBpbnB1dFNpemVbMF0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgIGlucHV0U2l6ZVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgIGlucHV0U2l6ZVsyXSA9IDEgLyBpbnB1dFNpemVbMF07XG4gICAgaW5wdXRTaXplWzNdID0gMSAvIGlucHV0U2l6ZVsxXTtcbiAgICBpbnB1dFBpeGVsWzBdID0gTWF0aC5yb3VuZChpbnB1dFNpemVbMF0gKiBzdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICBpbnB1dFBpeGVsWzFdID0gTWF0aC5yb3VuZChpbnB1dFNpemVbMV0gKiBzdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICBpbnB1dFBpeGVsWzJdID0gMSAvIGlucHV0UGl4ZWxbMF07XG4gICAgaW5wdXRQaXhlbFszXSA9IDEgLyBpbnB1dFBpeGVsWzFdO1xuICAgIGlucHV0Q2xhbXBbMF0gPSAwLjUgKiBpbnB1dFBpeGVsWzJdO1xuICAgIGlucHV0Q2xhbXBbMV0gPSAwLjUgKiBpbnB1dFBpeGVsWzNdO1xuICAgIGlucHV0Q2xhbXBbMl0gPSBzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCAqIGlucHV0U2l6ZVsyXSAtIDAuNSAqIGlucHV0UGl4ZWxbMl07XG4gICAgaW5wdXRDbGFtcFszXSA9IHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCAqIGlucHV0U2l6ZVszXSAtIDAuNSAqIGlucHV0UGl4ZWxbM107XG4gICAgaWYgKHN0YXRlLmxlZ2FjeSkge1xuICAgICAgY29uc3QgZmlsdGVyQXJlYSA9IGdsb2JhbFVuaWZvcm1zLmZpbHRlckFyZWE7XG4gICAgICBmaWx0ZXJBcmVhWzBdID0gc3RhdGUuZGVzdGluYXRpb25GcmFtZS53aWR0aDtcbiAgICAgIGZpbHRlckFyZWFbMV0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcbiAgICAgIGZpbHRlckFyZWFbMl0gPSBzdGF0ZS5zb3VyY2VGcmFtZS54O1xuICAgICAgZmlsdGVyQXJlYVszXSA9IHN0YXRlLnNvdXJjZUZyYW1lLnk7XG4gICAgICBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XG4gICAgfVxuICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMudXBkYXRlKCk7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gZmlsdGVyU3RhY2tbZmlsdGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5ibGl0KCk7XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmaWx0ZXJzWzBdLmFwcGx5KHRoaXMsIHN0YXRlLnJlbmRlclRleHR1cmUsIGxhc3RTdGF0ZS5yZW5kZXJUZXh0dXJlLCBDTEVBUl9NT0RFUy5CTEVORCwgc3RhdGUpO1xuICAgICAgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKHN0YXRlLnJlbmRlclRleHR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZmxpcCA9IHN0YXRlLnJlbmRlclRleHR1cmU7XG4gICAgICBsZXQgZmxvcCA9IHRoaXMuZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUoZmxpcC53aWR0aCwgZmxpcC5oZWlnaHQsIHN0YXRlLnJlc29sdXRpb24pO1xuICAgICAgZmxvcC5maWx0ZXJGcmFtZSA9IGZsaXAuZmlsdGVyRnJhbWU7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT09IDEgJiYgc3RhdGUubXVsdGlzYW1wbGUgPiAxKSB7XG4gICAgICAgICAgZmxvcCA9IHRoaXMuZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUoZmxpcC53aWR0aCwgZmxpcC5oZWlnaHQsIHN0YXRlLnJlc29sdXRpb24pO1xuICAgICAgICAgIGZsb3AuZmlsdGVyRnJhbWUgPSBmbGlwLmZpbHRlckZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgZmxvcCwgQ0xFQVJfTU9ERVMuQ0xFQVIsIHN0YXRlKTtcbiAgICAgICAgY29uc3QgdCA9IGZsaXA7XG4gICAgICAgIGZsaXAgPSBmbG9wO1xuICAgICAgICBmbG9wID0gdDtcbiAgICAgIH1cbiAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgbGFzdFN0YXRlLnJlbmRlclRleHR1cmUsIENMRUFSX01PREVTLkJMRU5ELCBzdGF0ZSk7XG4gICAgICBpZiAoaSA+IDEgJiYgc3RhdGUubXVsdGlzYW1wbGUgPiAxKSB7XG4gICAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShzdGF0ZS5yZW5kZXJUZXh0dXJlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbGlwKTtcbiAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbG9wKTtcbiAgICB9XG4gICAgc3RhdGUuY2xlYXIoKTtcbiAgICB0aGlzLnN0YXRlUG9vbC5wdXNoKHN0YXRlKTtcbiAgfVxuICBiaW5kQW5kQ2xlYXIoZmlsdGVyVGV4dHVyZSwgY2xlYXJNb2RlID0gQ0xFQVJfTU9ERVMuQ0xFQVIpIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJUZXh0dXJlOiByZW5kZXJUZXh0dXJlU3lzdGVtLFxuICAgICAgc3RhdGU6IHN0YXRlU3lzdGVtXG4gICAgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgaWYgKGZpbHRlclRleHR1cmUgPT09IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrW3RoaXMuZGVmYXVsdEZpbHRlclN0YWNrLmxlbmd0aCAtIDFdLnJlbmRlclRleHR1cmUpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSB0aGlzLmFjdGl2ZVN0YXRlLnRyYW5zZm9ybTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJUZXh0dXJlPy5maWx0ZXJGcmFtZSkge1xuICAgICAgY29uc3QgZGVzdGluYXRpb25GcmFtZSA9IHRoaXMudGVtcFJlY3Q7XG4gICAgICBkZXN0aW5hdGlvbkZyYW1lLnggPSAwO1xuICAgICAgZGVzdGluYXRpb25GcmFtZS55ID0gMDtcbiAgICAgIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lLndpZHRoO1xuICAgICAgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lLmhlaWdodDtcbiAgICAgIHJlbmRlclRleHR1cmVTeXN0ZW0uYmluZChmaWx0ZXJUZXh0dXJlLCBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lLCBkZXN0aW5hdGlvbkZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZpbHRlclRleHR1cmUgIT09IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrW3RoaXMuZGVmYXVsdEZpbHRlclN0YWNrLmxlbmd0aCAtIDFdLnJlbmRlclRleHR1cmUpIHtcbiAgICAgIHJlbmRlclRleHR1cmVTeXN0ZW0uYmluZChmaWx0ZXJUZXh0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoZmlsdGVyVGV4dHVyZSwgdGhpcy5hY3RpdmVTdGF0ZS5iaW5kaW5nU291cmNlRnJhbWUsIHRoaXMuYWN0aXZlU3RhdGUuYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUpO1xuICAgIH1cbiAgICBjb25zdCBhdXRvQ2xlYXIgPSBzdGF0ZVN5c3RlbS5zdGF0ZUlkICYgMSB8fCB0aGlzLmZvcmNlQ2xlYXI7XG4gICAgaWYgKGNsZWFyTW9kZSA9PT0gQ0xFQVJfTU9ERVMuQ0xFQVIgfHwgY2xlYXJNb2RlID09PSBDTEVBUl9NT0RFUy5CTElUICYmIGF1dG9DbGVhcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5jbGVhcigwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KGZpbHRlci5zdGF0ZSk7XG4gICAgdGhpcy5iaW5kQW5kQ2xlYXIob3V0cHV0LCBjbGVhck1vZGUpO1xuICAgIGZpbHRlci51bmlmb3Jtcy51U2FtcGxlciA9IGlucHV0O1xuICAgIGZpbHRlci51bmlmb3Jtcy5maWx0ZXJHbG9iYWxzID0gdGhpcy5nbG9iYWxVbmlmb3JtcztcbiAgICByZW5kZXJlci5zaGFkZXIuYmluZChmaWx0ZXIpO1xuICAgIGZpbHRlci5sZWdhY3kgPSAhIWZpbHRlci5wcm9ncmFtLmF0dHJpYnV0ZURhdGEuYVRleHR1cmVDb29yZDtcbiAgICBpZiAoZmlsdGVyLmxlZ2FjeSkge1xuICAgICAgdGhpcy5xdWFkVXYubWFwKGlucHV0Ll9mcmFtZSwgaW5wdXQuZmlsdGVyRnJhbWUpO1xuICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWRVdik7XG4gICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KERSQVdfTU9ERVMuVFJJQU5HTEVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWQpO1xuICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyhEUkFXX01PREVTLlRSSUFOR0xFX1NUUklQKTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgc3ByaXRlKSB7XG4gICAgY29uc3QgeyBzb3VyY2VGcmFtZSwgZGVzdGluYXRpb25GcmFtZSB9ID0gdGhpcy5hY3RpdmVTdGF0ZTtcbiAgICBjb25zdCB7IG9yaWcgfSA9IHNwcml0ZS5fdGV4dHVyZTtcbiAgICBjb25zdCBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguc2V0KGRlc3RpbmF0aW9uRnJhbWUud2lkdGgsIDAsIDAsIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0LCBzb3VyY2VGcmFtZS54LCBzb3VyY2VGcmFtZS55KTtcbiAgICBjb25zdCB3b3JsZFRyYW5zZm9ybSA9IHNwcml0ZS53b3JsZFRyYW5zZm9ybS5jb3B5VG8oTWF0cml4LlRFTVBfTUFUUklYKTtcbiAgICB3b3JsZFRyYW5zZm9ybS5pbnZlcnQoKTtcbiAgICBtYXBwZWRNYXRyaXgucHJlcGVuZCh3b3JsZFRyYW5zZm9ybSk7XG4gICAgbWFwcGVkTWF0cml4LnNjYWxlKDEgLyBvcmlnLndpZHRoLCAxIC8gb3JpZy5oZWlnaHQpO1xuICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoc3ByaXRlLmFuY2hvci54LCBzcHJpdGUuYW5jaG9yLnkpO1xuICAgIHJldHVybiBtYXBwZWRNYXRyaXg7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVQb29sLmNsZWFyKGZhbHNlKTtcbiAgfVxuICBnZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uID0gMSwgbXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORSkge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24sIG11bHRpc2FtcGxlKTtcbiAgfVxuICBnZXRGaWx0ZXJUZXh0dXJlKGlucHV0LCByZXNvbHV0aW9uLCBtdWx0aXNhbXBsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHN3YXAgPSBpbnB1dDtcbiAgICAgIGlucHV0ID0gcmVzb2x1dGlvbjtcbiAgICAgIHJlc29sdXRpb24gPSBzd2FwO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0IHx8IHRoaXMuYWN0aXZlU3RhdGUucmVuZGVyVGV4dHVyZTtcbiAgICBjb25zdCBmaWx0ZXJUZXh0dXJlID0gdGhpcy50ZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShpbnB1dC53aWR0aCwgaW5wdXQuaGVpZ2h0LCByZXNvbHV0aW9uIHx8IGlucHV0LnJlc29sdXRpb24sIG11bHRpc2FtcGxlIHx8IE1TQUFfUVVBTElUWS5OT05FKTtcbiAgICBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gaW5wdXQuZmlsdGVyRnJhbWU7XG4gICAgcmV0dXJuIGZpbHRlclRleHR1cmU7XG4gIH1cbiAgcmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKHJlbmRlclRleHR1cmUpO1xuICB9XG4gIGVtcHR5UG9vbCgpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLmNsZWFyKHRydWUpO1xuICB9XG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLnNldFNjcmVlblNpemUodGhpcy5yZW5kZXJlci52aWV3KTtcbiAgfVxuICB0cmFuc2Zvcm1BQUJCKG1hdHJpeCwgcmVjdCkge1xuICAgIGNvbnN0IGx0ID0gdGVtcFBvaW50c1swXTtcbiAgICBjb25zdCBsYiA9IHRlbXBQb2ludHNbMV07XG4gICAgY29uc3QgcnQgPSB0ZW1wUG9pbnRzWzJdO1xuICAgIGNvbnN0IHJiID0gdGVtcFBvaW50c1szXTtcbiAgICBsdC5zZXQocmVjdC5sZWZ0LCByZWN0LnRvcCk7XG4gICAgbGIuc2V0KHJlY3QubGVmdCwgcmVjdC5ib3R0b20pO1xuICAgIHJ0LnNldChyZWN0LnJpZ2h0LCByZWN0LnRvcCk7XG4gICAgcmIuc2V0KHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICBtYXRyaXguYXBwbHkobHQsIGx0KTtcbiAgICBtYXRyaXguYXBwbHkobGIsIGxiKTtcbiAgICBtYXRyaXguYXBwbHkocnQsIHJ0KTtcbiAgICBtYXRyaXguYXBwbHkocmIsIHJiKTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWluKGx0LngsIGxiLngsIHJ0LngsIHJiLngpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5taW4obHQueSwgbGIueSwgcnQueSwgcmIueSk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1heChsdC54LCBsYi54LCBydC54LCByYi54KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KGx0LnksIGxiLnksIHJ0LnksIHJiLnkpO1xuICAgIHJlY3QueCA9IHgwO1xuICAgIHJlY3QueSA9IHkwO1xuICAgIHJlY3Qud2lkdGggPSB4MSAtIHgwO1xuICAgIHJlY3QuaGVpZ2h0ID0geTEgLSB5MDtcbiAgfVxuICByb3VuZEZyYW1lKGZyYW1lLCByZXNvbHV0aW9uLCBiaW5kaW5nU291cmNlRnJhbWUsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoZnJhbWUud2lkdGggPD0gMCB8fCBmcmFtZS5oZWlnaHQgPD0gMCB8fCBiaW5kaW5nU291cmNlRnJhbWUud2lkdGggPD0gMCB8fCBiaW5kaW5nU291cmNlRnJhbWUuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSB0cmFuc2Zvcm07XG4gICAgICBpZiAoKE1hdGguYWJzKGIpID4gMWUtNCB8fCBNYXRoLmFicyhjKSA+IDFlLTQpICYmIChNYXRoLmFicyhhKSA+IDFlLTQgfHwgTWF0aC5hYnMoZCkgPiAxZS00KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybSA/IHRlbXBNYXRyaXguY29weUZyb20odHJhbnNmb3JtKSA6IHRlbXBNYXRyaXguaWRlbnRpdHkoKTtcbiAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKC1iaW5kaW5nU291cmNlRnJhbWUueCwgLWJpbmRpbmdTb3VyY2VGcmFtZS55KS5zY2FsZShiaW5kaW5nRGVzdGluYXRpb25GcmFtZS53aWR0aCAvIGJpbmRpbmdTb3VyY2VGcmFtZS53aWR0aCwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gYmluZGluZ1NvdXJjZUZyYW1lLmhlaWdodCkudHJhbnNsYXRlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLngsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLnkpO1xuICAgIHRoaXMudHJhbnNmb3JtQUFCQih0cmFuc2Zvcm0sIGZyYW1lKTtcbiAgICBmcmFtZS5jZWlsKHJlc29sdXRpb24pO1xuICAgIHRoaXMudHJhbnNmb3JtQUFCQih0cmFuc2Zvcm0uaW52ZXJ0KCksIGZyYW1lKTtcbiAgfVxufVxuRmlsdGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJmaWx0ZXJcIlxufTtcbmV4dGVuc2lvbnMuYWRkKEZpbHRlclN5c3RlbSk7XG5cbmV4cG9ydCB7IEZpbHRlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IE1TQUFfUVVBTElUWSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5cbmNsYXNzIEdMRnJhbWVidWZmZXIge1xuICBjb25zdHJ1Y3RvcihmcmFtZWJ1ZmZlcikge1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcbiAgICB0aGlzLnN0ZW5jaWwgPSBudWxsO1xuICAgIHRoaXMuZGlydHlJZCA9IC0xO1xuICAgIHRoaXMuZGlydHlGb3JtYXQgPSAtMTtcbiAgICB0aGlzLmRpcnR5U2l6ZSA9IC0xO1xuICAgIHRoaXMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORTtcbiAgICB0aGlzLm1zYWFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYmxpdEZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLm1pcExldmVsID0gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBHTEZyYW1lYnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTEZyYW1lYnVmZmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEVOViwgQlVGRkVSX0JJVFMsIE1TQUFfUVVBTElUWSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICdAcGl4aS9tYXRoJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgRnJhbWVidWZmZXIgfSBmcm9tICcuL0ZyYW1lYnVmZmVyLm1qcyc7XG5pbXBvcnQgeyBHTEZyYW1lYnVmZmVyIH0gZnJvbSAnLi9HTEZyYW1lYnVmZmVyLm1qcyc7XG5cbmNvbnN0IHRlbXBSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKCk7XG5jbGFzcyBGcmFtZWJ1ZmZlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycyA9IFtdO1xuICAgIHRoaXMudW5rbm93bkZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyKDEwLCAxMCk7XG4gICAgdGhpcy5tc2FhU2FtcGxlcyA9IG51bGw7XG4gIH1cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VBbGwodHJ1ZSk7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnVua25vd25GcmFtZWJ1ZmZlcjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHRoaXMuaGFzTVJUID0gdHJ1ZTtcbiAgICB0aGlzLndyaXRlRGVwdGhUZXh0dXJlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgbGV0IG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZHJhd0J1ZmZlcnM7XG4gICAgICBsZXQgbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZGVwdGhUZXh0dXJlO1xuICAgICAgaWYgKHNldHRpbmdzLlBSRUZFUl9FTlYgPT09IEVOVi5XRUJHTF9MRUdBQ1kpIHtcbiAgICAgICAgbmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24gPSBudWxsO1xuICAgICAgICBuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uKSB7XG4gICAgICAgIGdsLmRyYXdCdWZmZXJzID0gKGFjdGl2ZVRleHR1cmVzKSA9PiBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbi5kcmF3QnVmZmVyc1dFQkdMKGFjdGl2ZVRleHR1cmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFzTVJUID0gZmFsc2U7XG4gICAgICAgIGdsLmRyYXdCdWZmZXJzID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24pIHtcbiAgICAgICAgdGhpcy53cml0ZURlcHRoVGV4dHVyZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1zYWFTYW1wbGVzID0gZ2wuZ2V0SW50ZXJuYWxmb3JtYXRQYXJhbWV0ZXIoZ2wuUkVOREVSQlVGRkVSLCBnbC5SR0JBOCwgZ2wuU0FNUExFUyk7XG4gICAgfVxuICB9XG4gIGJpbmQoZnJhbWVidWZmZXIsIGZyYW1lLCBtaXBMZXZlbCA9IDApIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0gfHwgdGhpcy5pbml0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudCAhPT0gZnJhbWVidWZmZXIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gZnJhbWVidWZmZXI7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvLmZyYW1lYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChmYm8ubWlwTGV2ZWwgIT09IG1pcExldmVsKSB7XG4gICAgICAgIGZyYW1lYnVmZmVyLmRpcnR5SWQrKztcbiAgICAgICAgZnJhbWVidWZmZXIuZGlydHlGb3JtYXQrKztcbiAgICAgICAgZmJvLm1pcExldmVsID0gbWlwTGV2ZWw7XG4gICAgICB9XG4gICAgICBpZiAoZmJvLmRpcnR5SWQgIT09IGZyYW1lYnVmZmVyLmRpcnR5SWQpIHtcbiAgICAgICAgZmJvLmRpcnR5SWQgPSBmcmFtZWJ1ZmZlci5kaXJ0eUlkO1xuICAgICAgICBpZiAoZmJvLmRpcnR5Rm9ybWF0ICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eUZvcm1hdCkge1xuICAgICAgICAgIGZiby5kaXJ0eUZvcm1hdCA9IGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0O1xuICAgICAgICAgIGZiby5kaXJ0eVNpemUgPSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemU7XG4gICAgICAgICAgdGhpcy51cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlciwgbWlwTGV2ZWwpO1xuICAgICAgICB9IGVsc2UgaWYgKGZiby5kaXJ0eVNpemUgIT09IGZyYW1lYnVmZmVyLmRpcnR5U2l6ZSkge1xuICAgICAgICAgIGZiby5kaXJ0eVNpemUgPSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemU7XG4gICAgICAgICAgdGhpcy5yZXNpemVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0ZXggPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUudW5iaW5kKHRleC5wYXJlbnRUZXh0dXJlQXJyYXkgfHwgdGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgIGNvbnN0IG1pcFdpZHRoID0gZnJhbWUud2lkdGggPj4gbWlwTGV2ZWw7XG4gICAgICAgIGNvbnN0IG1pcEhlaWdodCA9IGZyYW1lLmhlaWdodCA+PiBtaXBMZXZlbDtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBtaXBXaWR0aCAvIGZyYW1lLndpZHRoO1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KGZyYW1lLnggKiBzY2FsZSwgZnJhbWUueSAqIHNjYWxlLCBtaXBXaWR0aCwgbWlwSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pcFdpZHRoID0gZnJhbWVidWZmZXIud2lkdGggPj4gbWlwTGV2ZWw7XG4gICAgICAgIGNvbnN0IG1pcEhlaWdodCA9IGZyYW1lYnVmZmVyLmhlaWdodCA+PiBtaXBMZXZlbDtcbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCgwLCAwLCBtaXBXaWR0aCwgbWlwSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoZnJhbWUueCwgZnJhbWUueSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIHRoaXMucmVuZGVyZXIud2lkdGgsIHRoaXMucmVuZGVyZXIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0Vmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLnZpZXdwb3J0O1xuICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgIGlmICh2LndpZHRoICE9PSB3aWR0aCB8fCB2LmhlaWdodCAhPT0gaGVpZ2h0IHx8IHYueCAhPT0geCB8fCB2LnkgIT09IHkpIHtcbiAgICAgIHYueCA9IHg7XG4gICAgICB2LnkgPSB5O1xuICAgICAgdi53aWR0aCA9IHdpZHRoO1xuICAgICAgdi5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmdsLnZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogdGhpcy5jdXJyZW50LndpZHRoLCBoZWlnaHQ6IHRoaXMuY3VycmVudC5oZWlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IHRoaXMucmVuZGVyZXIud2lkdGgsIGhlaWdodDogdGhpcy5yZW5kZXJlci5oZWlnaHQgfTtcbiAgfVxuICBjbGVhcihyLCBnLCBiLCBhLCBtYXNrID0gQlVGRkVSX0JJVFMuQ09MT1IgfCBCVUZGRVJfQklUUy5ERVBUSCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcbiAgICBnbC5jbGVhcihtYXNrKTtcbiAgfVxuICBpbml0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZibyA9IG5ldyBHTEZyYW1lYnVmZmVyKGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCkpO1xuICAgIGZiby5tdWx0aXNhbXBsZSA9IHRoaXMuZGV0ZWN0U2FtcGxlcyhmcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZSk7XG4gICAgZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0gPSBmYm87XG4gICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLnB1c2goZnJhbWVidWZmZXIpO1xuICAgIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpO1xuICAgIHJldHVybiBmYm87XG4gIH1cbiAgcmVzaXplRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGlmIChmYm8uc3RlbmNpbCkge1xuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKTtcbiAgICAgIGlmIChmYm8ubXNhYUJ1ZmZlcikge1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXVsdGlzYW1wbGUsIGdsLkRFUFRIMjRfU1RFTkNJTDgsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb2xvclRleHR1cmVzID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcztcbiAgICBsZXQgY291bnQgPSBjb2xvclRleHR1cmVzLmxlbmd0aDtcbiAgICBpZiAoIWdsLmRyYXdCdWZmZXJzKSB7XG4gICAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCAxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY29sb3JUZXh0dXJlc1tpXTtcbiAgICAgIGNvbnN0IHBhcmVudFRleHR1cmUgPSB0ZXh0dXJlLnBhcmVudFRleHR1cmVBcnJheSB8fCB0ZXh0dXJlO1xuICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQocGFyZW50VGV4dHVyZSwgMCk7XG4gICAgICBpZiAoaSA9PT0gMCAmJiBmYm8ubXNhYUJ1ZmZlcikge1xuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZmJvLm1zYWFCdWZmZXIpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXVsdGlzYW1wbGUsIHBhcmVudFRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0uaW50ZXJuYWxGb3JtYXQsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlICYmIHRoaXMud3JpdGVEZXB0aFRleHR1cmUpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5iaW5kKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSwgMCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyLCBtaXBMZXZlbCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgY29uc3QgY29sb3JUZXh0dXJlcyA9IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXM7XG4gICAgbGV0IGNvdW50ID0gY29sb3JUZXh0dXJlcy5sZW5ndGg7XG4gICAgaWYgKCFnbC5kcmF3QnVmZmVycykge1xuICAgICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgMSk7XG4gICAgfVxuICAgIGlmIChmYm8ubXVsdGlzYW1wbGUgPiAxICYmIHRoaXMuY2FuTXVsdGlzYW1wbGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikpIHtcbiAgICAgIGZiby5tc2FhQnVmZmVyID0gZmJvLm1zYWFCdWZmZXIgfHwgZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgfSBlbHNlIGlmIChmYm8ubXNhYUJ1ZmZlcikge1xuICAgICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGZiby5tc2FhQnVmZmVyKTtcbiAgICAgIGZiby5tc2FhQnVmZmVyID0gbnVsbDtcbiAgICAgIGlmIChmYm8uYmxpdEZyYW1lYnVmZmVyKSB7XG4gICAgICAgIGZiby5ibGl0RnJhbWVidWZmZXIuZGlzcG9zZSgpO1xuICAgICAgICBmYm8uYmxpdEZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWN0aXZlVGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBjb2xvclRleHR1cmVzW2ldO1xuICAgICAgY29uc3QgcGFyZW50VGV4dHVyZSA9IHRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5IHx8IHRleHR1cmU7XG4gICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChwYXJlbnRUZXh0dXJlLCAwKTtcbiAgICAgIGlmIChpID09PSAwICYmIGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXNhYUJ1ZmZlcik7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShnbC5SRU5ERVJCVUZGRVIsIGZiby5tdWx0aXNhbXBsZSwgcGFyZW50VGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS5pbnRlcm5hbEZvcm1hdCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXNhYUJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCB0ZXh0dXJlLnRhcmdldCwgcGFyZW50VGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS50ZXh0dXJlLCBtaXBMZXZlbCk7XG4gICAgICAgIGFjdGl2ZVRleHR1cmVzLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFjdGl2ZVRleHR1cmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGdsLmRyYXdCdWZmZXJzKGFjdGl2ZVRleHR1cmVzKTtcbiAgICB9XG4gICAgaWYgKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSkge1xuICAgICAgY29uc3Qgd3JpdGVEZXB0aFRleHR1cmUgPSB0aGlzLndyaXRlRGVwdGhUZXh0dXJlO1xuICAgICAgaWYgKHdyaXRlRGVwdGhUZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IGRlcHRoVGV4dHVyZSA9IGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoZGVwdGhUZXh0dXJlLCAwKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIGRlcHRoVGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS50ZXh0dXJlLCBtaXBMZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoZnJhbWVidWZmZXIuc3RlbmNpbCB8fCBmcmFtZWJ1ZmZlci5kZXB0aCkgJiYgIShmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUgJiYgdGhpcy53cml0ZURlcHRoVGV4dHVyZSkpIHtcbiAgICAgIGZiby5zdGVuY2lsID0gZmJvLnN0ZW5jaWwgfHwgZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgICAgaWYgKGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShnbC5SRU5ERVJCVUZGRVIsIGZiby5tdWx0aXNhbXBsZSwgZ2wuREVQVEgyNF9TVEVOQ0lMOCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKTtcbiAgICB9IGVsc2UgaWYgKGZiby5zdGVuY2lsKSB7XG4gICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoZmJvLnN0ZW5jaWwpO1xuICAgICAgZmJvLnN0ZW5jaWwgPSBudWxsO1xuICAgIH1cbiAgfVxuICBjYW5NdWx0aXNhbXBsZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gIT09IDEgJiYgZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcy5sZW5ndGggPD0gMSAmJiAhZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlO1xuICB9XG4gIGRldGVjdFNhbXBsZXMoc2FtcGxlcykge1xuICAgIGNvbnN0IHsgbXNhYVNhbXBsZXMgfSA9IHRoaXM7XG4gICAgbGV0IHJlcyA9IE1TQUFfUVVBTElUWS5OT05FO1xuICAgIGlmIChzYW1wbGVzIDw9IDEgfHwgbXNhYVNhbXBsZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNhYVNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtc2FhU2FtcGxlc1tpXSA8PSBzYW1wbGVzKSB7XG4gICAgICAgIHJlcyA9IG1zYWFTYW1wbGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlcyA9PT0gMSkge1xuICAgICAgcmVzID0gTVNBQV9RVUFMSVRZLk5PTkU7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgYmxpdChmcmFtZWJ1ZmZlciwgc291cmNlUGl4ZWxzLCBkZXN0UGl4ZWxzKSB7XG4gICAgY29uc3QgeyBjdXJyZW50LCByZW5kZXJlciwgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGlmIChyZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiAhPT0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmJvID0gY3VycmVudC5nbEZyYW1lYnVmZmVyc1tDT05URVhUX1VJRF07XG4gICAgaWYgKCFmYm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFmcmFtZWJ1ZmZlcikge1xuICAgICAgaWYgKCFmYm8ubXNhYUJ1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb2xvclRleHR1cmUgPSBjdXJyZW50LmNvbG9yVGV4dHVyZXNbMF07XG4gICAgICBpZiAoIWNvbG9yVGV4dHVyZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWZiby5ibGl0RnJhbWVidWZmZXIpIHtcbiAgICAgICAgZmJvLmJsaXRGcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcihjdXJyZW50LndpZHRoLCBjdXJyZW50LmhlaWdodCk7XG4gICAgICAgIGZiby5ibGl0RnJhbWVidWZmZXIuYWRkQ29sb3JUZXh0dXJlKDAsIGNvbG9yVGV4dHVyZSk7XG4gICAgICB9XG4gICAgICBmcmFtZWJ1ZmZlciA9IGZiby5ibGl0RnJhbWVidWZmZXI7XG4gICAgICBpZiAoZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlc1swXSAhPT0gY29sb3JUZXh0dXJlKSB7XG4gICAgICAgIGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbMF0gPSBjb2xvclRleHR1cmU7XG4gICAgICAgIGZyYW1lYnVmZmVyLmRpcnR5SWQrKztcbiAgICAgICAgZnJhbWVidWZmZXIuZGlydHlGb3JtYXQrKztcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZWJ1ZmZlci53aWR0aCAhPT0gY3VycmVudC53aWR0aCB8fCBmcmFtZWJ1ZmZlci5oZWlnaHQgIT09IGN1cnJlbnQuaGVpZ2h0KSB7XG4gICAgICAgIGZyYW1lYnVmZmVyLndpZHRoID0gY3VycmVudC53aWR0aDtcbiAgICAgICAgZnJhbWVidWZmZXIuaGVpZ2h0ID0gY3VycmVudC5oZWlnaHQ7XG4gICAgICAgIGZyYW1lYnVmZmVyLmRpcnR5SWQrKztcbiAgICAgICAgZnJhbWVidWZmZXIuZGlydHlTaXplKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc291cmNlUGl4ZWxzKSB7XG4gICAgICBzb3VyY2VQaXhlbHMgPSB0ZW1wUmVjdGFuZ2xlO1xuICAgICAgc291cmNlUGl4ZWxzLndpZHRoID0gY3VycmVudC53aWR0aDtcbiAgICAgIHNvdXJjZVBpeGVscy5oZWlnaHQgPSBjdXJyZW50LmhlaWdodDtcbiAgICB9XG4gICAgaWYgKCFkZXN0UGl4ZWxzKSB7XG4gICAgICBkZXN0UGl4ZWxzID0gc291cmNlUGl4ZWxzO1xuICAgIH1cbiAgICBjb25zdCBzYW1lU2l6ZSA9IHNvdXJjZVBpeGVscy53aWR0aCA9PT0gZGVzdFBpeGVscy53aWR0aCAmJiBzb3VyY2VQaXhlbHMuaGVpZ2h0ID09PSBkZXN0UGl4ZWxzLmhlaWdodDtcbiAgICB0aGlzLmJpbmQoZnJhbWVidWZmZXIpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCBmYm8uZnJhbWVidWZmZXIpO1xuICAgIGdsLmJsaXRGcmFtZWJ1ZmZlcihzb3VyY2VQaXhlbHMubGVmdCwgc291cmNlUGl4ZWxzLnRvcCwgc291cmNlUGl4ZWxzLnJpZ2h0LCBzb3VyY2VQaXhlbHMuYm90dG9tLCBkZXN0UGl4ZWxzLmxlZnQsIGRlc3RQaXhlbHMudG9wLCBkZXN0UGl4ZWxzLnJpZ2h0LCBkZXN0UGl4ZWxzLmJvdHRvbSwgZ2wuQ09MT1JfQlVGRkVSX0JJVCwgc2FtZVNpemUgPyBnbC5ORUFSRVNUIDogZ2wuTElORUFSKTtcbiAgfVxuICBkaXNwb3NlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIsIGNvbnRleHRMb3N0KSB7XG4gICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGlmICghZmJvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycy5pbmRleE9mKGZyYW1lYnVmZmVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xuICAgIGlmICghY29udGV4dExvc3QpIHtcbiAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZiby5mcmFtZWJ1ZmZlcik7XG4gICAgICBpZiAoZmJvLm1zYWFCdWZmZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGZiby5tc2FhQnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChmYm8uc3RlbmNpbCkge1xuICAgICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoZmJvLnN0ZW5jaWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmJvLmJsaXRGcmFtZWJ1ZmZlcikge1xuICAgICAgdGhpcy5kaXNwb3NlRnJhbWVidWZmZXIoZmJvLmJsaXRGcmFtZWJ1ZmZlciwgY29udGV4dExvc3QpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlQWxsKGNvbnRleHRMb3N0KSB7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycztcbiAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZGlzcG9zZUZyYW1lYnVmZmVyKGxpc3RbaV0sIGNvbnRleHRMb3N0KTtcbiAgICB9XG4gIH1cbiAgZm9yY2VTdGVuY2lsKCkge1xuICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZnJhbWVidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKCFmYm8gfHwgZmJvLnN0ZW5jaWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnJhbWVidWZmZXIuc3RlbmNpbCA9IHRydWU7XG4gICAgY29uc3QgdyA9IGZyYW1lYnVmZmVyLndpZHRoO1xuICAgIGNvbnN0IGggPSBmcmFtZWJ1ZmZlci5oZWlnaHQ7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHN0ZW5jaWwgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbCk7XG4gICAgaWYgKGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXVsdGlzYW1wbGUsIGdsLkRFUFRIMjRfU1RFTkNJTDgsIHcsIGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgdywgaCk7XG4gICAgfVxuICAgIGZiby5zdGVuY2lsID0gc3RlbmNpbDtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWwpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMudW5rbm93bkZyYW1lYnVmZmVyO1xuICAgIHRoaXMudmlld3BvcnQgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuRnJhbWVidWZmZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImZyYW1lYnVmZmVyXCJcbn07XG5leHRlbnNpb25zLmFkZChGcmFtZWJ1ZmZlclN5c3RlbSk7XG5cbmV4cG9ydCB7IEZyYW1lYnVmZmVyU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GcmFtZWJ1ZmZlclN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFTlYsIEJVRkZFUl9UWVBFIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuXG5jb25zdCBieXRlU2l6ZU1hcCA9IHsgNTEyNjogNCwgNTEyMzogMiwgNTEyMTogMSB9O1xuY2xhc3MgR2VvbWV0cnlTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcbiAgICB0aGlzLmhhc1ZhbyA9IHRydWU7XG4gICAgdGhpcy5oYXNJbnN0YW5jZSA9IHRydWU7XG4gICAgdGhpcy5jYW5Vc2VVSW50MzJFbGVtZW50SW5kZXggPSBmYWxzZTtcbiAgICB0aGlzLm1hbmFnZWRHZW9tZXRyaWVzID0ge307XG4gIH1cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VBbGwodHJ1ZSk7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5yZW5kZXJlci5jb250ZXh0O1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICAgIGlmIChjb250ZXh0LndlYkdMVmVyc2lvbiAhPT0gMikge1xuICAgICAgbGV0IG5hdGl2ZVZhb0V4dGVuc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLnZlcnRleEFycmF5T2JqZWN0O1xuICAgICAgaWYgKHNldHRpbmdzLlBSRUZFUl9FTlYgPT09IEVOVi5XRUJHTF9MRUdBQ1kpIHtcbiAgICAgICAgbmF0aXZlVmFvRXh0ZW5zaW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChuYXRpdmVWYW9FeHRlbnNpb24pIHtcbiAgICAgICAgZ2wuY3JlYXRlVmVydGV4QXJyYXkgPSAoKSA9PiBuYXRpdmVWYW9FeHRlbnNpb24uY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5ID0gKHZhbykgPT4gbmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8pO1xuICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSA9ICh2YW8pID0+IG5hdGl2ZVZhb0V4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh2YW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYXNWYW8gPSBmYWxzZTtcbiAgICAgICAgZ2wuY3JlYXRlVmVydGV4QXJyYXkgPSAoKSA9PiBudWxsO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkgPSAoKSA9PiBudWxsO1xuICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSA9ICgpID0+IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0LndlYkdMVmVyc2lvbiAhPT0gMikge1xuICAgICAgY29uc3QgaW5zdGFuY2VFeHQgPSBnbC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xuICAgICAgaWYgKGluc3RhbmNlRXh0KSB7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IgPSAoYSwgYikgPT4gaW5zdGFuY2VFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGEsIGIpO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQgPSAoYSwgYiwgYywgZCwgZSkgPT4gaW5zdGFuY2VFeHQuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoYSwgYiwgYywgZCwgZSk7XG4gICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQgPSAoYSwgYiwgYywgZCkgPT4gaW5zdGFuY2VFeHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKGEsIGIsIGMsIGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYXNJbnN0YW5jZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhblVzZVVJbnQzMkVsZW1lbnRJbmRleCA9IGNvbnRleHQud2ViR0xWZXJzaW9uID09PSAyIHx8ICEhY29udGV4dC5leHRlbnNpb25zLnVpbnQzMkVsZW1lbnRJbmRleDtcbiAgfVxuICBiaW5kKGdlb21ldHJ5LCBzaGFkZXIpIHtcbiAgICBzaGFkZXIgPSBzaGFkZXIgfHwgdGhpcy5yZW5kZXJlci5zaGFkZXIuc2hhZGVyO1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgbGV0IHZhb3MgPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBsZXQgaW5jUmVmQ291bnQgPSBmYWxzZTtcbiAgICBpZiAoIXZhb3MpIHtcbiAgICAgIHRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdID0gZ2VvbWV0cnk7XG4gICAgICBnZW9tZXRyeS5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICAgIGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdID0gdmFvcyA9IHt9O1xuICAgICAgaW5jUmVmQ291bnQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB2YW8gPSB2YW9zW3NoYWRlci5wcm9ncmFtLmlkXSB8fCB0aGlzLmluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgc2hhZGVyLCBpbmNSZWZDb3VudCk7XG4gICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICBpZiAodGhpcy5fYWN0aXZlVmFvICE9PSB2YW8pIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVZhbyA9IHZhbztcbiAgICAgIGlmICh0aGlzLmhhc1Zhbykge1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHNoYWRlci5wcm9ncmFtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51cGRhdGVCdWZmZXJzKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy51bmJpbmQoKTtcbiAgfVxuICB1cGRhdGVCdWZmZXJzKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fYWN0aXZlR2VvbWV0cnk7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5yZW5kZXJlci5idWZmZXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBnZW9tZXRyeS5idWZmZXJzW2ldO1xuICAgICAgYnVmZmVyU3lzdGVtLnVwZGF0ZShidWZmZXIpO1xuICAgIH1cbiAgfVxuICBjaGVja0NvbXBhdGliaWxpdHkoZ2VvbWV0cnksIHByb2dyYW0pIHtcbiAgICBjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHNoYWRlckF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgZm9yIChjb25zdCBqIGluIHNoYWRlckF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghZ2VvbWV0cnlBdHRyaWJ1dGVzW2pdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2hhZGVyIGFuZCBnZW9tZXRyeSBpbmNvbXBhdGlibGUsIGdlb21ldHJ5IG1pc3NpbmcgdGhlIFwiJHtqfVwiIGF0dHJpYnV0ZWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRTaWduYXR1cmUoZ2VvbWV0cnksIHByb2dyYW0pIHtcbiAgICBjb25zdCBhdHRyaWJzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBjb25zdCBzaGFkZXJBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhO1xuICAgIGNvbnN0IHN0cmluZ3MgPSBbXCJnXCIsIGdlb21ldHJ5LmlkXTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gYXR0cmlicykge1xuICAgICAgaWYgKHNoYWRlckF0dHJpYnV0ZXNbaV0pIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKGksIHNoYWRlckF0dHJpYnV0ZXNbaV0ubG9jYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5ncy5qb2luKFwiLVwiKTtcbiAgfVxuICBpbml0R2VvbWV0cnlWYW8oZ2VvbWV0cnksIHNoYWRlciwgaW5jUmVmQ291bnQgPSB0cnVlKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IENPTlRFWFRfVUlEID0gdGhpcy5DT05URVhUX1VJRDtcbiAgICBjb25zdCBidWZmZXJTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLmJ1ZmZlcjtcbiAgICBjb25zdCBwcm9ncmFtID0gc2hhZGVyLnByb2dyYW07XG4gICAgaWYgKCFwcm9ncmFtLmdsUHJvZ3JhbXNbQ09OVEVYVF9VSURdKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNoYWRlci5nZW5lcmF0ZVByb2dyYW0oc2hhZGVyKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja0NvbXBhdGliaWxpdHkoZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICBjb25zdCB2YW9PYmplY3RIYXNoID0gZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgbGV0IHZhbyA9IHZhb09iamVjdEhhc2hbc2lnbmF0dXJlXTtcbiAgICBpZiAodmFvKSB7XG4gICAgICB2YW9PYmplY3RIYXNoW3Byb2dyYW0uaWRdID0gdmFvO1xuICAgICAgcmV0dXJuIHZhbztcbiAgICB9XG4gICAgY29uc3QgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnM7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgdGVtcFN0cmlkZSA9IHt9O1xuICAgIGNvbnN0IHRlbXBTdGFydCA9IHt9O1xuICAgIGZvciAoY29uc3QgaiBpbiBidWZmZXJzKSB7XG4gICAgICB0ZW1wU3RyaWRlW2pdID0gMDtcbiAgICAgIHRlbXBTdGFydFtqXSA9IDA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWF0dHJpYnV0ZXNbal0uc2l6ZSAmJiBwcm9ncmFtLmF0dHJpYnV0ZURhdGFbal0pIHtcbiAgICAgICAgYXR0cmlidXRlc1tqXS5zaXplID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2pdLnNpemU7XG4gICAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzW2pdLnNpemUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQSVhJIEdlb21ldHJ5IGF0dHJpYnV0ZSAnJHtqfScgc2l6ZSBjYW5ub3QgYmUgZGV0ZXJtaW5lZCAobGlrZWx5IHRoZSBib3VuZCBzaGFkZXIgZG9lcyBub3QgaGF2ZSB0aGUgYXR0cmlidXRlKWApO1xuICAgICAgfVxuICAgICAgdGVtcFN0cmlkZVthdHRyaWJ1dGVzW2pdLmJ1ZmZlcl0gKz0gYXR0cmlidXRlc1tqXS5zaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlc1tqXS50eXBlXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICBjb25zdCBhdHRyaWJTaXplID0gYXR0cmlidXRlLnNpemU7XG4gICAgICBpZiAoYXR0cmlidXRlLnN0cmlkZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0ZW1wU3RyaWRlW2F0dHJpYnV0ZS5idWZmZXJdID09PSBhdHRyaWJTaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdKSB7XG4gICAgICAgICAgYXR0cmlidXRlLnN0cmlkZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0cmlidXRlLnN0cmlkZSA9IHRlbXBTdHJpZGVbYXR0cmlidXRlLmJ1ZmZlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUuc3RhcnQgPT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGUuc3RhcnQgPSB0ZW1wU3RhcnRbYXR0cmlidXRlLmJ1ZmZlcl07XG4gICAgICAgIHRlbXBTdGFydFthdHRyaWJ1dGUuYnVmZmVyXSArPSBhdHRyaWJTaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdO1xuICAgICAgfVxuICAgIH1cbiAgICB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgIGJ1ZmZlclN5c3RlbS5iaW5kKGJ1ZmZlcik7XG4gICAgICBpZiAoaW5jUmVmQ291bnQpIHtcbiAgICAgICAgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLnJlZkNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIHZhb09iamVjdEhhc2hbcHJvZ3JhbS5pZF0gPSB2YW87XG4gICAgdmFvT2JqZWN0SGFzaFtzaWduYXR1cmVdID0gdmFvO1xuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgICBidWZmZXJTeXN0ZW0udW5iaW5kKEJVRkZFUl9UWVBFLkFSUkFZX0JVRkZFUik7XG4gICAgcmV0dXJuIHZhbztcbiAgfVxuICBkaXNwb3NlR2VvbWV0cnkoZ2VvbWV0cnksIGNvbnRleHRMb3N0KSB7XG4gICAgaWYgKCF0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5tYW5hZ2VkR2VvbWV0cmllc1tnZW9tZXRyeS5pZF07XG4gICAgY29uc3QgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYnVmZmVycztcbiAgICBjb25zdCBidWZmZXJTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyPy5idWZmZXI7XG4gICAgZ2VvbWV0cnkuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgaWYgKCF2YW9zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChidWZmZXJTeXN0ZW0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBidWYgPSBidWZmZXJzW2ldLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIGlmIChidWYpIHtcbiAgICAgICAgICBidWYucmVmQ291bnQtLTtcbiAgICAgICAgICBpZiAoYnVmLnJlZkNvdW50ID09PSAwICYmICFjb250ZXh0TG9zdCkge1xuICAgICAgICAgICAgYnVmZmVyU3lzdGVtLmRpc3Bvc2UoYnVmZmVyc1tpXSwgY29udGV4dExvc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICBmb3IgKGNvbnN0IHZhb0lkIGluIHZhb3MpIHtcbiAgICAgICAgaWYgKHZhb0lkWzBdID09PSBcImdcIikge1xuICAgICAgICAgIGNvbnN0IHZhbyA9IHZhb3NbdmFvSWRdO1xuICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWYW8gPT09IHZhbykge1xuICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkodmFvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF07XG4gIH1cbiAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEdlb21ldHJpZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VHZW9tZXRyeSh0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2FsbFtpXV0sIGNvbnRleHRMb3N0KTtcbiAgICB9XG4gIH1cbiAgYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgQ09OVEVYVF9VSUQgPSB0aGlzLkNPTlRFWFRfVUlEO1xuICAgIGNvbnN0IGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgYnVmZmVyU3lzdGVtLmJpbmQoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpO1xuICAgIH1cbiAgICBsZXQgbGFzdEJ1ZmZlciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF07XG4gICAgICBpZiAocHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2pdKSB7XG4gICAgICAgIGlmIChsYXN0QnVmZmVyICE9PSBnbEJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlclN5c3RlbS5iaW5kKGJ1ZmZlcik7XG4gICAgICAgICAgbGFzdEJ1ZmZlciA9IGdsQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2pdLmxvY2F0aW9uO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGF0dHJpYnV0ZS5zaXplLCBhdHRyaWJ1dGUudHlwZSB8fCBnbC5GTE9BVCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQsIGF0dHJpYnV0ZS5zdHJpZGUsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNJbnN0YW5jZSkge1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgYXR0cmlidXRlLmRpdmlzb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyeSBlcnJvciwgR1BVIEluc3RhbmNpbmcgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhdyh0eXBlLCBzaXplLCBzdGFydCwgaW5zdGFuY2VDb3VudCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9hY3RpdmVHZW9tZXRyeTtcbiAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcbiAgICAgIGNvbnN0IGJ5dGVTaXplID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIGNvbnN0IGdsVHlwZSA9IGJ5dGVTaXplID09PSAyID8gZ2wuVU5TSUdORURfU0hPUlQgOiBnbC5VTlNJR05FRF9JTlQ7XG4gICAgICBpZiAoYnl0ZVNpemUgPT09IDIgfHwgYnl0ZVNpemUgPT09IDQgJiYgdGhpcy5jYW5Vc2VVSW50MzJFbGVtZW50SW5kZXgpIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5Lmluc3RhbmNlZCkge1xuICAgICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbFR5cGUsIChzdGFydCB8fCAwKSAqIGJ5dGVTaXplLCBpbnN0YW5jZUNvdW50IHx8IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbFR5cGUsIChzdGFydCB8fCAwKSAqIGJ5dGVTaXplKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidW5zdXBwb3J0ZWQgaW5kZXggYnVmZmVyIHR5cGU6IHVpbnQzMlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5Lmluc3RhbmNlZCkge1xuICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZCh0eXBlLCBzdGFydCwgc2l6ZSB8fCBnZW9tZXRyeS5nZXRTaXplKCksIGluc3RhbmNlQ291bnQgfHwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRyYXdBcnJheXModHlwZSwgc3RhcnQsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdW5iaW5kKCkge1xuICAgIHRoaXMuZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkdlb21ldHJ5U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJnZW9tZXRyeVwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoR2VvbWV0cnlTeXN0ZW0pO1xuXG5leHBvcnQgeyBHZW9tZXRyeVN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VvbWV0cnlTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnQHBpeGkvbWF0aCc7XG5cbmNvbnN0IHRlbXBNYXQgPSBuZXcgTWF0cml4KCk7XG5jbGFzcyBUZXh0dXJlTWF0cml4IHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgY2xhbXBNYXJnaW4pIHtcbiAgICB0aGlzLl90ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLm1hcENvb3JkID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMudUNsYW1wRnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHRoaXMudUNsYW1wT2Zmc2V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgdGhpcy5jbGFtcE9mZnNldCA9IDA7XG4gICAgdGhpcy5jbGFtcE1hcmdpbiA9IHR5cGVvZiBjbGFtcE1hcmdpbiA9PT0gXCJ1bmRlZmluZWRcIiA/IDAuNSA6IGNsYW1wTWFyZ2luO1xuICAgIHRoaXMuaXNTaW1wbGUgPSBmYWxzZTtcbiAgfVxuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcbiAgfVxuICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMuX3RleHR1cmUgPSB2YWx1ZTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgfVxuICBtdWx0aXBseVV2cyh1dnMsIG91dCkge1xuICAgIGlmIChvdXQgPT09IHZvaWQgMCkge1xuICAgICAgb3V0ID0gdXZzO1xuICAgIH1cbiAgICBjb25zdCBtYXQgPSB0aGlzLm1hcENvb3JkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXZzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gdXZzW2ldO1xuICAgICAgY29uc3QgeSA9IHV2c1tpICsgMV07XG4gICAgICBvdXRbaV0gPSB4ICogbWF0LmEgKyB5ICogbWF0LmMgKyBtYXQudHg7XG4gICAgICBvdXRbaSArIDFdID0geCAqIG1hdC5iICsgeSAqIG1hdC5kICsgbWF0LnR5O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHVwZGF0ZShmb3JjZVVwZGF0ZSkge1xuICAgIGNvbnN0IHRleCA9IHRoaXMuX3RleHR1cmU7XG4gICAgaWYgKCF0ZXggfHwgIXRleC52YWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWZvcmNlVXBkYXRlICYmIHRoaXMuX3RleHR1cmVJRCA9PT0gdGV4Ll91cGRhdGVJRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0dXJlSUQgPSB0ZXguX3VwZGF0ZUlEO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgY29uc3QgdXZzID0gdGV4Ll91dnM7XG4gICAgdGhpcy5tYXBDb29yZC5zZXQodXZzLngxIC0gdXZzLngwLCB1dnMueTEgLSB1dnMueTAsIHV2cy54MyAtIHV2cy54MCwgdXZzLnkzIC0gdXZzLnkwLCB1dnMueDAsIHV2cy55MCk7XG4gICAgY29uc3Qgb3JpZyA9IHRleC5vcmlnO1xuICAgIGNvbnN0IHRyaW0gPSB0ZXgudHJpbTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgdGVtcE1hdC5zZXQob3JpZy53aWR0aCAvIHRyaW0ud2lkdGgsIDAsIDAsIG9yaWcuaGVpZ2h0IC8gdHJpbS5oZWlnaHQsIC10cmltLnggLyB0cmltLndpZHRoLCAtdHJpbS55IC8gdHJpbS5oZWlnaHQpO1xuICAgICAgdGhpcy5tYXBDb29yZC5hcHBlbmQodGVtcE1hdCk7XG4gICAgfVxuICAgIGNvbnN0IHRleEJhc2UgPSB0ZXguYmFzZVRleHR1cmU7XG4gICAgY29uc3QgZnJhbWUgPSB0aGlzLnVDbGFtcEZyYW1lO1xuICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuY2xhbXBNYXJnaW4gLyB0ZXhCYXNlLnJlc29sdXRpb247XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jbGFtcE9mZnNldDtcbiAgICBmcmFtZVswXSA9ICh0ZXguX2ZyYW1lLnggKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcbiAgICBmcmFtZVsxXSA9ICh0ZXguX2ZyYW1lLnkgKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS5oZWlnaHQ7XG4gICAgZnJhbWVbMl0gPSAodGV4Ll9mcmFtZS54ICsgdGV4Ll9mcmFtZS53aWR0aCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoO1xuICAgIGZyYW1lWzNdID0gKHRleC5fZnJhbWUueSArIHRleC5fZnJhbWUuaGVpZ2h0IC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgIHRoaXMudUNsYW1wT2Zmc2V0WzBdID0gb2Zmc2V0IC8gdGV4QmFzZS5yZWFsV2lkdGg7XG4gICAgdGhpcy51Q2xhbXBPZmZzZXRbMV0gPSBvZmZzZXQgLyB0ZXhCYXNlLnJlYWxIZWlnaHQ7XG4gICAgdGhpcy5pc1NpbXBsZSA9IHRleC5fZnJhbWUud2lkdGggPT09IHRleEJhc2Uud2lkdGggJiYgdGV4Ll9mcmFtZS5oZWlnaHQgPT09IHRleEJhc2UuaGVpZ2h0ICYmIHRleC5yb3RhdGUgPT09IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgVGV4dHVyZU1hdHJpeCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZU1hdHJpeC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2TWFza0Nvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hc2s7XFxudW5pZm9ybSBmbG9hdCBhbHBoYTtcXG51bmlmb3JtIGZsb2F0IG5wbUFscGhhO1xcbnVuaWZvcm0gdmVjNCBtYXNrQ2xhbXA7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBmbG9hdCBjbGlwID0gc3RlcCgzLjUsXFxuICAgICAgICBzdGVwKG1hc2tDbGFtcC54LCB2TWFza0Nvb3JkLngpICtcXG4gICAgICAgIHN0ZXAobWFza0NsYW1wLnksIHZNYXNrQ29vcmQueSkgK1xcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLngsIG1hc2tDbGFtcC56KSArXFxuICAgICAgICBzdGVwKHZNYXNrQ29vcmQueSwgbWFza0NsYW1wLncpKTtcXG5cXG4gICAgdmVjNCBvcmlnaW5hbCA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIHZlYzQgbWFza3kgPSB0ZXh0dXJlMkQobWFzaywgdk1hc2tDb29yZCk7XFxuICAgIGZsb2F0IGFscGhhTXVsID0gMS4wIC0gbnBtQWxwaGEgKiAoMS4wIC0gbWFza3kuYSk7XFxuXFxuICAgIG9yaWdpbmFsICo9IChhbHBoYU11bCAqIG1hc2t5LnIgKiBhbHBoYSAqIGNsaXApO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBvcmlnaW5hbDtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZU1hc2tGaWx0ZXIyLm1qcy5tYXBcbiIsInZhciB2ZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyBvdGhlck1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdk1hc2tDb29yZCA9ICggb3RoZXJNYXRyaXggKiB2ZWMzKCBhVGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgdmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZU1hc2tGaWx0ZXIzLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJ0BwaXhpL21hdGgnO1xuaW1wb3J0IHsgVGV4dHVyZU1hdHJpeCB9IGZyb20gJy4uLy4uL3RleHR1cmVzL1RleHR1cmVNYXRyaXgubWpzJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL0ZpbHRlci5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vc3ByaXRlTWFza0ZpbHRlcjIubWpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi9zcHJpdGVNYXNrRmlsdGVyMy5tanMnO1xuXG5jbGFzcyBTcHJpdGVNYXNrRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpIHtcbiAgICBsZXQgc3ByaXRlID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHZlcnRleFNyYyAhPT0gXCJzdHJpbmdcIiAmJiBmcmFnbWVudFNyYyA9PT0gdm9pZCAwICYmIHVuaWZvcm1zID09PSB2b2lkIDApIHtcbiAgICAgIHNwcml0ZSA9IHZlcnRleFNyYztcbiAgICAgIHZlcnRleFNyYyA9IHZvaWQgMDtcbiAgICAgIGZyYWdtZW50U3JjID0gdm9pZCAwO1xuICAgICAgdW5pZm9ybXMgPSB2b2lkIDA7XG4gICAgfVxuICAgIHN1cGVyKHZlcnRleFNyYyB8fCB2ZXJ0ZXgsIGZyYWdtZW50U3JjIHx8IGZyYWdtZW50LCB1bmlmb3Jtcyk7XG4gICAgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xuICAgIHRoaXMubWFza01hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgfVxuICBnZXQgbWFza1Nwcml0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFza1Nwcml0ZTtcbiAgfVxuICBzZXQgbWFza1Nwcml0ZSh2YWx1ZSkge1xuICAgIHRoaXMuX21hc2tTcHJpdGUgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5fbWFza1Nwcml0ZSkge1xuICAgICAgdGhpcy5fbWFza1Nwcml0ZS5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGNvbnN0IG1hc2tTcHJpdGUgPSB0aGlzLl9tYXNrU3ByaXRlO1xuICAgIGNvbnN0IHRleCA9IG1hc2tTcHJpdGUuX3RleHR1cmU7XG4gICAgaWYgKCF0ZXgudmFsaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0ZXgudXZNYXRyaXgpIHtcbiAgICAgIHRleC51dk1hdHJpeCA9IG5ldyBUZXh0dXJlTWF0cml4KHRleCwgMCk7XG4gICAgfVxuICAgIHRleC51dk1hdHJpeC51cGRhdGUoKTtcbiAgICB0aGlzLnVuaWZvcm1zLm5wbUFscGhhID0gdGV4LmJhc2VUZXh0dXJlLmFscGhhTW9kZSA/IDAgOiAxO1xuICAgIHRoaXMudW5pZm9ybXMubWFzayA9IHRleDtcbiAgICB0aGlzLnVuaWZvcm1zLm90aGVyTWF0cml4ID0gZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVTcHJpdGVNYXRyaXgodGhpcy5tYXNrTWF0cml4LCBtYXNrU3ByaXRlKS5wcmVwZW5kKHRleC51dk1hdHJpeC5tYXBDb29yZCk7XG4gICAgdGhpcy51bmlmb3Jtcy5hbHBoYSA9IG1hc2tTcHJpdGUud29ybGRBbHBoYTtcbiAgICB0aGlzLnVuaWZvcm1zLm1hc2tDbGFtcCA9IHRleC51dk1hdHJpeC51Q2xhbXBGcmFtZTtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU3ByaXRlTWFza0ZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlTWFza0ZpbHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBNQVNLX1RZUEVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL2ZpbHRlcnMvRmlsdGVyLm1qcyc7XG5cbmNsYXNzIE1hc2tEYXRhIHtcbiAgY29uc3RydWN0b3IobWFza09iamVjdCA9IG51bGwpIHtcbiAgICB0aGlzLnR5cGUgPSBNQVNLX1RZUEVTLk5PTkU7XG4gICAgdGhpcy5hdXRvRGV0ZWN0ID0gdHJ1ZTtcbiAgICB0aGlzLm1hc2tPYmplY3QgPSBtYXNrT2JqZWN0IHx8IG51bGw7XG4gICAgdGhpcy5wb29sZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzTWFza0RhdGEgPSB0cnVlO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG51bGw7XG4gICAgdGhpcy5tdWx0aXNhbXBsZSA9IEZpbHRlci5kZWZhdWx0TXVsdGlzYW1wbGU7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNvbG9yTWFzayA9IDE1O1xuICAgIHRoaXMuX2ZpbHRlcnMgPSBudWxsO1xuICAgIHRoaXMuX3N0ZW5jaWxDb3VudGVyID0gMDtcbiAgICB0aGlzLl9zY2lzc29yQ291bnRlciA9IDA7XG4gICAgdGhpcy5fc2Npc3NvclJlY3QgPSBudWxsO1xuICAgIHRoaXMuX3NjaXNzb3JSZWN0TG9jYWwgPSBudWxsO1xuICAgIHRoaXMuX2NvbG9yTWFzayA9IDE1O1xuICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gIH1cbiAgZ2V0IGZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVycyA/IHRoaXMuX2ZpbHRlcnNbMF0gOiBudWxsO1xuICB9XG4gIHNldCBmaWx0ZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9maWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnNbMF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMgPSBbdmFsdWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9maWx0ZXJzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMucG9vbGVkKSB7XG4gICAgICB0aGlzLm1hc2tPYmplY3QgPSBudWxsO1xuICAgICAgdGhpcy50eXBlID0gTUFTS19UWVBFUy5OT05FO1xuICAgICAgdGhpcy5hdXRvRGV0ZWN0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9zY2lzc29yUmVjdExvY2FsID0gbnVsbDtcbiAgfVxuICBjb3B5Q291bnRlcnNPclJlc2V0KG1hc2tBYm92ZSkge1xuICAgIGlmIChtYXNrQWJvdmUpIHtcbiAgICAgIHRoaXMuX3N0ZW5jaWxDb3VudGVyID0gbWFza0Fib3ZlLl9zdGVuY2lsQ291bnRlcjtcbiAgICAgIHRoaXMuX3NjaXNzb3JDb3VudGVyID0gbWFza0Fib3ZlLl9zY2lzc29yQ291bnRlcjtcbiAgICAgIHRoaXMuX3NjaXNzb3JSZWN0ID0gbWFza0Fib3ZlLl9zY2lzc29yUmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RlbmNpbENvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5fc2Npc3NvckNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5fc2Npc3NvclJlY3QgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBNYXNrRGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFza0RhdGEubWpzLm1hcFxuIiwiaW1wb3J0IHsgTUFTS19UWVBFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBTcHJpdGVNYXNrRmlsdGVyIH0gZnJvbSAnLi4vZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXIubWpzJztcbmltcG9ydCB7IE1hc2tEYXRhIH0gZnJvbSAnLi9NYXNrRGF0YS5tanMnO1xuXG5jbGFzcyBNYXNrU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5lbmFibGVTY2lzc29yID0gdHJ1ZTtcbiAgICB0aGlzLmFscGhhTWFza1Bvb2wgPSBbXTtcbiAgICB0aGlzLm1hc2tEYXRhUG9vbCA9IFtdO1xuICAgIHRoaXMubWFza1N0YWNrID0gW107XG4gICAgdGhpcy5hbHBoYU1hc2tJbmRleCA9IDA7XG4gIH1cbiAgc2V0TWFza1N0YWNrKG1hc2tTdGFjaykge1xuICAgIHRoaXMubWFza1N0YWNrID0gbWFza1N0YWNrO1xuICAgIHRoaXMucmVuZGVyZXIuc2Npc3Nvci5zZXRNYXNrU3RhY2sobWFza1N0YWNrKTtcbiAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwuc2V0TWFza1N0YWNrKG1hc2tTdGFjayk7XG4gIH1cbiAgcHVzaCh0YXJnZXQsIG1hc2tEYXRhT3JUYXJnZXQpIHtcbiAgICBsZXQgbWFza0RhdGEgPSBtYXNrRGF0YU9yVGFyZ2V0O1xuICAgIGlmICghbWFza0RhdGEuaXNNYXNrRGF0YSkge1xuICAgICAgY29uc3QgZCA9IHRoaXMubWFza0RhdGFQb29sLnBvcCgpIHx8IG5ldyBNYXNrRGF0YSgpO1xuICAgICAgZC5wb29sZWQgPSB0cnVlO1xuICAgICAgZC5tYXNrT2JqZWN0ID0gbWFza0RhdGFPclRhcmdldDtcbiAgICAgIG1hc2tEYXRhID0gZDtcbiAgICB9XG4gICAgY29uc3QgbWFza0Fib3ZlID0gdGhpcy5tYXNrU3RhY2subGVuZ3RoICE9PSAwID8gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIG1hc2tEYXRhLmNvcHlDb3VudGVyc09yUmVzZXQobWFza0Fib3ZlKTtcbiAgICBtYXNrRGF0YS5fY29sb3JNYXNrID0gbWFza0Fib3ZlID8gbWFza0Fib3ZlLl9jb2xvck1hc2sgOiAxNTtcbiAgICBpZiAobWFza0RhdGEuYXV0b0RldGVjdCkge1xuICAgICAgdGhpcy5kZXRlY3QobWFza0RhdGEpO1xuICAgIH1cbiAgICBtYXNrRGF0YS5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmIChtYXNrRGF0YS50eXBlICE9PSBNQVNLX1RZUEVTLlNQUklURSkge1xuICAgICAgdGhpcy5tYXNrU3RhY2sucHVzaChtYXNrRGF0YSk7XG4gICAgfVxuICAgIGlmIChtYXNrRGF0YS5lbmFibGVkKSB7XG4gICAgICBzd2l0Y2ggKG1hc2tEYXRhLnR5cGUpIHtcbiAgICAgICAgY2FzZSBNQVNLX1RZUEVTLlNDSVNTT1I6XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zY2lzc29yLnB1c2gobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1BU0tfVFlQRVMuU1RFTkNJTDpcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwucHVzaChtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5TUFJJVEU6XG4gICAgICAgICAgbWFza0RhdGEuY29weUNvdW50ZXJzT3JSZXNldChudWxsKTtcbiAgICAgICAgICB0aGlzLnB1c2hTcHJpdGVNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNQVNLX1RZUEVTLkNPTE9SOlxuICAgICAgICAgIHRoaXMucHVzaENvbG9yTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXNrRGF0YS50eXBlID09PSBNQVNLX1RZUEVTLlNQUklURSkge1xuICAgICAgdGhpcy5tYXNrU3RhY2sucHVzaChtYXNrRGF0YSk7XG4gICAgfVxuICB9XG4gIHBvcCh0YXJnZXQpIHtcbiAgICBjb25zdCBtYXNrRGF0YSA9IHRoaXMubWFza1N0YWNrLnBvcCgpO1xuICAgIGlmICghbWFza0RhdGEgfHwgbWFza0RhdGEuX3RhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXNrRGF0YS5lbmFibGVkKSB7XG4gICAgICBzd2l0Y2ggKG1hc2tEYXRhLnR5cGUpIHtcbiAgICAgICAgY2FzZSBNQVNLX1RZUEVTLlNDSVNTT1I6XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zY2lzc29yLnBvcChtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5TVEVOQ0lMOlxuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5wb3AobWFza0RhdGEubWFza09iamVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5TUFJJVEU6XG4gICAgICAgICAgdGhpcy5wb3BTcHJpdGVNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNQVNLX1RZUEVTLkNPTE9SOlxuICAgICAgICAgIHRoaXMucG9wQ29sb3JNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbWFza0RhdGEucmVzZXQoKTtcbiAgICBpZiAobWFza0RhdGEucG9vbGVkKSB7XG4gICAgICB0aGlzLm1hc2tEYXRhUG9vbC5wdXNoKG1hc2tEYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFza1N0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgbWFza0N1cnJlbnQgPSB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChtYXNrQ3VycmVudC50eXBlID09PSBNQVNLX1RZUEVTLlNQUklURSAmJiBtYXNrQ3VycmVudC5fZmlsdGVycykge1xuICAgICAgICBtYXNrQ3VycmVudC5fZmlsdGVyc1swXS5tYXNrU3ByaXRlID0gbWFza0N1cnJlbnQubWFza09iamVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGV0ZWN0KG1hc2tEYXRhKSB7XG4gICAgY29uc3QgbWFza09iamVjdCA9IG1hc2tEYXRhLm1hc2tPYmplY3Q7XG4gICAgaWYgKCFtYXNrT2JqZWN0KSB7XG4gICAgICBtYXNrRGF0YS50eXBlID0gTUFTS19UWVBFUy5DT0xPUjtcbiAgICB9IGVsc2UgaWYgKG1hc2tPYmplY3QuaXNTcHJpdGUpIHtcbiAgICAgIG1hc2tEYXRhLnR5cGUgPSBNQVNLX1RZUEVTLlNQUklURTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZW5hYmxlU2Npc3NvciAmJiB0aGlzLnJlbmRlcmVyLnNjaXNzb3IudGVzdFNjaXNzb3IobWFza0RhdGEpKSB7XG4gICAgICBtYXNrRGF0YS50eXBlID0gTUFTS19UWVBFUy5TQ0lTU09SO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXNrRGF0YS50eXBlID0gTUFTS19UWVBFUy5TVEVOQ0lMO1xuICAgIH1cbiAgfVxuICBwdXNoU3ByaXRlTWFzayhtYXNrRGF0YSkge1xuICAgIGNvbnN0IHsgbWFza09iamVjdCB9ID0gbWFza0RhdGE7XG4gICAgY29uc3QgdGFyZ2V0ID0gbWFza0RhdGEuX3RhcmdldDtcbiAgICBsZXQgYWxwaGFNYXNrRmlsdGVyID0gbWFza0RhdGEuX2ZpbHRlcnM7XG4gICAgaWYgKCFhbHBoYU1hc2tGaWx0ZXIpIHtcbiAgICAgIGFscGhhTWFza0ZpbHRlciA9IHRoaXMuYWxwaGFNYXNrUG9vbFt0aGlzLmFscGhhTWFza0luZGV4XTtcbiAgICAgIGlmICghYWxwaGFNYXNrRmlsdGVyKSB7XG4gICAgICAgIGFscGhhTWFza0ZpbHRlciA9IHRoaXMuYWxwaGFNYXNrUG9vbFt0aGlzLmFscGhhTWFza0luZGV4XSA9IFtuZXcgU3ByaXRlTWFza0ZpbHRlcigpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IHJlbmRlclRleHR1cmVTeXN0ZW0gPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlO1xuICAgIGxldCByZXNvbHV0aW9uO1xuICAgIGxldCBtdWx0aXNhbXBsZTtcbiAgICBpZiAocmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50KSB7XG4gICAgICBjb25zdCByZW5kZXJUZXh0dXJlID0gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50O1xuICAgICAgcmVzb2x1dGlvbiA9IG1hc2tEYXRhLnJlc29sdXRpb24gfHwgcmVuZGVyVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgbXVsdGlzYW1wbGUgPSBtYXNrRGF0YS5tdWx0aXNhbXBsZSA/PyByZW5kZXJUZXh0dXJlLm11bHRpc2FtcGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHV0aW9uID0gbWFza0RhdGEucmVzb2x1dGlvbiB8fCByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgbXVsdGlzYW1wbGUgPSBtYXNrRGF0YS5tdWx0aXNhbXBsZSA/PyByZW5kZXJlci5tdWx0aXNhbXBsZTtcbiAgICB9XG4gICAgYWxwaGFNYXNrRmlsdGVyWzBdLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIGFscGhhTWFza0ZpbHRlclswXS5tdWx0aXNhbXBsZSA9IG11bHRpc2FtcGxlO1xuICAgIGFscGhhTWFza0ZpbHRlclswXS5tYXNrU3ByaXRlID0gbWFza09iamVjdDtcbiAgICBjb25zdCBzdGFzaEZpbHRlckFyZWEgPSB0YXJnZXQuZmlsdGVyQXJlYTtcbiAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IG1hc2tPYmplY3QuZ2V0Qm91bmRzKHRydWUpO1xuICAgIHJlbmRlcmVyLmZpbHRlci5wdXNoKHRhcmdldCwgYWxwaGFNYXNrRmlsdGVyKTtcbiAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IHN0YXNoRmlsdGVyQXJlYTtcbiAgICBpZiAoIW1hc2tEYXRhLl9maWx0ZXJzKSB7XG4gICAgICB0aGlzLmFscGhhTWFza0luZGV4Kys7XG4gICAgfVxuICB9XG4gIHBvcFNwcml0ZU1hc2sobWFza0RhdGEpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmZpbHRlci5wb3AoKTtcbiAgICBpZiAobWFza0RhdGEuX2ZpbHRlcnMpIHtcbiAgICAgIG1hc2tEYXRhLl9maWx0ZXJzWzBdLm1hc2tTcHJpdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFscGhhTWFza0luZGV4LS07XG4gICAgICB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF1bMF0ubWFza1Nwcml0ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHB1c2hDb2xvck1hc2sobWFza0RhdGEpIHtcbiAgICBjb25zdCBjdXJyQ29sb3JNYXNrID0gbWFza0RhdGEuX2NvbG9yTWFzaztcbiAgICBjb25zdCBuZXh0Q29sb3JNYXNrID0gbWFza0RhdGEuX2NvbG9yTWFzayA9IGN1cnJDb2xvck1hc2sgJiBtYXNrRGF0YS5jb2xvck1hc2s7XG4gICAgaWYgKG5leHRDb2xvck1hc2sgIT09IGN1cnJDb2xvck1hc2spIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2wuY29sb3JNYXNrKChuZXh0Q29sb3JNYXNrICYgMSkgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgMikgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgNCkgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgOCkgIT09IDApO1xuICAgIH1cbiAgfVxuICBwb3BDb2xvck1hc2sobWFza0RhdGEpIHtcbiAgICBjb25zdCBjdXJyQ29sb3JNYXNrID0gbWFza0RhdGEuX2NvbG9yTWFzaztcbiAgICBjb25zdCBuZXh0Q29sb3JNYXNrID0gdGhpcy5tYXNrU3RhY2subGVuZ3RoID4gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdLl9jb2xvck1hc2sgOiAxNTtcbiAgICBpZiAobmV4dENvbG9yTWFzayAhPT0gY3VyckNvbG9yTWFzaykge1xuICAgICAgdGhpcy5yZW5kZXJlci5nbC5jb2xvck1hc2soKG5leHRDb2xvck1hc2sgJiAxKSAhPT0gMCwgKG5leHRDb2xvck1hc2sgJiAyKSAhPT0gMCwgKG5leHRDb2xvck1hc2sgJiA0KSAhPT0gMCwgKG5leHRDb2xvck1hc2sgJiA4KSAhPT0gMCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbk1hc2tTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcIm1hc2tcIlxufTtcbmV4dGVuc2lvbnMuYWRkKE1hc2tTeXN0ZW0pO1xuXG5leHBvcnQgeyBNYXNrU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXNrU3lzdGVtLm1qcy5tYXBcbiIsImNsYXNzIEFic3RyYWN0TWFza1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMubWFza1N0YWNrID0gW107XG4gICAgdGhpcy5nbENvbnN0ID0gMDtcbiAgfVxuICBnZXRTdGFja0xlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrU3RhY2subGVuZ3RoO1xuICB9XG4gIHNldE1hc2tTdGFjayhtYXNrU3RhY2spIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGN1clN0YWNrTGVuID0gdGhpcy5nZXRTdGFja0xlbmd0aCgpO1xuICAgIHRoaXMubWFza1N0YWNrID0gbWFza1N0YWNrO1xuICAgIGNvbnN0IG5ld1N0YWNrTGVuID0gdGhpcy5nZXRTdGFja0xlbmd0aCgpO1xuICAgIGlmIChuZXdTdGFja0xlbiAhPT0gY3VyU3RhY2tMZW4pIHtcbiAgICAgIGlmIChuZXdTdGFja0xlbiA9PT0gMCkge1xuICAgICAgICBnbC5kaXNhYmxlKHRoaXMuZ2xDb25zdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5lbmFibGUodGhpcy5nbENvbnN0KTtcbiAgICAgICAgdGhpcy5fdXNlQ3VycmVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfdXNlQ3VycmVudCgpIHtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMubWFza1N0YWNrID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBBYnN0cmFjdE1hc2tTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TWFza1N5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBNYXRyaXgsIFJlY3RhbmdsZSB9IGZyb20gJ0BwaXhpL21hdGgnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBBYnN0cmFjdE1hc2tTeXN0ZW0gfSBmcm9tICcuL0Fic3RyYWN0TWFza1N5c3RlbS5tanMnO1xuXG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuY29uc3QgcmVjdFBvb2wgPSBbXTtcbmNvbnN0IF9TY2lzc29yU3lzdGVtID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1hc2tTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLmdsQ29uc3QgPSBzZXR0aW5ncy5BREFQVEVSLmdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCgpLlNDSVNTT1JfVEVTVDtcbiAgfVxuICBnZXRTdGFja0xlbmd0aCgpIHtcbiAgICBjb25zdCBtYXNrRGF0YSA9IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChtYXNrRGF0YSkge1xuICAgICAgcmV0dXJuIG1hc2tEYXRhLl9zY2lzc29yQ291bnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY2FsY1NjaXNzb3JSZWN0KG1hc2tEYXRhKSB7XG4gICAgaWYgKG1hc2tEYXRhLl9zY2lzc29yUmVjdExvY2FsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZEYXRhID0gbWFza0RhdGEuX3NjaXNzb3JSZWN0O1xuICAgIGNvbnN0IHsgbWFza09iamVjdCB9ID0gbWFza0RhdGE7XG4gICAgY29uc3QgeyByZW5kZXJlciB9ID0gdGhpcztcbiAgICBjb25zdCByZW5kZXJUZXh0dXJlU3lzdGVtID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZTtcbiAgICBjb25zdCByZWN0ID0gbWFza09iamVjdC5nZXRCb3VuZHModHJ1ZSwgcmVjdFBvb2wucG9wKCkgPz8gbmV3IFJlY3RhbmdsZSgpKTtcbiAgICB0aGlzLnJvdW5kRnJhbWVUb1BpeGVscyhyZWN0LCByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQgPyByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQucmVzb2x1dGlvbiA6IHJlbmRlcmVyLnJlc29sdXRpb24sIHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUsIHJlbmRlclRleHR1cmVTeXN0ZW0uZGVzdGluYXRpb25GcmFtZSwgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pO1xuICAgIGlmIChwcmV2RGF0YSkge1xuICAgICAgcmVjdC5maXQocHJldkRhdGEpO1xuICAgIH1cbiAgICBtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCA9IHJlY3Q7XG4gIH1cbiAgc3RhdGljIGlzTWF0cml4Um90YXRlZChtYXRyaXgpIHtcbiAgICBpZiAoIW1hdHJpeCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGEsIGIsIGMsIGQgfSA9IG1hdHJpeDtcbiAgICByZXR1cm4gKE1hdGguYWJzKGIpID4gMWUtNCB8fCBNYXRoLmFicyhjKSA+IDFlLTQpICYmIChNYXRoLmFicyhhKSA+IDFlLTQgfHwgTWF0aC5hYnMoZCkgPiAxZS00KTtcbiAgfVxuICB0ZXN0U2Npc3NvcihtYXNrRGF0YSkge1xuICAgIGNvbnN0IHsgbWFza09iamVjdCB9ID0gbWFza0RhdGE7XG4gICAgaWYgKCFtYXNrT2JqZWN0LmlzRmFzdFJlY3QgfHwgIW1hc2tPYmplY3QuaXNGYXN0UmVjdCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChfU2Npc3NvclN5c3RlbS5pc01hdHJpeFJvdGF0ZWQobWFza09iamVjdC53b3JsZFRyYW5zZm9ybSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKF9TY2lzc29yU3lzdGVtLmlzTWF0cml4Um90YXRlZCh0aGlzLnJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmNhbGNTY2lzc29yUmVjdChtYXNrRGF0YSk7XG4gICAgY29uc3QgcmVjdCA9IG1hc2tEYXRhLl9zY2lzc29yUmVjdExvY2FsO1xuICAgIHJldHVybiByZWN0LndpZHRoID4gMCAmJiByZWN0LmhlaWdodCA+IDA7XG4gIH1cbiAgcm91bmRGcmFtZVRvUGl4ZWxzKGZyYW1lLCByZXNvbHV0aW9uLCBiaW5kaW5nU291cmNlRnJhbWUsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoX1NjaXNzb3JTeXN0ZW0uaXNNYXRyaXhSb3RhdGVkKHRyYW5zZm9ybSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtID8gdGVtcE1hdHJpeC5jb3B5RnJvbSh0cmFuc2Zvcm0pIDogdGVtcE1hdHJpeC5pZGVudGl0eSgpO1xuICAgIHRyYW5zZm9ybS50cmFuc2xhdGUoLWJpbmRpbmdTb3VyY2VGcmFtZS54LCAtYmluZGluZ1NvdXJjZUZyYW1lLnkpLnNjYWxlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gYmluZGluZ1NvdXJjZUZyYW1lLndpZHRoLCBiaW5kaW5nRGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyBiaW5kaW5nU291cmNlRnJhbWUuaGVpZ2h0KS50cmFuc2xhdGUoYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUueCwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUueSk7XG4gICAgdGhpcy5yZW5kZXJlci5maWx0ZXIudHJhbnNmb3JtQUFCQih0cmFuc2Zvcm0sIGZyYW1lKTtcbiAgICBmcmFtZS5maXQoYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUpO1xuICAgIGZyYW1lLnggPSBNYXRoLnJvdW5kKGZyYW1lLnggKiByZXNvbHV0aW9uKTtcbiAgICBmcmFtZS55ID0gTWF0aC5yb3VuZChmcmFtZS55ICogcmVzb2x1dGlvbik7XG4gICAgZnJhbWUud2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lLndpZHRoICogcmVzb2x1dGlvbik7XG4gICAgZnJhbWUuaGVpZ2h0ID0gTWF0aC5yb3VuZChmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uKTtcbiAgfVxuICBwdXNoKG1hc2tEYXRhKSB7XG4gICAgaWYgKCFtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCkge1xuICAgICAgdGhpcy5jYWxjU2Npc3NvclJlY3QobWFza0RhdGEpO1xuICAgIH1cbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmICghbWFza0RhdGEuX3NjaXNzb3JSZWN0KSB7XG4gICAgICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICB9XG4gICAgbWFza0RhdGEuX3NjaXNzb3JDb3VudGVyKys7XG4gICAgbWFza0RhdGEuX3NjaXNzb3JSZWN0ID0gbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWw7XG4gICAgdGhpcy5fdXNlQ3VycmVudCgpO1xuICB9XG4gIHBvcChtYXNrRGF0YSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgaWYgKG1hc2tEYXRhKSB7XG4gICAgICByZWN0UG9vbC5wdXNoKG1hc2tEYXRhLl9zY2lzc29yUmVjdExvY2FsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0U3RhY2tMZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgIH1cbiAgfVxuICBfdXNlQ3VycmVudCgpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV0uX3NjaXNzb3JSZWN0O1xuICAgIGxldCB5O1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuY3VycmVudCkge1xuICAgICAgeSA9IHJlY3QueTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IHRoaXMucmVuZGVyZXIuaGVpZ2h0IC0gcmVjdC5oZWlnaHQgLSByZWN0Lnk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuZ2wuc2Npc3NvcihyZWN0LngsIHksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgfVxufTtcbmxldCBTY2lzc29yU3lzdGVtID0gX1NjaXNzb3JTeXN0ZW07XG5TY2lzc29yU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJzY2lzc29yXCJcbn07XG5leHRlbnNpb25zLmFkZChTY2lzc29yU3lzdGVtKTtcblxuZXhwb3J0IHsgU2Npc3NvclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2Npc3NvclN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmltcG9ydCB7IEFic3RyYWN0TWFza1N5c3RlbSB9IGZyb20gJy4vQWJzdHJhY3RNYXNrU3lzdGVtLm1qcyc7XG5cbmNsYXNzIFN0ZW5jaWxTeXN0ZW0gZXh0ZW5kcyBBYnN0cmFjdE1hc2tTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLmdsQ29uc3QgPSBzZXR0aW5ncy5BREFQVEVSLmdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCgpLlNURU5DSUxfVEVTVDtcbiAgfVxuICBnZXRTdGFja0xlbmd0aCgpIHtcbiAgICBjb25zdCBtYXNrRGF0YSA9IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChtYXNrRGF0YSkge1xuICAgICAgcmV0dXJuIG1hc2tEYXRhLl9zdGVuY2lsQ291bnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcHVzaChtYXNrRGF0YSkge1xuICAgIGNvbnN0IG1hc2tPYmplY3QgPSBtYXNrRGF0YS5tYXNrT2JqZWN0O1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgcHJldk1hc2tDb3VudCA9IG1hc2tEYXRhLl9zdGVuY2lsQ291bnRlcjtcbiAgICBpZiAocHJldk1hc2tDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5mb3JjZVN0ZW5jaWwoKTtcbiAgICAgIGdsLmNsZWFyU3RlbmNpbCgwKTtcbiAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG4gICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9XG4gICAgbWFza0RhdGEuX3N0ZW5jaWxDb3VudGVyKys7XG4gICAgY29uc3QgY29sb3JNYXNrID0gbWFza0RhdGEuX2NvbG9yTWFzaztcbiAgICBpZiAoY29sb3JNYXNrICE9PSAwKSB7XG4gICAgICBtYXNrRGF0YS5fY29sb3JNYXNrID0gMDtcbiAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCBwcmV2TWFza0NvdW50LCA0Mjk0OTY3Mjk1KTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuSU5DUik7XG4gICAgbWFza09iamVjdC5yZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICBtYXNrT2JqZWN0LnJlbmRlcih0aGlzLnJlbmRlcmVyKTtcbiAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgbWFza09iamVjdC5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgaWYgKGNvbG9yTWFzayAhPT0gMCkge1xuICAgICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IGNvbG9yTWFzaztcbiAgICAgIGdsLmNvbG9yTWFzaygoY29sb3JNYXNrICYgMSkgIT09IDAsIChjb2xvck1hc2sgJiAyKSAhPT0gMCwgKGNvbG9yTWFzayAmIDQpICE9PSAwLCAoY29sb3JNYXNrICYgOCkgIT09IDApO1xuICAgIH1cbiAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gIH1cbiAgcG9wKG1hc2tPYmplY3QpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgaWYgKHRoaXMuZ2V0U3RhY2tMZW5ndGgoKSA9PT0gMCkge1xuICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXNrRGF0YSA9IHRoaXMubWFza1N0YWNrLmxlbmd0aCAhPT0gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgIGNvbnN0IGNvbG9yTWFzayA9IG1hc2tEYXRhID8gbWFza0RhdGEuX2NvbG9yTWFzayA6IDE1O1xuICAgICAgaWYgKGNvbG9yTWFzayAhPT0gMCkge1xuICAgICAgICBtYXNrRGF0YS5fY29sb3JNYXNrID0gMDtcbiAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5ERUNSKTtcbiAgICAgIG1hc2tPYmplY3QucmVuZGVyYWJsZSA9IHRydWU7XG4gICAgICBtYXNrT2JqZWN0LnJlbmRlcih0aGlzLnJlbmRlcmVyKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgIG1hc2tPYmplY3QucmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKGNvbG9yTWFzayAhPT0gMCkge1xuICAgICAgICBtYXNrRGF0YS5fY29sb3JNYXNrID0gY29sb3JNYXNrO1xuICAgICAgICBnbC5jb2xvck1hc2soKGNvbG9yTWFzayAmIDEpICE9PSAwLCAoY29sb3JNYXNrICYgMikgIT09IDAsIChjb2xvck1hc2sgJiA0KSAhPT0gMCwgKGNvbG9yTWFzayAmIDgpICE9PSAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgICB9XG4gIH1cbiAgX3VzZUN1cnJlbnQoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCB0aGlzLmdldFN0YWNrTGVuZ3RoKCksIDQyOTQ5NjcyOTUpO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgfVxufVxuU3RlbmNpbFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwic3RlbmNpbFwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoU3RlbmNpbFN5c3RlbSk7XG5cbmV4cG9ydCB7IFN0ZW5jaWxTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0ZW5jaWxTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tICdAcGl4aS91dGlscyc7XG5cbmNsYXNzIFBsdWdpblN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMucGx1Z2lucywge1xuICAgICAgZXh0cmFjdDoge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wbHVnaW5zLmV4dHJhY3QgaGFzIG1vdmVkIHRvIHJlbmRlcmVyLmV4dHJhY3RcIik7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmV4dHJhY3Q7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcmVwYXJlOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBsdWdpbnMucHJlcGFyZSBoYXMgbW92ZWQgdG8gcmVuZGVyZXIucHJlcGFyZVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyZXIucHJlcGFyZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGludGVyYWN0aW9uOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb24gaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmV2ZW50c1wiKTtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzdGF0aWNNYXAgPSB0aGlzLnJlbmRlcmVyUGx1Z2lucztcbiAgICBmb3IgKGNvbnN0IG8gaW4gc3RhdGljTWFwKSB7XG4gICAgICB0aGlzLnBsdWdpbnNbb10gPSBuZXcgc3RhdGljTWFwW29dKHRoaXMucmVuZGVyZXIpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgbyBpbiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIHRoaXMucGx1Z2luc1tvXS5kZXN0cm95KCk7XG4gICAgICB0aGlzLnBsdWdpbnNbb10gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuUGx1Z2luU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcIl9wbHVnaW5cIlxufTtcbmV4dGVuc2lvbnMuYWRkKFBsdWdpblN5c3RlbSk7XG5cbmV4cG9ydCB7IFBsdWdpblN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGx1Z2luU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJ0BwaXhpL21hdGgnO1xuXG5jbGFzcyBQcm9qZWN0aW9uU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gbnVsbDtcbiAgICB0aGlzLnNvdXJjZUZyYW1lID0gbnVsbDtcbiAgICB0aGlzLmRlZmF1bHRGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgfVxuICB1cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBkZXN0aW5hdGlvbkZyYW1lIHx8IHRoaXMuZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlZmF1bHRGcmFtZTtcbiAgICB0aGlzLnNvdXJjZUZyYW1lID0gc291cmNlRnJhbWUgfHwgdGhpcy5zb3VyY2VGcmFtZSB8fCBkZXN0aW5hdGlvbkZyYW1lO1xuICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbih0aGlzLmRlc3RpbmF0aW9uRnJhbWUsIHRoaXMuc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpO1xuICAgIGlmICh0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4LmFwcGVuZCh0aGlzLnRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xuICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnVwZGF0ZSgpO1xuICAgIGlmIChyZW5kZXJlci5zaGFkZXIuc2hhZGVyKSB7XG4gICAgICByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1Hcm91cChyZW5kZXJlci5zaGFkZXIuc2hhZGVyLnVuaWZvcm1zLmdsb2JhbHMpO1xuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVQcm9qZWN0aW9uKF9kZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSwgX3Jlc29sdXRpb24sIHJvb3QpIHtcbiAgICBjb25zdCBwbSA9IHRoaXMucHJvamVjdGlvbk1hdHJpeDtcbiAgICBjb25zdCBzaWduID0gIXJvb3QgPyAxIDogLTE7XG4gICAgcG0uaWRlbnRpdHkoKTtcbiAgICBwbS5hID0gMSAvIHNvdXJjZUZyYW1lLndpZHRoICogMjtcbiAgICBwbS5kID0gc2lnbiAqICgxIC8gc291cmNlRnJhbWUuaGVpZ2h0ICogMik7XG4gICAgcG0udHggPSAtMSAtIHNvdXJjZUZyYW1lLnggKiBwbS5hO1xuICAgIHBtLnR5ID0gLXNpZ24gLSBzb3VyY2VGcmFtZS55ICogcG0uZDtcbiAgfVxuICBzZXRUcmFuc2Zvcm0oX21hdHJpeCkge1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cblByb2plY3Rpb25TeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInByb2plY3Rpb25cIlxufTtcbmV4dGVuc2lvbnMuYWRkKFByb2plY3Rpb25TeXN0ZW0pO1xuXG5leHBvcnQgeyBQcm9qZWN0aW9uU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9qZWN0aW9uU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IFRyYW5zZm9ybSwgTWF0cml4IH0gZnJvbSAnQHBpeGkvbWF0aCc7XG5pbXBvcnQgeyBSZW5kZXJUZXh0dXJlIH0gZnJvbSAnLi9SZW5kZXJUZXh0dXJlLm1qcyc7XG5cbmNvbnN0IHRlbXBUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG5jbGFzcyBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl90ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICB9XG4gIGdlbmVyYXRlVGV4dHVyZShkaXNwbGF5T2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZWdpb246IG1hbnVhbFJlZ2lvbiwgLi4udGV4dHVyZU9wdGlvbnMgfSA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcmVnaW9uID0gbWFudWFsUmVnaW9uIHx8IGRpc3BsYXlPYmplY3QuZ2V0TG9jYWxCb3VuZHMobnVsbCwgdHJ1ZSk7XG4gICAgaWYgKHJlZ2lvbi53aWR0aCA9PT0gMClcbiAgICAgIHJlZ2lvbi53aWR0aCA9IDE7XG4gICAgaWYgKHJlZ2lvbi5oZWlnaHQgPT09IDApXG4gICAgICByZWdpb24uaGVpZ2h0ID0gMTtcbiAgICBjb25zdCByZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZS5jcmVhdGUoe1xuICAgICAgd2lkdGg6IHJlZ2lvbi53aWR0aCxcbiAgICAgIGhlaWdodDogcmVnaW9uLmhlaWdodCxcbiAgICAgIC4uLnRleHR1cmVPcHRpb25zXG4gICAgfSk7XG4gICAgdGhpcy5fdGVtcE1hdHJpeC50eCA9IC1yZWdpb24ueDtcbiAgICB0aGlzLl90ZW1wTWF0cml4LnR5ID0gLXJlZ2lvbi55O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGRpc3BsYXlPYmplY3QudHJhbnNmb3JtO1xuICAgIGRpc3BsYXlPYmplY3QudHJhbnNmb3JtID0gdGVtcFRyYW5zZm9ybTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcihkaXNwbGF5T2JqZWN0LCB7XG4gICAgICByZW5kZXJUZXh0dXJlLFxuICAgICAgdHJhbnNmb3JtOiB0aGlzLl90ZW1wTWF0cml4LFxuICAgICAgc2tpcFVwZGF0ZVRyYW5zZm9ybTogISFkaXNwbGF5T2JqZWN0LnBhcmVudCxcbiAgICAgIGJsaXQ6IHRydWVcbiAgICB9KTtcbiAgICBkaXNwbGF5T2JqZWN0LnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICByZXR1cm4gcmVuZGVyVGV4dHVyZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5HZW5lcmF0ZVRleHR1cmVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwidGV4dHVyZUdlbmVyYXRvclwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoR2VuZXJhdGVUZXh0dXJlU3lzdGVtKTtcblxuZXhwb3J0IHsgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdAcGl4aS9jb2xvcic7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICdAcGl4aS9tYXRoJztcblxuY29uc3QgdGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5jb25zdCB0ZW1wUmVjdDIgPSBuZXcgUmVjdGFuZ2xlKCk7XG5jbGFzcyBSZW5kZXJUZXh0dXJlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5kZWZhdWx0TWFza1N0YWNrID0gW107XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnNvdXJjZUZyYW1lID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICB0aGlzLnZpZXdwb3J0RnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gIH1cbiAgYmluZChyZW5kZXJUZXh0dXJlID0gbnVsbCwgc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5jdXJyZW50ID0gcmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgYmFzZVRleHR1cmU7XG4gICAgbGV0IGZyYW1lYnVmZmVyO1xuICAgIGxldCByZXNvbHV0aW9uO1xuICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICBiYXNlVGV4dHVyZSA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICByZXNvbHV0aW9uID0gYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgIGlmICghc291cmNlRnJhbWUpIHtcbiAgICAgICAgdGVtcFJlY3Qud2lkdGggPSByZW5kZXJUZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgICAgICB0ZW1wUmVjdC5oZWlnaHQgPSByZW5kZXJUZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgICAgICAgc291cmNlRnJhbWUgPSB0ZW1wUmVjdDtcbiAgICAgIH1cbiAgICAgIGlmICghZGVzdGluYXRpb25GcmFtZSkge1xuICAgICAgICB0ZW1wUmVjdDIueCA9IHJlbmRlclRleHR1cmUuZnJhbWUueDtcbiAgICAgICAgdGVtcFJlY3QyLnkgPSByZW5kZXJUZXh0dXJlLmZyYW1lLnk7XG4gICAgICAgIHRlbXBSZWN0Mi53aWR0aCA9IHNvdXJjZUZyYW1lLndpZHRoO1xuICAgICAgICB0ZW1wUmVjdDIuaGVpZ2h0ID0gc291cmNlRnJhbWUuaGVpZ2h0O1xuICAgICAgICBkZXN0aW5hdGlvbkZyYW1lID0gdGVtcFJlY3QyO1xuICAgICAgfVxuICAgICAgZnJhbWVidWZmZXIgPSBiYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICBpZiAoIXNvdXJjZUZyYW1lKSB7XG4gICAgICAgIHRlbXBSZWN0LndpZHRoID0gcmVuZGVyZXIuX3ZpZXcuc2NyZWVuLndpZHRoO1xuICAgICAgICB0ZW1wUmVjdC5oZWlnaHQgPSByZW5kZXJlci5fdmlldy5zY3JlZW4uaGVpZ2h0O1xuICAgICAgICBzb3VyY2VGcmFtZSA9IHRlbXBSZWN0O1xuICAgICAgfVxuICAgICAgaWYgKCFkZXN0aW5hdGlvbkZyYW1lKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uRnJhbWUgPSB0ZW1wUmVjdDtcbiAgICAgICAgZGVzdGluYXRpb25GcmFtZS53aWR0aCA9IHNvdXJjZUZyYW1lLndpZHRoO1xuICAgICAgICBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHNvdXJjZUZyYW1lLmhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnRGcmFtZSA9IHRoaXMudmlld3BvcnRGcmFtZTtcbiAgICB2aWV3cG9ydEZyYW1lLnggPSBkZXN0aW5hdGlvbkZyYW1lLnggKiByZXNvbHV0aW9uO1xuICAgIHZpZXdwb3J0RnJhbWUueSA9IGRlc3RpbmF0aW9uRnJhbWUueSAqIHJlc29sdXRpb247XG4gICAgdmlld3BvcnRGcmFtZS53aWR0aCA9IGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiByZXNvbHV0aW9uO1xuICAgIHZpZXdwb3J0RnJhbWUuaGVpZ2h0ID0gZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgIGlmICghcmVuZGVyVGV4dHVyZSkge1xuICAgICAgdmlld3BvcnRGcmFtZS55ID0gcmVuZGVyZXIudmlldy5oZWlnaHQgLSAodmlld3BvcnRGcmFtZS55ICsgdmlld3BvcnRGcmFtZS5oZWlnaHQpO1xuICAgIH1cbiAgICB2aWV3cG9ydEZyYW1lLmNlaWwoKTtcbiAgICB0aGlzLnJlbmRlcmVyLmZyYW1lYnVmZmVyLmJpbmQoZnJhbWVidWZmZXIsIHZpZXdwb3J0RnJhbWUpO1xuICAgIHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi51cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sICFmcmFtZWJ1ZmZlcik7XG4gICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubWFzay5zZXRNYXNrU3RhY2soYmFzZVRleHR1cmUubWFza1N0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJlci5tYXNrLnNldE1hc2tTdGFjayh0aGlzLmRlZmF1bHRNYXNrU3RhY2spO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZUZyYW1lLmNvcHlGcm9tKHNvdXJjZUZyYW1lKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUuY29weUZyb20oZGVzdGluYXRpb25GcmFtZSk7XG4gIH1cbiAgY2xlYXIoY2xlYXJDb2xvciwgbWFzaykge1xuICAgIGNvbnN0IGZhbGxiYWNrQ29sb3IgPSB0aGlzLmN1cnJlbnQgPyB0aGlzLmN1cnJlbnQuYmFzZVRleHR1cmUuY2xlYXIgOiB0aGlzLnJlbmRlcmVyLmJhY2tncm91bmQuYmFja2dyb3VuZENvbG9yO1xuICAgIGNvbnN0IGNvbG9yID0gY2xlYXJDb2xvciA/IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShjbGVhckNvbG9yKSA6IGZhbGxiYWNrQ29sb3I7XG4gICAgY29uc3QgZGVzdGluYXRpb25GcmFtZSA9IHRoaXMuZGVzdGluYXRpb25GcmFtZTtcbiAgICBjb25zdCBiYXNlRnJhbWUgPSB0aGlzLmN1cnJlbnQgPyB0aGlzLmN1cnJlbnQuYmFzZVRleHR1cmUgOiB0aGlzLnJlbmRlcmVyLl92aWV3LnNjcmVlbjtcbiAgICBjb25zdCBjbGVhck1hc2sgPSBkZXN0aW5hdGlvbkZyYW1lLndpZHRoICE9PSBiYXNlRnJhbWUud2lkdGggfHwgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgIT09IGJhc2VGcmFtZS5oZWlnaHQ7XG4gICAgaWYgKGNsZWFyTWFzaykge1xuICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy52aWV3cG9ydEZyYW1lO1xuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsLmVuYWJsZSh0aGlzLnJlbmRlcmVyLmdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuY2xlYXIoY29sb3IucmVkLCBjb2xvci5ncmVlbiwgY29sb3IuYmx1ZSwgY29sb3IuYWxwaGEsIG1hc2spO1xuICAgIGlmIChjbGVhck1hc2spIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2Npc3Nvci5wb3AoKTtcbiAgICB9XG4gIH1cbiAgcmVzaXplKCkge1xuICAgIHRoaXMuYmluZChudWxsKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmJpbmQobnVsbCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuUmVuZGVyVGV4dHVyZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwicmVuZGVyVGV4dHVyZVwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoUmVuZGVyVGV4dHVyZVN5c3RlbSk7XG5cbmV4cG9ydCB7IFJlbmRlclRleHR1cmVTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlclRleHR1cmVTeXN0ZW0ubWpzLm1hcFxuIiwiY2xhc3MgSUdMVW5pZm9ybURhdGEge1xufVxuY2xhc3MgR0xQcm9ncmFtIHtcbiAgY29uc3RydWN0b3IocHJvZ3JhbSwgdW5pZm9ybURhdGEpIHtcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgIHRoaXMudW5pZm9ybURhdGEgPSB1bmlmb3JtRGF0YTtcbiAgICB0aGlzLnVuaWZvcm1Hcm91cHMgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm1EaXJ0eUdyb3VwcyA9IHt9O1xuICAgIHRoaXMudW5pZm9ybUJ1ZmZlckJpbmRpbmdzID0ge307XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVuaWZvcm1EYXRhID0gbnVsbDtcbiAgICB0aGlzLnVuaWZvcm1Hcm91cHMgPSBudWxsO1xuICAgIHRoaXMudW5pZm9ybURpcnR5R3JvdXBzID0gbnVsbDtcbiAgICB0aGlzLnVuaWZvcm1CdWZmZXJCaW5kaW5ncyA9IG51bGw7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBHTFByb2dyYW0sIElHTFVuaWZvcm1EYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFByb2dyYW0ubWpzLm1hcFxuIiwiZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgdHlwZSwgc3JjKSB7XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICByZXR1cm4gc2hhZGVyO1xufVxuXG5leHBvcnQgeyBjb21waWxlU2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlU2hhZGVyLm1qcy5tYXBcbiIsImZ1bmN0aW9uIGJvb2xlYW5BcnJheShzaXplKSB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBkZWZhdWx0VmFsdWUodHlwZSwgc2l6ZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgXCJ2ZWMyXCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgyICogc2l6ZSk7XG4gICAgY2FzZSBcInZlYzNcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDMgKiBzaXplKTtcbiAgICBjYXNlIFwidmVjNFwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCAqIHNpemUpO1xuICAgIGNhc2UgXCJpbnRcIjpcbiAgICBjYXNlIFwidWludFwiOlxuICAgIGNhc2UgXCJzYW1wbGVyMkRcIjpcbiAgICBjYXNlIFwic2FtcGxlcjJEQXJyYXlcIjpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgXCJpdmVjMlwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDIgKiBzaXplKTtcbiAgICBjYXNlIFwiaXZlYzNcIjpcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgzICogc2l6ZSk7XG4gICAgY2FzZSBcIml2ZWM0XCI6XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoNCAqIHNpemUpO1xuICAgIGNhc2UgXCJ1dmVjMlwiOlxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSgyICogc2l6ZSk7XG4gICAgY2FzZSBcInV2ZWMzXCI6XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KDMgKiBzaXplKTtcbiAgICBjYXNlIFwidXZlYzRcIjpcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoNCAqIHNpemUpO1xuICAgIGNhc2UgXCJib29sXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcImJ2ZWMyXCI6XG4gICAgICByZXR1cm4gYm9vbGVhbkFycmF5KDIgKiBzaXplKTtcbiAgICBjYXNlIFwiYnZlYzNcIjpcbiAgICAgIHJldHVybiBib29sZWFuQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJidmVjNFwiOlxuICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcIm1hdDJcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMVxuICAgICAgXSk7XG4gICAgY2FzZSBcIm1hdDNcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMVxuICAgICAgXSk7XG4gICAgY2FzZSBcIm1hdDRcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMVxuICAgICAgXSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IGRlZmF1bHRWYWx1ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdFZhbHVlLm1qcy5tYXBcbiIsImltcG9ydCB7IG1hcFNpemUgfSBmcm9tICcuL21hcFNpemUubWpzJztcbmltcG9ydCB7IG1hcFR5cGUgfSBmcm9tICcuL21hcFR5cGUubWpzJztcblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlRGF0YShwcm9ncmFtLCBnbCkge1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IHRvdGFsQXR0cmlidXRlcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQXR0cmlidXRlczsgaSsrKSB7XG4gICAgY29uc3QgYXR0cmliRGF0YSA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcbiAgICBpZiAoYXR0cmliRGF0YS5uYW1lLnN0YXJ0c1dpdGgoXCJnbF9cIikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gbWFwVHlwZShnbCwgYXR0cmliRGF0YS50eXBlKTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgdHlwZSxcbiAgICAgIG5hbWU6IGF0dHJpYkRhdGEubmFtZSxcbiAgICAgIHNpemU6IG1hcFNpemUodHlwZSksXG4gICAgICBsb2NhdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmliRGF0YS5uYW1lKVxuICAgIH07XG4gICAgYXR0cmlidXRlc1thdHRyaWJEYXRhLm5hbWVdID0gZGF0YTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cblxuZXhwb3J0IHsgZ2V0QXR0cmlidXRlRGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0QXR0cmlidXRlRGF0YS5tanMubWFwXG4iLCJpbXBvcnQgeyBkZWZhdWx0VmFsdWUgfSBmcm9tICcuL2RlZmF1bHRWYWx1ZS5tanMnO1xuaW1wb3J0IHsgbWFwVHlwZSB9IGZyb20gJy4vbWFwVHlwZS5tanMnO1xuXG5mdW5jdGlvbiBnZXRVbmlmb3JtRGF0YShwcm9ncmFtLCBnbCkge1xuICBjb25zdCB1bmlmb3JtcyA9IHt9O1xuICBjb25zdCB0b3RhbFVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsVW5pZm9ybXM7IGkrKykge1xuICAgIGNvbnN0IHVuaWZvcm1EYXRhID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKTtcbiAgICBjb25zdCBuYW1lID0gdW5pZm9ybURhdGEubmFtZS5yZXBsYWNlKC9cXFsuKj9cXF0kLywgXCJcIik7XG4gICAgY29uc3QgaXNBcnJheSA9ICEhdW5pZm9ybURhdGEubmFtZS5tYXRjaCgvXFxbLio/XFxdJC8pO1xuICAgIGNvbnN0IHR5cGUgPSBtYXBUeXBlKGdsLCB1bmlmb3JtRGF0YS50eXBlKTtcbiAgICB1bmlmb3Jtc1tuYW1lXSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICBpbmRleDogaSxcbiAgICAgIHR5cGUsXG4gICAgICBzaXplOiB1bmlmb3JtRGF0YS5zaXplLFxuICAgICAgaXNBcnJheSxcbiAgICAgIHZhbHVlOiBkZWZhdWx0VmFsdWUodHlwZSwgdW5pZm9ybURhdGEuc2l6ZSlcbiAgICB9O1xuICB9XG4gIHJldHVybiB1bmlmb3Jtcztcbn1cblxuZXhwb3J0IHsgZ2V0VW5pZm9ybURhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFVuaWZvcm1EYXRhLm1qcy5tYXBcbiIsImZ1bmN0aW9uIGxvZ1ByZXR0eVNoYWRlckVycm9yKGdsLCBzaGFkZXIpIHtcbiAgY29uc3Qgc2hhZGVyU3JjID0gZ2wuZ2V0U2hhZGVyU291cmNlKHNoYWRlcikuc3BsaXQoXCJcXG5cIikubWFwKChsaW5lLCBpbmRleCkgPT4gYCR7aW5kZXh9OiAke2xpbmV9YCk7XG4gIGNvbnN0IHNoYWRlckxvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgY29uc3Qgc3BsaXRTaGFkZXIgPSBzaGFkZXJMb2cuc3BsaXQoXCJcXG5cIik7XG4gIGNvbnN0IGRlZHVwZSA9IHt9O1xuICBjb25zdCBsaW5lTnVtYmVycyA9IHNwbGl0U2hhZGVyLm1hcCgobGluZSkgPT4gcGFyc2VGbG9hdChsaW5lLnJlcGxhY2UoL15FUlJPUlxcOiAwXFw6KFtcXGRdKylcXDouKiQvLCBcIiQxXCIpKSkuZmlsdGVyKChuKSA9PiB7XG4gICAgaWYgKG4gJiYgIWRlZHVwZVtuXSkge1xuICAgICAgZGVkdXBlW25dID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICBjb25zdCBsb2dBcmdzID0gW1wiXCJdO1xuICBsaW5lTnVtYmVycy5mb3JFYWNoKChudW1iZXIpID0+IHtcbiAgICBzaGFkZXJTcmNbbnVtYmVyIC0gMV0gPSBgJWMke3NoYWRlclNyY1tudW1iZXIgLSAxXX0lY2A7XG4gICAgbG9nQXJncy5wdXNoKFwiYmFja2dyb3VuZDogI0ZGMDAwMDsgY29sb3I6I0ZGRkZGRjsgZm9udC1zaXplOiAxMHB4XCIsIFwiZm9udC1zaXplOiAxMHB4XCIpO1xuICB9KTtcbiAgY29uc3QgZnJhZ21lbnRTb3VyY2VUb0xvZyA9IHNoYWRlclNyYy5qb2luKFwiXFxuXCIpO1xuICBsb2dBcmdzWzBdID0gZnJhZ21lbnRTb3VyY2VUb0xvZztcbiAgY29uc29sZS5lcnJvcihzaGFkZXJMb2cpO1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFwiY2xpY2sgdG8gdmlldyBmdWxsIHNoYWRlciBjb2RlXCIpO1xuICBjb25zb2xlLndhcm4oLi4ubG9nQXJncyk7XG4gIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbn1cbmZ1bmN0aW9uIGxvZ1Byb2dyYW1FcnJvcihnbCwgcHJvZ3JhbSwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcikge1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIGxvZ1ByZXR0eVNoYWRlckVycm9yKGdsLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIH1cbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICBsb2dQcmV0dHlTaGFkZXJFcnJvcihnbCwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKFwiUGl4aUpTIEVycm9yOiBDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIuXCIpO1xuICAgIGlmIChnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSAhPT0gXCJcIikge1xuICAgICAgY29uc29sZS53YXJuKFwiUGl4aUpTIFdhcm5pbmc6IGdsLmdldFByb2dyYW1JbmZvTG9nKClcIiwgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBsb2dQcm9ncmFtRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ1Byb2dyYW1FcnJvci5tanMubWFwXG4iLCJpbXBvcnQgeyBHTFByb2dyYW0gfSBmcm9tICcuLi9HTFByb2dyYW0ubWpzJztcbmltcG9ydCB7IGNvbXBpbGVTaGFkZXIgfSBmcm9tICcuL2NvbXBpbGVTaGFkZXIubWpzJztcbmltcG9ydCB7IGRlZmF1bHRWYWx1ZSB9IGZyb20gJy4vZGVmYXVsdFZhbHVlLm1qcyc7XG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVEYXRhIH0gZnJvbSAnLi9nZXRBdHRyaWJ1dGVEYXRhLm1qcyc7XG5pbXBvcnQgeyBnZXRVbmlmb3JtRGF0YSB9IGZyb20gJy4vZ2V0VW5pZm9ybURhdGEubWpzJztcbmltcG9ydCB7IGxvZ1Byb2dyYW1FcnJvciB9IGZyb20gJy4vbG9nUHJvZ3JhbUVycm9yLm1qcyc7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICBjb25zdCBnbFZlcnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCBwcm9ncmFtLnZlcnRleFNyYyk7XG4gIGNvbnN0IGdsRnJhZ1NoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgcHJvZ3JhbS5mcmFnbWVudFNyYyk7XG4gIGNvbnN0IHdlYkdMUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHdlYkdMUHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHdlYkdMUHJvZ3JhbSwgZ2xGcmFnU2hhZGVyKTtcbiAgY29uc3QgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyA9IHByb2dyYW0uZXh0cmE/LnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M7XG4gIGlmICh0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVHJhbnNmb3JtRmVlZGJhY2sgaXMgbm90IHN1cHBvcnRlZCBidXQgVHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyBhcmUgZ2l2ZW4uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3Mod2ViR0xQcm9ncmFtLCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzLm5hbWVzLCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzLmJ1ZmZlck1vZGUgPT09IFwic2VwYXJhdGVcIiA/IGdsLlNFUEFSQVRFX0FUVFJJQlMgOiBnbC5JTlRFUkxFQVZFRF9BVFRSSUJTKTtcbiAgICB9XG4gIH1cbiAgZ2wubGlua1Byb2dyYW0od2ViR0xQcm9ncmFtKTtcbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHdlYkdMUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgbG9nUHJvZ3JhbUVycm9yKGdsLCB3ZWJHTFByb2dyYW0sIGdsVmVydFNoYWRlciwgZ2xGcmFnU2hhZGVyKTtcbiAgfVxuICBwcm9ncmFtLmF0dHJpYnV0ZURhdGEgPSBnZXRBdHRyaWJ1dGVEYXRhKHdlYkdMUHJvZ3JhbSwgZ2wpO1xuICBwcm9ncmFtLnVuaWZvcm1EYXRhID0gZ2V0VW5pZm9ybURhdGEod2ViR0xQcm9ncmFtLCBnbCk7XG4gIGlmICghL15bIFxcdF0qI1sgXFx0XSp2ZXJzaW9uWyBcXHRdKzMwMFsgXFx0XStlc1sgXFx0XSokL20udGVzdChwcm9ncmFtLnZlcnRleFNyYykpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvZ3JhbS5hdHRyaWJ1dGVEYXRhKTtcbiAgICBrZXlzLnNvcnQoKGEsIGIpID0+IGEgPiBiID8gMSA6IC0xKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2dyYW0uYXR0cmlidXRlRGF0YVtrZXlzW2ldXS5sb2NhdGlvbiA9IGk7XG4gICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24od2ViR0xQcm9ncmFtLCBpLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgZ2wubGlua1Byb2dyYW0od2ViR0xQcm9ncmFtKTtcbiAgfVxuICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XG4gIGNvbnN0IHVuaWZvcm1EYXRhID0ge307XG4gIGZvciAoY29uc3QgaSBpbiBwcm9ncmFtLnVuaWZvcm1EYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IHByb2dyYW0udW5pZm9ybURhdGFbaV07XG4gICAgdW5pZm9ybURhdGFbaV0gPSB7XG4gICAgICBsb2NhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgaSksXG4gICAgICB2YWx1ZTogZGVmYXVsdFZhbHVlKGRhdGEudHlwZSwgZGF0YS5zaXplKVxuICAgIH07XG4gIH1cbiAgY29uc3QgZ2xQcm9ncmFtID0gbmV3IEdMUHJvZ3JhbSh3ZWJHTFByb2dyYW0sIHVuaWZvcm1EYXRhKTtcbiAgcmV0dXJuIGdsUHJvZ3JhbTtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZVByb2dyYW0ubWpzLm1hcFxuIiwiaW1wb3J0ICcuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyB1bmlmb3JtUGFyc2VycyB9IGZyb20gJy4vdW5pZm9ybVBhcnNlcnMubWpzJztcbmltcG9ydCB7IG1hcFNpemUgfSBmcm9tICcuL21hcFNpemUubWpzJztcblxuZnVuY3Rpb24gdWJvVXBkYXRlKF91ZCwgX3V2LCBfcmVuZGVyZXIsIF9zeW5jRGF0YSwgYnVmZmVyKSB7XG4gIF9yZW5kZXJlci5idWZmZXIudXBkYXRlKGJ1ZmZlcik7XG59XG5jb25zdCBVQk9fVE9fU0lOR0xFX1NFVFRFUlMgPSB7XG4gIGZsb2F0OiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHY7XG4gICAgYCxcbiAgdmVjMjogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCsxXSA9IHZbMV07XG4gICAgYCxcbiAgdmVjMzogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCsxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzJdID0gdlsyXTtcblxuICAgIGAsXG4gIHZlYzQ6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCsyXSA9IHZbMl07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzNdID0gdlszXTtcbiAgICBgLFxuICBtYXQyOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcblxuICAgICAgICBkYXRhW29mZnNldCs0XSA9IHZbMl07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzVdID0gdlszXTtcbiAgICBgLFxuICBtYXQzOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2WzJdO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNF0gPSB2WzNdO1xuICAgICAgICBkYXRhW29mZnNldCArIDVdID0gdls0XTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA2XSA9IHZbNV07XG5cbiAgICAgICAgZGF0YVtvZmZzZXQgKyA4XSA9IHZbNl07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgOV0gPSB2WzddO1xuICAgICAgICBkYXRhW29mZnNldCArIDEwXSA9IHZbOF07XG4gICAgYCxcbiAgbWF0NDogYFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyBpXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICBgXG59O1xuY29uc3QgR0xTTF9UT19TVEQ0MF9TSVpFID0ge1xuICBmbG9hdDogNCxcbiAgdmVjMjogOCxcbiAgdmVjMzogMTIsXG4gIHZlYzQ6IDE2LFxuICBpbnQ6IDQsXG4gIGl2ZWMyOiA4LFxuICBpdmVjMzogMTIsXG4gIGl2ZWM0OiAxNixcbiAgdWludDogNCxcbiAgdXZlYzI6IDgsXG4gIHV2ZWMzOiAxMixcbiAgdXZlYzQ6IDE2LFxuICBib29sOiA0LFxuICBidmVjMjogOCxcbiAgYnZlYzM6IDEyLFxuICBidmVjNDogMTYsXG4gIG1hdDI6IDE2ICogMixcbiAgbWF0MzogMTYgKiAzLFxuICBtYXQ0OiAxNiAqIDRcbn07XG5mdW5jdGlvbiBjcmVhdGVVQk9FbGVtZW50cyh1bmlmb3JtRGF0YSkge1xuICBjb25zdCB1Ym9FbGVtZW50cyA9IHVuaWZvcm1EYXRhLm1hcCgoZGF0YSkgPT4gKHtcbiAgICBkYXRhLFxuICAgIG9mZnNldDogMCxcbiAgICBkYXRhTGVuOiAwLFxuICAgIGRpcnR5OiAwXG4gIH0pKTtcbiAgbGV0IHNpemUgPSAwO1xuICBsZXQgY2h1bmtTaXplID0gMDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdWJvRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB1Ym9FbGVtZW50ID0gdWJvRWxlbWVudHNbaV07XG4gICAgc2l6ZSA9IEdMU0xfVE9fU1RENDBfU0laRVt1Ym9FbGVtZW50LmRhdGEudHlwZV07XG4gICAgaWYgKHVib0VsZW1lbnQuZGF0YS5zaXplID4gMSkge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIDE2KSAqIHVib0VsZW1lbnQuZGF0YS5zaXplO1xuICAgIH1cbiAgICB1Ym9FbGVtZW50LmRhdGFMZW4gPSBzaXplO1xuICAgIGlmIChjaHVua1NpemUgJSBzaXplICE9PSAwICYmIGNodW5rU2l6ZSA8IDE2KSB7XG4gICAgICBjb25zdCBsaW5lVXBWYWx1ZSA9IGNodW5rU2l6ZSAlIHNpemUgJSAxNjtcbiAgICAgIGNodW5rU2l6ZSArPSBsaW5lVXBWYWx1ZTtcbiAgICAgIG9mZnNldCArPSBsaW5lVXBWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGNodW5rU2l6ZSArIHNpemUgPiAxNikge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5jZWlsKG9mZnNldCAvIDE2KSAqIDE2O1xuICAgICAgdWJvRWxlbWVudC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgIGNodW5rU2l6ZSA9IHNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVib0VsZW1lbnQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgY2h1bmtTaXplICs9IHNpemU7XG4gICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbiAgb2Zmc2V0ID0gTWF0aC5jZWlsKG9mZnNldCAvIDE2KSAqIDE2O1xuICByZXR1cm4geyB1Ym9FbGVtZW50cywgc2l6ZTogb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBnZXRVQk9EYXRhKHVuaWZvcm1zLCB1bmlmb3JtRGF0YSkge1xuICBjb25zdCB1c2VkVW5pZm9ybURhdGFzID0gW107XG4gIGZvciAoY29uc3QgaSBpbiB1bmlmb3Jtcykge1xuICAgIGlmICh1bmlmb3JtRGF0YVtpXSkge1xuICAgICAgdXNlZFVuaWZvcm1EYXRhcy5wdXNoKHVuaWZvcm1EYXRhW2ldKTtcbiAgICB9XG4gIH1cbiAgdXNlZFVuaWZvcm1EYXRhcy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gIHJldHVybiB1c2VkVW5pZm9ybURhdGFzO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyhncm91cCwgdW5pZm9ybURhdGEpIHtcbiAgaWYgKCFncm91cC5hdXRvTWFuYWdlKSB7XG4gICAgcmV0dXJuIHsgc2l6ZTogMCwgc3luY0Z1bmM6IHVib1VwZGF0ZSB9O1xuICB9XG4gIGNvbnN0IHVzZWRVbmlmb3JtRGF0YXMgPSBnZXRVQk9EYXRhKGdyb3VwLnVuaWZvcm1zLCB1bmlmb3JtRGF0YSk7XG4gIGNvbnN0IHsgdWJvRWxlbWVudHMsIHNpemUgfSA9IGNyZWF0ZVVCT0VsZW1lbnRzKHVzZWRVbmlmb3JtRGF0YXMpO1xuICBjb25zdCBmdW5jRnJhZ21lbnRzID0gW2BcbiAgICB2YXIgdiA9IG51bGw7XG4gICAgdmFyIHYyID0gbnVsbDtcbiAgICB2YXIgY3YgPSBudWxsO1xuICAgIHZhciB0ID0gMDtcbiAgICB2YXIgZ2wgPSByZW5kZXJlci5nbFxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGRhdGEgPSBidWZmZXIuZGF0YTtcbiAgICBgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1Ym9FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHVib0VsZW1lbnQgPSB1Ym9FbGVtZW50c1tpXTtcbiAgICBjb25zdCB1bmlmb3JtID0gZ3JvdXAudW5pZm9ybXNbdWJvRWxlbWVudC5kYXRhLm5hbWVdO1xuICAgIGNvbnN0IG5hbWUgPSB1Ym9FbGVtZW50LmRhdGEubmFtZTtcbiAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlmb3JtUGFyc2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgdW5pZm9ybVBhcnNlciA9IHVuaWZvcm1QYXJzZXJzW2pdO1xuICAgICAgaWYgKHVuaWZvcm1QYXJzZXIuY29kZVVibyAmJiB1bmlmb3JtUGFyc2VyLnRlc3QodWJvRWxlbWVudC5kYXRhLCB1bmlmb3JtKSkge1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYG9mZnNldCA9ICR7dWJvRWxlbWVudC5vZmZzZXQgLyA0fTtgLCB1bmlmb3JtUGFyc2Vyc1tqXS5jb2RlVWJvKHVib0VsZW1lbnQuZGF0YS5uYW1lLCB1bmlmb3JtKSk7XG4gICAgICAgIHBhcnNlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgaWYgKHVib0VsZW1lbnQuZGF0YS5zaXplID4gMSkge1xuICAgICAgICBjb25zdCBzaXplMiA9IG1hcFNpemUodWJvRWxlbWVudC5kYXRhLnR5cGUpO1xuICAgICAgICBjb25zdCByb3dTaXplID0gTWF0aC5tYXgoR0xTTF9UT19TVEQ0MF9TSVpFW3Vib0VsZW1lbnQuZGF0YS50eXBlXSAvIDE2LCAxKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBzaXplMiAvIHJvd1NpemU7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9ICg0IC0gZWxlbWVudFNpemUgJSA0KSAlIDQ7XG4gICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC4ke25hbWV9LnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9ICR7dWJvRWxlbWVudC5vZmZzZXQgLyA0fTtcblxuICAgICAgICAgICAgICAgIHQgPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCAke3Vib0VsZW1lbnQuZGF0YS5zaXplICogcm93U2l6ZX07IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCAke2VsZW1lbnRTaXplfTsgaisrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXSA9IHZbdCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gJHtyZW1haW5kZXJ9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBVQk9fVE9fU0lOR0xFX1NFVFRFUlNbdWJvRWxlbWVudC5kYXRhLnR5cGVdO1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgIGN2ID0gdWQuJHtuYW1lfS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAke3Vib0VsZW1lbnQub2Zmc2V0IC8gNH07XG4gICAgICAgICAgICAgICAgJHt0ZW1wbGF0ZX07XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgcmVuZGVyZXIuYnVmZmVyLnVwZGF0ZShidWZmZXIpO1xuICAgIGApO1xuICByZXR1cm4ge1xuICAgIHNpemUsXG4gICAgc3luY0Z1bmM6IG5ldyBGdW5jdGlvbihcInVkXCIsIFwidXZcIiwgXCJyZW5kZXJlclwiLCBcInN5bmNEYXRhXCIsIFwiYnVmZmVyXCIsIGZ1bmNGcmFnbWVudHMuam9pbihcIlxcblwiKSlcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlVUJPRWxlbWVudHMsIGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMsIGdldFVCT0RhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMubWpzLm1hcFxuIiwibGV0IHVuc2FmZUV2YWw7XG5mdW5jdGlvbiB1bnNhZmVFdmFsU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHVuc2FmZUV2YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHVuc2FmZUV2YWw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmdW5jID0gbmV3IEZ1bmN0aW9uKFwicGFyYW0xXCIsIFwicGFyYW0yXCIsIFwicGFyYW0zXCIsIFwicmV0dXJuIHBhcmFtMVtwYXJhbTJdID09PSBwYXJhbTM7XCIpO1xuICAgIHVuc2FmZUV2YWwgPSBmdW5jKHsgYTogXCJiXCIgfSwgXCJhXCIsIFwiYlwiKSA9PT0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHVuc2FmZUV2YWwgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdW5zYWZlRXZhbDtcbn1cblxuZXhwb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5zYWZlRXZhbFN1cHBvcnRlZC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgJy4vdXRpbHMvaW5kZXgubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlUHJvZ3JhbSB9IGZyb20gJy4vdXRpbHMvZ2VuZXJhdGVQcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jIH0gZnJvbSAnLi91dGlscy9nZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLm1qcyc7XG5pbXBvcnQgeyB1bnNhZmVFdmFsU3VwcG9ydGVkIH0gZnJvbSAnLi91dGlscy91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVVuaWZvcm1zU3luYyB9IGZyb20gJy4vdXRpbHMvZ2VuZXJhdGVVbmlmb3Jtc1N5bmMubWpzJztcblxubGV0IFVJRCA9IDA7XG5jb25zdCBkZWZhdWx0U3luY0RhdGEgPSB7IHRleHR1cmVDb3VudDogMCwgdWJvQ291bnQ6IDAgfTtcbmNsYXNzIFNoYWRlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5zeXN0ZW1DaGVjaygpO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB0aGlzLl91Ym9DYWNoZSA9IHt9O1xuICAgIHRoaXMuaWQgPSBVSUQrKztcbiAgfVxuICBzeXN0ZW1DaGVjaygpIHtcbiAgICBpZiAoIXVuc2FmZUV2YWxTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBhbGxvdyB1bnNhZmUtZXZhbCwgcGxlYXNlIHVzZSBAcGl4aS91bnNhZmUtZXZhbCBtb2R1bGUgdG8gZW5hYmxlIHN1cHBvcnQuXCIpO1xuICAgIH1cbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICBiaW5kKHNoYWRlciwgZG9udFN5bmMpIHtcbiAgICBzaGFkZXIuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgc2hhZGVyLnVuaWZvcm1zLmdsb2JhbHMgPSB0aGlzLnJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zO1xuICAgIGNvbnN0IHByb2dyYW0gPSBzaGFkZXIucHJvZ3JhbTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBwcm9ncmFtLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0gfHwgdGhpcy5nZW5lcmF0ZVByb2dyYW0oc2hhZGVyKTtcbiAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbiAgICBpZiAodGhpcy5wcm9ncmFtICE9PSBwcm9ncmFtKSB7XG4gICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKGdsUHJvZ3JhbS5wcm9ncmFtKTtcbiAgICB9XG4gICAgaWYgKCFkb250U3luYykge1xuICAgICAgZGVmYXVsdFN5bmNEYXRhLnRleHR1cmVDb3VudCA9IDA7XG4gICAgICBkZWZhdWx0U3luY0RhdGEudWJvQ291bnQgPSAwO1xuICAgICAgdGhpcy5zeW5jVW5pZm9ybUdyb3VwKHNoYWRlci51bmlmb3JtR3JvdXAsIGRlZmF1bHRTeW5jRGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBnbFByb2dyYW07XG4gIH1cbiAgc2V0VW5pZm9ybXModW5pZm9ybXMpIHtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlci5wcm9ncmFtO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IHNoYWRlci5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCB1bmlmb3JtcywgdGhpcy5yZW5kZXJlcik7XG4gIH1cbiAgc3luY1VuaWZvcm1Hcm91cChncm91cCwgc3luY0RhdGEpIHtcbiAgICBjb25zdCBnbFByb2dyYW0gPSB0aGlzLmdldEdsUHJvZ3JhbSgpO1xuICAgIGlmICghZ3JvdXAuc3RhdGljIHx8IGdyb3VwLmRpcnR5SWQgIT09IGdsUHJvZ3JhbS51bmlmb3JtRGlydHlHcm91cHNbZ3JvdXAuaWRdKSB7XG4gICAgICBnbFByb2dyYW0udW5pZm9ybURpcnR5R3JvdXBzW2dyb3VwLmlkXSA9IGdyb3VwLmRpcnR5SWQ7XG4gICAgICB0aGlzLnN5bmNVbmlmb3Jtcyhncm91cCwgZ2xQcm9ncmFtLCBzeW5jRGF0YSk7XG4gICAgfVxuICB9XG4gIHN5bmNVbmlmb3Jtcyhncm91cCwgZ2xQcm9ncmFtLCBzeW5jRGF0YSkge1xuICAgIGNvbnN0IHN5bmNGdW5jID0gZ3JvdXAuc3luY1VuaWZvcm1zW3RoaXMuc2hhZGVyLnByb2dyYW0uaWRdIHx8IHRoaXMuY3JlYXRlU3luY0dyb3Vwcyhncm91cCk7XG4gICAgc3luY0Z1bmMoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCBncm91cC51bmlmb3JtcywgdGhpcy5yZW5kZXJlciwgc3luY0RhdGEpO1xuICB9XG4gIGNyZWF0ZVN5bmNHcm91cHMoZ3JvdXApIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhLCBcInVcIik7XG4gICAgaWYgKCF0aGlzLmNhY2hlW2lkXSkge1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBnZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSk7XG4gICAgfVxuICAgIGdyb3VwLnN5bmNVbmlmb3Jtc1t0aGlzLnNoYWRlci5wcm9ncmFtLmlkXSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgIHJldHVybiBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF07XG4gIH1cbiAgc3luY1VuaWZvcm1CdWZmZXJHcm91cChncm91cCwgbmFtZSkge1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IHRoaXMuZ2V0R2xQcm9ncmFtKCk7XG4gICAgaWYgKCFncm91cC5zdGF0aWMgfHwgZ3JvdXAuZGlydHlJZCAhPT0gMCB8fCAhZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdKSB7XG4gICAgICBncm91cC5kaXJ0eUlkID0gMDtcbiAgICAgIGNvbnN0IHN5bmNGdW5jID0gZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdIHx8IHRoaXMuY3JlYXRlU3luY0J1ZmZlckdyb3VwKGdyb3VwLCBnbFByb2dyYW0sIG5hbWUpO1xuICAgICAgZ3JvdXAuYnVmZmVyLnVwZGF0ZSgpO1xuICAgICAgc3luY0Z1bmMoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCBncm91cC51bmlmb3JtcywgdGhpcy5yZW5kZXJlciwgZGVmYXVsdFN5bmNEYXRhLCBncm91cC5idWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyLmJ1ZmZlci5iaW5kQnVmZmVyQmFzZShncm91cC5idWZmZXIsIGdsUHJvZ3JhbS51bmlmb3JtQnVmZmVyQmluZGluZ3NbbmFtZV0pO1xuICB9XG4gIGNyZWF0ZVN5bmNCdWZmZXJHcm91cChncm91cCwgZ2xQcm9ncmFtLCBuYW1lKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICB0aGlzLnJlbmRlcmVyLmJ1ZmZlci5iaW5kKGdyb3VwLmJ1ZmZlcik7XG4gICAgY29uc3QgdW5pZm9ybUJsb2NrSW5kZXggPSB0aGlzLmdsLmdldFVuaWZvcm1CbG9ja0luZGV4KGdsUHJvZ3JhbS5wcm9ncmFtLCBuYW1lKTtcbiAgICBnbFByb2dyYW0udW5pZm9ybUJ1ZmZlckJpbmRpbmdzW25hbWVdID0gdGhpcy5zaGFkZXIudW5pZm9ybUJpbmRDb3VudDtcbiAgICBnbC51bmlmb3JtQmxvY2tCaW5kaW5nKGdsUHJvZ3JhbS5wcm9ncmFtLCB1bmlmb3JtQmxvY2tJbmRleCwgdGhpcy5zaGFkZXIudW5pZm9ybUJpbmRDb3VudCk7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybUJpbmRDb3VudCsrO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRTaWduYXR1cmUoZ3JvdXAsIHRoaXMuc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEsIFwidWJvXCIpO1xuICAgIGxldCB1Ym9EYXRhID0gdGhpcy5fdWJvQ2FjaGVbaWRdO1xuICAgIGlmICghdWJvRGF0YSkge1xuICAgICAgdWJvRGF0YSA9IHRoaXMuX3Vib0NhY2hlW2lkXSA9IGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMoZ3JvdXAsIHRoaXMuc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAuYXV0b01hbmFnZSkge1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodWJvRGF0YS5zaXplIC8gNCk7XG4gICAgICBncm91cC5idWZmZXIudXBkYXRlKGRhdGEpO1xuICAgIH1cbiAgICBnbFByb2dyYW0udW5pZm9ybUdyb3Vwc1tncm91cC5pZF0gPSB1Ym9EYXRhLnN5bmNGdW5jO1xuICAgIHJldHVybiBnbFByb2dyYW0udW5pZm9ybUdyb3Vwc1tncm91cC5pZF07XG4gIH1cbiAgZ2V0U2lnbmF0dXJlKGdyb3VwLCB1bmlmb3JtRGF0YSwgcHJlRml4KSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBncm91cC51bmlmb3JtcztcbiAgICBjb25zdCBzdHJpbmdzID0gW2Ake3ByZUZpeH0tYF07XG4gICAgZm9yIChjb25zdCBpIGluIHVuaWZvcm1zKSB7XG4gICAgICBzdHJpbmdzLnB1c2goaSk7XG4gICAgICBpZiAodW5pZm9ybURhdGFbaV0pIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKHVuaWZvcm1EYXRhW2ldLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5ncy5qb2luKFwiLVwiKTtcbiAgfVxuICBnZXRHbFByb2dyYW0oKSB7XG4gICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFkZXIucHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZW5lcmF0ZVByb2dyYW0oc2hhZGVyKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHByb2dyYW0gPSBzaGFkZXIucHJvZ3JhbTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBnZW5lcmF0ZVByb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgIHByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSA9IGdsUHJvZ3JhbTtcbiAgICByZXR1cm4gZ2xQcm9ncmFtO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICB9XG4gIGRpc3Bvc2VTaGFkZXIoc2hhZGVyKSB7XG4gICAgaWYgKHRoaXMuc2hhZGVyID09PSBzaGFkZXIpIHtcbiAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbn1cblNoYWRlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwic2hhZGVyXCJcbn07XG5leHRlbnNpb25zLmFkZChTaGFkZXJTeXN0ZW0pO1xuXG5leHBvcnQgeyBTaGFkZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYWRlclN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5cbmNsYXNzIFN0YXJ0dXBTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBydW4ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcmVuZGVyZXIgfSA9IHRoaXM7XG4gICAgcmVuZGVyZXIucnVubmVycy5pbml0LmVtaXQocmVuZGVyZXIub3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaGVsbG8pIHtcbiAgICAgIGNvbnNvbGUubG9nKGBQaXhpSlMgJHtcIjcuMi4zXCJ9IC0gJHtyZW5kZXJlci5yZW5kZXJlckxvZ0lkfSAtIGh0dHBzOi8vcGl4aWpzLmNvbWApO1xuICAgIH1cbiAgICByZW5kZXJlci5yZXNpemUocmVuZGVyZXIuc2NyZWVuLndpZHRoLCByZW5kZXJlci5zY3JlZW4uaGVpZ2h0KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5TdGFydHVwU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICBoZWxsbzogZmFsc2Vcbn07XG5TdGFydHVwU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcInN0YXJ0dXBcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFN0YXJ0dXBTeXN0ZW0pO1xuXG5leHBvcnQgeyBTdGFydHVwU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGFydHVwU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEJMRU5EX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcblxuZnVuY3Rpb24gbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpKGdsLCBhcnJheSA9IFtdKSB7XG4gIGFycmF5W0JMRU5EX01PREVTLk5PUk1BTF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuQUREXSA9IFtnbC5PTkUsIGdsLk9ORV07XG4gIGFycmF5W0JMRU5EX01PREVTLk1VTFRJUExZXSA9IFtnbC5EU1RfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLlNDUkVFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5PVkVSTEFZXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5EQVJLRU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkxJR0hURU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkNPTE9SX0RPREdFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5DT0xPUl9CVVJOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5IQVJEX0xJR0hUXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5TT0ZUX0xJR0hUXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5ESUZGRVJFTkNFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5FWENMVVNJT05dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkhVRV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuU0FUVVJBVElPTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuQ09MT1JdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkxVTUlOT1NJVFldID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLk5PTkVdID0gWzAsIDBdO1xuICBhcnJheVtCTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkFERF9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkUsIGdsLk9ORV07XG4gIGFycmF5W0JMRU5EX01PREVTLlNDUkVFTl9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuU1JDX0lOXSA9IFtnbC5EU1RfQUxQSEEsIGdsLlpFUk9dO1xuICBhcnJheVtCTEVORF9NT0RFUy5TUkNfT1VUXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5aRVJPXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuU1JDX0FUT1BdID0gW2dsLkRTVF9BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkRTVF9PVkVSXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkVdO1xuICBhcnJheVtCTEVORF9NT0RFUy5EU1RfSU5dID0gW2dsLlpFUk8sIGdsLlNSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkRTVF9PVVRdID0gW2dsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5EU1RfQVRPUF0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuWE9SXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuU1VCVFJBQ1RdID0gW2dsLk9ORSwgZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNULCBnbC5GVU5DX0FERF07XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IHsgbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzLm1hcFxuIiwiaW1wb3J0IHsgQkxFTkRfTU9ERVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkgfSBmcm9tICcuL3V0aWxzL21hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aS5tanMnO1xuXG5jb25zdCBCTEVORCA9IDA7XG5jb25zdCBPRkZTRVQgPSAxO1xuY29uc3QgQ1VMTElORyA9IDI7XG5jb25zdCBERVBUSF9URVNUID0gMztcbmNvbnN0IFdJTkRJTkcgPSA0O1xuY29uc3QgREVQVEhfTUFTSyA9IDU7XG5jb25zdCBfU3RhdGVTeXN0ZW0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuc3RhdGVJZCA9IDA7XG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IEJMRU5EX01PREVTLk5PTkU7XG4gICAgdGhpcy5fYmxlbmRFcSA9IGZhbHNlO1xuICAgIHRoaXMubWFwID0gW107XG4gICAgdGhpcy5tYXBbQkxFTkRdID0gdGhpcy5zZXRCbGVuZDtcbiAgICB0aGlzLm1hcFtPRkZTRVRdID0gdGhpcy5zZXRPZmZzZXQ7XG4gICAgdGhpcy5tYXBbQ1VMTElOR10gPSB0aGlzLnNldEN1bGxGYWNlO1xuICAgIHRoaXMubWFwW0RFUFRIX1RFU1RdID0gdGhpcy5zZXREZXB0aFRlc3Q7XG4gICAgdGhpcy5tYXBbV0lORElOR10gPSB0aGlzLnNldEZyb250RmFjZTtcbiAgICB0aGlzLm1hcFtERVBUSF9NQVNLXSA9IHRoaXMuc2V0RGVwdGhNYXNrO1xuICAgIHRoaXMuY2hlY2tzID0gW107XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZS5ibGVuZCA9IHRydWU7XG4gIH1cbiAgY29udGV4dENoYW5nZShnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmJsZW5kTW9kZXMgPSBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkoZ2wpO1xuICAgIHRoaXMuc2V0KHRoaXMuZGVmYXVsdFN0YXRlKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgc2V0KHN0YXRlKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICBpZiAodGhpcy5zdGF0ZUlkICE9PSBzdGF0ZS5kYXRhKSB7XG4gICAgICBsZXQgZGlmZiA9IHRoaXMuc3RhdGVJZCBeIHN0YXRlLmRhdGE7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoZGlmZikge1xuICAgICAgICBpZiAoZGlmZiAmIDEpIHtcbiAgICAgICAgICB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAxIDw8IGkpKTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmID0gZGlmZiA+PiAxO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlSWQgPSBzdGF0ZS5kYXRhO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmNoZWNrc1tpXSh0aGlzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZvcmNlU3RhdGUoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubWFwW2ldLmNhbGwodGhpcywgISEoc3RhdGUuZGF0YSAmIDEgPDwgaSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmNoZWNrc1tpXSh0aGlzLCBzdGF0ZSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVJZCA9IHN0YXRlLmRhdGE7XG4gIH1cbiAgc2V0QmxlbmQodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZUNoZWNrKF9TdGF0ZVN5c3RlbS5jaGVja0JsZW5kTW9kZSwgdmFsdWUpO1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuQkxFTkQpO1xuICB9XG4gIHNldE9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlQ2hlY2soX1N0YXRlU3lzdGVtLmNoZWNrUG9seWdvbk9mZnNldCwgdmFsdWUpO1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG4gIH1cbiAgc2V0RGVwdGhUZXN0KHZhbHVlKSB7XG4gICAgdGhpcy5nbFt2YWx1ZSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0odGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgfVxuICBzZXREZXB0aE1hc2sodmFsdWUpIHtcbiAgICB0aGlzLmdsLmRlcHRoTWFzayh2YWx1ZSk7XG4gIH1cbiAgc2V0Q3VsbEZhY2UodmFsdWUpIHtcbiAgICB0aGlzLmdsW3ZhbHVlID8gXCJlbmFibGVcIiA6IFwiZGlzYWJsZVwiXSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gIH1cbiAgc2V0RnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5nbC5mcm9udEZhY2UodGhpcy5nbFt2YWx1ZSA/IFwiQ1dcIiA6IFwiQ0NXXCJdKTtcbiAgfVxuICBzZXRCbGVuZE1vZGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMuYmxlbmRNb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMuYmxlbmRNb2Rlc1t2YWx1ZV07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGlmIChtb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgZ2wuYmxlbmRGdW5jKG1vZGVbMF0sIG1vZGVbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShtb2RlWzBdLCBtb2RlWzFdLCBtb2RlWzJdLCBtb2RlWzNdKTtcbiAgICB9XG4gICAgaWYgKG1vZGUubGVuZ3RoID09PSA2KSB7XG4gICAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcbiAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShtb2RlWzRdLCBtb2RlWzVdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JsZW5kRXEpIHtcbiAgICAgIHRoaXMuX2JsZW5kRXEgPSBmYWxzZTtcbiAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgIH1cbiAgfVxuICBzZXRQb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSkge1xuICAgIHRoaXMuZ2wucG9seWdvbk9mZnNldCh2YWx1ZSwgc2NhbGUpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgdGhpcy5mb3JjZVN0YXRlKHRoaXMuZGVmYXVsdFN0YXRlKTtcbiAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IC0xO1xuICAgIHRoaXMuc2V0QmxlbmRNb2RlKDApO1xuICB9XG4gIHVwZGF0ZUNoZWNrKGZ1bmMsIHZhbHVlKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoZWNrcy5pbmRleE9mKGZ1bmMpO1xuICAgIGlmICh2YWx1ZSAmJiBpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuY2hlY2tzLnB1c2goZnVuYyk7XG4gICAgfSBlbHNlIGlmICghdmFsdWUgJiYgaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmNoZWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY2hlY2tCbGVuZE1vZGUoc3lzdGVtLCBzdGF0ZSkge1xuICAgIHN5c3RlbS5zZXRCbGVuZE1vZGUoc3RhdGUuYmxlbmRNb2RlKTtcbiAgfVxuICBzdGF0aWMgY2hlY2tQb2x5Z29uT2Zmc2V0KHN5c3RlbSwgc3RhdGUpIHtcbiAgICBzeXN0ZW0uc2V0UG9seWdvbk9mZnNldCgxLCBzdGF0ZS5wb2x5Z29uT2Zmc2V0KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICB9XG59O1xubGV0IFN0YXRlU3lzdGVtID0gX1N0YXRlU3lzdGVtO1xuU3RhdGVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInN0YXRlXCJcbn07XG5leHRlbnNpb25zLmFkZChTdGF0ZVN5c3RlbSk7XG5cbmV4cG9ydCB7IFN0YXRlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZVN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBSdW5uZXIgfSBmcm9tICdAcGl4aS9ydW5uZXInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuXG5jbGFzcyBTeXN0ZW1NYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnJ1bm5lcnMgPSB7fTtcbiAgICB0aGlzLl9zeXN0ZW1zSGFzaCA9IHt9O1xuICB9XG4gIHNldHVwKGNvbmZpZykge1xuICAgIHRoaXMuYWRkUnVubmVycyguLi5jb25maWcucnVubmVycyk7XG4gICAgY29uc3QgcHJpb3JpdHkgPSAoY29uZmlnLnByaW9yaXR5ID8/IFtdKS5maWx0ZXIoKGtleSkgPT4gY29uZmlnLnN5c3RlbXNba2V5XSk7XG4gICAgY29uc3Qgb3JkZXJCeVByaW9yaXR5ID0gW1xuICAgICAgLi4ucHJpb3JpdHksXG4gICAgICAuLi5PYmplY3Qua2V5cyhjb25maWcuc3lzdGVtcykuZmlsdGVyKChrZXkpID0+ICFwcmlvcml0eS5pbmNsdWRlcyhrZXkpKVxuICAgIF07XG4gICAgZm9yIChjb25zdCBpIG9mIG9yZGVyQnlQcmlvcml0eSkge1xuICAgICAgdGhpcy5hZGRTeXN0ZW0oY29uZmlnLnN5c3RlbXNbaV0sIGkpO1xuICAgIH1cbiAgfVxuICBhZGRSdW5uZXJzKC4uLnJ1bm5lcklkcykge1xuICAgIHJ1bm5lcklkcy5mb3JFYWNoKChydW5uZXJJZCkgPT4ge1xuICAgICAgdGhpcy5ydW5uZXJzW3J1bm5lcklkXSA9IG5ldyBSdW5uZXIocnVubmVySWQpO1xuICAgIH0pO1xuICB9XG4gIGFkZFN5c3RlbShDbGFzc1JlZiwgbmFtZSkge1xuICAgIGNvbnN0IHN5c3RlbSA9IG5ldyBDbGFzc1JlZih0aGlzKTtcbiAgICBpZiAodGhpc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaG9vcHMhIFRoZSBuYW1lIFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgaW4gdXNlYCk7XG4gICAgfVxuICAgIHRoaXNbbmFtZV0gPSBzeXN0ZW07XG4gICAgdGhpcy5fc3lzdGVtc0hhc2hbbmFtZV0gPSBzeXN0ZW07XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMucnVubmVycykge1xuICAgICAgdGhpcy5ydW5uZXJzW2ldLmFkZChzeXN0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbWl0V2l0aEN1c3RvbU9wdGlvbnMocnVubmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3lzdGVtSGFzaEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9zeXN0ZW1zSGFzaCk7XG4gICAgcnVubmVyLml0ZW1zLmZvckVhY2goKHN5c3RlbSkgPT4ge1xuICAgICAgY29uc3Qgc3lzdGVtTmFtZSA9IHN5c3RlbUhhc2hLZXlzLmZpbmQoKHN5c3RlbUlkKSA9PiB0aGlzLl9zeXN0ZW1zSGFzaFtzeXN0ZW1JZF0gPT09IHN5c3RlbSk7XG4gICAgICBzeXN0ZW1bcnVubmVyLm5hbWVdKG9wdGlvbnNbc3lzdGVtTmFtZV0pO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLnJ1bm5lcnMpLmZvckVhY2goKHJ1bm5lcikgPT4ge1xuICAgICAgcnVubmVyLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLl9zeXN0ZW1zSGFzaCA9IHt9O1xuICB9XG59XG5cbmV4cG9ydCB7IFN5c3RlbU1hbmFnZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5c3RlbU1hbmFnZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgR0NfTU9ERVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuXG5jb25zdCBfVGV4dHVyZUdDU3lzdGVtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLmNoZWNrQ291bnQgPSAwO1xuICAgIHRoaXMubWF4SWRsZSA9IF9UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1heElkbGU7XG4gICAgdGhpcy5jaGVja0NvdW50TWF4ID0gX1RleHR1cmVHQ1N5c3RlbS5kZWZhdWx0Q2hlY2tDb3VudE1heDtcbiAgICB0aGlzLm1vZGUgPSBfVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlO1xuICB9XG4gIHBvc3RyZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyLm9iamVjdFJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY291bnQrKztcbiAgICBpZiAodGhpcy5tb2RlID09PSBHQ19NT0RFUy5NQU5VQUwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGVja0NvdW50Kys7XG4gICAgaWYgKHRoaXMuY2hlY2tDb3VudCA+IHRoaXMuY2hlY2tDb3VudE1heCkge1xuICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuICB9XG4gIHJ1bigpIHtcbiAgICBjb25zdCB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICBjb25zdCBtYW5hZ2VkVGV4dHVyZXMgPSB0bS5tYW5hZ2VkVGV4dHVyZXM7XG4gICAgbGV0IHdhc1JlbW92ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IG1hbmFnZWRUZXh0dXJlc1tpXTtcbiAgICAgIGlmICghdGV4dHVyZS5mcmFtZWJ1ZmZlciAmJiB0aGlzLmNvdW50IC0gdGV4dHVyZS50b3VjaGVkID4gdGhpcy5tYXhJZGxlKSB7XG4gICAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHRydWUpO1xuICAgICAgICBtYW5hZ2VkVGV4dHVyZXNbaV0gPSBudWxsO1xuICAgICAgICB3YXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdhc1JlbW92ZWQpIHtcbiAgICAgIGxldCBqID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYW5hZ2VkVGV4dHVyZXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICBtYW5hZ2VkVGV4dHVyZXNbaisrXSA9IG1hbmFnZWRUZXh0dXJlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWFuYWdlZFRleHR1cmVzLmxlbmd0aCA9IGo7XG4gICAgfVxuICB9XG4gIHVubG9hZChkaXNwbGF5T2JqZWN0KSB7XG4gICAgY29uc3QgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XG4gICAgY29uc3QgdGV4dHVyZSA9IGRpc3BsYXlPYmplY3QuX3RleHR1cmU7XG4gICAgaWYgKHRleHR1cmUgJiYgIXRleHR1cmUuZnJhbWVidWZmZXIpIHtcbiAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy51bmxvYWQoZGlzcGxheU9iamVjdC5jaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG5sZXQgVGV4dHVyZUdDU3lzdGVtID0gX1RleHR1cmVHQ1N5c3RlbTtcblRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TW9kZSA9IEdDX01PREVTLkFVVE87XG5UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1heElkbGUgPSA2MCAqIDYwO1xuVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4ID0gNjAgKiAxMDtcblRleHR1cmVHQ1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwidGV4dHVyZUdDXCJcbn07XG5leHRlbnNpb25zLmFkZChUZXh0dXJlR0NTeXN0ZW0pO1xuXG5leHBvcnQgeyBUZXh0dXJlR0NTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVHQ1N5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBUWVBFUywgRk9STUFUUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5cbmNsYXNzIEdMVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUpIHtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHRoaXMud2lkdGggPSAtMTtcbiAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgIHRoaXMuZGlydHlJZCA9IC0xO1xuICAgIHRoaXMuZGlydHlTdHlsZUlkID0gLTE7XG4gICAgdGhpcy5taXBtYXAgPSBmYWxzZTtcbiAgICB0aGlzLndyYXBNb2RlID0gMzMwNzE7XG4gICAgdGhpcy50eXBlID0gVFlQRVMuVU5TSUdORURfQllURTtcbiAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gRk9STUFUUy5SR0JBO1xuICAgIHRoaXMuc2FtcGxlclR5cGUgPSAwO1xuICB9XG59XG5cbmV4cG9ydCB7IEdMVGV4dHVyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xUZXh0dXJlLm1qcy5tYXBcbiIsImltcG9ydCB7IFRZUEVTLCBGT1JNQVRTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcblxuZnVuY3Rpb24gbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQoZ2wpIHtcbiAgbGV0IHRhYmxlO1xuICBpZiAoXCJXZWJHTDJSZW5kZXJpbmdDb250ZXh0XCIgaW4gZ2xvYmFsVGhpcyAmJiBnbCBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHRhYmxlID0ge1xuICAgICAgW1RZUEVTLlVOU0lHTkVEX0JZVEVdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0JBOCxcbiAgICAgICAgW0ZPUk1BVFMuUkdCXTogZ2wuUkdCOCxcbiAgICAgICAgW0ZPUk1BVFMuUkddOiBnbC5SRzgsXG4gICAgICAgIFtGT1JNQVRTLlJFRF06IGdsLlI4LFxuICAgICAgICBbRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0JBOFVJLFxuICAgICAgICBbRk9STUFUUy5SR0JfSU5URUdFUl06IGdsLlJHQjhVSSxcbiAgICAgICAgW0ZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHOFVJLFxuICAgICAgICBbRk9STUFUUy5SRURfSU5URUdFUl06IGdsLlI4VUksXG4gICAgICAgIFtGT1JNQVRTLkFMUEhBXTogZ2wuQUxQSEEsXG4gICAgICAgIFtGT1JNQVRTLkxVTUlOQU5DRV06IGdsLkxVTUlOQU5DRSxcbiAgICAgICAgW0ZPUk1BVFMuTFVNSU5BTkNFX0FMUEhBXTogZ2wuTFVNSU5BTkNFX0FMUEhBXG4gICAgICB9LFxuICAgICAgW1RZUEVTLkJZVEVdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0JBOF9TTk9STSxcbiAgICAgICAgW0ZPUk1BVFMuUkdCXTogZ2wuUkdCOF9TTk9STSxcbiAgICAgICAgW0ZPUk1BVFMuUkddOiBnbC5SRzhfU05PUk0sXG4gICAgICAgIFtGT1JNQVRTLlJFRF06IGdsLlI4X1NOT1JNLFxuICAgICAgICBbRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0JBOEksXG4gICAgICAgIFtGT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCOEksXG4gICAgICAgIFtGT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzhJLFxuICAgICAgICBbRk9STUFUUy5SRURfSU5URUdFUl06IGdsLlI4SVxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9TSE9SVF06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQTE2VUksXG4gICAgICAgIFtGT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCMTZVSSxcbiAgICAgICAgW0ZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHMTZVSSxcbiAgICAgICAgW0ZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SMTZVSSxcbiAgICAgICAgW0ZPUk1BVFMuREVQVEhfQ09NUE9ORU5UXTogZ2wuREVQVEhfQ09NUE9ORU5UMTZcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuU0hPUlRdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkExNkksXG4gICAgICAgIFtGT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCMTZJLFxuICAgICAgICBbRk9STUFUUy5SR19JTlRFR0VSXTogZ2wuUkcxNkksXG4gICAgICAgIFtGT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjE2SVxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9JTlRdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkEzMlVJLFxuICAgICAgICBbRk9STUFUUy5SR0JfSU5URUdFUl06IGdsLlJHQjMyVUksXG4gICAgICAgIFtGT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzMyVUksXG4gICAgICAgIFtGT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjMyVUksXG4gICAgICAgIFtGT1JNQVRTLkRFUFRIX0NPTVBPTkVOVF06IGdsLkRFUFRIX0NPTVBPTkVOVDI0XG4gICAgICB9LFxuICAgICAgW1RZUEVTLklOVF06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQTMySSxcbiAgICAgICAgW0ZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0IzMkksXG4gICAgICAgIFtGT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzMySSxcbiAgICAgICAgW0ZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SMzJJXG4gICAgICB9LFxuICAgICAgW1RZUEVTLkZMT0FUXToge1xuICAgICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCQTMyRixcbiAgICAgICAgW0ZPUk1BVFMuUkdCXTogZ2wuUkdCMzJGLFxuICAgICAgICBbRk9STUFUUy5SR106IGdsLlJHMzJGLFxuICAgICAgICBbRk9STUFUUy5SRURdOiBnbC5SMzJGLFxuICAgICAgICBbRk9STUFUUy5ERVBUSF9DT01QT05FTlRdOiBnbC5ERVBUSF9DT01QT05FTlQzMkZcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuSEFMRl9GTE9BVF06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQkExNkYsXG4gICAgICAgIFtGT1JNQVRTLlJHQl06IGdsLlJHQjE2RixcbiAgICAgICAgW0ZPUk1BVFMuUkddOiBnbC5SRzE2RixcbiAgICAgICAgW0ZPUk1BVFMuUkVEXTogZ2wuUjE2RlxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9TSE9SVF81XzZfNV06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCXTogZ2wuUkdCNTY1XG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzRfNF80XzRdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0JBNFxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9TSE9SVF81XzVfNV8xXToge1xuICAgICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCNV9BMVxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0IxMF9BMixcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCMTBfQTJVSVxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWXToge1xuICAgICAgICBbRk9STUFUUy5SR0JdOiBnbC5SMTFGX0cxMUZfQjEwRlxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9JTlRfNV85XzlfOV9SRVZdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQl06IGdsLlJHQjlfRTVcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuVU5TSUdORURfSU5UXzI0XzhdOiB7XG4gICAgICAgIFtGT1JNQVRTLkRFUFRIX1NURU5DSUxdOiBnbC5ERVBUSDI0X1NURU5DSUw4XG4gICAgICB9LFxuICAgICAgW1RZUEVTLkZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFVl06IHtcbiAgICAgICAgW0ZPUk1BVFMuREVQVEhfU1RFTkNJTF06IGdsLkRFUFRIMzJGX1NURU5DSUw4XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZSA9IHtcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9CWVRFXToge1xuICAgICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCQSxcbiAgICAgICAgW0ZPUk1BVFMuUkdCXTogZ2wuUkdCLFxuICAgICAgICBbRk9STUFUUy5BTFBIQV06IGdsLkFMUEhBLFxuICAgICAgICBbRk9STUFUUy5MVU1JTkFOQ0VdOiBnbC5MVU1JTkFOQ0UsXG4gICAgICAgIFtGT1JNQVRTLkxVTUlOQU5DRV9BTFBIQV06IGdsLkxVTUlOQU5DRV9BTFBIQVxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9TSE9SVF81XzZfNV06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCXTogZ2wuUkdCXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzRfNF80XzRdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0JBXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNV81XzFdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0JBXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5cbmV4cG9ydCB7IG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBUeXBlQW5kRm9ybWF0VG9JbnRlcm5hbEZvcm1hdC5tanMubWFwXG4iLCJpbXBvcnQgeyBTQU1QTEVSX1RZUEVTLCBUWVBFUywgTUlQTUFQX01PREVTLCBXUkFQX01PREVTLCBTQ0FMRV9NT0RFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyByZW1vdmVJdGVtcyB9IGZyb20gJ0BwaXhpL3V0aWxzJztcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSAnLi9CYXNlVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgR0xUZXh0dXJlIH0gZnJvbSAnLi9HTFRleHR1cmUubWpzJztcbmltcG9ydCB7IG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0IH0gZnJvbSAnLi91dGlscy9tYXBUeXBlQW5kRm9ybWF0VG9JbnRlcm5hbEZvcm1hdC5tanMnO1xuXG5jbGFzcyBUZXh0dXJlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5ib3VuZFRleHR1cmVzID0gW107XG4gICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSAtMTtcbiAgICB0aGlzLm1hbmFnZWRUZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gZmFsc2U7XG4gICAgdGhpcy51bmtub3duVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZSgpO1xuICAgIHRoaXMuaGFzSW50ZWdlclRleHR1cmVzID0gZmFsc2U7XG4gIH1cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICAgIHRoaXMud2ViR0xWZXJzaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbjtcbiAgICB0aGlzLmludGVybmFsRm9ybWF0cyA9IG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0KGdsKTtcbiAgICBjb25zdCBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aCA9IG1heFRleHR1cmVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5lbXB0eVRleHR1cmVzID0ge307XG4gICAgY29uc3QgZW1wdHlUZXh0dXJlMkQgPSBuZXcgR0xUZXh0dXJlKGdsLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZW1wdHlUZXh0dXJlMkQudGV4dHVyZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBuZXcgVWludDhBcnJheSg0KSk7XG4gICAgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfMkRdID0gZW1wdHlUZXh0dXJlMkQ7XG4gICAgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdID0gbmV3IEdMVGV4dHVyZShnbC5jcmVhdGVUZXh0dXJlKCkpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFX0NVQkVfTUFQXS50ZXh0dXJlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICB9XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYmluZChudWxsLCBpKTtcbiAgICB9XG4gIH1cbiAgYmluZCh0ZXh0dXJlLCBsb2NhdGlvbiA9IDApIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIHRleHR1cmUgPSB0ZXh0dXJlPy5jYXN0VG9CYXNlVGV4dHVyZSgpO1xuICAgIGlmICh0ZXh0dXJlPy52YWxpZCAmJiAhdGV4dHVyZS5wYXJlbnRUZXh0dXJlQXJyYXkpIHtcbiAgICAgIHRleHR1cmUudG91Y2hlZCA9IHRoaXMucmVuZGVyZXIudGV4dHVyZUdDLmNvdW50O1xuICAgICAgY29uc3QgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmluaXRUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgaWYgKHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gIT09IHRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBsb2NhdGlvbikge1xuICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgZ2xUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgfVxuICAgICAgaWYgKGdsVGV4dHVyZS5kaXJ0eUlkICE9PSB0ZXh0dXJlLmRpcnR5SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBsb2NhdGlvbikge1xuICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKGdsVGV4dHVyZS5kaXJ0eVN0eWxlSWQgIT09IHRleHR1cmUuZGlydHlTdHlsZUlkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZVN0eWxlKHRleHR1cmUpO1xuICAgICAgfVxuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSA9IHRleHR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFXzJEXS50ZXh0dXJlKTtcbiAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IHRydWU7XG4gICAgdGhpcy5oYXNJbnRlZ2VyVGV4dHVyZXMgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbaV0gPSB0aGlzLnVua25vd25UZXh0dXJlO1xuICAgIH1cbiAgfVxuICB1bmJpbmQodGV4dHVyZSkge1xuICAgIGNvbnN0IHsgZ2wsIGJvdW5kVGV4dHVyZXMgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzKSB7XG4gICAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChib3VuZFRleHR1cmVzW2ldID09PSB0aGlzLnVua25vd25UZXh0dXJlKSB7XG4gICAgICAgICAgdGhpcy5iaW5kKG51bGwsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJvdW5kVGV4dHVyZXNbaV0gPT09IHRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBpKSB7XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkpO1xuICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gaTtcbiAgICAgICAgfVxuICAgICAgICBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgdGhpcy5lbXB0eVRleHR1cmVzW3RleHR1cmUudGFyZ2V0XS50ZXh0dXJlKTtcbiAgICAgICAgYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuc3VyZVNhbXBsZXJUeXBlKG1heFRleHR1cmVzKSB7XG4gICAgY29uc3QgeyBib3VuZFRleHR1cmVzLCBoYXNJbnRlZ2VyVGV4dHVyZXMsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGlmICghaGFzSW50ZWdlclRleHR1cmVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBtYXhUZXh0dXJlcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCB0ZXggPSBib3VuZFRleHR1cmVzW2ldO1xuICAgICAgaWYgKHRleCkge1xuICAgICAgICBjb25zdCBnbFRleHR1cmUgPSB0ZXguX2dsVGV4dHVyZXNbQ09OVEVYVF9VSURdO1xuICAgICAgICBpZiAoZ2xUZXh0dXJlLnNhbXBsZXJUeXBlICE9PSBTQU1QTEVSX1RZUEVTLkZMT0FUKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZCh0ZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGluaXRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICBjb25zdCBnbFRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpKTtcbiAgICBnbFRleHR1cmUuZGlydHlJZCA9IC0xO1xuICAgIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0gPSBnbFRleHR1cmU7XG4gICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICB0ZXh0dXJlLm9uKFwiZGlzcG9zZVwiLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKTtcbiAgICByZXR1cm4gZ2xUZXh0dXJlO1xuICB9XG4gIGluaXRUZXh0dXJlVHlwZSh0ZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQgPSB0aGlzLmludGVybmFsRm9ybWF0c1t0ZXh0dXJlLnR5cGVdPy5bdGV4dHVyZS5mb3JtYXRdID8/IHRleHR1cmUuZm9ybWF0O1xuICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiA9PT0gMiAmJiB0ZXh0dXJlLnR5cGUgPT09IFRZUEVTLkhBTEZfRkxPQVQpIHtcbiAgICAgIGdsVGV4dHVyZS50eXBlID0gdGhpcy5nbC5IQUxGX0ZMT0FUO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbFRleHR1cmUudHlwZSA9IHRleHR1cmUudHlwZTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgY29uc3QgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBpZiAoIWdsVGV4dHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5pbml0VGV4dHVyZVR5cGUodGV4dHVyZSwgZ2xUZXh0dXJlKTtcbiAgICBpZiAodGV4dHVyZS5yZXNvdXJjZT8udXBsb2FkKHJlbmRlcmVyLCB0ZXh0dXJlLCBnbFRleHR1cmUpKSB7XG4gICAgICBpZiAoZ2xUZXh0dXJlLnNhbXBsZXJUeXBlICE9PSBTQU1QTEVSX1RZUEVTLkZMT0FUKSB7XG4gICAgICAgIHRoaXMuaGFzSW50ZWdlclRleHR1cmVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0dXJlLnJlYWxXaWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRleHR1cmUucmVhbEhlaWdodDtcbiAgICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICBpZiAoZ2xUZXh0dXJlLndpZHRoICE9PSB3aWR0aCB8fCBnbFRleHR1cmUuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgZ2xUZXh0dXJlLmRpcnR5SWQgPCAwKSB7XG4gICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBnbC50ZXhJbWFnZTJEKHRleHR1cmUudGFyZ2V0LCAwLCBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIHRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXh0dXJlLmRpcnR5U3R5bGVJZCAhPT0gZ2xUZXh0dXJlLmRpcnR5U3R5bGVJZCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0dXJlU3R5bGUodGV4dHVyZSk7XG4gICAgfVxuICAgIGdsVGV4dHVyZS5kaXJ0eUlkID0gdGV4dHVyZS5kaXJ0eUlkO1xuICB9XG4gIGRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHNraXBSZW1vdmUpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNhc3RUb0Jhc2VUZXh0dXJlKCk7XG4gICAgaWYgKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0pIHtcbiAgICAgIHRoaXMudW5iaW5kKHRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUpO1xuICAgICAgdGV4dHVyZS5vZmYoXCJkaXNwb3NlXCIsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xuICAgICAgZGVsZXRlIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICBpZiAoIXNraXBSZW1vdmUpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMubWFuYWdlZFRleHR1cmVzLmluZGV4T2YodGV4dHVyZSk7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgIHJlbW92ZUl0ZW1zKHRoaXMubWFuYWdlZFRleHR1cmVzLCBpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVUZXh0dXJlU3R5bGUodGV4dHVyZSkge1xuICAgIGNvbnN0IGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKCFnbFRleHR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCh0ZXh0dXJlLm1pcG1hcCA9PT0gTUlQTUFQX01PREVTLlBPVzIgfHwgdGhpcy53ZWJHTFZlcnNpb24gIT09IDIpICYmICF0ZXh0dXJlLmlzUG93ZXJPZlR3bykge1xuICAgICAgZ2xUZXh0dXJlLm1pcG1hcCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbFRleHR1cmUubWlwbWFwID0gdGV4dHVyZS5taXBtYXAgPj0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMud2ViR0xWZXJzaW9uICE9PSAyICYmICF0ZXh0dXJlLmlzUG93ZXJPZlR3bykge1xuICAgICAgZ2xUZXh0dXJlLndyYXBNb2RlID0gV1JBUF9NT0RFUy5DTEFNUDtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xUZXh0dXJlLndyYXBNb2RlID0gdGV4dHVyZS53cmFwTW9kZTtcbiAgICB9XG4gICAgaWYgKHRleHR1cmUucmVzb3VyY2U/LnN0eWxlKHRoaXMucmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkpIHtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpO1xuICAgIH1cbiAgICBnbFRleHR1cmUuZGlydHlTdHlsZUlkID0gdGV4dHVyZS5kaXJ0eVN0eWxlSWQ7XG4gIH1cbiAgc2V0U3R5bGUodGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGlmIChnbFRleHR1cmUubWlwbWFwICYmIHRleHR1cmUubWlwbWFwICE9PSBNSVBNQVBfTU9ERVMuT05fTUFOVUFMKSB7XG4gICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0ZXh0dXJlLnRhcmdldCk7XG4gICAgfVxuICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbFRleHR1cmUud3JhcE1vZGUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbFRleHR1cmUud3JhcE1vZGUpO1xuICAgIGlmIChnbFRleHR1cmUubWlwbWFwKSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBTQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgY29uc3QgYW5pc290cm9waWNFeHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy5hbmlzb3Ryb3BpY0ZpbHRlcmluZztcbiAgICAgIGlmIChhbmlzb3Ryb3BpY0V4dCAmJiB0ZXh0dXJlLmFuaXNvdHJvcGljTGV2ZWwgPiAwICYmIHRleHR1cmUuc2NhbGVNb2RlID09PSBTQ0FMRV9NT0RFUy5MSU5FQVIpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBNYXRoLm1pbih0ZXh0dXJlLmFuaXNvdHJvcGljTGV2ZWwsIGdsLmdldFBhcmFtZXRlcihhbmlzb3Ryb3BpY0V4dC5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyZih0ZXh0dXJlLnRhcmdldCwgYW5pc290cm9waWNFeHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIGxldmVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gICAgfVxuICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFNDQUxFX01PREVTLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cblRleHR1cmVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInRleHR1cmVcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFRleHR1cmVTeXN0ZW0pO1xuXG5leHBvcnQgeyBUZXh0dXJlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcblxuY2xhc3MgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICB9XG4gIGJpbmQodHJhbnNmb3JtRmVlZGJhY2spIHtcbiAgICBjb25zdCB7IGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcztcbiAgICBjb25zdCBnbFRyYW5zZm9ybUZlZWRiYWNrID0gdHJhbnNmb3JtRmVlZGJhY2suX2dsVHJhbnNmb3JtRmVlZGJhY2tzW0NPTlRFWFRfVUlEXSB8fCB0aGlzLmNyZWF0ZUdMVHJhbnNmb3JtRmVlZGJhY2sodHJhbnNmb3JtRmVlZGJhY2spO1xuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIGdsVHJhbnNmb3JtRmVlZGJhY2spO1xuICB9XG4gIHVuYmluZCgpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIG51bGwpO1xuICB9XG4gIGJlZ2luVHJhbnNmb3JtRmVlZGJhY2soZHJhd01vZGUsIHNoYWRlcikge1xuICAgIGNvbnN0IHsgZ2wsIHJlbmRlcmVyIH0gPSB0aGlzO1xuICAgIGlmIChzaGFkZXIpIHtcbiAgICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XG4gICAgfVxuICAgIGdsLmJlZ2luVHJhbnNmb3JtRmVlZGJhY2soZHJhd01vZGUpO1xuICB9XG4gIGVuZFRyYW5zZm9ybUZlZWRiYWNrKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuZW5kVHJhbnNmb3JtRmVlZGJhY2soKTtcbiAgfVxuICBjcmVhdGVHTFRyYW5zZm9ybUZlZWRiYWNrKHRmKSB7XG4gICAgY29uc3QgeyBnbCwgcmVuZGVyZXIsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdsVHJhbnNmb3JtRmVlZGJhY2sgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuICAgIHRmLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1tDT05URVhUX1VJRF0gPSBnbFRyYW5zZm9ybUZlZWRiYWNrO1xuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIGdsVHJhbnNmb3JtRmVlZGJhY2spO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGYuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gdGYuYnVmZmVyc1tpXTtcbiAgICAgIGlmICghYnVmZmVyKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJlbmRlcmVyLmJ1ZmZlci51cGRhdGUoYnVmZmVyKTtcbiAgICAgIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5yZWZDb3VudCsrO1xuICAgICAgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLmJ1ZmZlciB8fCBudWxsKTtcbiAgICB9XG4gICAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gICAgdGYuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgcmV0dXJuIGdsVHJhbnNmb3JtRmVlZGJhY2s7XG4gIH1cbiAgZGlzcG9zZVRyYW5zZm9ybUZlZWRiYWNrKHRmLCBjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGdsVEYgPSB0Zi5fZ2xUcmFuc2Zvcm1GZWVkYmFja3NbdGhpcy5DT05URVhUX1VJRF07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIHRmLmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xuICAgIGNvbnN0IGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGlmIChidWZmZXJTeXN0ZW0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGYuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0Zi5idWZmZXJzW2ldO1xuICAgICAgICBpZiAoIWJ1ZmZlcilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYnVmID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIGlmIChidWYpIHtcbiAgICAgICAgICBidWYucmVmQ291bnQtLTtcbiAgICAgICAgICBpZiAoYnVmLnJlZkNvdW50ID09PSAwICYmICFjb250ZXh0TG9zdCkge1xuICAgICAgICAgICAgYnVmZmVyU3lzdGVtLmRpc3Bvc2UoYnVmZmVyLCBjb250ZXh0TG9zdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZ2xURikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICBnbC5kZWxldGVUcmFuc2Zvcm1GZWVkYmFjayhnbFRGKTtcbiAgICB9XG4gICAgZGVsZXRlIHRmLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwidHJhbnNmb3JtRmVlZGJhY2tcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtKTtcblxuZXhwb3J0IHsgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJ0BwaXhpL21hdGgnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5cbmNsYXNzIFZpZXdTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnNjcmVlbiA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICAgIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMudmlldyB8fCBzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbiB8fCBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMuYXV0b0RlbnNpdHkgPSAhIW9wdGlvbnMuYXV0b0RlbnNpdHk7XG4gIH1cbiAgcmVzaXplVmlldyhkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQpIHtcbiAgICB0aGlzLmVsZW1lbnQud2lkdGggPSBNYXRoLnJvdW5kKGRlc2lyZWRTY3JlZW5XaWR0aCAqIHRoaXMucmVzb2x1dGlvbik7XG4gICAgdGhpcy5lbGVtZW50LmhlaWdodCA9IE1hdGgucm91bmQoZGVzaXJlZFNjcmVlbkhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gICAgY29uc3Qgc2NyZWVuV2lkdGggPSB0aGlzLmVsZW1lbnQud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgY29uc3Qgc2NyZWVuSGVpZ2h0ID0gdGhpcy5lbGVtZW50LmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLnNjcmVlbi53aWR0aCA9IHNjcmVlbldpZHRoO1xuICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IHNjcmVlbkhlaWdodDtcbiAgICBpZiAodGhpcy5hdXRvRGVuc2l0eSkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gYCR7c2NyZWVuV2lkdGh9cHhgO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3NjcmVlbkhlaWdodH1weGA7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuZW1pdChcInJlc2l6ZVwiLCBzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMucmVzaXplLmVtaXQodGhpcy5zY3JlZW4ud2lkdGgsIHRoaXMuc2NyZWVuLmhlaWdodCk7XG4gIH1cbiAgZGVzdHJveShyZW1vdmVWaWV3KSB7XG4gICAgaWYgKHJlbW92ZVZpZXcpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcbiAgfVxufVxuVmlld1N5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgd2lkdGg6IDgwMCxcbiAgaGVpZ2h0OiA2MDAsXG4gIHJlc29sdXRpb246IHNldHRpbmdzLlJFU09MVVRJT04sXG4gIGF1dG9EZW5zaXR5OiBmYWxzZVxufTtcblZpZXdTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiX3ZpZXdcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFZpZXdTeXN0ZW0pO1xuXG5leHBvcnQgeyBWaWV3U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3U3lzdGVtLm1qcy5tYXBcbiIsImV4cG9ydCB7IEJhY2tncm91bmRTeXN0ZW0gfSBmcm9tICcuL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgQmF0Y2hTeXN0ZW0gfSBmcm9tICcuL2JhdGNoL0JhdGNoU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBDb250ZXh0U3lzdGVtIH0gZnJvbSAnLi9jb250ZXh0L0NvbnRleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEZpbHRlclN5c3RlbSB9IGZyb20gJy4vZmlsdGVycy9GaWx0ZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEZyYW1lYnVmZmVyU3lzdGVtIH0gZnJvbSAnLi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2VvbWV0cnlTeXN0ZW0gfSBmcm9tICcuL2dlb21ldHJ5L0dlb21ldHJ5U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBNYXNrU3lzdGVtIH0gZnJvbSAnLi9tYXNrL01hc2tTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFNjaXNzb3JTeXN0ZW0gfSBmcm9tICcuL21hc2svU2Npc3NvclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgU3RlbmNpbFN5c3RlbSB9IGZyb20gJy4vbWFzay9TdGVuY2lsU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBQbHVnaW5TeXN0ZW0gfSBmcm9tICcuL3BsdWdpbi9QbHVnaW5TeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFByb2plY3Rpb25TeXN0ZW0gfSBmcm9tICcuL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJUZXh0dXJlL0dlbmVyYXRlVGV4dHVyZVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgUmVuZGVyVGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBTaGFkZXJTeXN0ZW0gfSBmcm9tICcuL3NoYWRlci9TaGFkZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFN0YXJ0dXBTeXN0ZW0gfSBmcm9tICcuL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgU3RhdGVTeXN0ZW0gfSBmcm9tICcuL3N0YXRlL1N0YXRlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBTeXN0ZW1NYW5hZ2VyIH0gZnJvbSAnLi9zeXN0ZW0vU3lzdGVtTWFuYWdlci5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZUdDU3lzdGVtIH0gZnJvbSAnLi90ZXh0dXJlcy9UZXh0dXJlR0NTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFRleHR1cmVTeXN0ZW0gfSBmcm9tICcuL3RleHR1cmVzL1RleHR1cmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtIH0gZnJvbSAnLi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgVmlld1N5c3RlbSB9IGZyb20gJy4vdmlldy9WaWV3U3lzdGVtLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeXN0ZW1zLm1qcy5tYXBcbiIsImltcG9ydCB7IEVOViB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgQmF0Y2hSZW5kZXJlciB9IGZyb20gJy4vYmF0Y2gvQmF0Y2hSZW5kZXJlci5tanMnO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlci5tanMnO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gJy4vc2hhZGVyL1Byb2dyYW0ubWpzJztcbmltcG9ydCAnLi9zeXN0ZW1zLm1qcyc7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvQmFzZVRleHR1cmUubWpzJztcbmltcG9ydCB7IENvbnRleHRTeXN0ZW0gfSBmcm9tICcuL2NvbnRleHQvQ29udGV4dFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgQmFja2dyb3VuZFN5c3RlbSB9IGZyb20gJy4vYmFja2dyb3VuZC9CYWNrZ3JvdW5kU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBWaWV3U3lzdGVtIH0gZnJvbSAnLi92aWV3L1ZpZXdTeXN0ZW0ubWpzJztcbmltcG9ydCB7IFN0YXJ0dXBTeXN0ZW0gfSBmcm9tICcuL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZUdDU3lzdGVtIH0gZnJvbSAnLi90ZXh0dXJlcy9UZXh0dXJlR0NTeXN0ZW0ubWpzJztcblxuc2V0dGluZ3MuUFJFRkVSX0VOViA9IEVOVi5XRUJHTDI7XG5zZXR0aW5ncy5TVFJJQ1RfVEVYVFVSRV9DQUNIRSA9IGZhbHNlO1xuc2V0dGluZ3MuUkVOREVSX09QVElPTlMgPSB7XG4gIC4uLkNvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsXG4gIC4uLkJhY2tncm91bmRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsXG4gIC4uLlZpZXdTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsXG4gIC4uLlN0YXJ0dXBTeXN0ZW0uZGVmYXVsdE9wdGlvbnNcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhzZXR0aW5ncywge1xuICBXUkFQX01PREU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMud3JhcE1vZGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5XUkFQX01PREUgaXMgZGVwcmVjYXRlZCwgdXNlIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLndyYXBNb2RlXCIpO1xuICAgICAgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMud3JhcE1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIFNDQUxFX01PREU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU0NBTEVfTU9ERSBpcyBkZXByZWNhdGVkLCB1c2UgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlXCIpO1xuICAgICAgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBNSVBNQVBfVEVYVFVSRVM6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMubWlwbWFwO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuTUlQTUFQX1RFWFRVUkVTIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5taXBtYXBcIik7XG4gICAgICBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5taXBtYXAgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIEFOSVNPVFJPUElDX0xFVkVMOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLmFuaXNvdHJvcGljTGV2ZWw7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5BTklTT1RST1BJQ19MRVZFTCBpcyBkZXByZWNhdGVkLCB1c2UgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuYW5pc290cm9waWNMZXZlbFwiKTtcbiAgICAgIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLmFuaXNvdHJvcGljTGV2ZWwgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIEZJTFRFUl9SRVNPTFVUSU9OOiB7XG4gICAgZ2V0KCkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkZJTFRFUl9SRVNPTFVUSU9OIGlzIGRlcHJlY2F0ZWQsIHVzZSBGaWx0ZXIuZGVmYXVsdFJlc29sdXRpb25cIik7XG4gICAgICByZXR1cm4gRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBGaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIEZJTFRFUl9NVUxUSVNBTVBMRToge1xuICAgIGdldCgpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5GSUxURVJfTVVMVElTQU1QTEUgaXMgZGVwcmVjYXRlZCwgdXNlIEZpbHRlci5kZWZhdWx0TXVsdGlzYW1wbGVcIik7XG4gICAgICByZXR1cm4gRmlsdGVyLmRlZmF1bHRNdWx0aXNhbXBsZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgRmlsdGVyLmRlZmF1bHRNdWx0aXNhbXBsZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgU1BSSVRFX01BWF9URVhUVVJFUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXRjaFJlbmRlcmVyLmRlZmF1bHRNYXhUZXh0dXJlcztcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlNQUklURV9NQVhfVEVYVFVSRVMgaXMgZGVwcmVjYXRlZCwgdXNlIEJhdGNoUmVuZGVyZXIuZGVmYXVsdE1heFRleHR1cmVzXCIpO1xuICAgICAgQmF0Y2hSZW5kZXJlci5kZWZhdWx0TWF4VGV4dHVyZXMgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIFNQUklURV9CQVRDSF9TSVpFOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlNQUklURV9CQVRDSF9TSVpFIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXRjaFJlbmRlcmVyLmRlZmF1bHRCYXRjaFNpemVcIik7XG4gICAgICBCYXRjaFJlbmRlcmVyLmRlZmF1bHRCYXRjaFNpemUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIENBTl9VUExPQURfU0FNRV9CVUZGRVI6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUiBpcyBkZXByZWNhdGVkLCB1c2UgQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyXCIpO1xuICAgICAgQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBHQ19NT0RFOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TW9kZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkdDX01PREUgaXMgZGVwcmVjYXRlZCwgdXNlIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TW9kZVwiKTtcbiAgICAgIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgR0NfTUFYX0lETEU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNYXhJZGxlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuR0NfTUFYX0lETEUgaXMgZGVwcmVjYXRlZCwgdXNlIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZVwiKTtcbiAgICAgIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgR0NfTUFYX0NIRUNLX0NPVU5UOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0Q2hlY2tDb3VudE1heDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkdDX01BWF9DSEVDS19DT1VOVCBpcyBkZXByZWNhdGVkLCB1c2UgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4XCIpO1xuICAgICAgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4ID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBQUkVDSVNJT05fVkVSVEVYOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFByb2dyYW0uZGVmYXVsdFZlcnRleFByZWNpc2lvbjtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlBSRUNJU0lPTl9WRVJURVggaXMgZGVwcmVjYXRlZCwgdXNlIFByb2dyYW0uZGVmYXVsdFZlcnRleFByZWNpc2lvblwiKTtcbiAgICAgIFByb2dyYW0uZGVmYXVsdFZlcnRleFByZWNpc2lvbiA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgUFJFQ0lTSU9OX0ZSQUdNRU5UOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFByb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuUFJFQ0lTSU9OX0ZSQUdNRU5UIGlzIGRlcHJlY2F0ZWQsIHVzZSBQcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvblwiKTtcbiAgICAgIFByb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uID0gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLm1qcy5tYXBcbiIsInZhciBVUERBVEVfUFJJT1JJVFkgPSAvKiBAX19QVVJFX18gKi8gKChVUERBVEVfUFJJT1JJVFkyKSA9PiB7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIklOVEVSQUNUSU9OXCJdID0gNTBdID0gXCJJTlRFUkFDVElPTlwiO1xuICBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTJbXCJISUdIXCJdID0gMjVdID0gXCJISUdIXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIk5PUk1BTFwiXSA9IDBdID0gXCJOT1JNQUxcIjtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiTE9XXCJdID0gLTI1XSA9IFwiTE9XXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIlVUSUxJVFlcIl0gPSAtNTBdID0gXCJVVElMSVRZXCI7XG4gIHJldHVybiBVUERBVEVfUFJJT1JJVFkyO1xufSkoVVBEQVRFX1BSSU9SSVRZIHx8IHt9KTtcblxuZXhwb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJjbGFzcyBUaWNrZXJMaXN0ZW5lciB7XG4gIGNvbnN0cnVjdG9yKGZuLCBjb250ZXh0ID0gbnVsbCwgcHJpb3JpdHkgPSAwLCBvbmNlID0gZmFsc2UpIHtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICB0aGlzLm9uY2UgPSBvbmNlO1xuICB9XG4gIG1hdGNoKGZuLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmZuID09PSBmbiAmJiB0aGlzLmNvbnRleHQgPT09IGNvbnRleHQ7XG4gIH1cbiAgZW1pdChkZWx0YVRpbWUpIHtcbiAgICBpZiAodGhpcy5mbikge1xuICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICB0aGlzLmZuLmNhbGwodGhpcy5jb250ZXh0LCBkZWx0YVRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mbihkZWx0YVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMubmV4dDtcbiAgICBpZiAodGhpcy5vbmNlKSB7XG4gICAgICB0aGlzLmRlc3Ryb3kodHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZWRpcmVjdDtcbiAgfVxuICBjb25uZWN0KHByZXZpb3VzKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIGlmIChwcmV2aW91cy5uZXh0KSB7XG4gICAgICBwcmV2aW91cy5uZXh0LnByZXZpb3VzID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5uZXh0ID0gcHJldmlvdXMubmV4dDtcbiAgICBwcmV2aW91cy5uZXh0ID0gdGhpcztcbiAgfVxuICBkZXN0cm95KGhhcmQgPSBmYWxzZSkge1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5mbiA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5wcmV2aW91cykge1xuICAgICAgdGhpcy5wcmV2aW91cy5uZXh0ID0gdGhpcy5uZXh0O1xuICAgIH1cbiAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICB0aGlzLm5leHQucHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMubmV4dDtcbiAgICB0aGlzLm5leHQgPSBoYXJkID8gbnVsbCA6IHJlZGlyZWN0O1xuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgIHJldHVybiByZWRpcmVjdDtcbiAgfVxufVxuXG5leHBvcnQgeyBUaWNrZXJMaXN0ZW5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyTGlzdGVuZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuaW1wb3J0IHsgVGlja2VyTGlzdGVuZXIgfSBmcm9tICcuL1RpY2tlckxpc3RlbmVyLm1qcyc7XG5cbmNvbnN0IF9UaWNrZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XG4gICAgdGhpcy5kZWx0YVRpbWUgPSAxO1xuICAgIHRoaXMubGFzdFRpbWUgPSAtMTtcbiAgICB0aGlzLnNwZWVkID0gMTtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEwMDtcbiAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgIHRoaXMuX3Byb3RlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3RGcmFtZSA9IC0xO1xuICAgIHRoaXMuX2hlYWQgPSBuZXcgVGlja2VyTGlzdGVuZXIobnVsbCwgbnVsbCwgSW5maW5pdHkpO1xuICAgIHRoaXMuZGVsdGFNUyA9IDEgLyBfVGlja2VyLnRhcmdldEZQTVM7XG4gICAgdGhpcy5lbGFwc2VkTVMgPSAxIC8gX1RpY2tlci50YXJnZXRGUE1TO1xuICAgIHRoaXMuX3RpY2sgPSAodGltZSkgPT4ge1xuICAgICAgdGhpcy5fcmVxdWVzdElkID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGUodGltZSk7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQgJiYgdGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX3JlcXVlc3RJZk5lZWRlZCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy5sYXN0VGltZTtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcbiAgICB9XG4gIH1cbiAgX2NhbmNlbElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfc3RhcnRJZlBvc3NpYmxlKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZk5lZWRlZCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgYWRkKGZuLCBjb250ZXh0LCBwcmlvcml0eSA9IFVQREFURV9QUklPUklUWS5OT1JNQUwpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSkpO1xuICB9XG4gIGFkZE9uY2UoZm4sIGNvbnRleHQsIHByaW9yaXR5ID0gVVBEQVRFX1BSSU9SSVRZLk5PUk1BTCkge1xuICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcihuZXcgVGlja2VyTGlzdGVuZXIoZm4sIGNvbnRleHQsIHByaW9yaXR5LCB0cnVlKSk7XG4gIH1cbiAgX2FkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgbGV0IHByZXZpb3VzID0gdGhpcy5faGVhZDtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBpZiAobGlzdGVuZXIucHJpb3JpdHkgPiBjdXJyZW50LnByaW9yaXR5KSB7XG4gICAgICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKCFsaXN0ZW5lci5wcmV2aW91cykge1xuICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc3RhcnRJZlBvc3NpYmxlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlKGZuLCBjb250ZXh0KSB7XG4gICAgbGV0IGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgaWYgKGxpc3RlbmVyLm1hdGNoKGZuLCBjb250ZXh0KSkge1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9oZWFkLm5leHQpIHtcbiAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldCBjb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQubmV4dCkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5fcHJvdGVjdGVkKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMuX2hlYWQubmV4dDtcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9oZWFkLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSkge1xuICAgIGxldCBlbGFwc2VkTVM7XG4gICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5sYXN0VGltZSkge1xuICAgICAgZWxhcHNlZE1TID0gdGhpcy5lbGFwc2VkTVMgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG4gICAgICBpZiAoZWxhcHNlZE1TID4gdGhpcy5fbWF4RWxhcHNlZE1TKSB7XG4gICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgIH1cbiAgICAgIGVsYXBzZWRNUyAqPSB0aGlzLnNwZWVkO1xuICAgICAgaWYgKHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fbGFzdEZyYW1lIHwgMDtcbiAgICAgICAgaWYgKGRlbHRhIDwgdGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGN1cnJlbnRUaW1lIC0gZGVsdGEgJSB0aGlzLl9taW5FbGFwc2VkTVM7XG4gICAgICB9XG4gICAgICB0aGlzLmRlbHRhTVMgPSBlbGFwc2VkTVM7XG4gICAgICB0aGlzLmRlbHRhVGltZSA9IHRoaXMuZGVsdGFNUyAqIF9UaWNrZXIudGFyZ2V0RlBNUztcbiAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgbGV0IGxpc3RlbmVyID0gaGVhZC5uZXh0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZW1pdCh0aGlzLmRlbHRhVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWhlYWQubmV4dCkge1xuICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlbHRhVGltZSA9IHRoaXMuZGVsdGFNUyA9IHRoaXMuZWxhcHNlZE1TID0gMDtcbiAgICB9XG4gICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIGdldCBGUFMoKSB7XG4gICAgcmV0dXJuIDFlMyAvIHRoaXMuZWxhcHNlZE1TO1xuICB9XG4gIGdldCBtaW5GUFMoKSB7XG4gICAgcmV0dXJuIDFlMyAvIHRoaXMuX21heEVsYXBzZWRNUztcbiAgfVxuICBzZXQgbWluRlBTKGZwcykge1xuICAgIGNvbnN0IG1pbkZQUyA9IE1hdGgubWluKHRoaXMubWF4RlBTLCBmcHMpO1xuICAgIGNvbnN0IG1pbkZQTVMgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBtaW5GUFMpIC8gMWUzLCBfVGlja2VyLnRhcmdldEZQTVMpO1xuICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEgLyBtaW5GUE1TO1xuICB9XG4gIGdldCBtYXhGUFMoKSB7XG4gICAgaWYgKHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoMWUzIC8gdGhpcy5fbWluRWxhcHNlZE1TKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc2V0IG1heEZQUyhmcHMpIHtcbiAgICBpZiAoZnBzID09PSAwKSB7XG4gICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhGUFMgPSBNYXRoLm1heCh0aGlzLm1pbkZQUywgZnBzKTtcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDEgLyAobWF4RlBTIC8gMWUzKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBzaGFyZWQoKSB7XG4gICAgaWYgKCFfVGlja2VyLl9zaGFyZWQpIHtcbiAgICAgIGNvbnN0IHNoYXJlZCA9IF9UaWNrZXIuX3NoYXJlZCA9IG5ldyBfVGlja2VyKCk7XG4gICAgICBzaGFyZWQuYXV0b1N0YXJ0ID0gdHJ1ZTtcbiAgICAgIHNoYXJlZC5fcHJvdGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIF9UaWNrZXIuX3NoYXJlZDtcbiAgfVxuICBzdGF0aWMgZ2V0IHN5c3RlbSgpIHtcbiAgICBpZiAoIV9UaWNrZXIuX3N5c3RlbSkge1xuICAgICAgY29uc3Qgc3lzdGVtID0gX1RpY2tlci5fc3lzdGVtID0gbmV3IF9UaWNrZXIoKTtcbiAgICAgIHN5c3RlbS5hdXRvU3RhcnQgPSB0cnVlO1xuICAgICAgc3lzdGVtLl9wcm90ZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlci5fc3lzdGVtO1xuICB9XG59O1xubGV0IFRpY2tlciA9IF9UaWNrZXI7XG5UaWNrZXIudGFyZ2V0RlBNUyA9IDAuMDY7XG5cbmV4cG9ydCB7IFRpY2tlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuZXhwb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gJ0BwaXhpL3V0aWxzJztcbmltcG9ydCB7IFRpY2tlciB9IGZyb20gJy4vVGlja2VyLm1qcyc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNldHRpbmdzLCB7XG4gIFRBUkdFVF9GUE1TOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFRpY2tlci50YXJnZXRGUE1TO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuVEFSR0VUX0ZQTVMgaXMgZGVwcmVjYXRlZCwgdXNlIFRpY2tlci50YXJnZXRGUE1TXCIpO1xuICAgICAgVGlja2VyLnRhcmdldEZQTVMgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuaW1wb3J0IHsgVGlja2VyIH0gZnJvbSAnLi9UaWNrZXIubWpzJztcblxuY2xhc3MgVGlja2VyUGx1Z2luIHtcbiAgc3RhdGljIGluaXQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGF1dG9TdGFydDogdHJ1ZSxcbiAgICAgIHNoYXJlZFRpY2tlcjogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aWNrZXJcIiwge1xuICAgICAgc2V0KHRpY2tlcikge1xuICAgICAgICBpZiAodGhpcy5fdGlja2VyKSB7XG4gICAgICAgICAgdGhpcy5fdGlja2VyLnJlbW92ZSh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGlja2VyID0gdGlja2VyO1xuICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgdGlja2VyLmFkZCh0aGlzLnJlbmRlciwgdGhpcywgVVBEQVRFX1BSSU9SSVRZLkxPVyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWNrZXI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdG9wID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdGlja2VyLnN0b3AoKTtcbiAgICB9O1xuICAgIHRoaXMuc3RhcnQgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aWNrZXIuc3RhcnQoKTtcbiAgICB9O1xuICAgIHRoaXMuX3RpY2tlciA9IG51bGw7XG4gICAgdGhpcy50aWNrZXIgPSBvcHRpb25zLnNoYXJlZFRpY2tlciA/IFRpY2tlci5zaGFyZWQgOiBuZXcgVGlja2VyKCk7XG4gICAgaWYgKG9wdGlvbnMuYXV0b1N0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl90aWNrZXIpIHtcbiAgICAgIGNvbnN0IG9sZFRpY2tlciA9IHRoaXMuX3RpY2tlcjtcbiAgICAgIHRoaXMudGlja2VyID0gbnVsbDtcbiAgICAgIG9sZFRpY2tlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcbmV4dGVuc2lvbnMuYWRkKFRpY2tlclBsdWdpbik7XG5cbmV4cG9ydCB7IFRpY2tlclBsdWdpbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyUGx1Z2luLm1qcy5tYXBcbiIsImltcG9ydCAnLi9zZXR0aW5ncy5tanMnO1xuZXhwb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuZXhwb3J0IHsgVGlja2VyIH0gZnJvbSAnLi9UaWNrZXIubWpzJztcbmV4cG9ydCB7IFRpY2tlclBsdWdpbiB9IGZyb20gJy4vVGlja2VyUGx1Z2luLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zLCBFeHRlbnNpb25UeXBlIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5cbmNvbnN0IHJlbmRlcmVycyA9IFtdO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeUxpc3QoRXh0ZW5zaW9uVHlwZS5SZW5kZXJlciwgcmVuZGVyZXJzKTtcbmZ1bmN0aW9uIGF1dG9EZXRlY3RSZW5kZXJlcihvcHRpb25zKSB7XG4gIGZvciAoY29uc3QgUmVuZGVyZXJUeXBlIG9mIHJlbmRlcmVycykge1xuICAgIGlmIChSZW5kZXJlclR5cGUudGVzdChvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBSZW5kZXJlclR5cGUob3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBhdXRvLWRldGVjdCBhIHN1aXRhYmxlIHJlbmRlcmVyLlwiKTtcbn1cblxuZXhwb3J0IHsgYXV0b0RldGVjdFJlbmRlcmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvRGV0ZWN0UmVuZGVyZXIubWpzLm1hcFxuIiwidmFyICRkZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG59XCI7XG5cbmV4cG9ydCB7ICRkZWZhdWx0VmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHQubWpzLm1hcFxuIiwidmFyICRkZWZhdWx0RmlsdGVyVmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxuXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxue1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbn1cXG5cXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxue1xcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7ICRkZWZhdWx0RmlsdGVyVmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRGaWx0ZXIubWpzLm1hcFxuIiwiaW1wb3J0ICRkZWZhdWx0VmVydGV4IGZyb20gJy4vZGVmYXVsdC5tanMnO1xuaW1wb3J0ICRkZWZhdWx0RmlsdGVyVmVydGV4IGZyb20gJy4vZGVmYXVsdEZpbHRlci5tanMnO1xuXG5jb25zdCBkZWZhdWx0VmVydGV4ID0gJGRlZmF1bHRWZXJ0ZXg7XG5jb25zdCBkZWZhdWx0RmlsdGVyVmVydGV4ID0gJGRlZmF1bHRGaWx0ZXJWZXJ0ZXg7XG5cbmV4cG9ydCB7IGRlZmF1bHRGaWx0ZXJWZXJ0ZXgsIGRlZmF1bHRWZXJ0ZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1TQUFfUVVBTElUWSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5cbmNsYXNzIE11bHRpc2FtcGxlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgY29udGV4dENoYW5nZShnbCkge1xuICAgIGxldCBzYW1wbGVzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmdldFBhcmFtZXRlcihnbC5GUkFNRUJVRkZFUl9CSU5ESU5HKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICBzYW1wbGVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNBTVBMRVMpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLkRSQVdfRlJBTUVCVUZGRVJfQklORElORyk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICBzYW1wbGVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNBTVBMRVMpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkRSQVdfRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKHNhbXBsZXMgPj0gTVNBQV9RVUFMSVRZLkhJR0gpIHtcbiAgICAgIHRoaXMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuSElHSDtcbiAgICB9IGVsc2UgaWYgKHNhbXBsZXMgPj0gTVNBQV9RVUFMSVRZLk1FRElVTSkge1xuICAgICAgdGhpcy5tdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5NRURJVU07XG4gICAgfSBlbHNlIGlmIChzYW1wbGVzID49IE1TQUFfUVVBTElUWS5MT1cpIHtcbiAgICAgIHRoaXMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTE9XO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk5PTkU7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cbk11bHRpc2FtcGxlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJfbXVsdGlzYW1wbGVcIlxufTtcbmV4dGVuc2lvbnMuYWRkKE11bHRpc2FtcGxlU3lzdGVtKTtcblxuZXhwb3J0IHsgTXVsdGlzYW1wbGVTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpc2FtcGxlU3lzdGVtLm1qcy5tYXBcbiIsImNsYXNzIEdMQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXIgfHwgbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUlEID0gLTE7XG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gLTE7XG4gICAgdGhpcy5yZWZDb3VudCA9IDA7XG4gIH1cbn1cblxuZXhwb3J0IHsgR0xCdWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdMQnVmZmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IEdMQnVmZmVyIH0gZnJvbSAnLi9HTEJ1ZmZlci5tanMnO1xuXG5jbGFzcyBCdWZmZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLm1hbmFnZWRCdWZmZXJzID0ge307XG4gICAgdGhpcy5ib3VuZEJ1ZmZlckJhc2VzID0ge307XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuZGlzcG9zZUFsbCh0cnVlKTtcbiAgICB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgfVxuICBiaW5kKGJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICBnbC5iaW5kQnVmZmVyKGJ1ZmZlci50eXBlLCBnbEJ1ZmZlci5idWZmZXIpO1xuICB9XG4gIHVuYmluZCh0eXBlKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIG51bGwpO1xuICB9XG4gIGJpbmRCdWZmZXJCYXNlKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICBjb25zdCB7IGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5ib3VuZEJ1ZmZlckJhc2VzW2luZGV4XSAhPT0gYnVmZmVyKSB7XG4gICAgICBjb25zdCBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXSB8fCB0aGlzLmNyZWF0ZUdMQnVmZmVyKGJ1ZmZlcik7XG4gICAgICB0aGlzLmJvdW5kQnVmZmVyQmFzZXNbaW5kZXhdID0gYnVmZmVyO1xuICAgICAgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVU5JRk9STV9CVUZGRVIsIGluZGV4LCBnbEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgfVxuICBiaW5kQnVmZmVyUmFuZ2UoYnVmZmVyLCBpbmRleCwgb2Zmc2V0KSB7XG4gICAgY29uc3QgeyBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gfHwgdGhpcy5jcmVhdGVHTEJ1ZmZlcihidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXJSYW5nZShnbC5VTklGT1JNX0JVRkZFUiwgaW5kZXggfHwgMCwgZ2xCdWZmZXIuYnVmZmVyLCBvZmZzZXQgKiAyNTYsIDI1Nik7XG4gIH1cbiAgdXBkYXRlKGJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICBpZiAoYnVmZmVyLl91cGRhdGVJRCA9PT0gZ2xCdWZmZXIudXBkYXRlSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2xCdWZmZXIudXBkYXRlSUQgPSBidWZmZXIuX3VwZGF0ZUlEO1xuICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnR5cGUsIGdsQnVmZmVyLmJ1ZmZlcik7XG4gICAgaWYgKGdsQnVmZmVyLmJ5dGVMZW5ndGggPj0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXIudHlwZSwgMCwgYnVmZmVyLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkcmF3VHlwZSA9IGJ1ZmZlci5zdGF0aWMgPyBnbC5TVEFUSUNfRFJBVyA6IGdsLkRZTkFNSUNfRFJBVztcbiAgICAgIGdsQnVmZmVyLmJ5dGVMZW5ndGggPSBidWZmZXIuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgYnVmZmVyLmRhdGEsIGRyYXdUeXBlKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZShidWZmZXIsIGNvbnRleHRMb3N0KSB7XG4gICAgaWYgKCF0aGlzLm1hbmFnZWRCdWZmZXJzW2J1ZmZlci5pZF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXTtcbiAgICBjb25zdCBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBidWZmZXIuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgaWYgKCFnbEJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICBnbC5kZWxldGVCdWZmZXIoZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZGVsZXRlIGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICB9XG4gIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcbiAgICBjb25zdCBhbGwgPSBPYmplY3Qua2V5cyh0aGlzLm1hbmFnZWRCdWZmZXJzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5kaXNwb3NlKHRoaXMubWFuYWdlZEJ1ZmZlcnNbYWxsW2ldXSwgY29udGV4dExvc3QpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVHTEJ1ZmZlcihidWZmZXIpIHtcbiAgICBjb25zdCB7IENPTlRFWFRfVUlELCBnbCB9ID0gdGhpcztcbiAgICBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gPSBuZXcgR0xCdWZmZXIoZ2wuY3JlYXRlQnVmZmVyKCkpO1xuICAgIHRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXSA9IGJ1ZmZlcjtcbiAgICBidWZmZXIuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgcmV0dXJuIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXTtcbiAgfVxufVxuQnVmZmVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJidWZmZXJcIlxufTtcbmV4dGVuc2lvbnMuYWRkKEJ1ZmZlclN5c3RlbSk7XG5cbmV4cG9ydCB7IEJ1ZmZlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcblxuY2xhc3MgT2JqZWN0UmVuZGVyZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICByZW5kZXIoZGlzcGxheU9iamVjdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgcmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgY2xlYXI7XG4gICAgbGV0IHRyYW5zZm9ybTtcbiAgICBsZXQgc2tpcFVwZGF0ZVRyYW5zZm9ybTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgcmVuZGVyVGV4dHVyZSA9IG9wdGlvbnMucmVuZGVyVGV4dHVyZTtcbiAgICAgIGNsZWFyID0gb3B0aW9ucy5jbGVhcjtcbiAgICAgIHRyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgICAgc2tpcFVwZGF0ZVRyYW5zZm9ybSA9IG9wdGlvbnMuc2tpcFVwZGF0ZVRyYW5zZm9ybTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9ICFyZW5kZXJUZXh0dXJlO1xuICAgIHJlbmRlcmVyLnJ1bm5lcnMucHJlcmVuZGVyLmVtaXQoKTtcbiAgICByZW5kZXJlci5lbWl0KFwicHJlcmVuZGVyXCIpO1xuICAgIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGlmIChyZW5kZXJlci5jb250ZXh0LmlzTG9zdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcbiAgICAgIHRoaXMubGFzdE9iamVjdFJlbmRlcmVkID0gZGlzcGxheU9iamVjdDtcbiAgICB9XG4gICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCBjYWNoZVBhcmVudCA9IGRpc3BsYXlPYmplY3QuZW5hYmxlVGVtcFBhcmVudCgpO1xuICAgICAgZGlzcGxheU9iamVjdC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIGRpc3BsYXlPYmplY3QuZGlzYWJsZVRlbXBQYXJlbnQoY2FjaGVQYXJlbnQpO1xuICAgIH1cbiAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQocmVuZGVyVGV4dHVyZSk7XG4gICAgcmVuZGVyZXIuYmF0Y2guY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgaWYgKGNsZWFyID8/IHJlbmRlcmVyLmJhY2tncm91bmQuY2xlYXJCZWZvcmVSZW5kZXIpIHtcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuY2xlYXIoKTtcbiAgICB9XG4gICAgZGlzcGxheU9iamVjdC5yZW5kZXIocmVuZGVyZXIpO1xuICAgIHJlbmRlcmVyLmJhdGNoLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xuICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICBpZiAob3B0aW9ucy5ibGl0KSB7XG4gICAgICAgIHJlbmRlcmVyLmZyYW1lYnVmZmVyLmJsaXQoKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUudXBkYXRlKCk7XG4gICAgfVxuICAgIHJlbmRlcmVyLnJ1bm5lcnMucG9zdHJlbmRlci5lbWl0KCk7XG4gICAgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBudWxsO1xuICAgIHJlbmRlcmVyLmVtaXQoXCJwb3N0cmVuZGVyXCIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5sYXN0T2JqZWN0UmVuZGVyZWQgPSBudWxsO1xuICB9XG59XG5PYmplY3RSZW5kZXJlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwib2JqZWN0UmVuZGVyZXJcIlxufTtcbmV4dGVuc2lvbnMuYWRkKE9iamVjdFJlbmRlcmVyU3lzdGVtKTtcblxuZXhwb3J0IHsgT2JqZWN0UmVuZGVyZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFJlbmRlcmVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IFJFTkRFUkVSX1RZUEUgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnQHBpeGkvbWF0aCc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCBpc1dlYkdMU3VwcG9ydGVkIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBTeXN0ZW1NYW5hZ2VyIH0gZnJvbSAnLi9zeXN0ZW0vU3lzdGVtTWFuYWdlci5tanMnO1xuXG5jb25zdCBfUmVuZGVyZXIgPSBjbGFzcyBleHRlbmRzIFN5c3RlbU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnR5cGUgPSBSRU5ERVJFUl9UWVBFLldFQkdMO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncy5SRU5ERVJfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdGhpcy5nbCA9IG51bGw7XG4gICAgdGhpcy5DT05URVhUX1VJRCA9IDA7XG4gICAgdGhpcy5nbG9iYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgcHJvamVjdGlvbk1hdHJpeDogbmV3IE1hdHJpeCgpXG4gICAgfSwgdHJ1ZSk7XG4gICAgY29uc3Qgc3lzdGVtQ29uZmlnID0ge1xuICAgICAgcnVubmVyczogW1xuICAgICAgICBcImluaXRcIixcbiAgICAgICAgXCJkZXN0cm95XCIsXG4gICAgICAgIFwiY29udGV4dENoYW5nZVwiLFxuICAgICAgICBcInJlc29sdXRpb25DaGFuZ2VcIixcbiAgICAgICAgXCJyZXNldFwiLFxuICAgICAgICBcInVwZGF0ZVwiLFxuICAgICAgICBcInBvc3RyZW5kZXJcIixcbiAgICAgICAgXCJwcmVyZW5kZXJcIixcbiAgICAgICAgXCJyZXNpemVcIlxuICAgICAgXSxcbiAgICAgIHN5c3RlbXM6IF9SZW5kZXJlci5fX3N5c3RlbXMsXG4gICAgICBwcmlvcml0eTogW1xuICAgICAgICBcIl92aWV3XCIsXG4gICAgICAgIFwidGV4dHVyZUdlbmVyYXRvclwiLFxuICAgICAgICBcImJhY2tncm91bmRcIixcbiAgICAgICAgXCJfcGx1Z2luXCIsXG4gICAgICAgIFwic3RhcnR1cFwiLFxuICAgICAgICBcImNvbnRleHRcIixcbiAgICAgICAgXCJzdGF0ZVwiLFxuICAgICAgICBcInRleHR1cmVcIixcbiAgICAgICAgXCJidWZmZXJcIixcbiAgICAgICAgXCJnZW9tZXRyeVwiLFxuICAgICAgICBcImZyYW1lYnVmZmVyXCIsXG4gICAgICAgIFwidHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICAgICAgXCJtYXNrXCIsXG4gICAgICAgIFwic2Npc3NvclwiLFxuICAgICAgICBcInN0ZW5jaWxcIixcbiAgICAgICAgXCJwcm9qZWN0aW9uXCIsXG4gICAgICAgIFwidGV4dHVyZUdDXCIsXG4gICAgICAgIFwiZmlsdGVyXCIsXG4gICAgICAgIFwicmVuZGVyVGV4dHVyZVwiLFxuICAgICAgICBcImJhdGNoXCIsXG4gICAgICAgIFwib2JqZWN0UmVuZGVyZXJcIixcbiAgICAgICAgXCJfbXVsdGlzYW1wbGVcIlxuICAgICAgXVxuICAgIH07XG4gICAgdGhpcy5zZXR1cChzeXN0ZW1Db25maWcpO1xuICAgIGlmIChcInVzZUNvbnRleHRBbHBoYVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJvcHRpb25zLnVzZUNvbnRleHRBbHBoYSBpcyBkZXByZWNhdGVkLCB1c2Ugb3B0aW9ucy5wcmVtdWx0aXBsaWVkQWxwaGEgYW5kIG9wdGlvbnMuYmFja2dyb3VuZEFscGhhIGluc3RlYWRcIik7XG4gICAgICBvcHRpb25zLnByZW11bHRpcGxpZWRBbHBoYSA9IG9wdGlvbnMudXNlQ29udGV4dEFscGhhICYmIG9wdGlvbnMudXNlQ29udGV4dEFscGhhICE9PSBcIm5vdE11bHRpcGxpZWRcIjtcbiAgICAgIG9wdGlvbnMuYmFja2dyb3VuZEFscGhhID0gb3B0aW9ucy51c2VDb250ZXh0QWxwaGEgPT09IGZhbHNlID8gMSA6IG9wdGlvbnMuYmFja2dyb3VuZEFscGhhO1xuICAgIH1cbiAgICB0aGlzLl9wbHVnaW4ucmVuZGVyZXJQbHVnaW5zID0gX1JlbmRlcmVyLl9fcGx1Z2lucztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3RhcnR1cC5ydW4odGhpcy5vcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgdGVzdChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnM/LmZvcmNlQ2FudmFzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1dlYkdMU3VwcG9ydGVkKCk7XG4gIH1cbiAgcmVuZGVyKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdFJlbmRlcmVyLnJlbmRlcihkaXNwbGF5T2JqZWN0LCBvcHRpb25zKTtcbiAgfVxuICByZXNpemUoZGVzaXJlZFNjcmVlbldpZHRoLCBkZXNpcmVkU2NyZWVuSGVpZ2h0KSB7XG4gICAgdGhpcy5fdmlldy5yZXNpemVWaWV3KGRlc2lyZWRTY3JlZW5XaWR0aCwgZGVzaXJlZFNjcmVlbkhlaWdodCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5ydW5uZXJzLnJlc2V0LmVtaXQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnJlbmRlclRleHR1cmUuYmluZCgpO1xuICAgIHRoaXMucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xuICB9XG4gIGRlc3Ryb3kocmVtb3ZlVmlldyA9IGZhbHNlKSB7XG4gICAgdGhpcy5ydW5uZXJzLmRlc3Ryb3kuaXRlbXMucmV2ZXJzZSgpO1xuICAgIHRoaXMuZW1pdFdpdGhDdXN0b21PcHRpb25zKHRoaXMucnVubmVycy5kZXN0cm95LCB7XG4gICAgICBfdmlldzogcmVtb3ZlVmlld1xuICAgIH0pO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2luLnBsdWdpbnM7XG4gIH1cbiAgZ2V0IG11bHRpc2FtcGxlKCkge1xuICAgIHJldHVybiB0aGlzLl9tdWx0aXNhbXBsZS5tdWx0aXNhbXBsZTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuZWxlbWVudC53aWR0aDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmVsZW1lbnQuaGVpZ2h0O1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LnJlc29sdXRpb247XG4gIH1cbiAgc2V0IHJlc29sdXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl92aWV3LnJlc29sdXRpb24gPSB2YWx1ZTtcbiAgICB0aGlzLnJ1bm5lcnMucmVzb2x1dGlvbkNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgfVxuICBnZXQgYXV0b0RlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuYXV0b0RlbnNpdHk7XG4gIH1cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuZWxlbWVudDtcbiAgfVxuICBnZXQgc2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LnNjcmVlbjtcbiAgfVxuICBnZXQgbGFzdE9iamVjdFJlbmRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgfVxuICBnZXQgcmVuZGVyaW5nVG9TY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0UmVuZGVyZXIucmVuZGVyaW5nVG9TY3JlZW47XG4gIH1cbiAgZ2V0IHJlbmRlcmVyTG9nSWQoKSB7XG4gICAgcmV0dXJuIGBXZWJHTCAke3RoaXMuY29udGV4dC53ZWJHTFZlcnNpb259YDtcbiAgfVxuICBnZXQgY2xlYXJCZWZvcmVSZW5kZXIoKSB7XG4gICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLmNsZWFyQmVmb3JlUmVuZGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgcmVuZGVyZXIuYmFja2dyb3VuZC5jbGVhckJlZm9yZVJlbmRlciBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kLmNsZWFyQmVmb3JlUmVuZGVyO1xuICB9XG4gIGdldCB1c2VDb250ZXh0QWxwaGEoKSB7XG4gICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnVzZUNvbnRleHRBbHBoYSBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlbmRlcmVyLmNvbnRleHQucHJlbXVsdGlwbGllZEFscGhhIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQudXNlQ29udGV4dEFscGhhO1xuICB9XG4gIGdldCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIoKSB7XG4gICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnByZXNlcnZlRHJhd2luZ0J1ZmZlciBoYXMgYmVlbiBkZXByZWNhdGVkLCB3ZSBjYW5ub3QgdHJ1bHkga25vdyB0aGlzIHVubGVzcyBwaXhpIGNyZWF0ZWQgdGhlIGNvbnRleHRcIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG4gIH1cbiAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIuYmFja2dyb3VuZENvbG9yIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5iYWNrZ3JvdW5kLmNvbG9yIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmQuY29sb3I7XG4gIH1cbiAgc2V0IGJhY2tncm91bmRDb2xvcih2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5iYWNrZ3JvdW5kQ29sb3IgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuY29sb3IgaW5zdGVhZC5cIik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kLmNvbG9yID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJhY2tncm91bmRBbHBoYSgpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIuYmFja2dyb3VuZEFscGhhIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5iYWNrZ3JvdW5kLmFscGhhIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmQuYWxwaGE7XG4gIH1cbiAgc2V0IGJhY2tncm91bmRBbHBoYSh2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5iYWNrZ3JvdW5kQWxwaGEgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuYWxwaGEgaW5zdGVhZC5cIik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kLmFscGhhID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHBvd2VyUHJlZmVyZW5jZSgpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIucG93ZXJQcmVmZXJlbmNlIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHdlIGNhbiBvbmx5IGtub3cgdGhpcyBpZiBwaXhpIGNyZWF0ZXMgdGhlIGNvbnRleHRcIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5wb3dlclByZWZlcmVuY2U7XG4gIH1cbiAgZ2VuZXJhdGVUZXh0dXJlKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlR2VuZXJhdG9yLmdlbmVyYXRlVGV4dHVyZShkaXNwbGF5T2JqZWN0LCBvcHRpb25zKTtcbiAgfVxufTtcbmxldCBSZW5kZXJlciA9IF9SZW5kZXJlcjtcblJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlcixcbiAgcHJpb3JpdHk6IDFcbn07XG5SZW5kZXJlci5fX3BsdWdpbnMgPSB7fTtcblJlbmRlcmVyLl9fc3lzdGVtcyA9IHt9O1xuZXh0ZW5zaW9ucy5oYW5kbGVCeU1hcChFeHRlbnNpb25UeXBlLlJlbmRlcmVyUGx1Z2luLCBSZW5kZXJlci5fX3BsdWdpbnMpO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeU1hcChFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLCBSZW5kZXJlci5fX3N5c3RlbXMpO1xuZXh0ZW5zaW9ucy5hZGQoUmVuZGVyZXIpO1xuXG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQmFzZVRleHR1cmUgfSBmcm9tICcuLi9CYXNlVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgYXV0b0RldGVjdFJlc291cmNlIH0gZnJvbSAnLi9hdXRvRGV0ZWN0UmVzb3VyY2UubWpzJztcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSAnLi9SZXNvdXJjZS5tanMnO1xuXG5jbGFzcyBBYnN0cmFjdE11bHRpUmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLml0ZW1zID0gW107XG4gICAgdGhpcy5pdGVtRGlydHlJZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0VGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZSgpO1xuICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhcnRUZXh0dXJlKTtcbiAgICAgIHRoaXMuaXRlbURpcnR5SWRzLnB1c2goLTIpO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgfVxuICBpbml0RnJvbUFycmF5KHJlc291cmNlcywgb3B0aW9ucykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFyZXNvdXJjZXNbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVzb3VyY2VzW2ldLmNhc3RUb0Jhc2VUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuYWRkQmFzZVRleHR1cmVBdChyZXNvdXJjZXNbaV0uY2FzdFRvQmFzZVRleHR1cmUoKSwgaSk7XG4gICAgICB9IGVsc2UgaWYgKHJlc291cmNlc1tpXSBpbnN0YW5jZW9mIFJlc291cmNlKSB7XG4gICAgICAgIHRoaXMuYWRkUmVzb3VyY2VBdChyZXNvdXJjZXNbaV0sIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRSZXNvdXJjZUF0KGF1dG9EZXRlY3RSZXNvdXJjZShyZXNvdXJjZXNbaV0sIG9wdGlvbnMpLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbXMgPSBudWxsO1xuICAgIHRoaXMuaXRlbURpcnR5SWRzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgfVxuICBhZGRSZXNvdXJjZUF0KHJlc291cmNlLCBpbmRleCkge1xuICAgIGlmICghdGhpcy5pdGVtc1tpbmRleF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIGJvdW5kc2ApO1xuICAgIH1cbiAgICBpZiAocmVzb3VyY2UudmFsaWQgJiYgIXRoaXMudmFsaWQpIHtcbiAgICAgIHRoaXMucmVzaXplKHJlc291cmNlLndpZHRoLCByZXNvdXJjZS5oZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zW2luZGV4XS5zZXRSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBiYXNlIHRleHR1cmUgcGVyIFRleHR1cmVBcnJheSBpcyBhbGxvd2VkXCIpO1xuICAgIH1cbiAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaXRlbXNbaV0ucGFyZW50VGV4dHVyZUFycmF5ID0gYmFzZVRleHR1cmU7XG4gICAgICB0aGlzLml0ZW1zW2ldLm9uKFwidXBkYXRlXCIsIGJhc2VUZXh0dXJlLnVwZGF0ZSwgYmFzZVRleHR1cmUpO1xuICAgIH1cbiAgfVxuICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICBzdXBlci51bmJpbmQoYmFzZVRleHR1cmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS5wYXJlbnRUZXh0dXJlQXJyYXkgPSBudWxsO1xuICAgICAgdGhpcy5pdGVtc1tpXS5vZmYoXCJ1cGRhdGVcIiwgYmFzZVRleHR1cmUudXBkYXRlLCBiYXNlVGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLml0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5yZXNvdXJjZSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IHJlc291cmNlcy5tYXAoKGl0ZW0pID0+IGl0ZW0ubG9hZCgpKTtcbiAgICB0aGlzLl9sb2FkID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWFsV2lkdGgsIHJlYWxIZWlnaHQgfSA9IHRoaXMuaXRlbXNbMF07XG4gICAgICB0aGlzLnJlc2l6ZShyZWFsV2lkdGgsIHJlYWxIZWlnaHQpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgfVxufVxuXG5leHBvcnQgeyBBYnN0cmFjdE11bHRpUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TXVsdGlSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBUQVJHRVRTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEFic3RyYWN0TXVsdGlSZXNvdXJjZSB9IGZyb20gJy4vQWJzdHJhY3RNdWx0aVJlc291cmNlLm1qcyc7XG5cbmNsYXNzIEFycmF5UmVzb3VyY2UgZXh0ZW5kcyBBYnN0cmFjdE11bHRpUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnMgfHwge307XG4gICAgbGV0IHVybHM7XG4gICAgbGV0IGxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICB1cmxzID0gc291cmNlO1xuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gc291cmNlO1xuICAgIH1cbiAgICBzdXBlcihsZW5ndGgsIHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICBpZiAodXJscykge1xuICAgICAgdGhpcy5pbml0RnJvbUFycmF5KHVybHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhZGRCYXNlVGV4dHVyZUF0KGJhc2VUZXh0dXJlLCBpbmRleCkge1xuICAgIGlmIChiYXNlVGV4dHVyZS5yZXNvdXJjZSkge1xuICAgICAgdGhpcy5hZGRSZXNvdXJjZUF0KGJhc2VUZXh0dXJlLnJlc291cmNlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5UmVzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCBSZW5kZXJUZXh0dXJlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgc3VwZXIuYmluZChiYXNlVGV4dHVyZSk7XG4gICAgYmFzZVRleHR1cmUudGFyZ2V0ID0gVEFSR0VUUy5URVhUVVJFXzJEX0FSUkFZO1xuICB9XG4gIHVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgeyBsZW5ndGgsIGl0ZW1EaXJ0eUlkcywgaXRlbXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBnbCB9ID0gcmVuZGVyZXI7XG4gICAgaWYgKGdsVGV4dHVyZS5kaXJ0eUlkIDwgMCkge1xuICAgICAgZ2wudGV4SW1hZ2UzRChnbC5URVhUVVJFXzJEX0FSUkFZLCAwLCBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIGxlbmd0aCwgMCwgdGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS50eXBlLCBudWxsKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKGl0ZW1EaXJ0eUlkc1tpXSA8IGl0ZW0uZGlydHlJZCkge1xuICAgICAgICBpdGVtRGlydHlJZHNbaV0gPSBpdGVtLmRpcnR5SWQ7XG4gICAgICAgIGlmIChpdGVtLnZhbGlkKSB7XG4gICAgICAgICAgZ2wudGV4U3ViSW1hZ2UzRChnbC5URVhUVVJFXzJEX0FSUkFZLCAwLCAwLCAwLCBpLCBpdGVtLnJlc291cmNlLndpZHRoLCBpdGVtLnJlc291cmNlLmhlaWdodCwgMSwgdGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS50eXBlLCBpdGVtLnJlc291cmNlLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgQXJyYXlSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vQmFzZUltYWdlUmVzb3VyY2UubWpzJztcblxuY2xhc3MgQ2FudmFzUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHN1cGVyKHNvdXJjZSk7XG4gIH1cbiAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgY29uc3QgeyBPZmZzY3JlZW5DYW52YXMgfSA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKE9mZnNjcmVlbkNhbnZhcyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5IVE1MQ2FudmFzRWxlbWVudCAmJiBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgfVxufVxuXG5leHBvcnQgeyBDYW52YXNSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgVEFSR0VUUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBYnN0cmFjdE11bHRpUmVzb3VyY2UgfSBmcm9tICcuL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5tanMnO1xuXG5jb25zdCBfQ3ViZVJlc291cmNlID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE11bHRpUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGF1dG9Mb2FkLCBsaW5rQmFzZVRleHR1cmUgfSA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNvdXJjZSAmJiBzb3VyY2UubGVuZ3RoICE9PSBfQ3ViZVJlc291cmNlLlNJREVTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbGVuZ3RoLiBHb3QgJHtzb3VyY2UubGVuZ3RofSwgZXhwZWN0ZWQgNmApO1xuICAgIH1cbiAgICBzdXBlcig2LCB7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfQ3ViZVJlc291cmNlLlNJREVTOyBpKyspIHtcbiAgICAgIHRoaXMuaXRlbXNbaV0udGFyZ2V0ID0gVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpO1xuICAgIH1cbiAgICB0aGlzLmxpbmtCYXNlVGV4dHVyZSA9IGxpbmtCYXNlVGV4dHVyZSAhPT0gZmFsc2U7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5pbml0RnJvbUFycmF5KHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChhdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgfVxuICBiaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgc3VwZXIuYmluZChiYXNlVGV4dHVyZSk7XG4gICAgYmFzZVRleHR1cmUudGFyZ2V0ID0gVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQO1xuICB9XG4gIGFkZEJhc2VUZXh0dXJlQXQoYmFzZVRleHR1cmUsIGluZGV4LCBsaW5rQmFzZVRleHR1cmUpIHtcbiAgICBpZiAobGlua0Jhc2VUZXh0dXJlID09PSB2b2lkIDApIHtcbiAgICAgIGxpbmtCYXNlVGV4dHVyZSA9IHRoaXMubGlua0Jhc2VUZXh0dXJlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXRlbXNbaW5kZXhdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGV4ICR7aW5kZXh9IGlzIG91dCBvZiBib3VuZHNgKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxpbmtCYXNlVGV4dHVyZSB8fCBiYXNlVGV4dHVyZS5wYXJlbnRUZXh0dXJlQXJyYXkgfHwgT2JqZWN0LmtleXMoYmFzZVRleHR1cmUuX2dsVGV4dHVyZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChiYXNlVGV4dHVyZS5yZXNvdXJjZSkge1xuICAgICAgICB0aGlzLmFkZFJlc291cmNlQXQoYmFzZVRleHR1cmUucmVzb3VyY2UsIGluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3ViZVJlc291cmNlIGRvZXMgbm90IHN1cHBvcnQgY29weWluZyBvZiByZW5kZXJUZXh0dXJlLmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlVGV4dHVyZS50YXJnZXQgPSBUQVJHRVRTLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGluZGV4O1xuICAgICAgYmFzZVRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5ID0gdGhpcy5iYXNlVGV4dHVyZTtcbiAgICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gYmFzZVRleHR1cmU7XG4gICAgfVxuICAgIGlmIChiYXNlVGV4dHVyZS52YWxpZCAmJiAhdGhpcy52YWxpZCkge1xuICAgICAgdGhpcy5yZXNpemUoYmFzZVRleHR1cmUucmVhbFdpZHRoLCBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy5pdGVtc1tpbmRleF0gPSBiYXNlVGV4dHVyZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1cGxvYWQocmVuZGVyZXIsIF9iYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgZGlydHkgPSB0aGlzLml0ZW1EaXJ0eUlkcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9DdWJlUmVzb3VyY2UuU0lERVM7IGkrKykge1xuICAgICAgY29uc3Qgc2lkZSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICBpZiAoZGlydHlbaV0gPCBzaWRlLmRpcnR5SWQgfHwgZ2xUZXh0dXJlLmRpcnR5SWQgPCBfYmFzZVRleHR1cmUuZGlydHlJZCkge1xuICAgICAgICBpZiAoc2lkZS52YWxpZCAmJiBzaWRlLnJlc291cmNlKSB7XG4gICAgICAgICAgc2lkZS5yZXNvdXJjZS51cGxvYWQocmVuZGVyZXIsIHNpZGUsIGdsVGV4dHVyZSk7XG4gICAgICAgICAgZGlydHlbaV0gPSBzaWRlLmRpcnR5SWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlydHlbaV0gPCAtMSkge1xuICAgICAgICAgIHJlbmRlcmVyLmdsLnRleEltYWdlMkQoc2lkZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgX2Jhc2VUZXh0dXJlLnJlYWxXaWR0aCwgX2Jhc2VUZXh0dXJlLnJlYWxIZWlnaHQsIDAsIF9iYXNlVGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS50eXBlLCBudWxsKTtcbiAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNvdXJjZSkgJiYgc291cmNlLmxlbmd0aCA9PT0gX0N1YmVSZXNvdXJjZS5TSURFUztcbiAgfVxufTtcbmxldCBDdWJlUmVzb3VyY2UgPSBfQ3ViZVJlc291cmNlO1xuQ3ViZVJlc291cmNlLlNJREVTID0gNjtcblxuZXhwb3J0IHsgQ3ViZVJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdWJlUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgQUxQSEFfTU9ERVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vQmFzZUltYWdlUmVzb3VyY2UubWpzJztcblxuY2xhc3MgSW1hZ2VCaXRtYXBSZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgbGV0IGJhc2VTb3VyY2U7XG4gICAgbGV0IHVybDtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYmFzZVNvdXJjZSA9IEltYWdlQml0bWFwUmVzb3VyY2UuRU1QVFk7XG4gICAgICB1cmwgPSBzb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VTb3VyY2UgPSBzb3VyY2U7XG4gICAgICB1cmwgPSBudWxsO1xuICAgIH1cbiAgICBzdXBlcihiYXNlU291cmNlKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbiA/PyB0cnVlO1xuICAgIHRoaXMuYWxwaGFNb2RlID0gdHlwZW9mIG9wdGlvbnMuYWxwaGFNb2RlID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5hbHBoYU1vZGUgOiBudWxsO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICB9XG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMudXJsID09PSBudWxsKSB7XG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh0aGlzLnVybCwge1xuICAgICAgICAgIG1vZGU6IHRoaXMuY3Jvc3NPcmlnaW4gPyBcImNvcnNcIiA6IFwibm8tY29yc1wiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2VCbG9iLCB7XG4gICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogdGhpcy5hbHBoYU1vZGUgPT09IG51bGwgfHwgdGhpcy5hbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLlVOUEFDSyA/IFwicHJlbXVsdGlwbHlcIiA6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGltYWdlQml0bWFwO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIHRoaXMub25FcnJvci5lbWl0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICB9XG4gIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIGlmICghKHRoaXMuc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApKSB7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmFscGhhTW9kZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgYmFzZVRleHR1cmUuYWxwaGFNb2RlID0gdGhpcy5hbHBoYU1vZGU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICAgIHRoaXMuc291cmNlLmNsb3NlKCk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcbiAgICByZXR1cm4gISFnbG9iYWxUaGlzLmNyZWF0ZUltYWdlQml0bWFwICYmIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiB8fCBzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCk7XG4gIH1cbiAgc3RhdGljIGdldCBFTVBUWSgpIHtcbiAgICBJbWFnZUJpdG1hcFJlc291cmNlLl9FTVBUWSA9IEltYWdlQml0bWFwUmVzb3VyY2UuX0VNUFRZID8/IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKDAsIDApO1xuICAgIHJldHVybiBJbWFnZUJpdG1hcFJlc291cmNlLl9FTVBUWTtcbiAgfVxufVxuXG5leHBvcnQgeyBJbWFnZUJpdG1hcFJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZUJpdG1hcFJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgQmFzZUltYWdlUmVzb3VyY2UgfSBmcm9tICcuL0Jhc2VJbWFnZVJlc291cmNlLm1qcyc7XG5cbmNvbnN0IF9TVkdSZXNvdXJjZSA9IGNsYXNzIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VCYXNlNjQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBzdXBlcihzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpKTtcbiAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB0aGlzLnN2ZyA9IHNvdXJjZUJhc2U2NDtcbiAgICB0aGlzLnNjYWxlID0gb3B0aW9ucy5zY2FsZSB8fCAxO1xuICAgIHRoaXMuX292ZXJyaWRlV2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIHRoaXMuX292ZXJyaWRlSGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgdGhpcy5fY3Jvc3NvcmlnaW4gPSBvcHRpb25zLmNyb3Nzb3JpZ2luO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICB9XG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMuc291cmNlLndpZHRoLCB0aGlzLnNvdXJjZS5oZWlnaHQpO1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIGlmIChfU1ZHUmVzb3VyY2UuU1ZHX1hNTC50ZXN0KHRoaXMuc3ZnLnRyaW0oKSkpIHtcbiAgICAgICAgaWYgKCFidG9hKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBiYXNlNjQgY29udmVyc2lvbnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN2ZykpKX1gO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9hZFN2ZygpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICB9XG4gIF9sb2FkU3ZnKCkge1xuICAgIGNvbnN0IHRlbXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIEJhc2VJbWFnZVJlc291cmNlLmNyb3NzT3JpZ2luKHRlbXBJbWFnZSwgdGhpcy5zdmcsIHRoaXMuX2Nyb3Nzb3JpZ2luKTtcbiAgICB0ZW1wSW1hZ2Uuc3JjID0gdGhpcy5zdmc7XG4gICAgdGVtcEltYWdlLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzb2x2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZW1wSW1hZ2Uub25lcnJvciA9IG51bGw7XG4gICAgICB0aGlzLm9uRXJyb3IuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICB0ZW1wSW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN2Z1dpZHRoID0gdGVtcEltYWdlLndpZHRoO1xuICAgICAgY29uc3Qgc3ZnSGVpZ2h0ID0gdGVtcEltYWdlLmhlaWdodDtcbiAgICAgIGlmICghc3ZnV2lkdGggfHwgIXN2Z0hlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgU1ZHIGltYWdlIG11c3QgaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IGRlZmluZWQgKGluIHBpeGVscyksIGNhbnZhcyBBUEkgbmVlZHMgdGhlbS5cIik7XG4gICAgICB9XG4gICAgICBsZXQgd2lkdGggPSBzdmdXaWR0aCAqIHRoaXMuc2NhbGU7XG4gICAgICBsZXQgaGVpZ2h0ID0gc3ZnSGVpZ2h0ICogdGhpcy5zY2FsZTtcbiAgICAgIGlmICh0aGlzLl9vdmVycmlkZVdpZHRoIHx8IHRoaXMuX292ZXJyaWRlSGVpZ2h0KSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5fb3ZlcnJpZGVXaWR0aCB8fCB0aGlzLl9vdmVycmlkZUhlaWdodCAvIHN2Z0hlaWdodCAqIHN2Z1dpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLl9vdmVycmlkZUhlaWdodCB8fCB0aGlzLl9vdmVycmlkZVdpZHRoIC8gc3ZnV2lkdGggKiBzdmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5zb3VyY2U7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjYW52YXMuX3BpeGlJZCA9IGBjYW52YXNfJHt1aWQoKX1gO1xuICAgICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UodGVtcEltYWdlLCAwLCAwLCBzdmdXaWR0aCwgc3ZnSGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldFNpemUoc3ZnU3RyaW5nKSB7XG4gICAgY29uc3Qgc2l6ZU1hdGNoID0gX1NWR1Jlc291cmNlLlNWR19TSVpFLmV4ZWMoc3ZnU3RyaW5nKTtcbiAgICBjb25zdCBzaXplID0ge307XG4gICAgaWYgKHNpemVNYXRjaCkge1xuICAgICAgc2l6ZVtzaXplTWF0Y2hbMV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFszXSkpO1xuICAgICAgc2l6ZVtzaXplTWF0Y2hbNV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFs3XSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB0aGlzLl9jcm9zc29yaWdpbiA9IG51bGw7XG4gIH1cbiAgc3RhdGljIHRlc3Qoc291cmNlLCBleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uID09PSBcInN2Z1wiIHx8IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIgJiYgc291cmNlLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL3N2Zyt4bWxcIikgfHwgdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiAmJiBfU1ZHUmVzb3VyY2UuU1ZHX1hNTC50ZXN0KHNvdXJjZSk7XG4gIH1cbn07XG5sZXQgU1ZHUmVzb3VyY2UgPSBfU1ZHUmVzb3VyY2U7XG5TVkdSZXNvdXJjZS5TVkdfWE1MID0gL14oPFxcP3htbFteP10rXFw/Pik/XFxzKig8IS0tW14oLS0+KV0qLS0+KT9cXHMqXFw8c3ZnL207XG5TVkdSZXNvdXJjZS5TVkdfU0laRSA9IC88c3ZnW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKj4vaTtcblxuZXhwb3J0IHsgU1ZHUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNWR1Jlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IFRpY2tlciB9IGZyb20gJ0BwaXhpL3RpY2tlcic7XG5pbXBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vQmFzZUltYWdlUmVzb3VyY2UubWpzJztcblxuY29uc3QgX1ZpZGVvUmVzb3VyY2UgPSBjbGFzcyBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwcmVsb2FkXCIsIFwiYXV0b1wiKTtcbiAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ3ZWJraXQtcGxheXNpbmxpbmVcIiwgXCJcIik7XG4gICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwicGxheXNpbmxpbmVcIiwgXCJcIik7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpcnN0U3JjID0gc291cmNlWzBdLnNyYyB8fCBzb3VyY2VbMF07XG4gICAgICBCYXNlSW1hZ2VSZXNvdXJjZS5jcm9zc09yaWdpbih2aWRlb0VsZW1lbnQsIGZpcnN0U3JjLCBvcHRpb25zLmNyb3Nzb3JpZ2luKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuICAgICAgICBsZXQgeyBzcmMsIG1pbWUgfSA9IHNvdXJjZVtpXTtcbiAgICAgICAgc3JjID0gc3JjIHx8IHNvdXJjZVtpXTtcbiAgICAgICAgY29uc3QgYmFzZVNyYyA9IHNyYy5zcGxpdChcIj9cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBleHQgPSBiYXNlU3JjLnNsaWNlKGJhc2VTcmMubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgICAgIG1pbWUgPSBtaW1lIHx8IF9WaWRlb1Jlc291cmNlLk1JTUVfVFlQRVNbZXh0XSB8fCBgdmlkZW8vJHtleHR9YDtcbiAgICAgICAgc291cmNlRWxlbWVudC5zcmMgPSBzcmM7XG4gICAgICAgIHNvdXJjZUVsZW1lbnQudHlwZSA9IG1pbWU7XG4gICAgICAgIHZpZGVvRWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2VFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZSA9IHZpZGVvRWxlbWVudDtcbiAgICB9XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICB0aGlzLm5vU3ViSW1hZ2UgPSB0cnVlO1xuICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICB0aGlzLl91cGRhdGVGUFMgPSBvcHRpb25zLnVwZGF0ZUZQUyB8fCAwO1xuICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICB0aGlzLmF1dG9QbGF5ID0gb3B0aW9ucy5hdXRvUGxheSAhPT0gZmFsc2U7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgdGhpcy5fb25DYW5QbGF5ID0gdGhpcy5fb25DYW5QbGF5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25FcnJvciA9IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoX2RlbHRhVGltZSA9IDApIHtcbiAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICBjb25zdCBlbGFwc2VkTVMgPSBUaWNrZXIuc2hhcmVkLmVsYXBzZWRNUyAqIHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZTtcbiAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gTWF0aC5mbG9vcih0aGlzLl9tc1RvTmV4dFVwZGF0ZSAtIGVsYXBzZWRNUyk7XG4gICAgICBpZiAoIXRoaXMuX3VwZGF0ZUZQUyB8fCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA8PSAwKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IHRoaXMuX3VwZGF0ZUZQUyA/IE1hdGguZmxvb3IoMWUzIC8gdGhpcy5fdXBkYXRlRlBTKSA6IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBpZiAoKHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9FTk9VR0hfREFUQSB8fCBzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRlVUVVJFX0RBVEEpICYmIHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KSB7XG4gICAgICBzb3VyY2UuY29tcGxldGUgPSB0cnVlO1xuICAgIH1cbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlcIiwgdGhpcy5fb25QbGF5U3RhcnQuYmluZCh0aGlzKSk7XG4gICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCB0aGlzLl9vblBsYXlTdG9wLmJpbmQodGhpcykpO1xuICAgIGlmICghdGhpcy5faXNTb3VyY2VSZWFkeSgpKSB7XG4gICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25FcnJvciwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29uQ2FuUGxheSgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgc291cmNlLmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgfVxuICBfb25FcnJvcihldmVudCkge1xuICAgIHRoaXMuc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCB0cnVlKTtcbiAgICB0aGlzLm9uRXJyb3IuZW1pdChldmVudCk7XG4gIH1cbiAgX2lzU291cmNlUGxheWluZygpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICByZXR1cm4gIXNvdXJjZS5wYXVzZWQgJiYgIXNvdXJjZS5lbmRlZCAmJiB0aGlzLl9pc1NvdXJjZVJlYWR5KCk7XG4gIH1cbiAgX2lzU291cmNlUmVhZHkoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgcmV0dXJuIHNvdXJjZS5yZWFkeVN0YXRlID4gMjtcbiAgfVxuICBfb25QbGF5U3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICB0aGlzLl9vbkNhblBsYXkoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0b1VwZGF0ZSAmJiAhdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlcikge1xuICAgICAgVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIF9vblBsYXlTdG9wKCkge1xuICAgIGlmICh0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyKSB7XG4gICAgICBUaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9vbkNhblBsYXkoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZDtcbiAgICB0aGlzLnJlc2l6ZShzb3VyY2UudmlkZW9XaWR0aCwgc291cmNlLnZpZGVvSGVpZ2h0KTtcbiAgICBpZiAoIXZhbGlkICYmIHRoaXMuX3Jlc29sdmUpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmUodGhpcyk7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU291cmNlUGxheWluZygpKSB7XG4gICAgICB0aGlzLl9vblBsYXlTdGFydCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvUGxheSkge1xuICAgICAgc291cmNlLnBsYXkoKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlcikge1xuICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX29uRXJyb3IsIHRydWUpO1xuICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICBzb3VyY2Uuc3JjID0gXCJcIjtcbiAgICAgIHNvdXJjZS5sb2FkKCk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgYXV0b1VwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2F1dG9VcGRhdGUgJiYgIXRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgJiYgdGhpcy5faXNTb3VyY2VQbGF5aW5nKCkpIHtcbiAgICAgICAgVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHVwZGF0ZUZQUygpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRlBTO1xuICB9XG4gIHNldCB1cGRhdGVGUFModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3VwZGF0ZUZQUykge1xuICAgICAgdGhpcy5fdXBkYXRlRlBTID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSwgZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuSFRNTFZpZGVvRWxlbWVudCAmJiBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50IHx8IF9WaWRlb1Jlc291cmNlLlRZUEVTLmluY2x1ZGVzKGV4dGVuc2lvbik7XG4gIH1cbn07XG5sZXQgVmlkZW9SZXNvdXJjZSA9IF9WaWRlb1Jlc291cmNlO1xuVmlkZW9SZXNvdXJjZS5UWVBFUyA9IFtcIm1wNFwiLCBcIm00dlwiLCBcIndlYm1cIiwgXCJvZ2dcIiwgXCJvZ3ZcIiwgXCJoMjY0XCIsIFwiYXZpXCIsIFwibW92XCJdO1xuVmlkZW9SZXNvdXJjZS5NSU1FX1RZUEVTID0ge1xuICBvZ3Y6IFwidmlkZW8vb2dnXCIsXG4gIG1vdjogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgbTR2OiBcInZpZGVvL21wNFwiXG59O1xuXG5leHBvcnQgeyBWaWRlb1Jlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWRlb1Jlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IEFycmF5UmVzb3VyY2UgfSBmcm9tICcuL0FycmF5UmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEFycmF5UmVzb3VyY2UgfSBmcm9tICcuL0FycmF5UmVzb3VyY2UubWpzJztcbmltcG9ydCB7IElOU1RBTExFRCB9IGZyb20gJy4vYXV0b0RldGVjdFJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBJTlNUQUxMRUQsIGF1dG9EZXRlY3RSZXNvdXJjZSB9IGZyb20gJy4vYXV0b0RldGVjdFJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9IGZyb20gJy4vQnVmZmVyUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEJ1ZmZlclJlc291cmNlIH0gZnJvbSAnLi9CdWZmZXJSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzUmVzb3VyY2UgfSBmcm9tICcuL0NhbnZhc1Jlc291cmNlLm1qcyc7XG5leHBvcnQgeyBDYW52YXNSZXNvdXJjZSB9IGZyb20gJy4vQ2FudmFzUmVzb3VyY2UubWpzJztcbmltcG9ydCB7IEN1YmVSZXNvdXJjZSB9IGZyb20gJy4vQ3ViZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBDdWJlUmVzb3VyY2UgfSBmcm9tICcuL0N1YmVSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgSW1hZ2VCaXRtYXBSZXNvdXJjZSB9IGZyb20gJy4vSW1hZ2VCaXRtYXBSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgSW1hZ2VCaXRtYXBSZXNvdXJjZSB9IGZyb20gJy4vSW1hZ2VCaXRtYXBSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vSW1hZ2VSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vSW1hZ2VSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgU1ZHUmVzb3VyY2UgfSBmcm9tICcuL1NWR1Jlc291cmNlLm1qcyc7XG5leHBvcnQgeyBTVkdSZXNvdXJjZSB9IGZyb20gJy4vU1ZHUmVzb3VyY2UubWpzJztcbmltcG9ydCB7IFZpZGVvUmVzb3VyY2UgfSBmcm9tICcuL1ZpZGVvUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IFZpZGVvUmVzb3VyY2UgfSBmcm9tICcuL1ZpZGVvUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9CYXNlSW1hZ2VSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuL1Jlc291cmNlLm1qcyc7XG5leHBvcnQgeyBBYnN0cmFjdE11bHRpUmVzb3VyY2UgfSBmcm9tICcuL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5tanMnO1xuXG5JTlNUQUxMRUQucHVzaChJbWFnZUJpdG1hcFJlc291cmNlLCBJbWFnZVJlc291cmNlLCBDYW52YXNSZXNvdXJjZSwgVmlkZW9SZXNvdXJjZSwgU1ZHUmVzb3VyY2UsIEJ1ZmZlclJlc291cmNlLCBDdWJlUmVzb3VyY2UsIEFycmF5UmVzb3VyY2UpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnQHBpeGkvcnVubmVyJztcblxuY2xhc3MgVHJhbnNmb3JtRmVlZGJhY2sge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9nbFRyYW5zZm9ybUZlZWRiYWNrcyA9IHt9O1xuICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoXCJkaXNwb3NlVHJhbnNmb3JtRmVlZGJhY2tcIik7XG4gIH1cbiAgYmluZEJ1ZmZlcihpbmRleCwgYnVmZmVyKSB7XG4gICAgdGhpcy5idWZmZXJzW2luZGV4XSA9IGJ1ZmZlcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5lbWl0KHRoaXMsIGZhbHNlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBUcmFuc2Zvcm1GZWVkYmFjayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtRmVlZGJhY2subWpzLm1hcFxuIiwiaW1wb3J0ICcuL3NldHRpbmdzLm1qcyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9jb2xvcic7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9tYXRoJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL3J1bm5lcic7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS90aWNrZXInO1xuaW1wb3J0ICogYXMgdXRpbHMkMSBmcm9tICdAcGl4aS91dGlscyc7XG5leHBvcnQgeyB1dGlscyQxIGFzIHV0aWxzIH07XG5leHBvcnQgeyBhdXRvRGV0ZWN0UmVuZGVyZXIgfSBmcm9tICcuL2F1dG9EZXRlY3RSZW5kZXJlci5tanMnO1xuZXhwb3J0IHsgQmFja2dyb3VuZFN5c3RlbSB9IGZyb20gJy4vYmFja2dyb3VuZC9CYWNrZ3JvdW5kU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBCYXRjaERyYXdDYWxsIH0gZnJvbSAnLi9iYXRjaC9CYXRjaERyYXdDYWxsLm1qcyc7XG5leHBvcnQgeyBCYXRjaEdlb21ldHJ5IH0gZnJvbSAnLi9iYXRjaC9CYXRjaEdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBCYXRjaFJlbmRlcmVyIH0gZnJvbSAnLi9iYXRjaC9CYXRjaFJlbmRlcmVyLm1qcyc7XG5leHBvcnQgeyBCYXRjaFNoYWRlckdlbmVyYXRvciB9IGZyb20gJy4vYmF0Y2gvQmF0Y2hTaGFkZXJHZW5lcmF0b3IubWpzJztcbmV4cG9ydCB7IEJhdGNoU3lzdGVtIH0gZnJvbSAnLi9iYXRjaC9CYXRjaFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgQmF0Y2hUZXh0dXJlQXJyYXkgfSBmcm9tICcuL2JhdGNoL0JhdGNoVGV4dHVyZUFycmF5Lm1qcyc7XG5leHBvcnQgeyBPYmplY3RSZW5kZXJlciB9IGZyb20gJy4vYmF0Y2gvT2JqZWN0UmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IENvbnRleHRTeXN0ZW0gfSBmcm9tICcuL2NvbnRleHQvQ29udGV4dFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlci5tanMnO1xuZXhwb3J0IHsgRmlsdGVyU3RhdGUgfSBmcm9tICcuL2ZpbHRlcnMvRmlsdGVyU3RhdGUubWpzJztcbmV4cG9ydCB7IEZpbHRlclN5c3RlbSB9IGZyb20gJy4vZmlsdGVycy9GaWx0ZXJTeXN0ZW0ubWpzJztcbmltcG9ydCAnLi9maWx0ZXJzL0lGaWx0ZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IFNwcml0ZU1hc2tGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcnMvc3ByaXRlTWFzay9TcHJpdGVNYXNrRmlsdGVyLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0RmlsdGVyVmVydGV4LCBkZWZhdWx0VmVydGV4IH0gZnJvbSAnLi9mcmFnbWVudHMvaW5kZXgubWpzJztcbmV4cG9ydCB7IEZyYW1lYnVmZmVyIH0gZnJvbSAnLi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlci5tanMnO1xuZXhwb3J0IHsgRnJhbWVidWZmZXJTeXN0ZW0gfSBmcm9tICcuL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHTEZyYW1lYnVmZmVyIH0gZnJvbSAnLi9mcmFtZWJ1ZmZlci9HTEZyYW1lYnVmZmVyLm1qcyc7XG5leHBvcnQgeyBNdWx0aXNhbXBsZVN5c3RlbSB9IGZyb20gJy4vZnJhbWVidWZmZXIvTXVsdGlzYW1wbGVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEF0dHJpYnV0ZSB9IGZyb20gJy4vZ2VvbWV0cnkvQXR0cmlidXRlLm1qcyc7XG5leHBvcnQgeyBCdWZmZXIgfSBmcm9tICcuL2dlb21ldHJ5L0J1ZmZlci5tanMnO1xuZXhwb3J0IHsgQnVmZmVyU3lzdGVtIH0gZnJvbSAnLi9nZW9tZXRyeS9CdWZmZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgR2VvbWV0cnlTeXN0ZW0gfSBmcm9tICcuL2dlb21ldHJ5L0dlb21ldHJ5U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBWaWV3YWJsZUJ1ZmZlciB9IGZyb20gJy4vZ2VvbWV0cnkvVmlld2FibGVCdWZmZXIubWpzJztcbmltcG9ydCAnLi9JUmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IE1hc2tEYXRhIH0gZnJvbSAnLi9tYXNrL01hc2tEYXRhLm1qcyc7XG5leHBvcnQgeyBNYXNrU3lzdGVtIH0gZnJvbSAnLi9tYXNrL01hc2tTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFNjaXNzb3JTeXN0ZW0gfSBmcm9tICcuL21hc2svU2Npc3NvclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgU3RlbmNpbFN5c3RlbSB9IGZyb20gJy4vbWFzay9TdGVuY2lsU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBQbHVnaW5TeXN0ZW0gfSBmcm9tICcuL3BsdWdpbi9QbHVnaW5TeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFByb2plY3Rpb25TeXN0ZW0gfSBmcm9tICcuL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5tanMnO1xuZXhwb3J0IHsgT2JqZWN0UmVuZGVyZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlci9PYmplY3RSZW5kZXJlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgUmVuZGVyZXIgfSBmcm9tICcuL1JlbmRlcmVyLm1qcyc7XG5leHBvcnQgeyBCYXNlUmVuZGVyVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyVGV4dHVyZS9CYXNlUmVuZGVyVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJUZXh0dXJlL0dlbmVyYXRlVGV4dHVyZVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgUmVuZGVyVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJUZXh0dXJlUG9vbCB9IGZyb20gJy4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlUG9vbC5tanMnO1xuZXhwb3J0IHsgUmVuZGVyVGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHTFByb2dyYW0sIElHTFVuaWZvcm1EYXRhIH0gZnJvbSAnLi9zaGFkZXIvR0xQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBQcm9ncmFtIH0gZnJvbSAnLi9zaGFkZXIvUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi9zaGFkZXIvU2hhZGVyLm1qcyc7XG5leHBvcnQgeyBTaGFkZXJTeXN0ZW0gfSBmcm9tICcuL3NoYWRlci9TaGFkZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4vc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuZXhwb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9IGZyb20gJy4vc2hhZGVyL3V0aWxzL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlUHJvZ3JhbSB9IGZyb20gJy4vc2hhZGVyL3V0aWxzL2dlbmVyYXRlUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgY3JlYXRlVUJPRWxlbWVudHMsIGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMsIGdldFVCT0RhdGEgfSBmcm9tICcuL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLm1qcyc7XG5leHBvcnQgeyBnZXRUZXN0Q29udGV4dCB9IGZyb20gJy4vc2hhZGVyL3V0aWxzL2dldFRlc3RDb250ZXh0Lm1qcyc7XG5leHBvcnQgeyB1bmlmb3JtUGFyc2VycyB9IGZyb20gJy4vc2hhZGVyL3V0aWxzL3VuaWZvcm1QYXJzZXJzLm1qcyc7XG5leHBvcnQgeyB1bnNhZmVFdmFsU3VwcG9ydGVkIH0gZnJvbSAnLi9zaGFkZXIvdXRpbHMvdW5zYWZlRXZhbFN1cHBvcnRlZC5tanMnO1xuZXhwb3J0IHsgU3RhcnR1cFN5c3RlbSB9IGZyb20gJy4vc3RhcnR1cC9TdGFydHVwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBTdGF0ZSB9IGZyb20gJy4vc3RhdGUvU3RhdGUubWpzJztcbmV4cG9ydCB7IFN0YXRlU3lzdGVtIH0gZnJvbSAnLi9zdGF0ZS9TdGF0ZVN5c3RlbS5tanMnO1xuaW1wb3J0ICcuL3N5c3RlbS9JU3lzdGVtLm1qcyc7XG5pbXBvcnQgJy4vc3lzdGVtcy5tanMnO1xuZXhwb3J0IHsgQmFzZVRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0Jhc2VUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBHTFRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0dMVGV4dHVyZS5tanMnO1xuaW1wb3J0ICcuL3RleHR1cmVzL3Jlc291cmNlcy9pbmRleC5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZUdDU3lzdGVtIH0gZnJvbSAnLi90ZXh0dXJlcy9UZXh0dXJlR0NTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFRleHR1cmVNYXRyaXggfSBmcm9tICcuL3RleHR1cmVzL1RleHR1cmVNYXRyaXgubWpzJztcbmV4cG9ydCB7IFRleHR1cmVTeXN0ZW0gfSBmcm9tICcuL3RleHR1cmVzL1RleHR1cmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFRleHR1cmVVdnMgfSBmcm9tICcuL3RleHR1cmVzL1RleHR1cmVVdnMubWpzJztcbmV4cG9ydCB7IFRyYW5zZm9ybUZlZWRiYWNrIH0gZnJvbSAnLi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFjay5tanMnO1xuZXhwb3J0IHsgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gfSBmcm9tICcuL3RyYW5zZm9ybUZlZWRiYWNrL1RyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBRdWFkIH0gZnJvbSAnLi91dGlscy9RdWFkLm1qcyc7XG5leHBvcnQgeyBRdWFkVXYgfSBmcm9tICcuL3V0aWxzL1F1YWRVdi5tanMnO1xuZXhwb3J0IHsgVmlld1N5c3RlbSB9IGZyb20gJy4vdmlldy9WaWV3U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBTeXN0ZW1NYW5hZ2VyIH0gZnJvbSAnLi9zeXN0ZW0vU3lzdGVtTWFuYWdlci5tanMnO1xuZXhwb3J0IHsgQmFzZUltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9CYXNlSW1hZ2VSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9SZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQWJzdHJhY3RNdWx0aVJlc291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9yZXNvdXJjZXMvQWJzdHJhY3RNdWx0aVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBBcnJheVJlc291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9yZXNvdXJjZXMvQXJyYXlSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgSU5TVEFMTEVELCBhdXRvRGV0ZWN0UmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9hdXRvRGV0ZWN0UmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEJ1ZmZlclJlc291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9yZXNvdXJjZXMvQnVmZmVyUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IENhbnZhc1Jlc291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9yZXNvdXJjZXMvQ2FudmFzUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEN1YmVSZXNvdXJjZSB9IGZyb20gJy4vdGV4dHVyZXMvcmVzb3VyY2VzL0N1YmVSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgSW1hZ2VCaXRtYXBSZXNvdXJjZSB9IGZyb20gJy4vdGV4dHVyZXMvcmVzb3VyY2VzL0ltYWdlQml0bWFwUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9JbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBTVkdSZXNvdXJjZSB9IGZyb20gJy4vdGV4dHVyZXMvcmVzb3VyY2VzL1NWR1Jlc291cmNlLm1qcyc7XG5leHBvcnQgeyBWaWRlb1Jlc291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9yZXNvdXJjZXMvVmlkZW9SZXNvdXJjZS5tanMnO1xuXG5jb25zdCBWRVJTSU9OID0gXCI3LjIuM1wiO1xuXG5leHBvcnQgeyBWRVJTSU9OIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///525\n')},820:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "YZ": () => (/* reexport */ Bounds),\n  "W2": () => (/* reexport */ Container),\n  "s$": () => (/* reexport */ DisplayObject)\n});\n\n// UNUSED EXPORTS: TemporaryDisplayObject\n\n// EXTERNAL MODULE: ./node_modules/@pixi/core/lib/index.mjs + 118 modules\nvar lib = __webpack_require__(525);\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/Bounds.mjs\n\n\nclass Bounds {\n  constructor() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.rect = null;\n    this.updateID = -1;\n  }\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n  }\n  getRectangle(rect) {\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      return lib/* Rectangle.EMPTY */.Ae.EMPTY;\n    }\n    rect = rect || new lib/* Rectangle */.Ae(0, 0, 1, 1);\n    rect.x = this.minX;\n    rect.y = this.minY;\n    rect.width = this.maxX - this.minX;\n    rect.height = this.maxY - this.minY;\n    return rect;\n  }\n  addPoint(point) {\n    this.minX = Math.min(this.minX, point.x);\n    this.maxX = Math.max(this.maxX, point.x);\n    this.minY = Math.min(this.minY, point.y);\n    this.maxY = Math.max(this.maxY, point.y);\n  }\n  addPointMatrix(matrix, point) {\n    const { a, b, c, d, tx, ty } = matrix;\n    const x = a * point.x + c * point.y + tx;\n    const y = b * point.x + d * point.y + ty;\n    this.minX = Math.min(this.minX, x);\n    this.maxX = Math.max(this.maxX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxY = Math.max(this.maxY, y);\n  }\n  addQuad(vertices) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = vertices[0];\n    let y = vertices[1];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[2];\n    y = vertices[3];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[4];\n    y = vertices[5];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[6];\n    y = vertices[7];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addFrame(transform, x0, y0, x1, y1) {\n    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n  }\n  addFrameMatrix(matrix, x0, y0, x1, y1) {\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addVertexData(vertexData, beginOffset, endOffset) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const x = vertexData[i];\n      const y = vertexData[i + 1];\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addVertices(transform, vertices, beginOffset, endOffset) {\n    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n  }\n  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const rawX = vertices[i];\n      const rawY = vertices[i + 1];\n      const x = a * rawX + c * rawY + tx;\n      const y = d * rawY + b * rawX + ty;\n      minX = Math.min(minX, x - padX);\n      maxX = Math.max(maxX, x + padX);\n      minY = Math.min(minY, y - padY);\n      maxY = Math.max(maxY, y + padY);\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addBounds(bounds) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    this.minX = bounds.minX < minX ? bounds.minX : minX;\n    this.minY = bounds.minY < minY ? bounds.minY : minY;\n    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n  }\n  addBoundsMask(bounds, mask) {\n    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      const minX = this.minX;\n      const minY = this.minY;\n      const maxX = this.maxX;\n      const maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  }\n  addBoundsMatrix(bounds, matrix) {\n    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n  }\n  addBoundsArea(bounds, area) {\n    const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n    const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n    const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;\n    const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      const minX = this.minX;\n      const minY = this.minY;\n      const maxX = this.maxX;\n      const maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  }\n  pad(paddingX = 0, paddingY = paddingX) {\n    if (!this.isEmpty()) {\n      this.minX -= paddingX;\n      this.maxX += paddingX;\n      this.minY -= paddingY;\n      this.maxY += paddingY;\n    }\n  }\n  addFramePad(x0, y0, x1, y1, padX, padY) {\n    x0 -= padX;\n    y0 -= padY;\n    x1 += padX;\n    y1 += padY;\n    this.minX = this.minX < x0 ? this.minX : x0;\n    this.maxX = this.maxX > x1 ? this.maxX : x1;\n    this.minY = this.minY < y0 ? this.minY : y0;\n    this.maxY = this.maxY > y1 ? this.maxY : y1;\n  }\n}\n\n\n//# sourceMappingURL=Bounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/DisplayObject.mjs\n\n\n\nclass DisplayObject extends lib/* utils.EventEmitter */.P6.EventEmitter {\n  constructor() {\n    super();\n    this.tempDisplayObjectParent = null;\n    this.transform = new lib/* Transform */.wx();\n    this.alpha = 1;\n    this.visible = true;\n    this.renderable = true;\n    this.cullable = false;\n    this.cullArea = null;\n    this.parent = null;\n    this.worldAlpha = 1;\n    this._lastSortedIndex = 0;\n    this._zIndex = 0;\n    this.filterArea = null;\n    this.filters = null;\n    this._enabledFilters = null;\n    this._bounds = new Bounds();\n    this._localBounds = null;\n    this._boundsID = 0;\n    this._boundsRect = null;\n    this._localBoundsRect = null;\n    this._mask = null;\n    this._maskRefCount = 0;\n    this._destroyed = false;\n    this.isSprite = false;\n    this.isMask = false;\n  }\n  static mixin(source) {\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n      const propertyName = keys[i];\n      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));\n    }\n  }\n  get destroyed() {\n    return this._destroyed;\n  }\n  _recursivePostUpdateTransform() {\n    if (this.parent) {\n      this.parent._recursivePostUpdateTransform();\n      this.transform.updateTransform(this.parent.transform);\n    } else {\n      this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }\n  }\n  updateTransform() {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  }\n  getBounds(skipUpdate, rect) {\n    if (!skipUpdate) {\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n      } else {\n        this._recursivePostUpdateTransform();\n        this.updateTransform();\n      }\n    }\n    if (this._bounds.updateID !== this._boundsID) {\n      this.calculateBounds();\n      this._bounds.updateID = this._boundsID;\n    }\n    if (!rect) {\n      if (!this._boundsRect) {\n        this._boundsRect = new lib/* Rectangle */.Ae();\n      }\n      rect = this._boundsRect;\n    }\n    return this._bounds.getRectangle(rect);\n  }\n  getLocalBounds(rect) {\n    if (!rect) {\n      if (!this._localBoundsRect) {\n        this._localBoundsRect = new lib/* Rectangle */.Ae();\n      }\n      rect = this._localBoundsRect;\n    }\n    if (!this._localBounds) {\n      this._localBounds = new Bounds();\n    }\n    const transformRef = this.transform;\n    const parentRef = this.parent;\n    this.parent = null;\n    this.transform = this._tempDisplayObjectParent.transform;\n    const worldBounds = this._bounds;\n    const worldBoundsID = this._boundsID;\n    this._bounds = this._localBounds;\n    const bounds = this.getBounds(false, rect);\n    this.parent = parentRef;\n    this.transform = transformRef;\n    this._bounds = worldBounds;\n    this._bounds.updateID += this._boundsID - worldBoundsID;\n    return bounds;\n  }\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    return this.worldTransform.apply(position, point);\n  }\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n  setParent(container) {\n    if (!container || !container.addChild) {\n      throw new Error("setParent: Argument must be a Container");\n    }\n    container.addChild(this);\n    return container;\n  }\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  }\n  setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {\n    this.position.x = x;\n    this.position.y = y;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation;\n    this.skew.x = skewX;\n    this.skew.y = skewY;\n    this.pivot.x = pivotX;\n    this.pivot.y = pivotY;\n    return this;\n  }\n  destroy(_options) {\n    this.removeFromParent();\n    this._destroyed = true;\n    this.transform = null;\n    this.parent = null;\n    this._bounds = null;\n    this.mask = null;\n    this.cullArea = null;\n    this.filters = null;\n    this.filterArea = null;\n    this.hitArea = null;\n    this.eventMode = "auto";\n    this.interactiveChildren = false;\n    this.emit("destroyed");\n    this.removeAllListeners();\n  }\n  get _tempDisplayObjectParent() {\n    if (this.tempDisplayObjectParent === null) {\n      this.tempDisplayObjectParent = new TemporaryDisplayObject();\n    }\n    return this.tempDisplayObjectParent;\n  }\n  enableTempParent() {\n    const myParent = this.parent;\n    this.parent = this._tempDisplayObjectParent;\n    return myParent;\n  }\n  disableTempParent(cacheParent) {\n    this.parent = cacheParent;\n  }\n  get x() {\n    return this.position.x;\n  }\n  set x(value) {\n    this.transform.position.x = value;\n  }\n  get y() {\n    return this.position.y;\n  }\n  set y(value) {\n    this.transform.position.y = value;\n  }\n  get worldTransform() {\n    return this.transform.worldTransform;\n  }\n  get localTransform() {\n    return this.transform.localTransform;\n  }\n  get position() {\n    return this.transform.position;\n  }\n  set position(value) {\n    this.transform.position.copyFrom(value);\n  }\n  get scale() {\n    return this.transform.scale;\n  }\n  set scale(value) {\n    this.transform.scale.copyFrom(value);\n  }\n  get pivot() {\n    return this.transform.pivot;\n  }\n  set pivot(value) {\n    this.transform.pivot.copyFrom(value);\n  }\n  get skew() {\n    return this.transform.skew;\n  }\n  set skew(value) {\n    this.transform.skew.copyFrom(value);\n  }\n  get rotation() {\n    return this.transform.rotation;\n  }\n  set rotation(value) {\n    this.transform.rotation = value;\n  }\n  get angle() {\n    return this.transform.rotation * lib/* RAD_TO_DEG */.jl;\n  }\n  set angle(value) {\n    this.transform.rotation = value * lib/* DEG_TO_RAD */.ZX;\n  }\n  get zIndex() {\n    return this._zIndex;\n  }\n  set zIndex(value) {\n    this._zIndex = value;\n    if (this.parent) {\n      this.parent.sortDirty = true;\n    }\n  }\n  get worldVisible() {\n    let item = this;\n    do {\n      if (!item.visible) {\n        return false;\n      }\n      item = item.parent;\n    } while (item);\n    return true;\n  }\n  get mask() {\n    return this._mask;\n  }\n  set mask(value) {\n    if (this._mask === value) {\n      return;\n    }\n    if (this._mask) {\n      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n      if (maskObject) {\n        maskObject._maskRefCount--;\n        if (maskObject._maskRefCount === 0) {\n          maskObject.renderable = true;\n          maskObject.isMask = false;\n        }\n      }\n    }\n    this._mask = value;\n    if (this._mask) {\n      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n      if (maskObject) {\n        if (maskObject._maskRefCount === 0) {\n          maskObject.renderable = false;\n          maskObject.isMask = true;\n        }\n        maskObject._maskRefCount++;\n      }\n    }\n  }\n}\nclass TemporaryDisplayObject extends DisplayObject {\n  constructor() {\n    super(...arguments);\n    this.sortDirty = null;\n  }\n}\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n\n\n//# sourceMappingURL=DisplayObject.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/Container.mjs\n\n\n\nconst tempMatrix = new lib/* Matrix */.y3();\nfunction sortChildren(a, b) {\n  if (a.zIndex === b.zIndex) {\n    return a._lastSortedIndex - b._lastSortedIndex;\n  }\n  return a.zIndex - b.zIndex;\n}\nconst _Container = class extends DisplayObject {\n  constructor() {\n    super();\n    this.children = [];\n    this.sortableChildren = _Container.defaultSortableChildren;\n    this.sortDirty = false;\n  }\n  onChildrenChange(_length) {\n  }\n  addChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n    } else {\n      const child = children[0];\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n      child.parent = this;\n      this.sortDirty = true;\n      child.transform._parentID = -1;\n      this.children.push(child);\n      this._boundsID++;\n      this.onChildrenChange(this.children.length - 1);\n      this.emit("childAdded", child, this, this.children.length - 1);\n      child.emit("added", this);\n    }\n    return children[0];\n  }\n  addChildAt(child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    child.parent = this;\n    this.sortDirty = true;\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child);\n    this._boundsID++;\n    this.onChildrenChange(index);\n    child.emit("added", this);\n    this.emit("childAdded", child, this, index);\n    return child;\n  }\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  }\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error("The supplied DisplayObject must be a child of the caller");\n    }\n    return index;\n  }\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    const currentIndex = this.getChildIndex(child);\n    lib/* utils.removeItems */.P6.removeItems(this.children, currentIndex, 1);\n    this.children.splice(index, 0, child);\n    this.onChildrenChange(index);\n  }\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  }\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n    } else {\n      const child = children[0];\n      const index = this.children.indexOf(child);\n      if (index === -1)\n        return null;\n      child.parent = null;\n      child.transform._parentID = -1;\n      lib/* utils.removeItems */.P6.removeItems(this.children, index, 1);\n      this._boundsID++;\n      this.onChildrenChange(index);\n      child.emit("removed", this);\n      this.emit("childRemoved", child, this, index);\n    }\n    return children[0];\n  }\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    child.parent = null;\n    child.transform._parentID = -1;\n    lib/* utils.removeItems */.P6.removeItems(this.children, index, 1);\n    this._boundsID++;\n    this.onChildrenChange(index);\n    child.emit("removed", this);\n    this.emit("childRemoved", child, this, index);\n    return child;\n  }\n  removeChildren(beginIndex = 0, endIndex = this.children.length) {\n    const begin = beginIndex;\n    const end = endIndex;\n    const range = end - begin;\n    let removed;\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n      for (let i = 0; i < removed.length; ++i) {\n        removed[i].parent = null;\n        if (removed[i].transform) {\n          removed[i].transform._parentID = -1;\n        }\n      }\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n      for (let i = 0; i < removed.length; ++i) {\n        removed[i].emit("removed", this);\n        this.emit("childRemoved", removed[i], this, i);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");\n  }\n  sortChildren() {\n    let sortRequired = false;\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i];\n      child._lastSortedIndex = i;\n      if (!sortRequired && child.zIndex !== 0) {\n        sortRequired = true;\n      }\n    }\n    if (sortRequired && this.children.length > 1) {\n      this.children.sort(sortChildren);\n    }\n    this.sortDirty = false;\n  }\n  updateTransform() {\n    if (this.sortableChildren && this.sortDirty) {\n      this.sortChildren();\n    }\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i];\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  }\n  calculateBounds() {\n    this._bounds.clear();\n    this._calculateBounds();\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n      child.calculateBounds();\n      if (child._mask) {\n        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;\n        if (maskObject) {\n          maskObject.calculateBounds();\n          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n        } else {\n          this._bounds.addBounds(child._bounds);\n        }\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n    this._bounds.updateID = this._boundsID;\n  }\n  getLocalBounds(rect, skipChildrenUpdate = false) {\n    const result = super.getLocalBounds(rect);\n    if (!skipChildrenUpdate) {\n      for (let i = 0, j = this.children.length; i < j; ++i) {\n        const child = this.children[i];\n        if (child.visible) {\n          child.updateTransform();\n        }\n      }\n    }\n    return result;\n  }\n  _calculateBounds() {\n  }\n  _renderWithCulling(renderer) {\n    const sourceFrame = renderer.renderTexture.sourceFrame;\n    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {\n      return;\n    }\n    let bounds;\n    let transform;\n    if (this.cullArea) {\n      bounds = this.cullArea;\n      transform = this.worldTransform;\n    } else if (this._render !== _Container.prototype._render) {\n      bounds = this.getBounds(true);\n    }\n    const projectionTransform = renderer.projection.transform;\n    if (projectionTransform) {\n      if (transform) {\n        transform = tempMatrix.copyFrom(transform);\n        transform.prepend(projectionTransform);\n      } else {\n        transform = projectionTransform;\n      }\n    }\n    if (bounds && sourceFrame.intersects(bounds, transform)) {\n      this._render(renderer);\n    } else if (this.cullArea) {\n      return;\n    }\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i];\n      const childCullable = child.cullable;\n      child.cullable = childCullable || !this.cullArea;\n      child.render(renderer);\n      child.cullable = childCullable;\n    }\n  }\n  render(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n    if (this._mask || this.filters?.length) {\n      this.renderAdvanced(renderer);\n    } else if (this.cullable) {\n      this._renderWithCulling(renderer);\n    } else {\n      this._render(renderer);\n      for (let i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].render(renderer);\n      }\n    }\n  }\n  renderAdvanced(renderer) {\n    const filters = this.filters;\n    const mask = this._mask;\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n      this._enabledFilters.length = 0;\n      for (let i = 0; i < filters.length; i++) {\n        if (filters[i].enabled) {\n          this._enabledFilters.push(filters[i]);\n        }\n      }\n    }\n    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== lib/* MASK_TYPES.NONE */.A7.NONE));\n    if (flush) {\n      renderer.batch.flush();\n    }\n    if (filters && this._enabledFilters?.length) {\n      renderer.filter.push(this, this._enabledFilters);\n    }\n    if (mask) {\n      renderer.mask.push(this, this._mask);\n    }\n    if (this.cullable) {\n      this._renderWithCulling(renderer);\n    } else {\n      this._render(renderer);\n      for (let i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].render(renderer);\n      }\n    }\n    if (flush) {\n      renderer.batch.flush();\n    }\n    if (mask) {\n      renderer.mask.pop(this);\n    }\n    if (filters && this._enabledFilters?.length) {\n      renderer.filter.pop();\n    }\n  }\n  _render(_renderer) {\n  }\n  destroy(options) {\n    super.destroy();\n    this.sortDirty = false;\n    const destroyChildren = typeof options === "boolean" ? options : options?.children;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  }\n  get width() {\n    return this.scale.x * this.getLocalBounds().width;\n  }\n  set width(value) {\n    const width = this.getLocalBounds().width;\n    if (width !== 0) {\n      this.scale.x = value / width;\n    } else {\n      this.scale.x = 1;\n    }\n    this._width = value;\n  }\n  get height() {\n    return this.scale.y * this.getLocalBounds().height;\n  }\n  set height(value) {\n    const height = this.getLocalBounds().height;\n    if (height !== 0) {\n      this.scale.y = value / height;\n    } else {\n      this.scale.y = 1;\n    }\n    this._height = value;\n  }\n};\nlet Container = _Container;\nContainer.defaultSortableChildren = false;\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n\n\n//# sourceMappingURL=Container.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/settings.mjs\n\n\n\n\nObject.defineProperties(lib/* settings */.Xd, {\n  SORTABLE_CHILDREN: {\n    get() {\n      return Container.defaultSortableChildren;\n    },\n    set(value) {\n      lib/* utils.deprecation */.P6.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");\n      Container.defaultSortableChildren = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlDQUFlO0FBQzVCO0FBQ0EsdUJBQXVCLHFCQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtCO0FBQ2xCOzs7QUM1T2lGO0FBQzNDOztBQUV0Qyw0QkFBNEIsMkNBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFVO0FBQy9DO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksZ0NBQWU7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFCO0FBQ3JCOzs7QUMzVjZDO0FBQ1A7QUFDTTs7QUFFNUMsd0JBQXdCLG9CQUFRO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhLGlDQUFpQztBQUM5QyxLQUFLO0FBQ0w7QUFDQSxNQUFNLHlDQUFpQjtBQUN2QixNQUFNLGlDQUFpQztBQUN2QztBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUNmd0I7QUFDYztBQUNNO0FBQ2dDO0FBQzVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Rpc3BsYXkvbGliL0JvdW5kcy5tanM/NjI3NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvRGlzcGxheU9iamVjdC5tanM/MmY5YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvQ29udGFpbmVyLm1qcz9kMThmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9zZXR0aW5ncy5tanM/N2U5YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvaW5kZXgubWpzPzJkNmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNsYXNzIEJvdW5kcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4WCA9IC1JbmZpbml0eTtcbiAgICB0aGlzLm1heFkgPSAtSW5maW5pdHk7XG4gICAgdGhpcy5yZWN0ID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUlEID0gLTE7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xuICB9XG4gIGdldFJlY3RhbmdsZShyZWN0KSB7XG4gICAgaWYgKHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFkpIHtcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuRU1QVFk7XG4gICAgfVxuICAgIHJlY3QgPSByZWN0IHx8IG5ldyBSZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG4gICAgcmVjdC54ID0gdGhpcy5taW5YO1xuICAgIHJlY3QueSA9IHRoaXMubWluWTtcbiAgICByZWN0LndpZHRoID0gdGhpcy5tYXhYIC0gdGhpcy5taW5YO1xuICAgIHJlY3QuaGVpZ2h0ID0gdGhpcy5tYXhZIC0gdGhpcy5taW5ZO1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGFkZFBvaW50KHBvaW50KSB7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCBwb2ludC54KTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHBvaW50LngpO1xuICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgcG9pbnQueSk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCBwb2ludC55KTtcbiAgfVxuICBhZGRQb2ludE1hdHJpeChtYXRyaXgsIHBvaW50KSB7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCB0eCwgdHkgfSA9IG1hdHJpeDtcbiAgICBjb25zdCB4ID0gYSAqIHBvaW50LnggKyBjICogcG9pbnQueSArIHR4O1xuICAgIGNvbnN0IHkgPSBiICogcG9pbnQueCArIGQgKiBwb2ludC55ICsgdHk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCB4KTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHgpO1xuICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgeSk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCB5KTtcbiAgfVxuICBhZGRRdWFkKHZlcnRpY2VzKSB7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblg7XG4gICAgbGV0IG1pblkgPSB0aGlzLm1pblk7XG4gICAgbGV0IG1heFggPSB0aGlzLm1heFg7XG4gICAgbGV0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgbGV0IHggPSB2ZXJ0aWNlc1swXTtcbiAgICBsZXQgeSA9IHZlcnRpY2VzWzFdO1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIHggPSB2ZXJ0aWNlc1syXTtcbiAgICB5ID0gdmVydGljZXNbM107XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgeCA9IHZlcnRpY2VzWzRdO1xuICAgIHkgPSB2ZXJ0aWNlc1s1XTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB4ID0gdmVydGljZXNbNl07XG4gICAgeSA9IHZlcnRpY2VzWzddO1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgdGhpcy5taW5ZID0gbWluWTtcbiAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgIHRoaXMubWF4WSA9IG1heFk7XG4gIH1cbiAgYWRkRnJhbWUodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIHRoaXMuYWRkRnJhbWVNYXRyaXgodHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSk7XG4gIH1cbiAgYWRkRnJhbWVNYXRyaXgobWF0cml4LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWDtcbiAgICBsZXQgbWluWSA9IHRoaXMubWluWTtcbiAgICBsZXQgbWF4WCA9IHRoaXMubWF4WDtcbiAgICBsZXQgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBsZXQgeCA9IGEgKiB4MCArIGMgKiB5MCArIHR4O1xuICAgIGxldCB5ID0gYiAqIHgwICsgZCAqIHkwICsgdHk7XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgeCA9IGEgKiB4MSArIGMgKiB5MCArIHR4O1xuICAgIHkgPSBiICogeDEgKyBkICogeTAgKyB0eTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB4ID0gYSAqIHgwICsgYyAqIHkxICsgdHg7XG4gICAgeSA9IGIgKiB4MCArIGQgKiB5MSArIHR5O1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIHggPSBhICogeDEgKyBjICogeTEgKyB0eDtcbiAgICB5ID0gYiAqIHgxICsgZCAqIHkxICsgdHk7XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgdGhpcy5taW5YID0gbWluWDtcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICBhZGRWZXJ0ZXhEYXRhKHZlcnRleERhdGEsIGJlZ2luT2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWDtcbiAgICBsZXQgbWluWSA9IHRoaXMubWluWTtcbiAgICBsZXQgbWF4WCA9IHRoaXMubWF4WDtcbiAgICBsZXQgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBmb3IgKGxldCBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHZlcnRleERhdGFbaV07XG4gICAgICBjb25zdCB5ID0gdmVydGV4RGF0YVtpICsgMV07XG4gICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB9XG4gICAgdGhpcy5taW5YID0gbWluWDtcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICBhZGRWZXJ0aWNlcyh0cmFuc2Zvcm0sIHZlcnRpY2VzLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgdGhpcy5hZGRWZXJ0aWNlc01hdHJpeCh0cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0sIHZlcnRpY2VzLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgfVxuICBhZGRWZXJ0aWNlc01hdHJpeChtYXRyaXgsIHZlcnRpY2VzLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0LCBwYWRYID0gMCwgcGFkWSA9IHBhZFgpIHtcbiAgICBjb25zdCBhID0gbWF0cml4LmE7XG4gICAgY29uc3QgYiA9IG1hdHJpeC5iO1xuICAgIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgICBjb25zdCBkID0gbWF0cml4LmQ7XG4gICAgY29uc3QgdHggPSBtYXRyaXgudHg7XG4gICAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblg7XG4gICAgbGV0IG1pblkgPSB0aGlzLm1pblk7XG4gICAgbGV0IG1heFggPSB0aGlzLm1heFg7XG4gICAgbGV0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgZm9yIChsZXQgaSA9IGJlZ2luT2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHJhd1ggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgIGNvbnN0IHJhd1kgPSB2ZXJ0aWNlc1tpICsgMV07XG4gICAgICBjb25zdCB4ID0gYSAqIHJhd1ggKyBjICogcmF3WSArIHR4O1xuICAgICAgY29uc3QgeSA9IGQgKiByYXdZICsgYiAqIHJhd1ggKyB0eTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4IC0gcGFkWCk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCArIHBhZFgpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkgLSBwYWRZKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5ICsgcGFkWSk7XG4gICAgfVxuICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgdGhpcy5taW5ZID0gbWluWTtcbiAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgIHRoaXMubWF4WSA9IG1heFk7XG4gIH1cbiAgYWRkQm91bmRzKGJvdW5kcykge1xuICAgIGNvbnN0IG1pblggPSB0aGlzLm1pblg7XG4gICAgY29uc3QgbWluWSA9IHRoaXMubWluWTtcbiAgICBjb25zdCBtYXhYID0gdGhpcy5tYXhYO1xuICAgIGNvbnN0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgdGhpcy5taW5YID0gYm91bmRzLm1pblggPCBtaW5YID8gYm91bmRzLm1pblggOiBtaW5YO1xuICAgIHRoaXMubWluWSA9IGJvdW5kcy5taW5ZIDwgbWluWSA/IGJvdW5kcy5taW5ZIDogbWluWTtcbiAgICB0aGlzLm1heFggPSBib3VuZHMubWF4WCA+IG1heFggPyBib3VuZHMubWF4WCA6IG1heFg7XG4gICAgdGhpcy5tYXhZID0gYm91bmRzLm1heFkgPiBtYXhZID8gYm91bmRzLm1heFkgOiBtYXhZO1xuICB9XG4gIGFkZEJvdW5kc01hc2soYm91bmRzLCBtYXNrKSB7XG4gICAgY29uc3QgX21pblggPSBib3VuZHMubWluWCA+IG1hc2subWluWCA/IGJvdW5kcy5taW5YIDogbWFzay5taW5YO1xuICAgIGNvbnN0IF9taW5ZID0gYm91bmRzLm1pblkgPiBtYXNrLm1pblkgPyBib3VuZHMubWluWSA6IG1hc2subWluWTtcbiAgICBjb25zdCBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgbWFzay5tYXhYID8gYm91bmRzLm1heFggOiBtYXNrLm1heFg7XG4gICAgY29uc3QgX21heFkgPSBib3VuZHMubWF4WSA8IG1hc2subWF4WSA/IGJvdW5kcy5tYXhZIDogbWFzay5tYXhZO1xuICAgIGlmIChfbWluWCA8PSBfbWF4WCAmJiBfbWluWSA8PSBfbWF4WSkge1xuICAgICAgY29uc3QgbWluWCA9IHRoaXMubWluWDtcbiAgICAgIGNvbnN0IG1pblkgPSB0aGlzLm1pblk7XG4gICAgICBjb25zdCBtYXhYID0gdGhpcy5tYXhYO1xuICAgICAgY29uc3QgbWF4WSA9IHRoaXMubWF4WTtcbiAgICAgIHRoaXMubWluWCA9IF9taW5YIDwgbWluWCA/IF9taW5YIDogbWluWDtcbiAgICAgIHRoaXMubWluWSA9IF9taW5ZIDwgbWluWSA/IF9taW5ZIDogbWluWTtcbiAgICAgIHRoaXMubWF4WCA9IF9tYXhYID4gbWF4WCA/IF9tYXhYIDogbWF4WDtcbiAgICAgIHRoaXMubWF4WSA9IF9tYXhZID4gbWF4WSA/IF9tYXhZIDogbWF4WTtcbiAgICB9XG4gIH1cbiAgYWRkQm91bmRzTWF0cml4KGJvdW5kcywgbWF0cml4KSB7XG4gICAgdGhpcy5hZGRGcmFtZU1hdHJpeChtYXRyaXgsIGJvdW5kcy5taW5YLCBib3VuZHMubWluWSwgYm91bmRzLm1heFgsIGJvdW5kcy5tYXhZKTtcbiAgfVxuICBhZGRCb3VuZHNBcmVhKGJvdW5kcywgYXJlYSkge1xuICAgIGNvbnN0IF9taW5YID0gYm91bmRzLm1pblggPiBhcmVhLnggPyBib3VuZHMubWluWCA6IGFyZWEueDtcbiAgICBjb25zdCBfbWluWSA9IGJvdW5kcy5taW5ZID4gYXJlYS55ID8gYm91bmRzLm1pblkgOiBhcmVhLnk7XG4gICAgY29uc3QgX21heFggPSBib3VuZHMubWF4WCA8IGFyZWEueCArIGFyZWEud2lkdGggPyBib3VuZHMubWF4WCA6IGFyZWEueCArIGFyZWEud2lkdGg7XG4gICAgY29uc3QgX21heFkgPSBib3VuZHMubWF4WSA8IGFyZWEueSArIGFyZWEuaGVpZ2h0ID8gYm91bmRzLm1heFkgOiBhcmVhLnkgKyBhcmVhLmhlaWdodDtcbiAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcbiAgICAgIGNvbnN0IG1pblggPSB0aGlzLm1pblg7XG4gICAgICBjb25zdCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgY29uc3QgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgIGNvbnN0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgICB0aGlzLm1pblggPSBfbWluWCA8IG1pblggPyBfbWluWCA6IG1pblg7XG4gICAgICB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblk7XG4gICAgICB0aGlzLm1heFggPSBfbWF4WCA+IG1heFggPyBfbWF4WCA6IG1heFg7XG4gICAgICB0aGlzLm1heFkgPSBfbWF4WSA+IG1heFkgPyBfbWF4WSA6IG1heFk7XG4gICAgfVxuICB9XG4gIHBhZChwYWRkaW5nWCA9IDAsIHBhZGRpbmdZID0gcGFkZGluZ1gpIHtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLm1pblggLT0gcGFkZGluZ1g7XG4gICAgICB0aGlzLm1heFggKz0gcGFkZGluZ1g7XG4gICAgICB0aGlzLm1pblkgLT0gcGFkZGluZ1k7XG4gICAgICB0aGlzLm1heFkgKz0gcGFkZGluZ1k7XG4gICAgfVxuICB9XG4gIGFkZEZyYW1lUGFkKHgwLCB5MCwgeDEsIHkxLCBwYWRYLCBwYWRZKSB7XG4gICAgeDAgLT0gcGFkWDtcbiAgICB5MCAtPSBwYWRZO1xuICAgIHgxICs9IHBhZFg7XG4gICAgeTEgKz0gcGFkWTtcbiAgICB0aGlzLm1pblggPSB0aGlzLm1pblggPCB4MCA/IHRoaXMubWluWCA6IHgwO1xuICAgIHRoaXMubWF4WCA9IHRoaXMubWF4WCA+IHgxID8gdGhpcy5tYXhYIDogeDE7XG4gICAgdGhpcy5taW5ZID0gdGhpcy5taW5ZIDwgeTAgPyB0aGlzLm1pblkgOiB5MDtcbiAgICB0aGlzLm1heFkgPSB0aGlzLm1heFkgPiB5MSA/IHRoaXMubWF4WSA6IHkxO1xuICB9XG59XG5cbmV4cG9ydCB7IEJvdW5kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzLCBUcmFuc2Zvcm0sIFJlY3RhbmdsZSwgUkFEX1RPX0RFRywgREVHX1RPX1JBRCB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSAnLi9Cb3VuZHMubWpzJztcblxuY2xhc3MgRGlzcGxheU9iamVjdCBleHRlbmRzIHV0aWxzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xuICAgIHRoaXMuY3VsbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmN1bGxBcmVhID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy53b3JsZEFscGhhID0gMTtcbiAgICB0aGlzLl9sYXN0U29ydGVkSW5kZXggPSAwO1xuICAgIHRoaXMuX3pJbmRleCA9IDA7XG4gICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcbiAgICB0aGlzLmZpbHRlcnMgPSBudWxsO1xuICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kc0lEID0gMDtcbiAgICB0aGlzLl9ib3VuZHNSZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBudWxsO1xuICAgIHRoaXMuX21hc2sgPSBudWxsO1xuICAgIHRoaXMuX21hc2tSZWZDb3VudCA9IDA7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5pc1Nwcml0ZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNNYXNrID0gZmFsc2U7XG4gIH1cbiAgc3RhdGljIG1peGluKHNvdXJjZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0ga2V5c1tpXTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgcHJvcGVydHlOYW1lLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgcHJvcGVydHlOYW1lKSk7XG4gICAgfVxuICB9XG4gIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3llZDtcbiAgfVxuICBfcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50Ll9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xuICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICB9XG4gIGdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KSB7XG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2JvdW5kcy51cGRhdGVJRCAhPT0gdGhpcy5fYm91bmRzSUQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICB0aGlzLl9ib3VuZHMudXBkYXRlSUQgPSB0aGlzLl9ib3VuZHNJRDtcbiAgICB9XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICBpZiAoIXRoaXMuX2JvdW5kc1JlY3QpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzUmVjdCA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICAgIH1cbiAgICAgIHJlY3QgPSB0aGlzLl9ib3VuZHNSZWN0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYm91bmRzLmdldFJlY3RhbmdsZShyZWN0KTtcbiAgfVxuICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzUmVjdCkge1xuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICB9XG4gICAgICByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzKSB7XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtUmVmID0gdGhpcy50cmFuc2Zvcm07XG4gICAgY29uc3QgcGFyZW50UmVmID0gdGhpcy5wYXJlbnQ7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQudHJhbnNmb3JtO1xuICAgIGNvbnN0IHdvcmxkQm91bmRzID0gdGhpcy5fYm91bmRzO1xuICAgIGNvbnN0IHdvcmxkQm91bmRzSUQgPSB0aGlzLl9ib3VuZHNJRDtcbiAgICB0aGlzLl9ib3VuZHMgPSB0aGlzLl9sb2NhbEJvdW5kcztcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyhmYWxzZSwgcmVjdCk7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRSZWY7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1SZWY7XG4gICAgdGhpcy5fYm91bmRzID0gd29ybGRCb3VuZHM7XG4gICAgdGhpcy5fYm91bmRzLnVwZGF0ZUlEICs9IHRoaXMuX2JvdW5kc0lEIC0gd29ybGRCb3VuZHNJRDtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG4gIHRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICB0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHkocG9zaXRpb24sIHBvaW50KTtcbiAgfVxuICB0b0xvY2FsKHBvc2l0aW9uLCBmcm9tLCBwb2ludCwgc2tpcFVwZGF0ZSkge1xuICAgIGlmIChmcm9tKSB7XG4gICAgICBwb3NpdGlvbiA9IGZyb20udG9HbG9iYWwocG9zaXRpb24sIHBvaW50LCBza2lwVXBkYXRlKTtcbiAgICB9XG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICB0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvc2l0aW9uLCBwb2ludCk7XG4gIH1cbiAgc2V0UGFyZW50KGNvbnRhaW5lcikge1xuICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXIuYWRkQ2hpbGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFBhcmVudDogQXJndW1lbnQgbXVzdCBiZSBhIENvbnRhaW5lclwiKTtcbiAgICB9XG4gICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgcmVtb3ZlRnJvbVBhcmVudCgpIHtcbiAgICB0aGlzLnBhcmVudD8ucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKHggPSAwLCB5ID0gMCwgc2NhbGVYID0gMSwgc2NhbGVZID0gMSwgcm90YXRpb24gPSAwLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgcGl2b3RYID0gMCwgcGl2b3RZID0gMCkge1xuICAgIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gICAgdGhpcy5wb3NpdGlvbi55ID0geTtcbiAgICB0aGlzLnNjYWxlLnggPSAhc2NhbGVYID8gMSA6IHNjYWxlWDtcbiAgICB0aGlzLnNjYWxlLnkgPSAhc2NhbGVZID8gMSA6IHNjYWxlWTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5za2V3LnggPSBza2V3WDtcbiAgICB0aGlzLnNrZXcueSA9IHNrZXdZO1xuICAgIHRoaXMucGl2b3QueCA9IHBpdm90WDtcbiAgICB0aGlzLnBpdm90LnkgPSBwaXZvdFk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzdHJveShfb3B0aW9ucykge1xuICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICAgIHRoaXMubWFzayA9IG51bGw7XG4gICAgdGhpcy5jdWxsQXJlYSA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJzID0gbnVsbDtcbiAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICAgIHRoaXMuaGl0QXJlYSA9IG51bGw7XG4gICAgdGhpcy5ldmVudE1vZGUgPSBcImF1dG9cIjtcbiAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95ZWRcIik7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuICBnZXQgX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50KCkge1xuICAgIGlmICh0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID09PSBudWxsKSB7XG4gICAgICB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbmV3IFRlbXBvcmFyeURpc3BsYXlPYmplY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gIH1cbiAgZW5hYmxlVGVtcFBhcmVudCgpIHtcbiAgICBjb25zdCBteVBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgcmV0dXJuIG15UGFyZW50O1xuICB9XG4gIGRpc2FibGVUZW1wUGFyZW50KGNhY2hlUGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBjYWNoZVBhcmVudDtcbiAgfVxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xuICB9XG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24ueCA9IHZhbHVlO1xuICB9XG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XG4gIH1cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi55ID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHdvcmxkVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgfVxuICBnZXQgbG9jYWxUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtO1xuICB9XG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9zaXRpb247XG4gIH1cbiAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24uY29weUZyb20odmFsdWUpO1xuICB9XG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2NhbGU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUuY29weUZyb20odmFsdWUpO1xuICB9XG4gIGdldCBwaXZvdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucGl2b3Q7XG4gIH1cbiAgc2V0IHBpdm90KHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucGl2b3QuY29weUZyb20odmFsdWUpO1xuICB9XG4gIGdldCBza2V3KCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5za2V3O1xuICB9XG4gIHNldCBza2V3KHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0uc2tldy5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgfVxuICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlO1xuICB9XG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gKiBSQURfVE9fREVHO1xuICB9XG4gIHNldCBhbmdsZSh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsdWUgKiBERUdfVE9fUkFEO1xuICB9XG4gIGdldCB6SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pJbmRleDtcbiAgfVxuICBzZXQgekluZGV4KHZhbHVlKSB7XG4gICAgdGhpcy5fekluZGV4ID0gdmFsdWU7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5zb3J0RGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgd29ybGRWaXNpYmxlKCkge1xuICAgIGxldCBpdGVtID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAoIWl0ZW0udmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgfSB3aGlsZSAoaXRlbSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IG1hc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gIH1cbiAgc2V0IG1hc2sodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fbWFzayA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2tPYmplY3QgPSB0aGlzLl9tYXNrLmlzTWFza0RhdGEgPyB0aGlzLl9tYXNrLm1hc2tPYmplY3QgOiB0aGlzLl9tYXNrO1xuICAgICAgaWYgKG1hc2tPYmplY3QpIHtcbiAgICAgICAgbWFza09iamVjdC5fbWFza1JlZkNvdW50LS07XG4gICAgICAgIGlmIChtYXNrT2JqZWN0Ll9tYXNrUmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgICAgIG1hc2tPYmplY3QuaXNNYXNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrT2JqZWN0ID0gdGhpcy5fbWFzay5pc01hc2tEYXRhID8gdGhpcy5fbWFzay5tYXNrT2JqZWN0IDogdGhpcy5fbWFzaztcbiAgICAgIGlmIChtYXNrT2JqZWN0KSB7XG4gICAgICAgIGlmIChtYXNrT2JqZWN0Ll9tYXNrUmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICBtYXNrT2JqZWN0LmlzTWFzayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbWFza09iamVjdC5fbWFza1JlZkNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBUZW1wb3JhcnlEaXNwbGF5T2JqZWN0IGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zb3J0RGlydHkgPSBudWxsO1xuICB9XG59XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtID0gRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuXG5leHBvcnQgeyBEaXNwbGF5T2JqZWN0LCBUZW1wb3JhcnlEaXNwbGF5T2JqZWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXNwbGF5T2JqZWN0Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCwgdXRpbHMsIE1BU0tfVFlQRVMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IERpc3BsYXlPYmplY3QgfSBmcm9tICcuL0Rpc3BsYXlPYmplY3QubWpzJztcblxuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbmZ1bmN0aW9uIHNvcnRDaGlsZHJlbihhLCBiKSB7XG4gIGlmIChhLnpJbmRleCA9PT0gYi56SW5kZXgpIHtcbiAgICByZXR1cm4gYS5fbGFzdFNvcnRlZEluZGV4IC0gYi5fbGFzdFNvcnRlZEluZGV4O1xuICB9XG4gIHJldHVybiBhLnpJbmRleCAtIGIuekluZGV4O1xufVxuY29uc3QgX0NvbnRhaW5lciA9IGNsYXNzIGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuc29ydGFibGVDaGlsZHJlbiA9IF9Db250YWluZXIuZGVmYXVsdFNvcnRhYmxlQ2hpbGRyZW47XG4gICAgdGhpcy5zb3J0RGlydHkgPSBmYWxzZTtcbiAgfVxuICBvbkNoaWxkcmVuQ2hhbmdlKF9sZW5ndGgpIHtcbiAgfVxuICBhZGRDaGlsZCguLi5jaGlsZHJlbikge1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgIHRoaXMuc29ydERpcnR5ID0gdHJ1ZTtcbiAgICAgIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICB0aGlzLmVtaXQoXCJjaGlsZEFkZGVkXCIsIGNoaWxkLCB0aGlzLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgY2hpbGQuZW1pdChcImFkZGVkXCIsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gIH1cbiAgYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjaGlsZH1hZGRDaGlsZEF0OiBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke3RoaXMuY2hpbGRyZW4ubGVuZ3RofWApO1xuICAgIH1cbiAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMuc29ydERpcnR5ID0gdHJ1ZTtcbiAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gICAgY2hpbGQuZW1pdChcImFkZGVkXCIsIHRoaXMpO1xuICAgIHRoaXMuZW1pdChcImNoaWxkQWRkZWRcIiwgY2hpbGQsIHRoaXMsIGluZGV4KTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbiAgc3dhcENoaWxkcmVuKGNoaWxkLCBjaGlsZDIpIHtcbiAgICBpZiAoY2hpbGQgPT09IGNoaWxkMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleDEgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIGNvbnN0IGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4Ml0gPSBjaGlsZDtcbiAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgxIDwgaW5kZXgyID8gaW5kZXgxIDogaW5kZXgyKTtcbiAgfVxuICBnZXRDaGlsZEluZGV4KGNoaWxkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdXBwbGllZCBEaXNwbGF5T2JqZWN0IG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgY2FsbGVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgc2V0Q2hpbGRJbmRleChjaGlsZCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBpbmRleCAke2luZGV4fSBzdXBwbGllZCBpcyBvdXQgb2YgYm91bmRzICR7dGhpcy5jaGlsZHJlbi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XG4gICAgdXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgY3VycmVudEluZGV4LCAxKTtcbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gIH1cbiAgZ2V0Q2hpbGRBdChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Q2hpbGRBdDogSW5kZXggKCR7aW5kZXh9KSBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuICB9XG4gIHJlbW92ZUNoaWxkKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICB1dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG4gICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICAgIGNoaWxkLmVtaXQoXCJyZW1vdmVkXCIsIHRoaXMpO1xuICAgICAgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgfVxuICByZW1vdmVDaGlsZEF0KGluZGV4KSB7XG4gICAgY29uc3QgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaW5kZXgpO1xuICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgIHV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGluZGV4LCAxKTtcbiAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gICAgY2hpbGQuZW1pdChcInJlbW92ZWRcIiwgdGhpcyk7XG4gICAgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIHJlbW92ZUNoaWxkcmVuKGJlZ2luSW5kZXggPSAwLCBlbmRJbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgYmVnaW4gPSBiZWdpbkluZGV4O1xuICAgIGNvbnN0IGVuZCA9IGVuZEluZGV4O1xuICAgIGNvbnN0IHJhbmdlID0gZW5kIC0gYmVnaW47XG4gICAgbGV0IHJlbW92ZWQ7XG4gICAgaWYgKHJhbmdlID4gMCAmJiByYW5nZSA8PSBlbmQpIHtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLmNoaWxkcmVuLnNwbGljZShiZWdpbiwgcmFuZ2UpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlbW92ZWRbaV0ucGFyZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHJlbW92ZWRbaV0udHJhbnNmb3JtKSB7XG4gICAgICAgICAgcmVtb3ZlZFtpXS50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoYmVnaW5JbmRleCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVtb3ZlZFtpXS5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIHJlbW92ZWRbaV0sIHRoaXMsIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gMCAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJlbW92ZUNoaWxkcmVuOiBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZS5cIik7XG4gIH1cbiAgc29ydENoaWxkcmVuKCkge1xuICAgIGxldCBzb3J0UmVxdWlyZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBjaGlsZC5fbGFzdFNvcnRlZEluZGV4ID0gaTtcbiAgICAgIGlmICghc29ydFJlcXVpcmVkICYmIGNoaWxkLnpJbmRleCAhPT0gMCkge1xuICAgICAgICBzb3J0UmVxdWlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydFJlcXVpcmVkICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zb3J0KHNvcnRDaGlsZHJlbik7XG4gICAgfVxuICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gIH1cbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIGlmICh0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gJiYgdGhpcy5zb3J0RGlydHkpIHtcbiAgICAgIHRoaXMuc29ydENoaWxkcmVuKCk7XG4gICAgfVxuICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSk7XG4gICAgdGhpcy53b3JsZEFscGhhID0gdGhpcy5hbHBoYSAqIHRoaXMucGFyZW50LndvcmxkQWxwaGE7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnZpc2libGUpIHtcbiAgICAgICAgY2hpbGQudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICB0aGlzLl9ib3VuZHMuY2xlYXIoKTtcbiAgICB0aGlzLl9jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmICghY2hpbGQudmlzaWJsZSB8fCAhY2hpbGQucmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgaWYgKGNoaWxkLl9tYXNrKSB7XG4gICAgICAgIGNvbnN0IG1hc2tPYmplY3QgPSBjaGlsZC5fbWFzay5pc01hc2tEYXRhID8gY2hpbGQuX21hc2subWFza09iamVjdCA6IGNoaWxkLl9tYXNrO1xuICAgICAgICBpZiAobWFza09iamVjdCkge1xuICAgICAgICAgIG1hc2tPYmplY3QuY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kc01hc2soY2hpbGQuX2JvdW5kcywgbWFza09iamVjdC5fYm91bmRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkQm91bmRzKGNoaWxkLl9ib3VuZHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmZpbHRlckFyZWEpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kc0FyZWEoY2hpbGQuX2JvdW5kcywgY2hpbGQuZmlsdGVyQXJlYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib3VuZHMuYWRkQm91bmRzKGNoaWxkLl9ib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9ib3VuZHMudXBkYXRlSUQgPSB0aGlzLl9ib3VuZHNJRDtcbiAgfVxuICBnZXRMb2NhbEJvdW5kcyhyZWN0LCBza2lwQ2hpbGRyZW5VcGRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmdldExvY2FsQm91bmRzKHJlY3QpO1xuICAgIGlmICghc2tpcENoaWxkcmVuVXBkYXRlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLnZpc2libGUpIHtcbiAgICAgICAgICBjaGlsZC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gIH1cbiAgX3JlbmRlcldpdGhDdWxsaW5nKHJlbmRlcmVyKSB7XG4gICAgY29uc3Qgc291cmNlRnJhbWUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLnNvdXJjZUZyYW1lO1xuICAgIGlmICghKHNvdXJjZUZyYW1lLndpZHRoID4gMCAmJiBzb3VyY2VGcmFtZS5oZWlnaHQgPiAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYm91bmRzO1xuICAgIGxldCB0cmFuc2Zvcm07XG4gICAgaWYgKHRoaXMuY3VsbEFyZWEpIHtcbiAgICAgIGJvdW5kcyA9IHRoaXMuY3VsbEFyZWE7XG4gICAgICB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcmVuZGVyICE9PSBfQ29udGFpbmVyLnByb3RvdHlwZS5fcmVuZGVyKSB7XG4gICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyh0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgcHJvamVjdGlvblRyYW5zZm9ybSA9IHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtO1xuICAgIGlmIChwcm9qZWN0aW9uVHJhbnNmb3JtKSB7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRlbXBNYXRyaXguY29weUZyb20odHJhbnNmb3JtKTtcbiAgICAgICAgdHJhbnNmb3JtLnByZXBlbmQocHJvamVjdGlvblRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm0gPSBwcm9qZWN0aW9uVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm91bmRzICYmIHNvdXJjZUZyYW1lLmludGVyc2VjdHMoYm91bmRzLCB0cmFuc2Zvcm0pKSB7XG4gICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdWxsQXJlYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBjaGlsZEN1bGxhYmxlID0gY2hpbGQuY3VsbGFibGU7XG4gICAgICBjaGlsZC5jdWxsYWJsZSA9IGNoaWxkQ3VsbGFibGUgfHwgIXRoaXMuY3VsbEFyZWE7XG4gICAgICBjaGlsZC5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgY2hpbGQuY3VsbGFibGUgPSBjaGlsZEN1bGxhYmxlO1xuICAgIH1cbiAgfVxuICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9tYXNrIHx8IHRoaXMuZmlsdGVycz8ubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbmRlckFkdmFuY2VkKHJlbmRlcmVyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VsbGFibGUpIHtcbiAgICAgIHRoaXMuX3JlbmRlcldpdGhDdWxsaW5nKHJlbmRlcmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXJBZHZhbmNlZChyZW5kZXJlcikge1xuICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX21hc2s7XG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGlmICghdGhpcy5fZW5hYmxlZEZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5fZW5hYmxlZEZpbHRlcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZpbHRlcnNbaV0uZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLnB1c2goZmlsdGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmx1c2ggPSBmaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzPy5sZW5ndGggfHwgbWFzayAmJiAoIW1hc2suaXNNYXNrRGF0YSB8fCBtYXNrLmVuYWJsZWQgJiYgKG1hc2suYXV0b0RldGVjdCB8fCBtYXNrLnR5cGUgIT09IE1BU0tfVFlQRVMuTk9ORSkpO1xuICAgIGlmIChmbHVzaCkge1xuICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMgJiYgdGhpcy5fZW5hYmxlZEZpbHRlcnM/Lmxlbmd0aCkge1xuICAgICAgcmVuZGVyZXIuZmlsdGVyLnB1c2godGhpcywgdGhpcy5fZW5hYmxlZEZpbHRlcnMpO1xuICAgIH1cbiAgICBpZiAobWFzaykge1xuICAgICAgcmVuZGVyZXIubWFzay5wdXNoKHRoaXMsIHRoaXMuX21hc2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdWxsYWJsZSkge1xuICAgICAgdGhpcy5fcmVuZGVyV2l0aEN1bGxpbmcocmVuZGVyZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbHVzaCkge1xuICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICB9XG4gICAgaWYgKG1hc2spIHtcbiAgICAgIHJlbmRlcmVyLm1hc2sucG9wKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycz8ubGVuZ3RoKSB7XG4gICAgICByZW5kZXJlci5maWx0ZXIucG9wKCk7XG4gICAgfVxuICB9XG4gIF9yZW5kZXIoX3JlbmRlcmVyKSB7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gICAgY29uc3QgZGVzdHJveUNoaWxkcmVuID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LmNoaWxkcmVuO1xuICAgIGNvbnN0IG9sZENoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgaWYgKGRlc3Ryb3lDaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRDaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBvbGRDaGlsZHJlbltpXS5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcbiAgICBpZiAod2lkdGggIT09IDApIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IDE7XG4gICAgfVxuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgICBpZiAoaGVpZ2h0ICE9PSAwKSB7XG4gICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIGhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2FsZS55ID0gMTtcbiAgICB9XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cbn07XG5sZXQgQ29udGFpbmVyID0gX0NvbnRhaW5lcjtcbkNvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlbiA9IGZhbHNlO1xuQ29udGFpbmVyLnByb3RvdHlwZS5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0gPSBDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcblxuZXhwb3J0IHsgQ29udGFpbmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MsIHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5leHBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi9Db250YWluZXIubWpzJztcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2V0dGluZ3MsIHtcbiAgU09SVEFCTEVfQ0hJTERSRU46IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQ29udGFpbmVyLmRlZmF1bHRTb3J0YWJsZUNoaWxkcmVuO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU09SVEFCTEVfQ0hJTERSRU4gaXMgZGVwcmVjYXRlZCwgdXNlIENvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlblwiKTtcbiAgICAgIENvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlbiA9IHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5tanMubWFwXG4iLCJpbXBvcnQgJy4vc2V0dGluZ3MubWpzJztcbmV4cG9ydCB7IEJvdW5kcyB9IGZyb20gJy4vQm91bmRzLm1qcyc7XG5leHBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuL0NvbnRhaW5lci5tanMnO1xuZXhwb3J0IHsgRGlzcGxheU9iamVjdCwgVGVtcG9yYXJ5RGlzcGxheU9iamVjdCB9IGZyb20gJy4vRGlzcGxheU9iamVjdC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///820\n')},363:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Cd": () => (/* reexport */ Circle),\n  "ZX": () => (/* reexport */ DEG_TO_RAD),\n  "Pj": () => (/* reexport */ Ellipse),\n  "y3": () => (/* reexport */ Matrix),\n  "AB": () => (/* reexport */ ObservablePoint),\n  "_b": () => (/* reexport */ PI_2),\n  "E9": () => (/* reexport */ Point),\n  "mg": () => (/* reexport */ Polygon),\n  "jl": () => (/* reexport */ RAD_TO_DEG),\n  "Ae": () => (/* reexport */ Rectangle),\n  "c9": () => (/* reexport */ RoundedRectangle),\n  "HS": () => (/* reexport */ SHAPES),\n  "wx": () => (/* reexport */ Transform),\n  "Lv": () => (/* reexport */ groupD8)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/const.mjs\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\nvar SHAPES = /* @__PURE__ */ ((SHAPES2) => {\n  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";\n  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";\n  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";\n  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";\n  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";\n  return SHAPES2;\n})(SHAPES || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Point.mjs\nclass Point {\n  constructor(x = 0, y = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;\n  }\n}\n\n\n//# sourceMappingURL=Point.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Rectangle.mjs\n\n\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n    this.type = SHAPES.RECT;\n  }\n  get left() {\n    return this.x;\n  }\n  get right() {\n    return this.x + this.width;\n  }\n  get top() {\n    return this.y;\n  }\n  get bottom() {\n    return this.y + this.height;\n  }\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  copyTo(rectangle) {\n    rectangle.x = this.x;\n    rectangle.y = this.y;\n    rectangle.width = this.width;\n    rectangle.height = this.height;\n    return rectangle;\n  }\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  toString() {\n    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Rectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Circle.mjs\n\n\n\nclass Circle {\n  constructor(x = 0, y = 0, radius = 0) {\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.type = SHAPES.CIRC;\n  }\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  contains(x, y) {\n    if (this.radius <= 0) {\n      return false;\n    }\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  getBounds() {\n    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n  }\n  toString() {\n    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=Circle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Ellipse.mjs\n\n\n\nclass Ellipse {\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = halfWidth;\n    this.height = halfHeight;\n    this.type = SHAPES.ELIP;\n  }\n  clone() {\n    return new Ellipse(this.x, this.y, this.width, this.height);\n  }\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.width;\n    let normy = (y - this.y) / this.height;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  getBounds() {\n    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n  }\n  toString() {\n    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Ellipse.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Polygon.mjs\n\n\nclass Polygon {\n  constructor(...points) {\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== "number") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.type = SHAPES.POLY;\n    this.closeStroke = true;\n  }\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closeStroke = this.closeStroke;\n    return polygon;\n  }\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  toString() {\n    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;\n  }\n}\n\n\n//# sourceMappingURL=Polygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs\n\n\nclass RoundedRectangle {\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n    this.type = SHAPES.RREC;\n  }\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  toString() {\n    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=RoundedRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Matrix.mjs\n\n\n\nclass Matrix {\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  apply(pos, newPos) {\n    newPos = newPos || new Point();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point();\n    const id = 1 / (this.a * this.d + this.c * -this.b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;\n    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;\n    return newPos;\n  }\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  toString() {\n    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  static get IDENTITY() {\n    return new Matrix();\n  }\n  static get TEMP_MATRIX() {\n    return new Matrix();\n  }\n}\n\n\n//# sourceMappingURL=Matrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/groupD8.mjs\n\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MAIN_DIAGONAL: 10,\n  MIRROR_HORIZONTAL: 12,\n  REVERSE_DIAGONAL: 14,\n  uX: (ind) => ux[ind],\n  uY: (ind) => uy[ind],\n  vX: (ind) => vx[ind],\n  vY: (ind) => vy[ind],\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  rotate180: (rotation) => rotation ^ 4,\n  isVertical: (rotation) => (rotation & 3) === 2,\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\n\n//# sourceMappingURL=groupD8.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/ObservablePoint.mjs\nclass ObservablePoint {\n  constructor(cb, scope, x = 0, y = 0) {\n    this._x = x;\n    this._y = y;\n    this.cb = cb;\n    this.scope = scope;\n  }\n  clone(cb = this.cb, scope = this.scope) {\n    return new ObservablePoint(cb, scope, this._x, this._y);\n  }\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this.cb.call(this.scope);\n    }\n    return this;\n  }\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this.cb.call(this.scope);\n    }\n    return this;\n  }\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this.cb.call(this.scope);\n    }\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this.cb.call(this.scope);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ObservablePoint.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Transform.mjs\n\n\n\nconst _Transform = class {\n  constructor() {\n    this.worldTransform = new Matrix();\n    this.localTransform = new Matrix();\n    this.position = new ObservablePoint(this.onChange, this, 0, 0);\n    this.scale = new ObservablePoint(this.onChange, this, 1, 1);\n    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);\n    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);\n    this._rotation = 0;\n    this._cx = 1;\n    this._sx = 0;\n    this._cy = 0;\n    this._sy = 1;\n    this._localID = 0;\n    this._currentLocalID = 0;\n    this._worldID = 0;\n    this._parentID = 0;\n  }\n  onChange() {\n    this._localID++;\n  }\n  updateSkew() {\n    this._cx = Math.cos(this._rotation + this.skew.y);\n    this._sx = Math.sin(this._rotation + this.skew.y);\n    this._cy = -Math.sin(this._rotation - this.skew.x);\n    this._sy = Math.cos(this._rotation - this.skew.x);\n    this._localID++;\n  }\n  toString() {\n    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;\n  }\n  updateLocalTransform() {\n    const lt = this.localTransform;\n    if (this._localID !== this._currentLocalID) {\n      lt.a = this._cx * this.scale.x;\n      lt.b = this._sx * this.scale.x;\n      lt.c = this._cy * this.scale.y;\n      lt.d = this._sy * this.scale.y;\n      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n      this._currentLocalID = this._localID;\n      this._parentID = -1;\n    }\n  }\n  updateTransform(parentTransform) {\n    const lt = this.localTransform;\n    if (this._localID !== this._currentLocalID) {\n      lt.a = this._cx * this.scale.x;\n      lt.b = this._sx * this.scale.x;\n      lt.c = this._cy * this.scale.y;\n      lt.d = this._sy * this.scale.y;\n      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n      this._currentLocalID = this._localID;\n      this._parentID = -1;\n    }\n    if (this._parentID !== parentTransform._worldID) {\n      const pt = parentTransform.worldTransform;\n      const wt = this.worldTransform;\n      wt.a = lt.a * pt.a + lt.b * pt.c;\n      wt.b = lt.a * pt.b + lt.b * pt.d;\n      wt.c = lt.c * pt.a + lt.d * pt.c;\n      wt.d = lt.c * pt.b + lt.d * pt.d;\n      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n      this._parentID = parentTransform._worldID;\n      this._worldID++;\n    }\n  }\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n    this._localID++;\n  }\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this.updateSkew();\n    }\n  }\n};\nlet Transform = _Transform;\nTransform.IDENTITY = new _Transform();\n\n\n//# sourceMappingURL=Transform.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsS0FBSyxTQUFTLEtBQUssUUFBUTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQjs7O0FDbE9zQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUI7QUFDbkI7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxHQUFHLElBQUksR0FBRyxRQUFRLFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0I7OztBQ3pEc0M7QUFDa0I7O0FBRXhEO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQyw4QkFBOEIsTUFBTTtBQUNwQyx3QkFBd0IsZUFBZTtBQUN2QyxxQkFBcUIsZUFBZTtBQUNwQyxxQkFBcUIsZUFBZTtBQUNwQyxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLElBQUksZ0JBQWdCLGFBQWEsZUFBZSxTQUFTLGFBQWEsSUFBSSxhQUFhLFVBQVUsWUFBWSxJQUFJLFlBQVk7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFCO0FBQ3JCOzs7QUMxRjZDO0FBQ0U7QUFDQTtBQUNJO0FBQ2M7QUFDekI7QUFDbEI7QUFDSTtBQUNZO0FBQ2tCO0FBQ3BCO0FBQ1E7QUFDdUI7QUFDbkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvY29uc3QubWpzPzliYTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL1BvaW50Lm1qcz9iZjA0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvUmVjdGFuZ2xlLm1qcz8yMzJhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvQ2lyY2xlLm1qcz8wOTRlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvRWxsaXBzZS5tanM/MDU0MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvc2hhcGVzL1BvbHlnb24ubWpzPzg3NjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLm1qcz9mMTY0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9NYXRyaXgubWpzPzViYjAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL2dyb3VwRDgubWpzP2E3NmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL09ic2VydmFibGVQb2ludC5tanM/MjdiOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvVHJhbnNmb3JtLm1qcz8xZWQwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9pbmRleC5tanM/NzlmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBQSV8yID0gTWF0aC5QSSAqIDI7XG5jb25zdCBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbmNvbnN0IERFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xudmFyIFNIQVBFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNIQVBFUzIpID0+IHtcbiAgU0hBUEVTMltTSEFQRVMyW1wiUE9MWVwiXSA9IDBdID0gXCJQT0xZXCI7XG4gIFNIQVBFUzJbU0hBUEVTMltcIlJFQ1RcIl0gPSAxXSA9IFwiUkVDVFwiO1xuICBTSEFQRVMyW1NIQVBFUzJbXCJDSVJDXCJdID0gMl0gPSBcIkNJUkNcIjtcbiAgU0hBUEVTMltTSEFQRVMyW1wiRUxJUFwiXSA9IDNdID0gXCJFTElQXCI7XG4gIFNIQVBFUzJbU0hBUEVTMltcIlJSRUNcIl0gPSA0XSA9IFwiUlJFQ1wiO1xuICByZXR1cm4gU0hBUEVTMjtcbn0pKFNIQVBFUyB8fCB7fSk7XG5cbmV4cG9ydCB7IERFR19UT19SQUQsIFBJXzIsIFJBRF9UT19ERUcsIFNIQVBFUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIiwiY2xhc3MgUG9pbnQge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGNvcHlGcm9tKHApIHtcbiAgICB0aGlzLnNldChwLngsIHAueSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29weVRvKHApIHtcbiAgICBwLnNldCh0aGlzLngsIHRoaXMueSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZXF1YWxzKHApIHtcbiAgICByZXR1cm4gcC54ID09PSB0aGlzLnggJiYgcC55ID09PSB0aGlzLnk7XG4gIH1cbiAgc2V0KHggPSAwLCB5ID0geCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlBvaW50IHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgUG9pbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50Lm1qcy5tYXBcbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL1BvaW50Lm1qcyc7XG5cbmNvbnN0IHRlbXBQb2ludHMgPSBbbmV3IFBvaW50KCksIG5ldyBQb2ludCgpLCBuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCldO1xuY2xhc3MgUmVjdGFuZ2xlIHtcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICB0aGlzLnggPSBOdW1iZXIoeCk7XG4gICAgdGhpcy55ID0gTnVtYmVyKHkpO1xuICAgIHRoaXMud2lkdGggPSBOdW1iZXIod2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTnVtYmVyKGhlaWdodCk7XG4gICAgdGhpcy50eXBlID0gU0hBUEVTLlJFQ1Q7XG4gIH1cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueDtcbiAgfVxuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gIH1cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy55O1xuICB9XG4gIGdldCBib3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICB9XG4gIHN0YXRpYyBnZXQgRU1QVFkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCwgMCwgMCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBjb3B5RnJvbShyZWN0YW5nbGUpIHtcbiAgICB0aGlzLnggPSByZWN0YW5nbGUueDtcbiAgICB0aGlzLnkgPSByZWN0YW5nbGUueTtcbiAgICB0aGlzLndpZHRoID0gcmVjdGFuZ2xlLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5VG8ocmVjdGFuZ2xlKSB7XG4gICAgcmVjdGFuZ2xlLnggPSB0aGlzLng7XG4gICAgcmVjdGFuZ2xlLnkgPSB0aGlzLnk7XG4gICAgcmVjdGFuZ2xlLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICByZWN0YW5nbGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgfVxuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDwgdGhpcy54ICsgdGhpcy53aWR0aCkge1xuICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGludGVyc2VjdHMob3RoZXIsIHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCB4MDIgPSB0aGlzLnggPCBvdGhlci54ID8gb3RoZXIueCA6IHRoaXMueDtcbiAgICAgIGNvbnN0IHgxMiA9IHRoaXMucmlnaHQgPiBvdGhlci5yaWdodCA/IG90aGVyLnJpZ2h0IDogdGhpcy5yaWdodDtcbiAgICAgIGlmICh4MTIgPD0geDAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHkwMiA9IHRoaXMueSA8IG90aGVyLnkgPyBvdGhlci55IDogdGhpcy55O1xuICAgICAgY29uc3QgeTEyID0gdGhpcy5ib3R0b20gPiBvdGhlci5ib3R0b20gPyBvdGhlci5ib3R0b20gOiB0aGlzLmJvdHRvbTtcbiAgICAgIHJldHVybiB5MTIgPiB5MDI7XG4gICAgfVxuICAgIGNvbnN0IHgwID0gdGhpcy5sZWZ0O1xuICAgIGNvbnN0IHgxID0gdGhpcy5yaWdodDtcbiAgICBjb25zdCB5MCA9IHRoaXMudG9wO1xuICAgIGNvbnN0IHkxID0gdGhpcy5ib3R0b207XG4gICAgaWYgKHgxIDw9IHgwIHx8IHkxIDw9IHkwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGx0ID0gdGVtcFBvaW50c1swXS5zZXQob3RoZXIubGVmdCwgb3RoZXIudG9wKTtcbiAgICBjb25zdCBsYiA9IHRlbXBQb2ludHNbMV0uc2V0KG90aGVyLmxlZnQsIG90aGVyLmJvdHRvbSk7XG4gICAgY29uc3QgcnQgPSB0ZW1wUG9pbnRzWzJdLnNldChvdGhlci5yaWdodCwgb3RoZXIudG9wKTtcbiAgICBjb25zdCByYiA9IHRlbXBQb2ludHNbM10uc2V0KG90aGVyLnJpZ2h0LCBvdGhlci5ib3R0b20pO1xuICAgIGlmIChydC54IDw9IGx0LnggfHwgbGIueSA8PSBsdC55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHMgPSBNYXRoLnNpZ24odHJhbnNmb3JtLmEgKiB0cmFuc2Zvcm0uZCAtIHRyYW5zZm9ybS5iICogdHJhbnNmb3JtLmMpO1xuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyYW5zZm9ybS5hcHBseShsdCwgbHQpO1xuICAgIHRyYW5zZm9ybS5hcHBseShsYiwgbGIpO1xuICAgIHRyYW5zZm9ybS5hcHBseShydCwgcnQpO1xuICAgIHRyYW5zZm9ybS5hcHBseShyYiwgcmIpO1xuICAgIGlmIChNYXRoLm1heChsdC54LCBsYi54LCBydC54LCByYi54KSA8PSB4MCB8fCBNYXRoLm1pbihsdC54LCBsYi54LCBydC54LCByYi54KSA+PSB4MSB8fCBNYXRoLm1heChsdC55LCBsYi55LCBydC55LCByYi55KSA8PSB5MCB8fCBNYXRoLm1pbihsdC55LCBsYi55LCBydC55LCByYi55KSA+PSB5MSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBueCA9IHMgKiAobGIueSAtIGx0LnkpO1xuICAgIGNvbnN0IG55ID0gcyAqIChsdC54IC0gbGIueCk7XG4gICAgY29uc3QgbjAwID0gbnggKiB4MCArIG55ICogeTA7XG4gICAgY29uc3QgbjEwID0gbnggKiB4MSArIG55ICogeTA7XG4gICAgY29uc3QgbjAxID0gbnggKiB4MCArIG55ICogeTE7XG4gICAgY29uc3QgbjExID0gbnggKiB4MSArIG55ICogeTE7XG4gICAgaWYgKE1hdGgubWF4KG4wMCwgbjEwLCBuMDEsIG4xMSkgPD0gbnggKiBsdC54ICsgbnkgKiBsdC55IHx8IE1hdGgubWluKG4wMCwgbjEwLCBuMDEsIG4xMSkgPj0gbnggKiByYi54ICsgbnkgKiByYi55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG14ID0gcyAqIChsdC55IC0gcnQueSk7XG4gICAgY29uc3QgbXkgPSBzICogKHJ0LnggLSBsdC54KTtcbiAgICBjb25zdCBtMDAgPSBteCAqIHgwICsgbXkgKiB5MDtcbiAgICBjb25zdCBtMTAgPSBteCAqIHgxICsgbXkgKiB5MDtcbiAgICBjb25zdCBtMDEgPSBteCAqIHgwICsgbXkgKiB5MTtcbiAgICBjb25zdCBtMTEgPSBteCAqIHgxICsgbXkgKiB5MTtcbiAgICBpZiAoTWF0aC5tYXgobTAwLCBtMTAsIG0wMSwgbTExKSA8PSBteCAqIGx0LnggKyBteSAqIGx0LnkgfHwgTWF0aC5taW4obTAwLCBtMTAsIG0wMSwgbTExKSA+PSBteCAqIHJiLnggKyBteSAqIHJiLnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcGFkKHBhZGRpbmdYID0gMCwgcGFkZGluZ1kgPSBwYWRkaW5nWCkge1xuICAgIHRoaXMueCAtPSBwYWRkaW5nWDtcbiAgICB0aGlzLnkgLT0gcGFkZGluZ1k7XG4gICAgdGhpcy53aWR0aCArPSBwYWRkaW5nWCAqIDI7XG4gICAgdGhpcy5oZWlnaHQgKz0gcGFkZGluZ1kgKiAyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpdChyZWN0YW5nbGUpIHtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdGFuZ2xlLngpO1xuICAgIGNvbnN0IHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0YW5nbGUueSk7XG4gICAgY29uc3QgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB0aGlzLnggPSB4MTtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoeDIgLSB4MSwgMCk7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh5MiAtIHkxLCAwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjZWlsKHJlc29sdXRpb24gPSAxLCBlcHMgPSAxZS0zKSB7XG4gICAgY29uc3QgeDIgPSBNYXRoLmNlaWwoKHRoaXMueCArIHRoaXMud2lkdGggLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIGNvbnN0IHkyID0gTWF0aC5jZWlsKCh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy54ID0gTWF0aC5mbG9vcigodGhpcy54ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCh0aGlzLnkgKyBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIHRoaXMud2lkdGggPSB4MiAtIHRoaXMueDtcbiAgICB0aGlzLmhlaWdodCA9IHkyIC0gdGhpcy55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVubGFyZ2UocmVjdGFuZ2xlKSB7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3RhbmdsZS54KTtcbiAgICBjb25zdCB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XG4gICAgdGhpcy54ID0geDE7XG4gICAgdGhpcy53aWR0aCA9IHgyIC0geDE7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSB5MiAtIHkxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW0BwaXhpL21hdGg6UmVjdGFuZ2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHdpZHRoPSR7dGhpcy53aWR0aH0gaGVpZ2h0PSR7dGhpcy5oZWlnaHR9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWN0YW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnLi4vY29uc3QubWpzJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4vUmVjdGFuZ2xlLm1qcyc7XG5cbmNsYXNzIENpcmNsZSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB0aGlzLnR5cGUgPSBTSEFQRVMuQ0lSQztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xuICB9XG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy5yYWRpdXMgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByMiA9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG4gICAgbGV0IGR4ID0gdGhpcy54IC0geDtcbiAgICBsZXQgZHkgPSB0aGlzLnkgLSB5O1xuICAgIGR4ICo9IGR4O1xuICAgIGR5ICo9IGR5O1xuICAgIHJldHVybiBkeCArIGR5IDw9IHIyO1xuICB9XG4gIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLnJhZGl1cywgdGhpcy55IC0gdGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOkNpcmNsZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBDaXJjbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNpcmNsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi9SZWN0YW5nbGUubWpzJztcblxuY2xhc3MgRWxsaXBzZSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgaGFsZldpZHRoID0gMCwgaGFsZkhlaWdodCA9IDApIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IGhhbGZXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhhbGZIZWlnaHQ7XG4gICAgdGhpcy50eXBlID0gU0hBUEVTLkVMSVA7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbm9ybXggPSAoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoO1xuICAgIGxldCBub3JteSA9ICh5IC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0O1xuICAgIG5vcm14ICo9IG5vcm14O1xuICAgIG5vcm15ICo9IG5vcm15O1xuICAgIHJldHVybiBub3JteCArIG5vcm15IDw9IDE7XG4gIH1cbiAgZ2V0Qm91bmRzKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMud2lkdGgsIHRoaXMueSAtIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpFbGxpcHNlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHdpZHRoPSR7dGhpcy53aWR0aH0gaGVpZ2h0PSR7dGhpcy5oZWlnaHR9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgRWxsaXBzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWxsaXBzZS5tanMubWFwXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5jbGFzcyBQb2x5Z29uIHtcbiAgY29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG4gICAgbGV0IGZsYXQgPSBBcnJheS5pc0FycmF5KHBvaW50c1swXSkgPyBwb2ludHNbMF0gOiBwb2ludHM7XG4gICAgaWYgKHR5cGVvZiBmbGF0WzBdICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBwID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBmbGF0Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcC5wdXNoKGZsYXRbaV0ueCwgZmxhdFtpXS55KTtcbiAgICAgIH1cbiAgICAgIGZsYXQgPSBwO1xuICAgIH1cbiAgICB0aGlzLnBvaW50cyA9IGZsYXQ7XG4gICAgdGhpcy50eXBlID0gU0hBUEVTLlBPTFk7XG4gICAgdGhpcy5jbG9zZVN0cm9rZSA9IHRydWU7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMuc2xpY2UoKTtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICBwb2x5Z29uLmNsb3NlU3Ryb2tlID0gdGhpcy5jbG9zZVN0cm9rZTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfVxuICBjb250YWlucyh4LCB5KSB7XG4gICAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICBjb25zdCB4aSA9IHRoaXMucG9pbnRzW2kgKiAyXTtcbiAgICAgIGNvbnN0IHlpID0gdGhpcy5wb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIGNvbnN0IHhqID0gdGhpcy5wb2ludHNbaiAqIDJdO1xuICAgICAgY29uc3QgeWogPSB0aGlzLnBvaW50c1tqICogMiArIDFdO1xuICAgICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPiB5ICE9PSB5aiA+IHkgJiYgeCA8ICh4aiAtIHhpKSAqICgoeSAtIHlpKSAvICh5aiAtIHlpKSkgKyB4aTtcbiAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc2lkZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlBvbHlnb25jbG9zZVN0cm9rZT0ke3RoaXMuY2xvc2VTdHJva2V9cG9pbnRzPSR7dGhpcy5wb2ludHMucmVkdWNlKChwb2ludHNEZXNjLCBjdXJyZW50UG9pbnQpID0+IGAke3BvaW50c0Rlc2N9LCAke2N1cnJlbnRQb2ludH1gLCBcIlwiKX1dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBQb2x5Z29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uLm1qcy5tYXBcbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5cbmNsYXNzIFJvdW5kZWRSZWN0YW5nbGUge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCwgcmFkaXVzID0gMjApIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIHRoaXMudHlwZSA9IFNIQVBFUy5SUkVDO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbiAgfVxuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGgpIHtcbiAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmFkaXVzLCBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyKSk7XG4gICAgICAgIGlmICh5ID49IHRoaXMueSArIHJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gcmFkaXVzIHx8IHggPj0gdGhpcy54ICsgcmFkaXVzICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAtIHJhZGl1cykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkeCA9IHggLSAodGhpcy54ICsgcmFkaXVzKTtcbiAgICAgICAgbGV0IGR5ID0geSAtICh0aGlzLnkgKyByYWRpdXMpO1xuICAgICAgICBjb25zdCByYWRpdXMyID0gcmFkaXVzICogcmFkaXVzO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gcmFkaXVzKTtcbiAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlJvdW5kZWRSZWN0YW5nbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX13aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3VuZGVkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IFBJXzIgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQubWpzJztcblxuY2xhc3MgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoYSA9IDEsIGIgPSAwLCBjID0gMCwgZCA9IDEsIHR4ID0gMCwgdHkgPSAwKSB7XG4gICAgdGhpcy5hcnJheSA9IG51bGw7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYyA9IGM7XG4gICAgdGhpcy5kID0gZDtcbiAgICB0aGlzLnR4ID0gdHg7XG4gICAgdGhpcy50eSA9IHR5O1xuICB9XG4gIGZyb21BcnJheShhcnJheSkge1xuICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xuICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgIHRoaXMudHggPSBhcnJheVsyXTtcbiAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG4gIH1cbiAgc2V0KGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy50eCA9IHR4O1xuICAgIHRoaXMudHkgPSB0eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b0FycmF5KHRyYW5zcG9zZSwgb3V0KSB7XG4gICAgaWYgKCF0aGlzLmFycmF5KSB7XG4gICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXkgPSBvdXQgfHwgdGhpcy5hcnJheTtcbiAgICBpZiAodHJhbnNwb3NlKSB7XG4gICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgIGFycmF5WzFdID0gdGhpcy5iO1xuICAgICAgYXJyYXlbMl0gPSAwO1xuICAgICAgYXJyYXlbM10gPSB0aGlzLmM7XG4gICAgICBhcnJheVs0XSA9IHRoaXMuZDtcbiAgICAgIGFycmF5WzVdID0gMDtcbiAgICAgIGFycmF5WzZdID0gdGhpcy50eDtcbiAgICAgIGFycmF5WzddID0gdGhpcy50eTtcbiAgICAgIGFycmF5WzhdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICBhcnJheVsxXSA9IHRoaXMuYztcbiAgICAgIGFycmF5WzJdID0gdGhpcy50eDtcbiAgICAgIGFycmF5WzNdID0gdGhpcy5iO1xuICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICBhcnJheVs1XSA9IHRoaXMudHk7XG4gICAgICBhcnJheVs2XSA9IDA7XG4gICAgICBhcnJheVs3XSA9IDA7XG4gICAgICBhcnJheVs4XSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBhcHBseShwb3MsIG5ld1Bvcykge1xuICAgIG5ld1BvcyA9IG5ld1BvcyB8fCBuZXcgUG9pbnQoKTtcbiAgICBjb25zdCB4ID0gcG9zLng7XG4gICAgY29uc3QgeSA9IHBvcy55O1xuICAgIG5ld1Bvcy54ID0gdGhpcy5hICogeCArIHRoaXMuYyAqIHkgKyB0aGlzLnR4O1xuICAgIG5ld1Bvcy55ID0gdGhpcy5iICogeCArIHRoaXMuZCAqIHkgKyB0aGlzLnR5O1xuICAgIHJldHVybiBuZXdQb3M7XG4gIH1cbiAgYXBwbHlJbnZlcnNlKHBvcywgbmV3UG9zKSB7XG4gICAgbmV3UG9zID0gbmV3UG9zIHx8IG5ldyBQb2ludCgpO1xuICAgIGNvbnN0IGlkID0gMSAvICh0aGlzLmEgKiB0aGlzLmQgKyB0aGlzLmMgKiAtdGhpcy5iKTtcbiAgICBjb25zdCB4ID0gcG9zLng7XG4gICAgY29uc3QgeSA9IHBvcy55O1xuICAgIG5ld1Bvcy54ID0gdGhpcy5kICogaWQgKiB4ICsgLXRoaXMuYyAqIGlkICogeSArICh0aGlzLnR5ICogdGhpcy5jIC0gdGhpcy50eCAqIHRoaXMuZCkgKiBpZDtcbiAgICBuZXdQb3MueSA9IHRoaXMuYSAqIGlkICogeSArIC10aGlzLmIgKiBpZCAqIHggKyAoLXRoaXMudHkgKiB0aGlzLmEgKyB0aGlzLnR4ICogdGhpcy5iKSAqIGlkO1xuICAgIHJldHVybiBuZXdQb3M7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLnR4ICs9IHg7XG4gICAgdGhpcy50eSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNjYWxlKHgsIHkpIHtcbiAgICB0aGlzLmEgKj0geDtcbiAgICB0aGlzLmQgKj0geTtcbiAgICB0aGlzLmMgKj0geDtcbiAgICB0aGlzLmIgKj0geTtcbiAgICB0aGlzLnR4ICo9IHg7XG4gICAgdGhpcy50eSAqPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICB0aGlzLmEgPSBhMSAqIGNvcyAtIHRoaXMuYiAqIHNpbjtcbiAgICB0aGlzLmIgPSBhMSAqIHNpbiArIHRoaXMuYiAqIGNvcztcbiAgICB0aGlzLmMgPSBjMSAqIGNvcyAtIHRoaXMuZCAqIHNpbjtcbiAgICB0aGlzLmQgPSBjMSAqIHNpbiArIHRoaXMuZCAqIGNvcztcbiAgICB0aGlzLnR4ID0gdHgxICogY29zIC0gdGhpcy50eSAqIHNpbjtcbiAgICB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhcHBlbmQobWF0cml4KSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgdGhpcy5hID0gbWF0cml4LmEgKiBhMSArIG1hdHJpeC5iICogYzE7XG4gICAgdGhpcy5iID0gbWF0cml4LmEgKiBiMSArIG1hdHJpeC5iICogZDE7XG4gICAgdGhpcy5jID0gbWF0cml4LmMgKiBhMSArIG1hdHJpeC5kICogYzE7XG4gICAgdGhpcy5kID0gbWF0cml4LmMgKiBiMSArIG1hdHJpeC5kICogZDE7XG4gICAgdGhpcy50eCA9IG1hdHJpeC50eCAqIGExICsgbWF0cml4LnR5ICogYzEgKyB0aGlzLnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRUcmFuc2Zvcm0oeCwgeSwgcGl2b3RYLCBwaXZvdFksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZKSB7XG4gICAgdGhpcy5hID0gTWF0aC5jb3Mocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5jID0gLU1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMuZCA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMudHggPSB4IC0gKHBpdm90WCAqIHRoaXMuYSArIHBpdm90WSAqIHRoaXMuYyk7XG4gICAgdGhpcy50eSA9IHkgLSAocGl2b3RYICogdGhpcy5iICsgcGl2b3RZICogdGhpcy5kKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwcmVwZW5kKG1hdHJpeCkge1xuICAgIGNvbnN0IHR4MSA9IHRoaXMudHg7XG4gICAgaWYgKG1hdHJpeC5hICE9PSAxIHx8IG1hdHJpeC5iICE9PSAwIHx8IG1hdHJpeC5jICE9PSAwIHx8IG1hdHJpeC5kICE9PSAxKSB7XG4gICAgICBjb25zdCBhMSA9IHRoaXMuYTtcbiAgICAgIGNvbnN0IGMxID0gdGhpcy5jO1xuICAgICAgdGhpcy5hID0gYTEgKiBtYXRyaXguYSArIHRoaXMuYiAqIG1hdHJpeC5jO1xuICAgICAgdGhpcy5iID0gYTEgKiBtYXRyaXguYiArIHRoaXMuYiAqIG1hdHJpeC5kO1xuICAgICAgdGhpcy5jID0gYzEgKiBtYXRyaXguYSArIHRoaXMuZCAqIG1hdHJpeC5jO1xuICAgICAgdGhpcy5kID0gYzEgKiBtYXRyaXguYiArIHRoaXMuZCAqIG1hdHJpeC5kO1xuICAgIH1cbiAgICB0aGlzLnR4ID0gdHgxICogbWF0cml4LmEgKyB0aGlzLnR5ICogbWF0cml4LmMgKyBtYXRyaXgudHg7XG4gICAgdGhpcy50eSA9IHR4MSAqIG1hdHJpeC5iICsgdGhpcy50eSAqIG1hdHJpeC5kICsgbWF0cml4LnR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlY29tcG9zZSh0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBhID0gdGhpcy5hO1xuICAgIGNvbnN0IGIgPSB0aGlzLmI7XG4gICAgY29uc3QgYyA9IHRoaXMuYztcbiAgICBjb25zdCBkID0gdGhpcy5kO1xuICAgIGNvbnN0IHBpdm90ID0gdHJhbnNmb3JtLnBpdm90O1xuICAgIGNvbnN0IHNrZXdYID0gLU1hdGguYXRhbjIoLWMsIGQpO1xuICAgIGNvbnN0IHNrZXdZID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgICBjb25zdCBkZWx0YSA9IE1hdGguYWJzKHNrZXdYICsgc2tld1kpO1xuICAgIGlmIChkZWx0YSA8IDFlLTUgfHwgTWF0aC5hYnMoUElfMiAtIGRlbHRhKSA8IDFlLTUpIHtcbiAgICAgIHRyYW5zZm9ybS5yb3RhdGlvbiA9IHNrZXdZO1xuICAgICAgdHJhbnNmb3JtLnNrZXcueCA9IHRyYW5zZm9ybS5za2V3LnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSAwO1xuICAgICAgdHJhbnNmb3JtLnNrZXcueCA9IHNrZXdYO1xuICAgICAgdHJhbnNmb3JtLnNrZXcueSA9IHNrZXdZO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0uc2NhbGUueCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICB0cmFuc2Zvcm0uc2NhbGUueSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb24ueCA9IHRoaXMudHggKyAocGl2b3QueCAqIGEgKyBwaXZvdC55ICogYyk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB0aGlzLnR5ICsgKHBpdm90LnggKiBiICsgcGl2b3QueSAqIGQpO1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH1cbiAgaW52ZXJ0KCkge1xuICAgIGNvbnN0IGExID0gdGhpcy5hO1xuICAgIGNvbnN0IGIxID0gdGhpcy5iO1xuICAgIGNvbnN0IGMxID0gdGhpcy5jO1xuICAgIGNvbnN0IGQxID0gdGhpcy5kO1xuICAgIGNvbnN0IHR4MSA9IHRoaXMudHg7XG4gICAgY29uc3QgbiA9IGExICogZDEgLSBiMSAqIGMxO1xuICAgIHRoaXMuYSA9IGQxIC8gbjtcbiAgICB0aGlzLmIgPSAtYjEgLyBuO1xuICAgIHRoaXMuYyA9IC1jMSAvIG47XG4gICAgdGhpcy5kID0gYTEgLyBuO1xuICAgIHRoaXMudHggPSAoYzEgKiB0aGlzLnR5IC0gZDEgKiB0eDEpIC8gbjtcbiAgICB0aGlzLnR5ID0gLShhMSAqIHRoaXMudHkgLSBiMSAqIHR4MSkgLyBuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlkZW50aXR5KCkge1xuICAgIHRoaXMuYSA9IDE7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmMgPSAwO1xuICAgIHRoaXMuZCA9IDE7XG4gICAgdGhpcy50eCA9IDA7XG4gICAgdGhpcy50eSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIGNvcHlUbyhtYXRyaXgpIHtcbiAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICBtYXRyaXguYyA9IHRoaXMuYztcbiAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgIG1hdHJpeC50eSA9IHRoaXMudHk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuICBjb3B5RnJvbShtYXRyaXgpIHtcbiAgICB0aGlzLmEgPSBtYXRyaXguYTtcbiAgICB0aGlzLmIgPSBtYXRyaXguYjtcbiAgICB0aGlzLmMgPSBtYXRyaXguYztcbiAgICB0aGlzLmQgPSBtYXRyaXguZDtcbiAgICB0aGlzLnR4ID0gbWF0cml4LnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpNYXRyaXggYT0ke3RoaXMuYX0gYj0ke3RoaXMuYn0gYz0ke3RoaXMuY30gZD0ke3RoaXMuZH0gdHg9JHt0aGlzLnR4fSB0eT0ke3RoaXMudHl9XWA7XG4gIH1cbiAgc3RhdGljIGdldCBJREVOVElUWSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xuICB9XG4gIHN0YXRpYyBnZXQgVEVNUF9NQVRSSVgoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBNYXRyaXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdHJpeC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuL01hdHJpeC5tanMnO1xuXG5jb25zdCB1eCA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxXTtcbmNvbnN0IHV5ID0gWzAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdO1xuY29uc3QgdnggPSBbMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV07XG5jb25zdCB2eSA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xXTtcbmNvbnN0IHJvdGF0aW9uQ2F5bGV5ID0gW107XG5jb25zdCByb3RhdGlvbk1hdHJpY2VzID0gW107XG5jb25zdCBzaWdudW0gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBpbml0KCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBbXTtcbiAgICByb3RhdGlvbkNheWxleS5wdXNoKHJvdyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICBjb25zdCBfdXggPSBzaWdudW0odXhbaV0gKiB1eFtqXSArIHZ4W2ldICogdXlbal0pO1xuICAgICAgY29uc3QgX3V5ID0gc2lnbnVtKHV5W2ldICogdXhbal0gKyB2eVtpXSAqIHV5W2pdKTtcbiAgICAgIGNvbnN0IF92eCA9IHNpZ251bSh1eFtpXSAqIHZ4W2pdICsgdnhbaV0gKiB2eVtqXSk7XG4gICAgICBjb25zdCBfdnkgPSBzaWdudW0odXlbaV0gKiB2eFtqXSArIHZ5W2ldICogdnlbal0pO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAxNjsgaysrKSB7XG4gICAgICAgIGlmICh1eFtrXSA9PT0gX3V4ICYmIHV5W2tdID09PSBfdXkgJiYgdnhba10gPT09IF92eCAmJiB2eVtrXSA9PT0gX3Z5KSB7XG4gICAgICAgICAgcm93LnB1c2goayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeCgpO1xuICAgIG1hdC5zZXQodXhbaV0sIHV5W2ldLCB2eFtpXSwgdnlbaV0sIDAsIDApO1xuICAgIHJvdGF0aW9uTWF0cmljZXMucHVzaChtYXQpO1xuICB9XG59XG5pbml0KCk7XG5jb25zdCBncm91cEQ4ID0ge1xuICBFOiAwLFxuICBTRTogMSxcbiAgUzogMixcbiAgU1c6IDMsXG4gIFc6IDQsXG4gIE5XOiA1LFxuICBOOiA2LFxuICBORTogNyxcbiAgTUlSUk9SX1ZFUlRJQ0FMOiA4LFxuICBNQUlOX0RJQUdPTkFMOiAxMCxcbiAgTUlSUk9SX0hPUklaT05UQUw6IDEyLFxuICBSRVZFUlNFX0RJQUdPTkFMOiAxNCxcbiAgdVg6IChpbmQpID0+IHV4W2luZF0sXG4gIHVZOiAoaW5kKSA9PiB1eVtpbmRdLFxuICB2WDogKGluZCkgPT4gdnhbaW5kXSxcbiAgdlk6IChpbmQpID0+IHZ5W2luZF0sXG4gIGludjogKHJvdGF0aW9uKSA9PiB7XG4gICAgaWYgKHJvdGF0aW9uICYgOCkge1xuICAgICAgcmV0dXJuIHJvdGF0aW9uICYgMTU7XG4gICAgfVxuICAgIHJldHVybiAtcm90YXRpb24gJiA3O1xuICB9LFxuICBhZGQ6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdLFxuICBzdWI6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW2dyb3VwRDguaW52KHJvdGF0aW9uRmlyc3QpXSxcbiAgcm90YXRlMTgwOiAocm90YXRpb24pID0+IHJvdGF0aW9uIF4gNCxcbiAgaXNWZXJ0aWNhbDogKHJvdGF0aW9uKSA9PiAocm90YXRpb24gJiAzKSA9PT0gMixcbiAgYnlEaXJlY3Rpb246IChkeCwgZHkpID0+IHtcbiAgICBpZiAoTWF0aC5hYnMoZHgpICogMiA8PSBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGlmIChkeSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBncm91cEQ4LlM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5OO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZHkpICogMiA8PSBNYXRoLmFicyhkeCkpIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cEQ4Llc7XG4gICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguU0U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5TVztcbiAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgcmV0dXJuIGdyb3VwRDguTkU7XG4gICAgfVxuICAgIHJldHVybiBncm91cEQ4Lk5XO1xuICB9LFxuICBtYXRyaXhBcHBlbmRSb3RhdGlvbkludjogKG1hdHJpeCwgcm90YXRpb24sIHR4ID0gMCwgdHkgPSAwKSA9PiB7XG4gICAgY29uc3QgbWF0ID0gcm90YXRpb25NYXRyaWNlc1tncm91cEQ4Lmludihyb3RhdGlvbildO1xuICAgIG1hdC50eCA9IHR4O1xuICAgIG1hdC50eSA9IHR5O1xuICAgIG1hdHJpeC5hcHBlbmQobWF0KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ3JvdXBEOCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXBEOC5tanMubWFwXG4iLCJjbGFzcyBPYnNlcnZhYmxlUG9pbnQge1xuICBjb25zdHJ1Y3RvcihjYiwgc2NvcGUsIHggPSAwLCB5ID0gMCkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIH1cbiAgY2xvbmUoY2IgPSB0aGlzLmNiLCBzY29wZSA9IHRoaXMuc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQb2ludChjYiwgc2NvcGUsIHRoaXMuX3gsIHRoaXMuX3kpO1xuICB9XG4gIHNldCh4ID0gMCwgeSA9IHgpIHtcbiAgICBpZiAodGhpcy5feCAhPT0geCB8fCB0aGlzLl95ICE9PSB5KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5RnJvbShwKSB7XG4gICAgaWYgKHRoaXMuX3ggIT09IHAueCB8fCB0aGlzLl95ICE9PSBwLnkpIHtcbiAgICAgIHRoaXMuX3ggPSBwLng7XG4gICAgICB0aGlzLl95ID0gcC55O1xuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5VG8ocCkge1xuICAgIHAuc2V0KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVxdWFscyhwKSB7XG4gICAgcmV0dXJuIHAueCA9PT0gdGhpcy5feCAmJiBwLnkgPT09IHRoaXMuX3k7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpPYnNlcnZhYmxlUG9pbnQgeD0kezB9IHk9JHswfSBzY29wZT0ke3RoaXMuc2NvcGV9XWA7XG4gIH1cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5feCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH1cbiAgc2V0IHkodmFsdWUpIHtcbiAgICBpZiAodGhpcy5feSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgT2JzZXJ2YWJsZVBvaW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlUG9pbnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi9NYXRyaXgubWpzJztcbmltcG9ydCB7IE9ic2VydmFibGVQb2ludCB9IGZyb20gJy4vT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5cbmNvbnN0IF9UcmFuc2Zvcm0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5sb2NhbFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKTtcbiAgICB0aGlzLnNjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAxLCAxKTtcbiAgICB0aGlzLnBpdm90ID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKTtcbiAgICB0aGlzLnNrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMudXBkYXRlU2tldywgdGhpcywgMCwgMCk7XG4gICAgdGhpcy5fcm90YXRpb24gPSAwO1xuICAgIHRoaXMuX2N4ID0gMTtcbiAgICB0aGlzLl9zeCA9IDA7XG4gICAgdGhpcy5fY3kgPSAwO1xuICAgIHRoaXMuX3N5ID0gMTtcbiAgICB0aGlzLl9sb2NhbElEID0gMDtcbiAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IDA7XG4gICAgdGhpcy5fd29ybGRJRCA9IDA7XG4gICAgdGhpcy5fcGFyZW50SUQgPSAwO1xuICB9XG4gIG9uQ2hhbmdlKCkge1xuICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgfVxuICB1cGRhdGVTa2V3KCkge1xuICAgIHRoaXMuX2N4ID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24gKyB0aGlzLnNrZXcueSk7XG4gICAgdGhpcy5fc3ggPSBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy55KTtcbiAgICB0aGlzLl9jeSA9IC1NYXRoLnNpbih0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy54KTtcbiAgICB0aGlzLl9zeSA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uIC0gdGhpcy5za2V3LngpO1xuICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlRyYW5zZm9ybSBwb3NpdGlvbj0oJHt0aGlzLnBvc2l0aW9uLnh9LCAke3RoaXMucG9zaXRpb24ueX0pIHJvdGF0aW9uPSR7dGhpcy5yb3RhdGlvbn0gc2NhbGU9KCR7dGhpcy5zY2FsZS54fSwgJHt0aGlzLnNjYWxlLnl9KSBza2V3PSgke3RoaXMuc2tldy54fSwgJHt0aGlzLnNrZXcueX0pIF1gO1xuICB9XG4gIHVwZGF0ZUxvY2FsVHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcbiAgICBpZiAodGhpcy5fbG9jYWxJRCAhPT0gdGhpcy5fY3VycmVudExvY2FsSUQpIHtcbiAgICAgIGx0LmEgPSB0aGlzLl9jeCAqIHRoaXMuc2NhbGUueDtcbiAgICAgIGx0LmIgPSB0aGlzLl9zeCAqIHRoaXMuc2NhbGUueDtcbiAgICAgIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUueTtcbiAgICAgIGx0LmQgPSB0aGlzLl9zeSAqIHRoaXMuc2NhbGUueTtcbiAgICAgIGx0LnR4ID0gdGhpcy5wb3NpdGlvbi54IC0gKHRoaXMucGl2b3QueCAqIGx0LmEgKyB0aGlzLnBpdm90LnkgKiBsdC5jKTtcbiAgICAgIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi55IC0gKHRoaXMucGl2b3QueCAqIGx0LmIgKyB0aGlzLnBpdm90LnkgKiBsdC5kKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbElEID0gdGhpcy5fbG9jYWxJRDtcbiAgICAgIHRoaXMuX3BhcmVudElEID0gLTE7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG4gICAgaWYgKHRoaXMuX2xvY2FsSUQgIT09IHRoaXMuX2N1cnJlbnRMb2NhbElEKSB7XG4gICAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLng7XG4gICAgICBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLng7XG4gICAgICBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgICBsdC50eCA9IHRoaXMucG9zaXRpb24ueCAtICh0aGlzLnBpdm90LnggKiBsdC5hICsgdGhpcy5waXZvdC55ICogbHQuYyk7XG4gICAgICBsdC50eSA9IHRoaXMucG9zaXRpb24ueSAtICh0aGlzLnBpdm90LnggKiBsdC5iICsgdGhpcy5waXZvdC55ICogbHQuZCk7XG4gICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IHRoaXMuX2xvY2FsSUQ7XG4gICAgICB0aGlzLl9wYXJlbnRJRCA9IC0xO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFyZW50SUQgIT09IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRCkge1xuICAgICAgY29uc3QgcHQgPSBwYXJlbnRUcmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICBjb25zdCB3dCA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgICB3dC5hID0gbHQuYSAqIHB0LmEgKyBsdC5iICogcHQuYztcbiAgICAgIHd0LmIgPSBsdC5hICogcHQuYiArIGx0LmIgKiBwdC5kO1xuICAgICAgd3QuYyA9IGx0LmMgKiBwdC5hICsgbHQuZCAqIHB0LmM7XG4gICAgICB3dC5kID0gbHQuYyAqIHB0LmIgKyBsdC5kICogcHQuZDtcbiAgICAgIHd0LnR4ID0gbHQudHggKiBwdC5hICsgbHQudHkgKiBwdC5jICsgcHQudHg7XG4gICAgICB3dC50eSA9IGx0LnR4ICogcHQuYiArIGx0LnR5ICogcHQuZCArIHB0LnR5O1xuICAgICAgdGhpcy5fcGFyZW50SUQgPSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgICB0aGlzLl93b3JsZElEKys7XG4gICAgfVxuICB9XG4gIHNldEZyb21NYXRyaXgobWF0cml4KSB7XG4gICAgbWF0cml4LmRlY29tcG9zZSh0aGlzKTtcbiAgICB0aGlzLl9sb2NhbElEKys7XG4gIH1cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgfVxuICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9yb3RhdGlvbiA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVTa2V3KCk7XG4gICAgfVxuICB9XG59O1xubGV0IFRyYW5zZm9ybSA9IF9UcmFuc2Zvcm07XG5UcmFuc2Zvcm0uSURFTlRJVFkgPSBuZXcgX1RyYW5zZm9ybSgpO1xuXG5leHBvcnQgeyBUcmFuc2Zvcm0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zZm9ybS5tanMubWFwXG4iLCJleHBvcnQgeyBDaXJjbGUgfSBmcm9tICcuL3NoYXBlcy9DaXJjbGUubWpzJztcbmV4cG9ydCB7IEVsbGlwc2UgfSBmcm9tICcuL3NoYXBlcy9FbGxpcHNlLm1qcyc7XG5leHBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi9zaGFwZXMvUG9seWdvbi5tanMnO1xuZXhwb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5leHBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5tanMnO1xuZXhwb3J0IHsgZ3JvdXBEOCB9IGZyb20gJy4vZ3JvdXBEOC5tanMnO1xuaW1wb3J0ICcuL0lQb2ludC5tanMnO1xuaW1wb3J0ICcuL0lQb2ludERhdGEubWpzJztcbmV4cG9ydCB7IE1hdHJpeCB9IGZyb20gJy4vTWF0cml4Lm1qcyc7XG5leHBvcnQgeyBPYnNlcnZhYmxlUG9pbnQgfSBmcm9tICcuL09ic2VydmFibGVQb2ludC5tanMnO1xuZXhwb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50Lm1qcyc7XG5leHBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICcuL1RyYW5zZm9ybS5tanMnO1xuZXhwb3J0IHsgREVHX1RPX1JBRCwgUElfMiwgUkFEX1RPX0RFRywgU0hBUEVTIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///363\n')},116:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"tq\": () => (/* reexport */ isMobile_isMobile),\n  \"Xd\": () => (/* reexport */ settings)\n});\n\n// UNUSED EXPORTS: BrowserAdapter\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/adapter.mjs\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\n\n//# sourceMappingURL=adapter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/settings.mjs\n\n\nconst settings = {\n  ADAPTER: BrowserAdapter,\n  RESOLUTION: 1,\n  CREATE_IMAGE_BITMAP: false,\n  ROUND_PIXELS: false\n};\n\n\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/ismobilejs/esm/isMobile.js\nvar appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function (navigator) {\n    return (typeof navigator !== 'undefined' &&\n        navigator.platform === 'MacIntel' &&\n        typeof navigator.maxTouchPoints === 'number' &&\n        navigator.maxTouchPoints > 1 &&\n        typeof MSStream === 'undefined');\n};\nfunction createMatch(userAgent) {\n    return function (regex) { return regex.test(userAgent); };\n}\nfunction isMobile(param) {\n    var nav = {\n        userAgent: '',\n        platform: '',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== 'undefined') {\n        nav = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            maxTouchPoints: navigator.maxTouchPoints || 0\n        };\n    }\n    else if (typeof param === 'string') {\n        nav.userAgent = param;\n    }\n    else if (param && param.userAgent) {\n        nav = {\n            userAgent: param.userAgent,\n            platform: param.platform,\n            maxTouchPoints: param.maxTouchPoints || 0\n        };\n    }\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split('[FBAN');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    tmp = userAgent.split('Twitter');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    var match = createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match(appleIphone) && !match(windowsPhone),\n            ipod: match(appleIpod),\n            tablet: !match(appleIphone) &&\n                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone),\n            universal: match(appleUniversal),\n            device: (match(appleIphone) ||\n                match(appleIpod) ||\n                match(appleTablet) ||\n                match(appleUniversal) ||\n                isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone)\n        },\n        amazon: {\n            phone: match(amazonPhone),\n            tablet: !match(amazonPhone) && match(amazonTablet),\n            device: match(amazonPhone) || match(amazonTablet)\n        },\n        android: {\n            phone: (!match(windowsPhone) && match(amazonPhone)) ||\n                (!match(windowsPhone) && match(androidPhone)),\n            tablet: !match(windowsPhone) &&\n                !match(amazonPhone) &&\n                !match(androidPhone) &&\n                (match(amazonTablet) || match(androidTablet)),\n            device: (!match(windowsPhone) &&\n                (match(amazonPhone) ||\n                    match(amazonTablet) ||\n                    match(androidPhone) ||\n                    match(androidTablet))) ||\n                match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match(windowsPhone),\n            tablet: match(windowsTablet),\n            device: match(windowsPhone) || match(windowsTablet)\n        },\n        other: {\n            blackberry: match(otherBlackBerry),\n            blackberry10: match(otherBlackBerry10),\n            opera: match(otherOpera),\n            firefox: match(otherFirefox),\n            chrome: match(otherChrome),\n            device: match(otherBlackBerry) ||\n                match(otherBlackBerry10) ||\n                match(otherOpera) ||\n                match(otherFirefox) ||\n                match(otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any =\n        result.apple.device ||\n            result.android.device ||\n            result.windows.device ||\n            result.other.device;\n    result.phone =\n        result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet =\n        result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/utils/isMobile.mjs\n\n\nconst isMobileCall = isMobile[\"default\"] ?? isMobile;\nconst isMobile_isMobile = isMobileCall(globalThis.navigator);\n\n\n//# sourceMappingURL=isMobile.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixDQUFDO2dCQUN4QixLQUFLLENBQUMsVUFBVSxDQUFDO2dCQUNqQixLQUFLLENBQUMsWUFBWSxDQUFDO2dCQUNuQixLQUFLLENBQUMsV0FBVyxDQUFDO1NBQ3JCO1FBQ0QsR0FBRyxFQUFFLEtBQUs7UUFDVixLQUFLLEVBQUUsS0FBSztRQUNaLE1BQU0sRUFBRSxLQUFLO0tBQ2QsQ0FBQztJQUVGLE1BQU0sQ0FBQyxHQUFHO1FBQ1IsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNO1lBQ25CLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTTtZQUNyQixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU07WUFDckIsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFFdEIsTUFBTSxDQUFDLEtBQUs7UUFDVixNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUNyRSxNQUFNLENBQUMsTUFBTTtRQUNYLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO0lBRXhFLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7OztBQy9MbUM7O0FBRXBDLHFCQUFxQixtQkFBa0IsSUFBSSxRQUFVO0FBQ3JELE1BQU0saUJBQVE7O0FBRU07QUFDcEI7OztBQ04rQztBQUN4QjtBQUNrQjtBQUNDO0FBQ007QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL2FkYXB0ZXIubWpzP2RmYjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3NldHRpbmdzL2xpYi9zZXR0aW5ncy5tanM/MzFmNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9zcmMvaXNNb2JpbGUudHM/YWE5OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL3V0aWxzL2lzTW9iaWxlLm1qcz8zMGEyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9zZXR0aW5ncy9saWIvaW5kZXgubWpzP2UxYjQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQnJvd3NlckFkYXB0ZXIgPSB7XG4gIGNyZWF0ZUNhbnZhczogKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfSxcbiAgZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiAoKSA9PiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dDogKCkgPT4gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBnZXROYXZpZ2F0b3I6ICgpID0+IG5hdmlnYXRvcixcbiAgZ2V0QmFzZVVybDogKCkgPT4gZG9jdW1lbnQuYmFzZVVSSSA/PyB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgZ2V0Rm9udEZhY2VTZXQ6ICgpID0+IGRvY3VtZW50LmZvbnRzLFxuICBmZXRjaDogKHVybCwgb3B0aW9ucykgPT4gZmV0Y2godXJsLCBvcHRpb25zKSxcbiAgcGFyc2VYTUw6ICh4bWwpID0+IHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCBcInRleHQveG1sXCIpO1xuICB9XG59O1xuXG5leHBvcnQgeyBCcm93c2VyQWRhcHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBCcm93c2VyQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlci5tanMnO1xuXG5jb25zdCBzZXR0aW5ncyA9IHtcbiAgQURBUFRFUjogQnJvd3NlckFkYXB0ZXIsXG4gIFJFU09MVVRJT046IDEsXG4gIENSRUFURV9JTUFHRV9CSVRNQVA6IGZhbHNlLFxuICBST1VORF9QSVhFTFM6IGZhbHNlXG59O1xuXG5leHBvcnQgeyBzZXR0aW5ncyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MubWpzLm1hcFxuIiwiY29uc3QgYXBwbGVJcGhvbmUgPSAvaVBob25lL2k7XG5jb25zdCBhcHBsZUlwb2QgPSAvaVBvZC9pO1xuY29uc3QgYXBwbGVUYWJsZXQgPSAvaVBhZC9pO1xuY29uc3QgYXBwbGVVbml2ZXJzYWwgPSAvXFxiaU9TLXVuaXZlcnNhbCg/Oi4rKU1hY1xcYi9pO1xuY29uc3QgYW5kcm9pZFBob25lID0gL1xcYkFuZHJvaWQoPzouKylNb2JpbGVcXGIvaTsgLy8gTWF0Y2ggJ0FuZHJvaWQnIEFORCAnTW9iaWxlJ1xuY29uc3QgYW5kcm9pZFRhYmxldCA9IC9BbmRyb2lkL2k7XG5jb25zdCBhbWF6b25QaG9uZSA9IC8oPzpTRDQ5MzBVUnxcXGJTaWxrKD86LispTW9iaWxlXFxiKS9pOyAvLyBNYXRjaCAnU2lsaycgQU5EICdNb2JpbGUnXG5jb25zdCBhbWF6b25UYWJsZXQgPSAvU2lsay9pO1xuY29uc3Qgd2luZG93c1Bob25lID0gL1dpbmRvd3MgUGhvbmUvaTtcbmNvbnN0IHdpbmRvd3NUYWJsZXQgPSAvXFxiV2luZG93cyg/Oi4rKUFSTVxcYi9pOyAvLyBNYXRjaCAnV2luZG93cycgQU5EICdBUk0nXG5jb25zdCBvdGhlckJsYWNrQmVycnkgPSAvQmxhY2tCZXJyeS9pO1xuY29uc3Qgb3RoZXJCbGFja0JlcnJ5MTAgPSAvQkIxMC9pO1xuY29uc3Qgb3RoZXJPcGVyYSA9IC9PcGVyYSBNaW5pL2k7XG5jb25zdCBvdGhlckNocm9tZSA9IC9cXGIoQ3JpT1N8Q2hyb21lKSg/Oi4rKU1vYmlsZS9pO1xuY29uc3Qgb3RoZXJGaXJlZm94ID0gL01vYmlsZSg/Oi4rKUZpcmVmb3hcXGIvaTsgLy8gTWF0Y2ggJ01vYmlsZScgQU5EICdGaXJlZm94J1xuXG5leHBvcnQgdHlwZSBVc2VyQWdlbnQgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBOYXZpZ2F0b3IgPSB7XG4gIHVzZXJBZ2VudDogc3RyaW5nO1xuICBwbGF0Zm9ybTogc3RyaW5nO1xuICBtYXhUb3VjaFBvaW50cz86IG51bWJlcjtcbn07XG5cbmNvbnN0IGlzQXBwbGVUYWJsZXRPbklvczEzID0gKG5hdmlnYXRvcj86IE5hdmlnYXRvcik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnTWFjSW50ZWwnICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA9PT0gJ251bWJlcicgJiZcbiAgICBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxICYmXG4gICAgdHlwZW9mIE1TU3RyZWFtID09PSAndW5kZWZpbmVkJ1xuICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2godXNlckFnZW50OiBVc2VyQWdlbnQpOiAocmVnZXg6IFJlZ0V4cCkgPT4gYm9vbGVhbiB7XG4gIHJldHVybiAocmVnZXg6IFJlZ0V4cCk6IGJvb2xlYW4gPT4gcmVnZXgudGVzdCh1c2VyQWdlbnQpO1xufVxuXG5leHBvcnQgdHlwZSBpc01vYmlsZVJlc3VsdCA9IHtcbiAgYXBwbGU6IHtcbiAgICBwaG9uZTogYm9vbGVhbjtcbiAgICBpcG9kOiBib29sZWFuO1xuICAgIHRhYmxldDogYm9vbGVhbjtcbiAgICB1bml2ZXJzYWw6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBhbWF6b246IHtcbiAgICBwaG9uZTogYm9vbGVhbjtcbiAgICB0YWJsZXQ6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBhbmRyb2lkOiB7XG4gICAgcGhvbmU6IGJvb2xlYW47XG4gICAgdGFibGV0OiBib29sZWFuO1xuICAgIGRldmljZTogYm9vbGVhbjtcbiAgfTtcbiAgd2luZG93czoge1xuICAgIHBob25lOiBib29sZWFuO1xuICAgIHRhYmxldDogYm9vbGVhbjtcbiAgICBkZXZpY2U6IGJvb2xlYW47XG4gIH07XG4gIG90aGVyOiB7XG4gICAgYmxhY2tiZXJyeTogYm9vbGVhbjtcbiAgICBibGFja2JlcnJ5MTA6IGJvb2xlYW47XG4gICAgb3BlcmE6IGJvb2xlYW47XG4gICAgZmlyZWZveDogYm9vbGVhbjtcbiAgICBjaHJvbWU6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBwaG9uZTogYm9vbGVhbjtcbiAgdGFibGV0OiBib29sZWFuO1xuICBhbnk6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBJc01vYmlsZVBhcmFtZXRlciA9IFVzZXJBZ2VudCB8IE5hdmlnYXRvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNb2JpbGUocGFyYW0/OiBJc01vYmlsZVBhcmFtZXRlcik6IGlzTW9iaWxlUmVzdWx0IHtcbiAgbGV0IG5hdjogTmF2aWdhdG9yID0ge1xuICAgIHVzZXJBZ2VudDogJycsXG4gICAgcGxhdGZvcm06ICcnLFxuICAgIG1heFRvdWNoUG9pbnRzOiAwLFxuICB9O1xuXG4gIGlmICghcGFyYW0gJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYXYgPSB7XG4gICAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBwbGF0Zm9ybTogbmF2aWdhdG9yLnBsYXRmb3JtLFxuICAgICAgbWF4VG91Y2hQb2ludHM6IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAwLFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIG5hdi51c2VyQWdlbnQgPSBwYXJhbTtcbiAgfSBlbHNlIGlmIChwYXJhbSAmJiBwYXJhbS51c2VyQWdlbnQpIHtcbiAgICBuYXYgPSB7XG4gICAgICB1c2VyQWdlbnQ6IHBhcmFtLnVzZXJBZ2VudCxcbiAgICAgIHBsYXRmb3JtOiBwYXJhbS5wbGF0Zm9ybSxcbiAgICAgIG1heFRvdWNoUG9pbnRzOiBwYXJhbS5tYXhUb3VjaFBvaW50cyB8fCAwLFxuICAgIH07XG4gIH1cblxuICBsZXQgdXNlckFnZW50ID0gbmF2LnVzZXJBZ2VudDtcblxuICAvLyBGYWNlYm9vayBtb2JpbGUgYXBwJ3MgaW50ZWdyYXRlZCBicm93c2VyIGFkZHMgYSBidW5jaCBvZiBzdHJpbmdzIHRoYXRcbiAgLy8gbWF0Y2ggZXZlcnl0aGluZy4gU3RyaXAgaXQgb3V0IGlmIGl0IGV4aXN0cy5cbiAgbGV0IHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnW0ZCQU4nKTtcbiAgaWYgKHR5cGVvZiB0bXBbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdXNlckFnZW50ID0gdG1wWzBdO1xuICB9XG5cbiAgLy8gVHdpdHRlciBtb2JpbGUgYXBwJ3MgaW50ZWdyYXRlZCBicm93c2VyIG9uIGlQYWQgYWRkcyBhIFwiVHdpdHRlciBmb3JcbiAgLy8gaVBob25lXCIgc3RyaW5nLiBTYW1lIHByb2JhYmx5IGhhcHBlbnMgb24gb3RoZXIgdGFibGV0IHBsYXRmb3Jtcy5cbiAgLy8gVGhpcyB3aWxsIGNvbmZ1c2UgZGV0ZWN0aW9uIHNvIHN0cmlwIGl0IG91dCBpZiBpdCBleGlzdHMuXG4gIHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnVHdpdHRlcicpO1xuICBpZiAodHlwZW9mIHRtcFsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB1c2VyQWdlbnQgPSB0bXBbMF07XG4gIH1cblxuICBjb25zdCBtYXRjaCA9IGNyZWF0ZU1hdGNoKHVzZXJBZ2VudCk7XG5cbiAgY29uc3QgcmVzdWx0OiBpc01vYmlsZVJlc3VsdCA9IHtcbiAgICBhcHBsZToge1xuICAgICAgcGhvbmU6IG1hdGNoKGFwcGxlSXBob25lKSAmJiAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgIGlwb2Q6IG1hdGNoKGFwcGxlSXBvZCksXG4gICAgICB0YWJsZXQ6XG4gICAgICAgICFtYXRjaChhcHBsZUlwaG9uZSkgJiZcbiAgICAgICAgKG1hdGNoKGFwcGxlVGFibGV0KSB8fCBpc0FwcGxlVGFibGV0T25Jb3MxMyhuYXYpKSAmJlxuICAgICAgICAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgIHVuaXZlcnNhbDogbWF0Y2goYXBwbGVVbml2ZXJzYWwpLFxuICAgICAgZGV2aWNlOlxuICAgICAgICAobWF0Y2goYXBwbGVJcGhvbmUpIHx8XG4gICAgICAgICAgbWF0Y2goYXBwbGVJcG9kKSB8fFxuICAgICAgICAgIG1hdGNoKGFwcGxlVGFibGV0KSB8fFxuICAgICAgICAgIG1hdGNoKGFwcGxlVW5pdmVyc2FsKSB8fFxuICAgICAgICAgIGlzQXBwbGVUYWJsZXRPbklvczEzKG5hdikpICYmXG4gICAgICAgICFtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgIH0sXG4gICAgYW1hem9uOiB7XG4gICAgICBwaG9uZTogbWF0Y2goYW1hem9uUGhvbmUpLFxuICAgICAgdGFibGV0OiAhbWF0Y2goYW1hem9uUGhvbmUpICYmIG1hdGNoKGFtYXpvblRhYmxldCksXG4gICAgICBkZXZpY2U6IG1hdGNoKGFtYXpvblBob25lKSB8fCBtYXRjaChhbWF6b25UYWJsZXQpLFxuICAgIH0sXG4gICAgYW5kcm9pZDoge1xuICAgICAgcGhvbmU6XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbWF6b25QaG9uZSkpIHx8XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbmRyb2lkUGhvbmUpKSxcbiAgICAgIHRhYmxldDpcbiAgICAgICAgIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiZcbiAgICAgICAgIW1hdGNoKGFtYXpvblBob25lKSAmJlxuICAgICAgICAhbWF0Y2goYW5kcm9pZFBob25lKSAmJlxuICAgICAgICAobWF0Y2goYW1hem9uVGFibGV0KSB8fCBtYXRjaChhbmRyb2lkVGFibGV0KSksXG4gICAgICBkZXZpY2U6XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJlxuICAgICAgICAgIChtYXRjaChhbWF6b25QaG9uZSkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFtYXpvblRhYmxldCkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRQaG9uZSkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRUYWJsZXQpKSkgfHxcbiAgICAgICAgbWF0Y2goL1xcYm9raHR0cFxcYi9pKSxcbiAgICB9LFxuICAgIHdpbmRvd3M6IHtcbiAgICAgIHBob25lOiBtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgdGFibGV0OiBtYXRjaCh3aW5kb3dzVGFibGV0KSxcbiAgICAgIGRldmljZTogbWF0Y2god2luZG93c1Bob25lKSB8fCBtYXRjaCh3aW5kb3dzVGFibGV0KSxcbiAgICB9LFxuICAgIG90aGVyOiB7XG4gICAgICBibGFja2JlcnJ5OiBtYXRjaChvdGhlckJsYWNrQmVycnkpLFxuICAgICAgYmxhY2tiZXJyeTEwOiBtYXRjaChvdGhlckJsYWNrQmVycnkxMCksXG4gICAgICBvcGVyYTogbWF0Y2gob3RoZXJPcGVyYSksXG4gICAgICBmaXJlZm94OiBtYXRjaChvdGhlckZpcmVmb3gpLFxuICAgICAgY2hyb21lOiBtYXRjaChvdGhlckNocm9tZSksXG4gICAgICBkZXZpY2U6XG4gICAgICAgIG1hdGNoKG90aGVyQmxhY2tCZXJyeSkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJCbGFja0JlcnJ5MTApIHx8XG4gICAgICAgIG1hdGNoKG90aGVyT3BlcmEpIHx8XG4gICAgICAgIG1hdGNoKG90aGVyRmlyZWZveCkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJDaHJvbWUpLFxuICAgIH0sXG4gICAgYW55OiBmYWxzZSxcbiAgICBwaG9uZTogZmFsc2UsXG4gICAgdGFibGV0OiBmYWxzZSxcbiAgfTtcblxuICByZXN1bHQuYW55ID1cbiAgICByZXN1bHQuYXBwbGUuZGV2aWNlIHx8XG4gICAgcmVzdWx0LmFuZHJvaWQuZGV2aWNlIHx8XG4gICAgcmVzdWx0LndpbmRvd3MuZGV2aWNlIHx8XG4gICAgcmVzdWx0Lm90aGVyLmRldmljZTtcbiAgLy8gZXhjbHVkZXMgJ290aGVyJyBkZXZpY2VzIGFuZCBpcG9kcywgdGFyZ2V0aW5nIHRvdWNoc2NyZWVuIHBob25lc1xuICByZXN1bHQucGhvbmUgPVxuICAgIHJlc3VsdC5hcHBsZS5waG9uZSB8fCByZXN1bHQuYW5kcm9pZC5waG9uZSB8fCByZXN1bHQud2luZG93cy5waG9uZTtcbiAgcmVzdWx0LnRhYmxldCA9XG4gICAgcmVzdWx0LmFwcGxlLnRhYmxldCB8fCByZXN1bHQuYW5kcm9pZC50YWJsZXQgfHwgcmVzdWx0LndpbmRvd3MudGFibGV0O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgaXNNb2JpbGVKcyBmcm9tICdpc21vYmlsZWpzJztcblxuY29uc3QgaXNNb2JpbGVDYWxsID0gaXNNb2JpbGVKcy5kZWZhdWx0ID8/IGlzTW9iaWxlSnM7XG5jb25zdCBpc01vYmlsZSA9IGlzTW9iaWxlQ2FsbChnbG9iYWxUaGlzLm5hdmlnYXRvcik7XG5cbmV4cG9ydCB7IGlzTW9iaWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc01vYmlsZS5tanMubWFwXG4iLCJleHBvcnQgeyBCcm93c2VyQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlci5tanMnO1xuaW1wb3J0ICcuL0lDYW52YXMubWpzJztcbmltcG9ydCAnLi9JQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELm1qcyc7XG5leHBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJy4vc2V0dGluZ3MubWpzJztcbmV4cG9ydCB7IGlzTW9iaWxlIH0gZnJvbSAnLi91dGlscy9pc01vYmlsZS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///116\n")},441:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "BaseTextureCache": () => (/* reexport */ BaseTextureCache),\n  "BoundingBox": () => (/* reexport */ BoundingBox),\n  "CanvasRenderTarget": () => (/* reexport */ CanvasRenderTarget),\n  "DATA_URI": () => (/* reexport */ DATA_URI),\n  "EventEmitter": () => (/* reexport */ eventemitter3),\n  "ProgramCache": () => (/* reexport */ ProgramCache),\n  "TextureCache": () => (/* reexport */ TextureCache),\n  "clearTextureCache": () => (/* reexport */ clearTextureCache),\n  "correctBlendMode": () => (/* reexport */ correctBlendMode),\n  "createIndicesForQuads": () => (/* reexport */ createIndicesForQuads),\n  "decomposeDataUri": () => (/* reexport */ decomposeDataUri),\n  "deprecation": () => (/* reexport */ deprecation),\n  "destroyTextureCache": () => (/* reexport */ destroyTextureCache),\n  "determineCrossOrigin": () => (/* reexport */ determineCrossOrigin),\n  "earcut": () => (/* reexport */ earcut),\n  "getBufferType": () => (/* reexport */ getBufferType),\n  "getCanvasBoundingBox": () => (/* reexport */ getCanvasBoundingBox),\n  "getResolutionOfUrl": () => (/* reexport */ getResolutionOfUrl),\n  "hex2rgb": () => (/* reexport */ hex2rgb),\n  "hex2string": () => (/* reexport */ hex2string),\n  "interleaveTypedArrays": () => (/* reexport */ interleaveTypedArrays),\n  "isMobile": () => (/* reexport */ lib/* isMobile */.tq),\n  "isPow2": () => (/* reexport */ isPow2),\n  "isWebGLSupported": () => (/* reexport */ isWebGLSupported),\n  "log2": () => (/* reexport */ log2),\n  "nextPow2": () => (/* reexport */ nextPow2),\n  "path": () => (/* reexport */ path),\n  "premultiplyBlendMode": () => (/* reexport */ premultiplyBlendMode),\n  "premultiplyRgba": () => (/* reexport */ premultiplyRgba),\n  "premultiplyTint": () => (/* reexport */ premultiplyTint),\n  "premultiplyTintToRgba": () => (/* reexport */ premultiplyTintToRgba),\n  "removeItems": () => (/* reexport */ removeItems),\n  "rgb2hex": () => (/* reexport */ rgb2hex),\n  "sayHello": () => (/* reexport */ sayHello),\n  "sign": () => (/* reexport */ sign),\n  "skipHello": () => (/* reexport */ skipHello),\n  "string2hex": () => (/* reexport */ string2hex),\n  "trimCanvas": () => (/* reexport */ trimCanvas),\n  "uid": () => (/* reexport */ uid),\n  "url": () => (/* reexport */ url_url)\n});\n\n// EXTERNAL MODULE: ./node_modules/@pixi/settings/lib/index.mjs + 4 modules\nvar lib = __webpack_require__(116);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/settings.mjs\n\n\n\nlib/* settings.RETINA_PREFIX */.Xd.RETINA_PREFIX = /@([0-9\\.]+)x/;\nlib/* settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT */.Xd.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;\n//# sourceMappingURL=settings.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.js\nvar eventemitter3 = __webpack_require__(34);\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n// EXTERNAL MODULE: ./node_modules/url/url.js\nvar url = __webpack_require__(44);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/url.mjs\n\n\nconst url_url = {\n  parse: url/* parse */.Qc,\n  format: url/* format */.WU,\n  resolve: url/* resolve */.DB\n};\n\n\n//# sourceMappingURL=url.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/path.mjs\n\n\nfunction assertPath(path2) {\n  if (typeof path2 !== "string") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split("?")[0];\n  return re.split("#")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = "";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf("/");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = "";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = "";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += "/..";\n          } else {\n            res = "..";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  toPosix(path2) {\n    return replaceAll(path2, "\\\\", "/");\n  },\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&\',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  hasProtocol(path2) {\n    return /^[^/:]+:\\//.test(this.toPosix(path2));\n  },\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let protocol = "";\n    const isFile = /^file:\\/\\/\\//.exec(path2);\n    const isHttp = /^[^/:]+:\\/\\//.exec(path2);\n    const isWindows = /^[^/:]+:\\//.exec(path2);\n    if (isFile || isHttp || isWindows) {\n      const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];\n      protocol = arr;\n      path2 = path2.slice(arr.length);\n    }\n    return protocol;\n  },\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    if (this.isDataUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? lib/* settings.ADAPTER.getBaseUrl */.Xd.ADAPTER.getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    assertPath(url);\n    url = this.toPosix(url);\n    if (url.startsWith("/")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  normalize(path2) {\n    path2 = this.toPosix(path2);\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    let protocol = "";\n    const isAbsolute = path2.startsWith("/");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith("/");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += "/";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith("/");\n  },\n  join(...segments) {\n    if (segments.length === 0) {\n      return ".";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? "";\n          if (this.extname(prevArg)) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return ".";\n    }\n    return this.normalize(joined);\n  },\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return "//";\n    return proto + path2.slice(0, end);\n  },\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = "";\n    if (path2.startsWith("/"))\n      root = "/";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf("/", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith("/"))\n        root += "/";\n    }\n    return root;\n  },\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return "";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return "";\n    return path2.slice(start, end);\n  },\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return "";\n    }\n    return path2.slice(startDot, end);\n  },\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: "", dir: "", base: "", ext: "", name: "" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = "";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: "/",\n  delimiter: ":"\n};\n\n\n//# sourceMappingURL=path.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/logging/deprecation.mjs\nconst warnings = {};\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === "undefined") {\n    console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split("\\n").splice(ignoreDepth).join("\\n");\n    if (console.groupCollapsed) {\n      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\n\n//# sourceMappingURL=deprecation.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/hello.mjs\n\n\nfunction skipHello() {\n  deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");\n}\nfunction sayHello() {\n  deprecation("7.0.0", `sayHello is deprecated, please use Renderer\'s "hello" option`);\n}\n\n\n//# sourceMappingURL=hello.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs\n\n\n\nlet supported;\nfunction isWebGLSupported() {\n  if (typeof supported === "undefined") {\n    supported = function supported2() {\n      const contextOptions = {\n        stencil: true,\n        failIfMajorPerformanceCaveat: lib/* settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT */.Xd.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n      };\n      try {\n        if (!lib/* settings.ADAPTER.getWebGLRenderingContext */.Xd.ADAPTER.getWebGLRenderingContext()) {\n          return false;\n        }\n        const canvas = lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);\n        const success = !!gl?.getContextAttributes()?.stencil;\n        if (gl) {\n          const loseContext = gl.getExtension("WEBGL_lose_context");\n          if (loseContext) {\n            loseContext.loseContext();\n          }\n        }\n        gl = null;\n        return success;\n      } catch (e) {\n        return false;\n      }\n    }();\n  }\n  return supported;\n}\n\n\n//# sourceMappingURL=isWebGLSupported.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/@pixi/color/lib/index.mjs + 3 modules\nvar color_lib = __webpack_require__(126);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/color/hex.mjs\n\n\n\nfunction hex2rgb(hex, out = []) {\n  deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");\n  return color_lib/* Color.shared.setValue */.I.shared.setValue(hex).toRgbArray(out);\n}\nfunction hex2string(hex) {\n  deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");\n  return color_lib/* Color.shared.setValue */.I.shared.setValue(hex).toHex();\n}\nfunction string2hex(string) {\n  deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");\n  return color_lib/* Color.shared.setValue */.I.shared.setValue(string).toNumber();\n}\nfunction rgb2hex(rgb) {\n  deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");\n  return color_lib/* Color.shared.setValue */.I.shared.setValue(rgb).toNumber();\n}\n\n\n//# sourceMappingURL=hex.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/@pixi/constants/lib/index.mjs\nvar constants_lib = __webpack_require__(361);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/color/premultiply.mjs\n\n\n\n\nfunction mapPremultipliedBlendModes() {\n  const pm = [];\n  const npm = [];\n  for (let i = 0; i < 32; i++) {\n    pm[i] = i;\n    npm[i] = i;\n  }\n  pm[constants_lib/* BLEND_MODES.NORMAL_NPM */.T$.NORMAL_NPM] = constants_lib/* BLEND_MODES.NORMAL */.T$.NORMAL;\n  pm[constants_lib/* BLEND_MODES.ADD_NPM */.T$.ADD_NPM] = constants_lib/* BLEND_MODES.ADD */.T$.ADD;\n  pm[constants_lib/* BLEND_MODES.SCREEN_NPM */.T$.SCREEN_NPM] = constants_lib/* BLEND_MODES.SCREEN */.T$.SCREEN;\n  npm[constants_lib/* BLEND_MODES.NORMAL */.T$.NORMAL] = constants_lib/* BLEND_MODES.NORMAL_NPM */.T$.NORMAL_NPM;\n  npm[constants_lib/* BLEND_MODES.ADD */.T$.ADD] = constants_lib/* BLEND_MODES.ADD_NPM */.T$.ADD_NPM;\n  npm[constants_lib/* BLEND_MODES.SCREEN */.T$.SCREEN] = constants_lib/* BLEND_MODES.SCREEN_NPM */.T$.SCREEN_NPM;\n  const array = [];\n  array.push(npm);\n  array.push(pm);\n  return array;\n}\nconst premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(blendMode, premultiplied) {\n  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\nfunction premultiplyRgba(rgb, alpha, out, premultiply = true) {\n  deprecation("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);\n  return color_lib/* Color.shared.setValue */.I.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));\n}\nfunction premultiplyTint(tint, alpha) {\n  deprecation("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);\n  return color_lib/* Color.shared.setValue */.I.shared.setValue(tint).toPremultiplied(alpha);\n}\nfunction premultiplyTintToRgba(tint, alpha, out, premultiply = true) {\n  deprecation("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);\n  return color_lib/* Color.shared.setValue */.I.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));\n}\n\n\n//# sourceMappingURL=premultiply.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/const.mjs\nconst DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  outBuffer = outBuffer || new Uint16Array(totalIndices);\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\n\n//# sourceMappingURL=createIndicesForQuads.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/getBufferType.mjs\nfunction getBufferType(array) {\n  if (array.BYTES_PER_ELEMENT === 4) {\n    if (array instanceof Float32Array) {\n      return "Float32Array";\n    } else if (array instanceof Uint32Array) {\n      return "Uint32Array";\n    }\n    return "Int32Array";\n  } else if (array.BYTES_PER_ELEMENT === 2) {\n    if (array instanceof Uint16Array) {\n      return "Uint16Array";\n    }\n  } else if (array.BYTES_PER_ELEMENT === 1) {\n    if (array instanceof Uint8Array) {\n      return "Uint8Array";\n    }\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=getBufferType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs\n\n\nconst map = { Float32Array, Uint32Array, Int32Array, Uint8Array };\nfunction interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0;\n  let stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++) {\n    stride += sizes[i];\n    outSize += arrays[i].length;\n  }\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null;\n  let littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i];\n    const array = arrays[i];\n    const type = getBufferType(array);\n    if (!views[type]) {\n      views[type] = new map[type](buffer);\n    }\n    out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset;\n      const index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\n\n\n//# sourceMappingURL=interleaveTypedArrays.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/pow2.mjs\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\n\n//# sourceMappingURL=pow2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/removeItems.mjs\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\n\n//# sourceMappingURL=removeItems.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/sign.mjs\nfunction sign(n) {\n  if (n === 0)\n    return 0;\n  return n < 0 ? -1 : 1;\n}\n\n\n//# sourceMappingURL=sign.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/uid.mjs\nlet nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\n\n\n//# sourceMappingURL=uid.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/BoundingBox.mjs\nconst _BoundingBox = class {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n  get width() {\n    return this.right - this.left;\n  }\n  get height() {\n    return this.bottom - this.top;\n  }\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n};\nlet BoundingBox = _BoundingBox;\nBoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);\n\n\n//# sourceMappingURL=BoundingBox.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/caches.mjs\nconst ProgramCache = {};\nconst TextureCache = /* @__PURE__ */ Object.create(null);\nconst BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction destroyTextureCache() {\n  let key;\n  for (key in TextureCache) {\n    TextureCache[key].destroy();\n  }\n  for (key in BaseTextureCache) {\n    BaseTextureCache[key].destroy();\n  }\n}\nfunction clearTextureCache() {\n  let key;\n  for (key in TextureCache) {\n    delete TextureCache[key];\n  }\n  for (key in BaseTextureCache) {\n    delete BaseTextureCache[key];\n  }\n}\n\n\n//# sourceMappingURL=caches.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs\n\n\nclass CanvasRenderTarget {\n  constructor(width, height, resolution) {\n    this._canvas = lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n    this._context = this._canvas.getContext("2d");\n    this.resolution = resolution || lib/* settings.RESOLUTION */.Xd.RESOLUTION;\n    this.resize(width, height);\n  }\n  clear() {\n    this._checkDestroyed();\n    this._context.setTransform(1, 0, 0, 1, 0, 0);\n    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\n  }\n  resize(desiredWidth, desiredHeight) {\n    this._checkDestroyed();\n    this._canvas.width = Math.round(desiredWidth * this.resolution);\n    this._canvas.height = Math.round(desiredHeight * this.resolution);\n  }\n  destroy() {\n    this._context = null;\n    this._canvas = null;\n  }\n  get width() {\n    this._checkDestroyed();\n    return this._canvas.width;\n  }\n  set width(val) {\n    this._checkDestroyed();\n    this._canvas.width = Math.round(val);\n  }\n  get height() {\n    this._checkDestroyed();\n    return this._canvas.height;\n  }\n  set height(val) {\n    this._checkDestroyed();\n    this._canvas.height = Math.round(val);\n  }\n  get canvas() {\n    this._checkDestroyed();\n    return this._canvas;\n  }\n  get context() {\n    this._checkDestroyed();\n    return this._context;\n  }\n  _checkDestroyed() {\n    if (this._canvas === null) {\n      throw new TypeError("The CanvasRenderTarget has already been destroyed");\n    }\n  }\n}\n\n\n//# sourceMappingURL=CanvasRenderTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs\n\n\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas) {\n  const { width, height } = canvas;\n  const context = canvas.getContext("2d", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError("Failed to get canvas 2D context");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return BoundingBox.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new BoundingBox(left, top, right, bottom);\n}\n\n\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/trimCanvas.mjs\n\n\nfunction trimCanvas(canvas) {\n  const boundingBox = getCanvasBoundingBox(canvas);\n  const { width, height } = boundingBox;\n  let data = null;\n  if (!boundingBox.isEmpty()) {\n    const context = canvas.getContext("2d");\n    if (context === null) {\n      throw new TypeError("Failed to get canvas 2D context");\n    }\n    data = context.getImageData(boundingBox.left, boundingBox.top, width, height);\n  }\n  return { width, height, data };\n}\n\n\n//# sourceMappingURL=trimCanvas.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs\n\n\nfunction decomposeDataUri(dataUri) {\n  const dataUriMatch = DATA_URI.exec(dataUri);\n  if (dataUriMatch) {\n    return {\n      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,\n      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,\n      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,\n      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,\n      data: dataUriMatch[5]\n    };\n  }\n  return void 0;\n}\n\n\n//# sourceMappingURL=decomposeDataUri.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs\n\n\nlet tempAnchor;\nfunction determineCrossOrigin(url$1, loc = globalThis.location) {\n  if (url$1.startsWith("data:")) {\n    return "";\n  }\n  loc = loc || globalThis.location;\n  if (!tempAnchor) {\n    tempAnchor = document.createElement("a");\n  }\n  tempAnchor.href = url$1;\n  const parsedUrl = url_url.parse(tempAnchor.href);\n  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;\n  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {\n    return "anonymous";\n  }\n  return "";\n}\n\n\n//# sourceMappingURL=determineCrossOrigin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs\n\n\n\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = lib/* settings.RETINA_PREFIX */.Xd.RETINA_PREFIX?.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue;\n}\n\n\n//# sourceMappingURL=getResolutionOfUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7O0FBRWdDO0FBQ2hDOzs7QUMvQ2tFOztBQUVsRTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFc0I7QUFDdEI7OztBQ2pCd0M7O0FBRXhDO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEI7QUFDNUI7OztBQ2pCaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQztBQUNoQzs7O0FDckJ5QjtBQUNpQjs7QUFFMUM7QUFDQSxxQkFBcUIsZ0RBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCO0FBQzlCOzs7QUNad0I7QUFDa0I7QUFDYztBQUNiO0FBQ1g7QUFDRTtBQUN3QjtBQUNRO0FBQ1M7QUFDK0Q7QUFDbkc7QUFDa0M7QUFDaEI7QUFDZ0I7QUFDaEI7QUFDSjtBQUNkO0FBQ0Y7QUFDbUI7QUFDRjtBQUNvRTtBQUN0RDtBQUNJO0FBQ3BCO0FBQ2M7QUFDUTtBQUNKO0FBQzNDO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9zZXR0aW5ncy5tanM/MWE2YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL3VybC5tanM/ZDVkOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL3BhdGgubWpzPzNjOWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcz81YmI3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvYnJvd3Nlci9oZWxsby5tanM/MjhmMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2Jyb3dzZXIvaXNXZWJHTFN1cHBvcnRlZC5tanM/YTJiNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2NvbG9yL2hleC5tanM/ZjVmNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2NvbG9yL3ByZW11bHRpcGx5Lm1qcz9iYmQ5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvY29uc3QubWpzPzAzOGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9kYXRhL2NyZWF0ZUluZGljZXNGb3JRdWFkcy5tanM/YjE4MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvZ2V0QnVmZmVyVHlwZS5tanM/MmIyNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvaW50ZXJsZWF2ZVR5cGVkQXJyYXlzLm1qcz8yNWEyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9wb3cyLm1qcz82MTAzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9yZW1vdmVJdGVtcy5tanM/ZTljOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvc2lnbi5tanM/NmJmNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvdWlkLm1qcz9hNDM0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbWVkaWEvQm91bmRpbmdCb3gubWpzP2UxMzgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS9jYWNoZXMubWpzPzg1OTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS9DYW52YXNSZW5kZXJUYXJnZXQubWpzP2QxZTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS9nZXRDYW52YXNCb3VuZGluZ0JveC5tanM/NmM5OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL21lZGlhL3RyaW1DYW52YXMubWpzPzRmOGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9uZXR3b3JrL2RlY29tcG9zZURhdGFVcmkubWpzPzA4OWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9uZXR3b3JrL2RldGVybWluZUNyb3NzT3JpZ2luLm1qcz9jNGFlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbmV0d29yay9nZXRSZXNvbHV0aW9uT2ZVcmwubWpzP2ExNGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9pbmRleC5tanM/ZjgyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmV4cG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuXG5zZXR0aW5ncy5SRVRJTkFfUFJFRklYID0gL0AoWzAtOVxcLl0rKXgvO1xuc2V0dGluZ3MuRkFJTF9JRl9NQUpPUl9QRVJGT1JNQU5DRV9DQVZFQVQgPSBmYWxzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLm1qcy5tYXBcbiIsImltcG9ydCB7IHBhcnNlLCBmb3JtYXQsIHJlc29sdmUgfSBmcm9tICd1cmwnO1xuXG5jb25zdCB1cmwgPSB7XG4gIHBhcnNlOiBwYXJzZSxcbiAgZm9ybWF0OiBmb3JtYXQsXG4gIHJlc29sdmU6IHJlc29sdmVcbn07XG5cbmV4cG9ydCB7IHVybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgyKSB7XG4gIGlmICh0eXBlb2YgcGF0aDIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkocGF0aDIpfWApO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVVcmxQYXJhbXModXJsKSB7XG4gIGNvbnN0IHJlID0gdXJsLnNwbGl0KFwiP1wiKVswXTtcbiAgcmV0dXJuIHJlLnNwbGl0KFwiI1wiKVswXTtcbn1cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsKHN0ciwgZmluZCwgcmVwbGFjZSkge1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoZmluZCksIFwiZ1wiKSwgcmVwbGFjZSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoMiwgYWxsb3dBYm92ZVJvb3QpIHtcbiAgbGV0IHJlcyA9IFwiXCI7XG4gIGxldCBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gIGxldCBsYXN0U2xhc2ggPSAtMTtcbiAgbGV0IGRvdHMgPSAwO1xuICBsZXQgY29kZSA9IC0xO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXRoMi5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgcGF0aDIubGVuZ3RoKSB7XG4gICAgICBjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IDQ3O1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgIGlmIChsYXN0U2xhc2ggPT09IGkgLSAxIHx8IGRvdHMgPT09IDEpIHtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNsYXNoICE9PSBpIC0gMSAmJiBkb3RzID09PSAyKSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMSkgIT09IDQ2IHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gNDYpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTbGFzaEluZGV4ID0gcmVzLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCAhPT0gcmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCk7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmxlbmd0aCA9PT0gMiB8fCByZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXMgPSBcIlwiO1xuICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzICs9IFwiLy4uXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IFwiLi5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXMgKz0gYC8ke3BhdGgyLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gcGF0aDIuc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICBkb3RzID0gMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ2ICYmIGRvdHMgIT09IC0xKSB7XG4gICAgICArK2RvdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdHMgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IHBhdGggPSB7XG4gIHRvUG9zaXgocGF0aDIpIHtcbiAgICByZXR1cm4gcmVwbGFjZUFsbChwYXRoMiwgXCJcXFxcXCIsIFwiL1wiKTtcbiAgfSxcbiAgaXNVcmwocGF0aDIpIHtcbiAgICByZXR1cm4gL15odHRwcz86Ly50ZXN0KHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICB9LFxuICBpc0RhdGFVcmwocGF0aDIpIHtcbiAgICByZXR1cm4gL15kYXRhOihbYS16XStcXC9bYS16MC05LSsuXSsoO1thLXowLTktLiEjJCUqKy57fXx+YF0rPVthLXowLTktLiEjJCUqKy57fSgpX3x+YF0rKSopPyg7YmFzZTY0KT8sKFthLXowLTkhJCYnLCgpKis7PVxcLS5ffjpAXFwvPyVcXHM8Pl0qPykkL2kudGVzdChwYXRoMik7XG4gIH0sXG4gIGhhc1Byb3RvY29sKHBhdGgyKSB7XG4gICAgcmV0dXJuIC9eW14vOl0rOlxcLy8udGVzdCh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgfSxcbiAgZ2V0UHJvdG9jb2wocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IHByb3RvY29sID0gXCJcIjtcbiAgICBjb25zdCBpc0ZpbGUgPSAvXmZpbGU6XFwvXFwvXFwvLy5leGVjKHBhdGgyKTtcbiAgICBjb25zdCBpc0h0dHAgPSAvXlteLzpdKzpcXC9cXC8vLmV4ZWMocGF0aDIpO1xuICAgIGNvbnN0IGlzV2luZG93cyA9IC9eW14vOl0rOlxcLy8uZXhlYyhwYXRoMik7XG4gICAgaWYgKGlzRmlsZSB8fCBpc0h0dHAgfHwgaXNXaW5kb3dzKSB7XG4gICAgICBjb25zdCBhcnIgPSBpc0ZpbGU/LlswXSB8fCBpc0h0dHA/LlswXSB8fCBpc1dpbmRvd3M/LlswXTtcbiAgICAgIHByb3RvY29sID0gYXJyO1xuICAgICAgcGF0aDIgPSBwYXRoMi5zbGljZShhcnIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3RvY29sO1xuICB9LFxuICB0b0Fic29sdXRlKHVybCwgY3VzdG9tQmFzZVVybCwgY3VzdG9tUm9vdFVybCkge1xuICAgIGlmICh0aGlzLmlzRGF0YVVybCh1cmwpKVxuICAgICAgcmV0dXJuIHVybDtcbiAgICBjb25zdCBiYXNlVXJsID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChjdXN0b21CYXNlVXJsID8/IHNldHRpbmdzLkFEQVBURVIuZ2V0QmFzZVVybCgpKSk7XG4gICAgY29uc3Qgcm9vdFVybCA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgoY3VzdG9tUm9vdFVybCA/PyB0aGlzLnJvb3RuYW1lKGJhc2VVcmwpKSk7XG4gICAgYXNzZXJ0UGF0aCh1cmwpO1xuICAgIHVybCA9IHRoaXMudG9Qb3NpeCh1cmwpO1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4ocm9vdFVybCwgdXJsLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgY29uc3QgYWJzb2x1dGVQYXRoID0gdGhpcy5pc0Fic29sdXRlKHVybCkgPyB1cmwgOiB0aGlzLmpvaW4oYmFzZVVybCwgdXJsKTtcbiAgICByZXR1cm4gYWJzb2x1dGVQYXRoO1xuICB9LFxuICBub3JtYWxpemUocGF0aDIpIHtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBsZXQgcHJvdG9jb2wgPSBcIlwiO1xuICAgIGNvbnN0IGlzQWJzb2x1dGUgPSBwYXRoMi5zdGFydHNXaXRoKFwiL1wiKTtcbiAgICBpZiAodGhpcy5oYXNQcm90b2NvbChwYXRoMikpIHtcbiAgICAgIHByb3RvY29sID0gdGhpcy5yb290bmFtZShwYXRoMik7XG4gICAgICBwYXRoMiA9IHBhdGgyLnNsaWNlKHByb3RvY29sLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aDIuZW5kc1dpdGgoXCIvXCIpO1xuICAgIHBhdGgyID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aDIsIGZhbHNlKTtcbiAgICBpZiAocGF0aDIubGVuZ3RoID4gMCAmJiB0cmFpbGluZ1NlcGFyYXRvcilcbiAgICAgIHBhdGgyICs9IFwiL1wiO1xuICAgIGlmIChpc0Fic29sdXRlKVxuICAgICAgcmV0dXJuIGAvJHtwYXRoMn1gO1xuICAgIHJldHVybiBwcm90b2NvbCArIHBhdGgyO1xuICB9LFxuICBpc0Fic29sdXRlKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGlmICh0aGlzLmhhc1Byb3RvY29sKHBhdGgyKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBwYXRoMi5zdGFydHNXaXRoKFwiL1wiKTtcbiAgfSxcbiAgam9pbiguLi5zZWdtZW50cykge1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICB9XG4gICAgbGV0IGpvaW5lZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBhcmcgPSBzZWdtZW50c1tpXTtcbiAgICAgIGFzc2VydFBhdGgoYXJnKTtcbiAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoam9pbmVkID09PSB2b2lkIDApXG4gICAgICAgICAgam9pbmVkID0gYXJnO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwcmV2QXJnID0gc2VnbWVudHNbaSAtIDFdID8/IFwiXCI7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0bmFtZShwcmV2QXJnKSkge1xuICAgICAgICAgICAgam9pbmVkICs9IGAvLi4vJHthcmd9YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgam9pbmVkICs9IGAvJHthcmd9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGpvaW5lZCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZShqb2luZWQpO1xuICB9LFxuICBkaXJuYW1lKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IGhhc1Jvb3QgPSBjb2RlID09PSA0NztcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgY29uc3QgcHJvdG8gPSB0aGlzLmdldFByb3RvY29sKHBhdGgyKTtcbiAgICBjb25zdCBvcmlncGF0aCA9IHBhdGgyO1xuICAgIHBhdGgyID0gcGF0aDIuc2xpY2UocHJvdG8ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgcmV0dXJuIGhhc1Jvb3QgPyBcIi9cIiA6IHRoaXMuaXNVcmwob3JpZ3BhdGgpID8gcHJvdG8gKyBwYXRoMiA6IHByb3RvO1xuICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSlcbiAgICAgIHJldHVybiBcIi8vXCI7XG4gICAgcmV0dXJuIHByb3RvICsgcGF0aDIuc2xpY2UoMCwgZW5kKTtcbiAgfSxcbiAgcm9vdG5hbWUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IHJvb3QgPSBcIlwiO1xuICAgIGlmIChwYXRoMi5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgIHJvb3QgPSBcIi9cIjtcbiAgICBlbHNlIHtcbiAgICAgIHJvb3QgPSB0aGlzLmdldFByb3RvY29sKHBhdGgyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcmwocGF0aDIpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhdGgyLmluZGV4T2YoXCIvXCIsIHJvb3QubGVuZ3RoKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcm9vdCA9IHBhdGgyLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByb290ID0gcGF0aDI7XG4gICAgICBpZiAoIXJvb3QuZW5kc1dpdGgoXCIvXCIpKVxuICAgICAgICByb290ICs9IFwiL1wiO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfSxcbiAgYmFzZW5hbWUocGF0aDIsIGV4dCkge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGlmIChleHQpXG4gICAgICBhc3NlcnRQYXRoKGV4dCk7XG4gICAgcGF0aDIgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgbGV0IGk7XG4gICAgaWYgKGV4dCAhPT0gdm9pZCAwICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aDIubGVuZ3RoKSB7XG4gICAgICBpZiAoZXh0Lmxlbmd0aCA9PT0gcGF0aDIubGVuZ3RoICYmIGV4dCA9PT0gcGF0aDIpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgbGV0IGV4dElkeCA9IGV4dC5sZW5ndGggLSAxO1xuICAgICAgbGV0IGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcbiAgICAgIGZvciAoaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XG4gICAgICAgICAgICAgIGlmICgtLWV4dElkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKVxuICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgZWxzZSBpZiAoZW5kID09PSAtMSlcbiAgICAgICAgZW5kID0gcGF0aDIubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBhdGgyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgaWYgKHBhdGgyLmNoYXJDb2RlQXQoaSkgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICByZXR1cm4gcGF0aDIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH0sXG4gIGV4dG5hbWUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgbGV0IHByZURvdFN0YXRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fCBwcmVEb3RTdGF0ZSA9PT0gMCB8fCBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBwYXRoMi5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgfSxcbiAgcGFyc2UocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBjb25zdCByZXQgPSB7IHJvb3Q6IFwiXCIsIGRpcjogXCJcIiwgYmFzZTogXCJcIiwgZXh0OiBcIlwiLCBuYW1lOiBcIlwiIH07XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiByZXQ7XG4gICAgcGF0aDIgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gICAgbGV0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IGlzQWJzb2x1dGUgPSB0aGlzLmlzQWJzb2x1dGUocGF0aDIpO1xuICAgIGxldCBzdGFydDtcbiAgICBjb25zdCBwcm90b2NvbCA9IFwiXCI7XG4gICAgcmV0LnJvb3QgPSB0aGlzLnJvb3RuYW1lKHBhdGgyKTtcbiAgICBpZiAoaXNBYnNvbHV0ZSB8fCB0aGlzLmhhc1Byb3RvY29sKHBhdGgyKSkge1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGxldCBzdGFydERvdCA9IC0xO1xuICAgIGxldCBzdGFydFBhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAtMTtcbiAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBsZXQgaSA9IHBhdGgyLmxlbmd0aCAtIDE7XG4gICAgbGV0IHByZURvdFN0YXRlID0gMDtcbiAgICBmb3IgKDsgaSA+PSBzdGFydDsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDQ2KSB7XG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHwgcHJlRG90U3RhdGUgPT09IDAgfHwgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIGlmIChlbmQgIT09IC0xKSB7XG4gICAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSlcbiAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aDIuc2xpY2UoMSwgZW5kKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoMi5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgICByZXQubmFtZSA9IHBhdGgyLnNsaWNlKDEsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoMi5zbGljZSgxLCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoMi5zbGljZShzdGFydFBhcnQsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoMi5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICByZXQuZXh0ID0gcGF0aDIuc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gICAgfVxuICAgIHJldC5kaXIgPSB0aGlzLmRpcm5hbWUocGF0aDIpO1xuICAgIGlmIChwcm90b2NvbClcbiAgICAgIHJldC5kaXIgPSBwcm90b2NvbCArIHJldC5kaXI7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgc2VwOiBcIi9cIixcbiAgZGVsaW1pdGVyOiBcIjpcIlxufTtcblxuZXhwb3J0IHsgcGF0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC5tanMubWFwXG4iLCJjb25zdCB3YXJuaW5ncyA9IHt9O1xuZnVuY3Rpb24gZGVwcmVjYXRpb24odmVyc2lvbiwgbWVzc2FnZSwgaWdub3JlRGVwdGggPSAzKSB7XG4gIGlmICh3YXJuaW5nc1ttZXNzYWdlXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUud2FybihcIlBpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiBcIiwgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFjayA9IHN0YWNrLnNwbGl0KFwiXFxuXCIpLnNwbGljZShpZ25vcmVEZXB0aCkuam9pbihcIlxcblwiKTtcbiAgICBpZiAoY29uc29sZS5ncm91cENvbGxhcHNlZCkge1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcIiVjUGl4aUpTIERlcHJlY2F0aW9uIFdhcm5pbmc6ICVjJXNcIiwgXCJjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNlwiLCBcImZvbnQtd2VpZ2h0Om5vcm1hbDtjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNlwiLCBgJHttZXNzYWdlfVxuRGVwcmVjYXRlZCBzaW5jZSB2JHt2ZXJzaW9ufWApO1xuICAgICAgY29uc29sZS53YXJuKHN0YWNrKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiUGl4aUpTIERlcHJlY2F0aW9uIFdhcm5pbmc6IFwiLCBgJHttZXNzYWdlfVxuRGVwcmVjYXRlZCBzaW5jZSB2JHt2ZXJzaW9ufWApO1xuICAgICAgY29uc29sZS53YXJuKHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgd2FybmluZ3NbbWVzc2FnZV0gPSB0cnVlO1xufVxuXG5leHBvcnQgeyBkZXByZWNhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwcmVjYXRpb24ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tICcuLi9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cbmZ1bmN0aW9uIHNraXBIZWxsbygpIHtcbiAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInNraXBIZWxsbyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHNldHRpbmdzLlJFTkRFUl9PUFRJT05TLmhlbGxvXCIpO1xufVxuZnVuY3Rpb24gc2F5SGVsbG8oKSB7XG4gIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgYHNheUhlbGxvIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUmVuZGVyZXIncyBcImhlbGxvXCIgb3B0aW9uYCk7XG59XG5cbmV4cG9ydCB7IHNheUhlbGxvLCBza2lwSGVsbG8gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbGxvLm1qcy5tYXBcbiIsImltcG9ydCAnLi4vc2V0dGluZ3MubWpzJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuXG5sZXQgc3VwcG9ydGVkO1xuZnVuY3Rpb24gaXNXZWJHTFN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0ZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzdXBwb3J0ZWQgPSBmdW5jdGlvbiBzdXBwb3J0ZWQyKCkge1xuICAgICAgY29uc3QgY29udGV4dE9wdGlvbnMgPSB7XG4gICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHNldHRpbmdzLkZBSUxfSUZfTUFKT1JfUEVSRk9STUFOQ0VfQ0FWRUFUXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5BREFQVEVSLmdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgIGxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgY29udGV4dE9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9ICEhZ2w/LmdldENvbnRleHRBdHRyaWJ1dGVzKCk/LnN0ZW5jaWw7XG4gICAgICAgIGlmIChnbCkge1xuICAgICAgICAgIGNvbnN0IGxvc2VDb250ZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuICAgICAgICAgIGlmIChsb3NlQ29udGV4dCkge1xuICAgICAgICAgICAgbG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2wgPSBudWxsO1xuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0oKTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG5leHBvcnQgeyBpc1dlYkdMU3VwcG9ydGVkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1dlYkdMU3VwcG9ydGVkLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnQHBpeGkvY29sb3InO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tICcuLi9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cbmZ1bmN0aW9uIGhleDJyZ2IoaGV4LCBvdXQgPSBbXSkge1xuICBkZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMuaGV4MnJnYiBpcyBkZXByZWNhdGVkLCB1c2UgQ29sb3IjdG9SZ2JBcnJheSBpbnN0ZWFkXCIpO1xuICByZXR1cm4gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGhleCkudG9SZ2JBcnJheShvdXQpO1xufVxuZnVuY3Rpb24gaGV4MnN0cmluZyhoZXgpIHtcbiAgZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLmhleDJzdHJpbmcgaXMgZGVwcmVjYXRlZCwgdXNlIENvbG9yI3RvSGV4IGluc3RlYWRcIik7XG4gIHJldHVybiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoaGV4KS50b0hleCgpO1xufVxuZnVuY3Rpb24gc3RyaW5nMmhleChzdHJpbmcpIHtcbiAgZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLnN0cmluZzJoZXggaXMgZGVwcmVjYXRlZCwgdXNlIENvbG9yI3RvTnVtYmVyIGluc3RlYWRcIik7XG4gIHJldHVybiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoc3RyaW5nKS50b051bWJlcigpO1xufVxuZnVuY3Rpb24gcmdiMmhleChyZ2IpIHtcbiAgZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLnJnYjJoZXggaXMgZGVwcmVjYXRlZCwgdXNlIENvbG9yI3RvTnVtYmVyIGluc3RlYWRcIik7XG4gIHJldHVybiBDb2xvci5zaGFyZWQuc2V0VmFsdWUocmdiKS50b051bWJlcigpO1xufVxuXG5leHBvcnQgeyBoZXgycmdiLCBoZXgyc3RyaW5nLCByZ2IyaGV4LCBzdHJpbmcyaGV4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdAcGl4aS9jb2xvcic7XG5pbXBvcnQgeyBCTEVORF9NT0RFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gJy4uL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuZnVuY3Rpb24gbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMoKSB7XG4gIGNvbnN0IHBtID0gW107XG4gIGNvbnN0IG5wbSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBwbVtpXSA9IGk7XG4gICAgbnBtW2ldID0gaTtcbiAgfVxuICBwbVtCTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IEJMRU5EX01PREVTLk5PUk1BTDtcbiAgcG1bQkxFTkRfTU9ERVMuQUREX05QTV0gPSBCTEVORF9NT0RFUy5BREQ7XG4gIHBtW0JMRU5EX01PREVTLlNDUkVFTl9OUE1dID0gQkxFTkRfTU9ERVMuU0NSRUVOO1xuICBucG1bQkxFTkRfTU9ERVMuTk9STUFMXSA9IEJMRU5EX01PREVTLk5PUk1BTF9OUE07XG4gIG5wbVtCTEVORF9NT0RFUy5BRERdID0gQkxFTkRfTU9ERVMuQUREX05QTTtcbiAgbnBtW0JMRU5EX01PREVTLlNDUkVFTl0gPSBCTEVORF9NT0RFUy5TQ1JFRU5fTlBNO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBhcnJheS5wdXNoKG5wbSk7XG4gIGFycmF5LnB1c2gocG0pO1xuICByZXR1cm4gYXJyYXk7XG59XG5jb25zdCBwcmVtdWx0aXBseUJsZW5kTW9kZSA9IG1hcFByZW11bHRpcGxpZWRCbGVuZE1vZGVzKCk7XG5mdW5jdGlvbiBjb3JyZWN0QmxlbmRNb2RlKGJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZCkge1xuICByZXR1cm4gcHJlbXVsdGlwbHlCbGVuZE1vZGVbcHJlbXVsdGlwbGllZCA/IDEgOiAwXVtibGVuZE1vZGVdO1xufVxuZnVuY3Rpb24gcHJlbXVsdGlwbHlSZ2JhKHJnYiwgYWxwaGEsIG91dCwgcHJlbXVsdGlwbHkgPSB0cnVlKSB7XG4gIGRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgYHV0aWxzLnByZW11bHRpcGx5UmdiYSBoYXMgbW92ZWQgdG8gQ29sb3IucHJlbXVsdGlwbHlgKTtcbiAgcmV0dXJuIENvbG9yLnNoYXJlZC5zZXRWYWx1ZShyZ2IpLnByZW11bHRpcGx5KGFscGhhLCBwcmVtdWx0aXBseSkudG9BcnJheShvdXQgPz8gbmV3IEZsb2F0MzJBcnJheSg0KSk7XG59XG5mdW5jdGlvbiBwcmVtdWx0aXBseVRpbnQodGludCwgYWxwaGEpIHtcbiAgZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBgdXRpbHMucHJlbXVsdGlwbHlUaW50IGhhcyBtb3ZlZCB0byBDb2xvci50b1ByZW11bHRpcGxpZWRgKTtcbiAgcmV0dXJuIENvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0aW50KS50b1ByZW11bHRpcGxpZWQoYWxwaGEpO1xufVxuZnVuY3Rpb24gcHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRpbnQsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5ID0gdHJ1ZSkge1xuICBkZXByZWNhdGlvbihcIjcuMi4wXCIsIGB1dGlscy5wcmVtdWx0aXBseVRpbnRUb1JnYmEgaGFzIG1vdmVkIHRvIENvbG9yLnByZW11bHRpcGx5YCk7XG4gIHJldHVybiBDb2xvci5zaGFyZWQuc2V0VmFsdWUodGludCkucHJlbXVsdGlwbHkoYWxwaGEsIHByZW11bHRpcGx5KS50b0FycmF5KG91dCA/PyBuZXcgRmxvYXQzMkFycmF5KDQpKTtcbn1cblxuZXhwb3J0IHsgY29ycmVjdEJsZW5kTW9kZSwgcHJlbXVsdGlwbHlCbGVuZE1vZGUsIHByZW11bHRpcGx5UmdiYSwgcHJlbXVsdGlwbHlUaW50LCBwcmVtdWx0aXBseVRpbnRUb1JnYmEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZW11bHRpcGx5Lm1qcy5tYXBcbiIsImNvbnN0IERBVEFfVVJJID0gL15cXHMqZGF0YTooPzooW1xcdy1dKylcXC8oW1xcdysuLV0rKSk/KD86O2NoYXJzZXQ9KFtcXHctXSspKT8oPzo7KGJhc2U2NCkpPywoLiopL2k7XG5cbmV4cG9ydCB7IERBVEFfVVJJIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJmdW5jdGlvbiBjcmVhdGVJbmRpY2VzRm9yUXVhZHMoc2l6ZSwgb3V0QnVmZmVyID0gbnVsbCkge1xuICBjb25zdCB0b3RhbEluZGljZXMgPSBzaXplICogNjtcbiAgb3V0QnVmZmVyID0gb3V0QnVmZmVyIHx8IG5ldyBVaW50MTZBcnJheSh0b3RhbEluZGljZXMpO1xuICBpZiAob3V0QnVmZmVyLmxlbmd0aCAhPT0gdG90YWxJbmRpY2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBPdXQgYnVmZmVyIGxlbmd0aCBpcyBpbmNvcnJlY3QsIGdvdCAke291dEJ1ZmZlci5sZW5ndGh9IGFuZCBleHBlY3RlZCAke3RvdGFsSW5kaWNlc31gKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b3RhbEluZGljZXM7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgb3V0QnVmZmVyW2kgKyAwXSA9IGogKyAwO1xuICAgIG91dEJ1ZmZlcltpICsgMV0gPSBqICsgMTtcbiAgICBvdXRCdWZmZXJbaSArIDJdID0gaiArIDI7XG4gICAgb3V0QnVmZmVyW2kgKyAzXSA9IGogKyAwO1xuICAgIG91dEJ1ZmZlcltpICsgNF0gPSBqICsgMjtcbiAgICBvdXRCdWZmZXJbaSArIDVdID0gaiArIDM7XG4gIH1cbiAgcmV0dXJuIG91dEJ1ZmZlcjtcbn1cblxuZXhwb3J0IHsgY3JlYXRlSW5kaWNlc0ZvclF1YWRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVJbmRpY2VzRm9yUXVhZHMubWpzLm1hcFxuIiwiZnVuY3Rpb24gZ2V0QnVmZmVyVHlwZShhcnJheSkge1xuICBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDQpIHtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHJldHVybiBcIkZsb2F0MzJBcnJheVwiO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuICAgICAgcmV0dXJuIFwiVWludDMyQXJyYXlcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiSW50MzJBcnJheVwiO1xuICB9IGVsc2UgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSAyKSB7XG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHtcbiAgICAgIHJldHVybiBcIlVpbnQxNkFycmF5XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSAxKSB7XG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIFwiVWludDhBcnJheVwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgZ2V0QnVmZmVyVHlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0QnVmZmVyVHlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBnZXRCdWZmZXJUeXBlIH0gZnJvbSAnLi9nZXRCdWZmZXJUeXBlLm1qcyc7XG5cbmNvbnN0IG1hcCA9IHsgRmxvYXQzMkFycmF5LCBVaW50MzJBcnJheSwgSW50MzJBcnJheSwgVWludDhBcnJheSB9O1xuZnVuY3Rpb24gaW50ZXJsZWF2ZVR5cGVkQXJyYXlzKGFycmF5cywgc2l6ZXMpIHtcbiAgbGV0IG91dFNpemUgPSAwO1xuICBsZXQgc3RyaWRlID0gMDtcbiAgY29uc3Qgdmlld3MgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpZGUgKz0gc2l6ZXNbaV07XG4gICAgb3V0U2l6ZSArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihvdXRTaXplICogNCk7XG4gIGxldCBvdXQgPSBudWxsO1xuICBsZXQgbGl0dGxlT2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaXplID0gc2l6ZXNbaV07XG4gICAgY29uc3QgYXJyYXkgPSBhcnJheXNbaV07XG4gICAgY29uc3QgdHlwZSA9IGdldEJ1ZmZlclR5cGUoYXJyYXkpO1xuICAgIGlmICghdmlld3NbdHlwZV0pIHtcbiAgICAgIHZpZXdzW3R5cGVdID0gbmV3IG1hcFt0eXBlXShidWZmZXIpO1xuICAgIH1cbiAgICBvdXQgPSB2aWV3c1t0eXBlXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBpbmRleFN0YXJ0ID0gKGogLyBzaXplIHwgMCkgKiBzdHJpZGUgKyBsaXR0bGVPZmZzZXQ7XG4gICAgICBjb25zdCBpbmRleCA9IGogJSBzaXplO1xuICAgICAgb3V0W2luZGV4U3RhcnQgKyBpbmRleF0gPSBhcnJheVtqXTtcbiAgICB9XG4gICAgbGl0dGxlT2Zmc2V0ICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbn1cblxuZXhwb3J0IHsgaW50ZXJsZWF2ZVR5cGVkQXJyYXlzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmxlYXZlVHlwZWRBcnJheXMubWpzLm1hcFxuIiwiZnVuY3Rpb24gbmV4dFBvdzIodikge1xuICB2ICs9IHYgPT09IDAgPyAxIDogMDtcbiAgLS12O1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2ICsgMTtcbn1cbmZ1bmN0aW9uIGlzUG93Mih2KSB7XG4gIHJldHVybiAhKHYgJiB2IC0gMSkgJiYgISF2O1xufVxuZnVuY3Rpb24gbG9nMih2KSB7XG4gIGxldCByID0gKHYgPiA2NTUzNSA/IDEgOiAwKSA8PCA0O1xuICB2ID4+Pj0gcjtcbiAgbGV0IHNoaWZ0ID0gKHYgPiAyNTUgPyAxIDogMCkgPDwgMztcbiAgdiA+Pj49IHNoaWZ0O1xuICByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMTUgPyAxIDogMCkgPDwgMjtcbiAgdiA+Pj49IHNoaWZ0O1xuICByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMyA/IDEgOiAwKSA8PCAxO1xuICB2ID4+Pj0gc2hpZnQ7XG4gIHIgfD0gc2hpZnQ7XG4gIHJldHVybiByIHwgdiA+PiAxO1xufVxuXG5leHBvcnQgeyBpc1BvdzIsIGxvZzIsIG5leHRQb3cyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3cyLm1qcy5tYXBcbiIsImZ1bmN0aW9uIHJlbW92ZUl0ZW1zKGFyciwgc3RhcnRJZHgsIHJlbW92ZUNvdW50KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIGxldCBpO1xuICBpZiAoc3RhcnRJZHggPj0gbGVuZ3RoIHx8IHJlbW92ZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlbW92ZUNvdW50ID0gc3RhcnRJZHggKyByZW1vdmVDb3VudCA+IGxlbmd0aCA/IGxlbmd0aCAtIHN0YXJ0SWR4IDogcmVtb3ZlQ291bnQ7XG4gIGNvbnN0IGxlbiA9IGxlbmd0aCAtIHJlbW92ZUNvdW50O1xuICBmb3IgKGkgPSBzdGFydElkeDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXJyW2ldID0gYXJyW2kgKyByZW1vdmVDb3VudF07XG4gIH1cbiAgYXJyLmxlbmd0aCA9IGxlbjtcbn1cblxuZXhwb3J0IHsgcmVtb3ZlSXRlbXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZUl0ZW1zLm1qcy5tYXBcbiIsImZ1bmN0aW9uIHNpZ24obikge1xuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gMDtcbiAgcmV0dXJuIG4gPCAwID8gLTEgOiAxO1xufVxuXG5leHBvcnQgeyBzaWduIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduLm1qcy5tYXBcbiIsImxldCBuZXh0VWlkID0gMDtcbmZ1bmN0aW9uIHVpZCgpIHtcbiAgcmV0dXJuICsrbmV4dFVpZDtcbn1cblxuZXhwb3J0IHsgdWlkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aWQubWpzLm1hcFxuIiwiY29uc3QgX0JvdW5kaW5nQm94ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQ7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b20gLSB0aGlzLnRvcDtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQgPT09IHRoaXMucmlnaHQgfHwgdGhpcy50b3AgPT09IHRoaXMuYm90dG9tO1xuICB9XG59O1xubGV0IEJvdW5kaW5nQm94ID0gX0JvdW5kaW5nQm94O1xuQm91bmRpbmdCb3guRU1QVFkgPSBuZXcgX0JvdW5kaW5nQm94KDAsIDAsIDAsIDApO1xuXG5leHBvcnQgeyBCb3VuZGluZ0JveCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRpbmdCb3gubWpzLm1hcFxuIiwiY29uc3QgUHJvZ3JhbUNhY2hlID0ge307XG5jb25zdCBUZXh0dXJlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IEJhc2VUZXh0dXJlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGRlc3Ryb3lUZXh0dXJlQ2FjaGUoKSB7XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIFRleHR1cmVDYWNoZSkge1xuICAgIFRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcbiAgfVxuICBmb3IgKGtleSBpbiBCYXNlVGV4dHVyZUNhY2hlKSB7XG4gICAgQmFzZVRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJUZXh0dXJlQ2FjaGUoKSB7XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIFRleHR1cmVDYWNoZSkge1xuICAgIGRlbGV0ZSBUZXh0dXJlQ2FjaGVba2V5XTtcbiAgfVxuICBmb3IgKGtleSBpbiBCYXNlVGV4dHVyZUNhY2hlKSB7XG4gICAgZGVsZXRlIEJhc2VUZXh0dXJlQ2FjaGVba2V5XTtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXNlVGV4dHVyZUNhY2hlLCBQcm9ncmFtQ2FjaGUsIFRleHR1cmVDYWNoZSwgY2xlYXJUZXh0dXJlQ2FjaGUsIGRlc3Ryb3lUZXh0dXJlQ2FjaGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcblxuY2xhc3MgQ2FudmFzUmVuZGVyVGFyZ2V0IHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbikge1xuICAgIHRoaXMuX2NhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCk7XG4gICAgdGhpcy5fY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgfVxuICByZXNpemUoZGVzaXJlZFdpZHRoLCBkZXNpcmVkSGVpZ2h0KSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKTtcbiAgICB0aGlzLl9jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKGRlc2lyZWRXaWR0aCAqIHRoaXMucmVzb2x1dGlvbik7XG4gICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQoZGVzaXJlZEhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHJldHVybiB0aGlzLl9jYW52YXMud2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCk7XG4gICAgdGhpcy5fY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh2YWwpO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCk7XG4gICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQodmFsKTtcbiAgfVxuICBnZXQgY2FudmFzKCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG4gIF9jaGVja0Rlc3Ryb3llZCgpIHtcbiAgICBpZiAodGhpcy5fY2FudmFzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIENhbnZhc1JlbmRlclRhcmdldCBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZFwiKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQ2FudmFzUmVuZGVyVGFyZ2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNSZW5kZXJUYXJnZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tICcuL0JvdW5kaW5nQm94Lm1qcyc7XG5cbmZ1bmN0aW9uIGNoZWNrUm93KGRhdGEsIHdpZHRoLCB5KSB7XG4gIGZvciAobGV0IHggPSAwLCBpbmRleCA9IDQgKiB5ICogd2lkdGg7IHggPCB3aWR0aDsgKyt4LCBpbmRleCArPSA0KSB7XG4gICAgaWYgKGRhdGFbaW5kZXggKyAzXSAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCB4LCB0b3AsIGJvdHRvbSkge1xuICBjb25zdCBzdHJpZGUgPSA0ICogd2lkdGg7XG4gIGZvciAobGV0IHkgPSB0b3AsIGluZGV4ID0gdG9wICogc3RyaWRlICsgNCAqIHg7IHkgPD0gYm90dG9tOyArK3ksIGluZGV4ICs9IHN0cmlkZSkge1xuICAgIGlmIChkYXRhW2luZGV4ICsgM10gIT09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXM7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgfSk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBnZXQgY2FudmFzIDJEIGNvbnRleHRcIik7XG4gIH1cbiAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgdG9wID0gMDtcbiAgbGV0IHJpZ2h0ID0gd2lkdGggLSAxO1xuICBsZXQgYm90dG9tID0gaGVpZ2h0IC0gMTtcbiAgd2hpbGUgKHRvcCA8IGhlaWdodCAmJiBjaGVja1JvdyhkYXRhLCB3aWR0aCwgdG9wKSlcbiAgICArK3RvcDtcbiAgaWYgKHRvcCA9PT0gaGVpZ2h0KVxuICAgIHJldHVybiBCb3VuZGluZ0JveC5FTVBUWTtcbiAgd2hpbGUgKGNoZWNrUm93KGRhdGEsIHdpZHRoLCBib3R0b20pKVxuICAgIC0tYm90dG9tO1xuICB3aGlsZSAoY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIGxlZnQsIHRvcCwgYm90dG9tKSlcbiAgICArK2xlZnQ7XG4gIHdoaWxlIChjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgcmlnaHQsIHRvcCwgYm90dG9tKSlcbiAgICAtLXJpZ2h0O1xuICArK3JpZ2h0O1xuICArK2JvdHRvbTtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pO1xufVxuXG5leHBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q2FudmFzQm91bmRpbmdCb3gubWpzLm1hcFxuIiwiaW1wb3J0IHsgZ2V0Q2FudmFzQm91bmRpbmdCb3ggfSBmcm9tICcuL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcyc7XG5cbmZ1bmN0aW9uIHRyaW1DYW52YXMoY2FudmFzKSB7XG4gIGNvbnN0IGJvdW5kaW5nQm94ID0gZ2V0Q2FudmFzQm91bmRpbmdCb3goY2FudmFzKTtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBib3VuZGluZ0JveDtcbiAgbGV0IGRhdGEgPSBudWxsO1xuICBpZiAoIWJvdW5kaW5nQm94LmlzRW1wdHkoKSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGdldCBjYW52YXMgMkQgY29udGV4dFwiKTtcbiAgICB9XG4gICAgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKGJvdW5kaW5nQm94LmxlZnQsIGJvdW5kaW5nQm94LnRvcCwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgZGF0YSB9O1xufVxuXG5leHBvcnQgeyB0cmltQ2FudmFzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltQ2FudmFzLm1qcy5tYXBcbiIsImltcG9ydCB7IERBVEFfVVJJIH0gZnJvbSAnLi4vY29uc3QubWpzJztcblxuZnVuY3Rpb24gZGVjb21wb3NlRGF0YVVyaShkYXRhVXJpKSB7XG4gIGNvbnN0IGRhdGFVcmlNYXRjaCA9IERBVEFfVVJJLmV4ZWMoZGF0YVVyaSk7XG4gIGlmIChkYXRhVXJpTWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWFUeXBlOiBkYXRhVXJpTWF0Y2hbMV0gPyBkYXRhVXJpTWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6IHZvaWQgMCxcbiAgICAgIHN1YlR5cGU6IGRhdGFVcmlNYXRjaFsyXSA/IGRhdGFVcmlNYXRjaFsyXS50b0xvd2VyQ2FzZSgpIDogdm9pZCAwLFxuICAgICAgY2hhcnNldDogZGF0YVVyaU1hdGNoWzNdID8gZGF0YVVyaU1hdGNoWzNdLnRvTG93ZXJDYXNlKCkgOiB2b2lkIDAsXG4gICAgICBlbmNvZGluZzogZGF0YVVyaU1hdGNoWzRdID8gZGF0YVVyaU1hdGNoWzRdLnRvTG93ZXJDYXNlKCkgOiB2b2lkIDAsXG4gICAgICBkYXRhOiBkYXRhVXJpTWF0Y2hbNV1cbiAgICB9O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbmV4cG9ydCB7IGRlY29tcG9zZURhdGFVcmkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29tcG9zZURhdGFVcmkubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXJsIH0gZnJvbSAnLi4vdXJsLm1qcyc7XG5cbmxldCB0ZW1wQW5jaG9yO1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odXJsJDEsIGxvYyA9IGdsb2JhbFRoaXMubG9jYXRpb24pIHtcbiAgaWYgKHVybCQxLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGxvYyA9IGxvYyB8fCBnbG9iYWxUaGlzLmxvY2F0aW9uO1xuICBpZiAoIXRlbXBBbmNob3IpIHtcbiAgICB0ZW1wQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gIH1cbiAgdGVtcEFuY2hvci5ocmVmID0gdXJsJDE7XG4gIGNvbnN0IHBhcnNlZFVybCA9IHVybC5wYXJzZSh0ZW1wQW5jaG9yLmhyZWYpO1xuICBjb25zdCBzYW1lUG9ydCA9ICFwYXJzZWRVcmwucG9ydCAmJiBsb2MucG9ydCA9PT0gXCJcIiB8fCBwYXJzZWRVcmwucG9ydCA9PT0gbG9jLnBvcnQ7XG4gIGlmIChwYXJzZWRVcmwuaG9zdG5hbWUgIT09IGxvYy5ob3N0bmFtZSB8fCAhc2FtZVBvcnQgfHwgcGFyc2VkVXJsLnByb3RvY29sICE9PSBsb2MucHJvdG9jb2wpIHtcbiAgICByZXR1cm4gXCJhbm9ueW1vdXNcIjtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cblxuZXhwb3J0IHsgZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVybWluZUNyb3NzT3JpZ2luLm1qcy5tYXBcbiIsImltcG9ydCAnLi4vc2V0dGluZ3MubWpzJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuXG5mdW5jdGlvbiBnZXRSZXNvbHV0aW9uT2ZVcmwodXJsLCBkZWZhdWx0VmFsdWUgPSAxKSB7XG4gIGNvbnN0IHJlc29sdXRpb24gPSBzZXR0aW5ncy5SRVRJTkFfUFJFRklYPy5leGVjKHVybCk7XG4gIGlmIChyZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzb2x1dGlvblsxXSk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuZXhwb3J0IHsgZ2V0UmVzb2x1dGlvbk9mVXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRSZXNvbHV0aW9uT2ZVcmwubWpzLm1hcFxuIiwiaW1wb3J0ICcuL3NldHRpbmdzLm1qcyc7XG5leHBvcnQgeyBpc01vYmlsZSB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVhcmN1dCB9IGZyb20gJ2VhcmN1dCc7XG5leHBvcnQgeyB1cmwgfSBmcm9tICcuL3VybC5tanMnO1xuZXhwb3J0IHsgcGF0aCB9IGZyb20gJy4vcGF0aC5tanMnO1xuZXhwb3J0IHsgc2F5SGVsbG8sIHNraXBIZWxsbyB9IGZyb20gJy4vYnJvd3Nlci9oZWxsby5tanMnO1xuZXhwb3J0IHsgaXNXZWJHTFN1cHBvcnRlZCB9IGZyb20gJy4vYnJvd3Nlci9pc1dlYkdMU3VwcG9ydGVkLm1qcyc7XG5leHBvcnQgeyBoZXgycmdiLCBoZXgyc3RyaW5nLCByZ2IyaGV4LCBzdHJpbmcyaGV4IH0gZnJvbSAnLi9jb2xvci9oZXgubWpzJztcbmV4cG9ydCB7IGNvcnJlY3RCbGVuZE1vZGUsIHByZW11bHRpcGx5QmxlbmRNb2RlLCBwcmVtdWx0aXBseVJnYmEsIHByZW11bHRpcGx5VGludCwgcHJlbXVsdGlwbHlUaW50VG9SZ2JhIH0gZnJvbSAnLi9jb2xvci9wcmVtdWx0aXBseS5tanMnO1xuZXhwb3J0IHsgREFUQV9VUkkgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBjcmVhdGVJbmRpY2VzRm9yUXVhZHMgfSBmcm9tICcuL2RhdGEvY3JlYXRlSW5kaWNlc0ZvclF1YWRzLm1qcyc7XG5leHBvcnQgeyBnZXRCdWZmZXJUeXBlIH0gZnJvbSAnLi9kYXRhL2dldEJ1ZmZlclR5cGUubWpzJztcbmV4cG9ydCB7IGludGVybGVhdmVUeXBlZEFycmF5cyB9IGZyb20gJy4vZGF0YS9pbnRlcmxlYXZlVHlwZWRBcnJheXMubWpzJztcbmV4cG9ydCB7IGlzUG93MiwgbG9nMiwgbmV4dFBvdzIgfSBmcm9tICcuL2RhdGEvcG93Mi5tanMnO1xuZXhwb3J0IHsgcmVtb3ZlSXRlbXMgfSBmcm9tICcuL2RhdGEvcmVtb3ZlSXRlbXMubWpzJztcbmV4cG9ydCB7IHNpZ24gfSBmcm9tICcuL2RhdGEvc2lnbi5tanMnO1xuZXhwb3J0IHsgdWlkIH0gZnJvbSAnLi9kYXRhL3VpZC5tanMnO1xuZXhwb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tICcuL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmV4cG9ydCB7IEJvdW5kaW5nQm94IH0gZnJvbSAnLi9tZWRpYS9Cb3VuZGluZ0JveC5tanMnO1xuZXhwb3J0IHsgQmFzZVRleHR1cmVDYWNoZSwgUHJvZ3JhbUNhY2hlLCBUZXh0dXJlQ2FjaGUsIGNsZWFyVGV4dHVyZUNhY2hlLCBkZXN0cm95VGV4dHVyZUNhY2hlIH0gZnJvbSAnLi9tZWRpYS9jYWNoZXMubWpzJztcbmV4cG9ydCB7IENhbnZhc1JlbmRlclRhcmdldCB9IGZyb20gJy4vbWVkaWEvQ2FudmFzUmVuZGVyVGFyZ2V0Lm1qcyc7XG5leHBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9IGZyb20gJy4vbWVkaWEvZ2V0Q2FudmFzQm91bmRpbmdCb3gubWpzJztcbmV4cG9ydCB7IHRyaW1DYW52YXMgfSBmcm9tICcuL21lZGlhL3RyaW1DYW52YXMubWpzJztcbmV4cG9ydCB7IGRlY29tcG9zZURhdGFVcmkgfSBmcm9tICcuL25ldHdvcmsvZGVjb21wb3NlRGF0YVVyaS5tanMnO1xuZXhwb3J0IHsgZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4gfSBmcm9tICcuL25ldHdvcmsvZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4ubWpzJztcbmV4cG9ydCB7IGdldFJlc29sdXRpb25PZlVybCB9IGZyb20gJy4vbmV0d29yay9nZXRSZXNvbHV0aW9uT2ZVcmwubWpzJztcbmltcG9ydCAnLi90eXBlcy9pbmRleC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///441\n')},453:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "MxU": () => (/* reexport */ Application),\n  "W20": () => (/* reexport */ display_lib/* Container */.W2),\n  "nRP": () => (/* reexport */ FederatedPointerEvent),\n  "TCu": () => (/* reexport */ Graphics),\n  "E9j": () => (/* reexport */ lib/* Point */.E9),\n  "AeJ": () => (/* reexport */ lib/* Rectangle */.Ae),\n  "HSM": () => (/* reexport */ lib/* SHAPES */.HS),\n  "vB5": () => (/* reexport */ lib/* Ticker */.vB)\n});\n\n// UNUSED EXPORTS: ALPHA_MODES, AbstractMultiResource, AccessibilityManager, AlphaFilter, AnimatedSprite, ArrayResource, Assets, AssetsClass, Attribute, BLEND_MODES, BUFFER_BITS, BUFFER_TYPE, BackgroundSystem, BaseImageResource, BasePrepare, BaseRenderTexture, BaseTexture, BatchDrawCall, BatchGeometry, BatchRenderer, BatchShaderGenerator, BatchSystem, BatchTextureArray, BitmapFont, BitmapFontData, BitmapText, BlobResource, BlurFilter, BlurFilterPass, Bounds, BrowserAdapter, Buffer, BufferResource, BufferSystem, CLEAR_MODES, COLOR_MASK_BITS, Cache, CanvasResource, Circle, Color, ColorMatrixFilter, CompressedTextureResource, ContextSystem, CountLimiter, CubeResource, DEG_TO_RAD, DRAW_MODES, DisplacementFilter, DisplayObject, ENV, Ellipse, EventBoundary, EventSystem, ExtensionType, Extract, FORMATS, FORMATS_TO_COMPONENTS, FXAAFilter, FederatedDisplayObject, FederatedEvent, FederatedMouseEvent, FederatedWheelEvent, FillStyle, Filter, FilterState, FilterSystem, Framebuffer, FramebufferSystem, GC_MODES, GLFramebuffer, GLProgram, GLTexture, GRAPHICS_CURVES, GenerateTextureSystem, Geometry, GeometrySystem, GraphicsData, GraphicsGeometry, HTMLText, HTMLTextStyle, IGLUniformData, INSTALLED, INTERNAL_FORMATS, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL, ImageBitmapResource, ImageResource, LINE_CAP, LINE_JOIN, LineStyle, LoaderParserPriority, MASK_TYPES, MIPMAP_MODES, MSAA_QUALITY, MaskData, MaskSystem, Matrix, Mesh, MeshBatchUvs, MeshGeometry, MeshMaterial, MultisampleSystem, NineSlicePlane, NoiseFilter, ObjectRenderer, ObjectRendererSystem, ObservablePoint, PI_2, PRECISION, ParticleContainer, ParticleRenderer, PlaneGeometry, PluginSystem, Polygon, Prepare, Program, ProjectionSystem, Quad, QuadUv, RAD_TO_DEG, RENDERER_TYPE, RenderTexture, RenderTexturePool, RenderTextureSystem, Renderer, ResizePlugin, Resource, RopeGeometry, RoundedRectangle, Runner, SAMPLER_TYPES, SCALE_MODES, SVGResource, ScissorSystem, Shader, ShaderSystem, SimpleMesh, SimplePlane, SimpleRope, Sprite, SpriteMaskFilter, Spritesheet, StartupSystem, State, StateSystem, StencilSystem, SystemManager, TARGETS, TEXT_GRADIENT, TYPES, TYPES_TO_BYTES_PER_COMPONENT, TYPES_TO_BYTES_PER_PIXEL, TemporaryDisplayObject, Text, TextFormat, TextMetrics, TextStyle, Texture, TextureGCSystem, TextureMatrix, TextureSystem, TextureUvs, TickerPlugin, TilingSprite, TilingSpriteRenderer, TimeLimiter, Transform, TransformFeedback, TransformFeedbackSystem, UPDATE_PRIORITY, UniformGroup, VERSION, VideoResource, ViewSystem, ViewableBuffer, WRAP_MODES, XMLFormat, XMLStringFormat, accessibleTarget, autoDetectFormat, autoDetectRenderer, autoDetectResource, cacheTextureArray, checkDataUrl, checkExtension, checkMaxIfStatementsInShader, convertToList, copySearchParams, createStringVariations, createTexture, createUBOElements, curves, defaultFilterVertex, defaultVertex, detectAvif, detectCompressedTextures, detectDefaults, detectWebp, extensions, filters, generateProgram, generateUniformBufferSync, getFontFamilyName, getTestContext, getUBOData, graphicsUtils, groupD8, isMobile, isSingleItem, loadBitmapFont, loadDDS, loadImageBitmap, loadJson, loadKTX, loadSVG, loadTextures, loadTxt, loadWebFont, parseDDS, parseKTX, resolveCompressedTextureUrl, resolveTextureUrl, settings, spritesheetAsset, uniformParsers, unsafeEvalSupported, utils\n\n// EXTERNAL MODULE: ./node_modules/@pixi/core/lib/index.mjs + 118 modules\nvar lib = __webpack_require__(525);\n// EXTERNAL MODULE: ./node_modules/@pixi/display/lib/index.mjs + 4 modules\nvar display_lib = __webpack_require__(820);\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite/lib/Sprite.mjs\n\n\n\nconst tempPoint = new lib/* Point */.E9();\nconst indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\nclass Sprite_Sprite extends display_lib/* Container */.W2 {\n  constructor(texture) {\n    super();\n    this._anchor = new lib/* ObservablePoint */.AB(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);\n    this._texture = null;\n    this._width = 0;\n    this._height = 0;\n    this._tintColor = new lib/* Color */.Il(16777215);\n    this._tintRGB = null;\n    this.tint = 16777215;\n    this.blendMode = lib/* BLEND_MODES.NORMAL */.T$.NORMAL;\n    this._cachedTint = 16777215;\n    this.uvs = null;\n    this.texture = texture || lib/* Texture.EMPTY */.xE.EMPTY;\n    this.vertexData = new Float32Array(8);\n    this.vertexTrimmedData = null;\n    this._transformID = -1;\n    this._textureID = -1;\n    this._transformTrimmedID = -1;\n    this._textureTrimmedID = -1;\n    this.indices = indices;\n    this.pluginName = "batch";\n    this.isSprite = true;\n    this._roundPixels = lib/* settings.ROUND_PIXELS */.Xd.ROUND_PIXELS;\n  }\n  _onTextureUpdate() {\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 16777215;\n    if (this._width) {\n      this.scale.x = lib/* utils.sign */.P6.sign(this.scale.x) * this._width / this._texture.orig.width;\n    }\n    if (this._height) {\n      this.scale.y = lib/* utils.sign */.P6.sign(this.scale.y) * this._height / this._texture.orig.height;\n    }\n  }\n  _onAnchorUpdate() {\n    this._transformID = -1;\n    this._transformTrimmedID = -1;\n  }\n  calculateVertices() {\n    const texture = this._texture;\n    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {\n      return;\n    }\n    if (this._textureID !== texture._updateID) {\n      this.uvs = this._texture._uvs.uvsFloat32;\n    }\n    this._transformID = this.transform._worldID;\n    this._textureID = texture._updateID;\n    const wt = this.transform.worldTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const vertexData = this.vertexData;\n    const trim = texture.trim;\n    const orig = texture.orig;\n    const anchor = this._anchor;\n    let w0 = 0;\n    let w1 = 0;\n    let h0 = 0;\n    let h1 = 0;\n    if (trim) {\n      w1 = trim.x - anchor._x * orig.width;\n      w0 = w1 + trim.width;\n      h1 = trim.y - anchor._y * orig.height;\n      h0 = h1 + trim.height;\n    } else {\n      w1 = -anchor._x * orig.width;\n      w0 = w1 + orig.width;\n      h1 = -anchor._y * orig.height;\n      h0 = h1 + orig.height;\n    }\n    vertexData[0] = a * w1 + c * h1 + tx;\n    vertexData[1] = d * h1 + b * w1 + ty;\n    vertexData[2] = a * w0 + c * h1 + tx;\n    vertexData[3] = d * h1 + b * w0 + ty;\n    vertexData[4] = a * w0 + c * h0 + tx;\n    vertexData[5] = d * h0 + b * w0 + ty;\n    vertexData[6] = a * w1 + c * h0 + tx;\n    vertexData[7] = d * h0 + b * w1 + ty;\n    if (this._roundPixels) {\n      const resolution = lib/* settings.RESOLUTION */.Xd.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i) {\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n      }\n    }\n  }\n  calculateTrimmedVertices() {\n    if (!this.vertexTrimmedData) {\n      this.vertexTrimmedData = new Float32Array(8);\n    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {\n      return;\n    }\n    this._transformTrimmedID = this.transform._worldID;\n    this._textureTrimmedID = this._texture._updateID;\n    const texture = this._texture;\n    const vertexData = this.vertexTrimmedData;\n    const orig = texture.orig;\n    const anchor = this._anchor;\n    const wt = this.transform.worldTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const w1 = -anchor._x * orig.width;\n    const w0 = w1 + orig.width;\n    const h1 = -anchor._y * orig.height;\n    const h0 = h1 + orig.height;\n    vertexData[0] = a * w1 + c * h1 + tx;\n    vertexData[1] = d * h1 + b * w1 + ty;\n    vertexData[2] = a * w0 + c * h1 + tx;\n    vertexData[3] = d * h1 + b * w0 + ty;\n    vertexData[4] = a * w0 + c * h0 + tx;\n    vertexData[5] = d * h0 + b * w0 + ty;\n    vertexData[6] = a * w1 + c * h0 + tx;\n    vertexData[7] = d * h0 + b * w1 + ty;\n  }\n  _render(renderer) {\n    this.calculateVertices();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  }\n  _calculateBounds() {\n    const trim = this._texture.trim;\n    const orig = this._texture.orig;\n    if (!trim || trim.width === orig.width && trim.height === orig.height) {\n      this.calculateVertices();\n      this._bounds.addQuad(this.vertexData);\n    } else {\n      this.calculateTrimmedVertices();\n      this._bounds.addQuad(this.vertexTrimmedData);\n    }\n  }\n  getLocalBounds(rect) {\n    if (this.children.length === 0) {\n      if (!this._localBounds) {\n        this._localBounds = new display_lib/* Bounds */.YZ();\n      }\n      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;\n      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;\n      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);\n      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new lib/* Rectangle */.Ae();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._localBounds.getRectangle(rect);\n    }\n    return super.getLocalBounds.call(this, rect);\n  }\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    const width = this._texture.orig.width;\n    const height = this._texture.orig.height;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._texture.off("update", this._onTextureUpdate, this);\n    this._anchor = null;\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyBaseTexture = typeof options === "boolean" ? options : options?.baseTexture;\n      this._texture.destroy(!!destroyBaseTexture);\n    }\n    this._texture = null;\n  }\n  static from(source, options) {\n    const texture = source instanceof lib/* Texture */.xE ? source : lib/* Texture.from */.xE.from(source, options);\n    return new Sprite_Sprite(texture);\n  }\n  set roundPixels(value) {\n    if (this._roundPixels !== value) {\n      this._transformID = -1;\n    }\n    this._roundPixels = value;\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    const s = lib/* utils.sign */.P6.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._texture.orig.width;\n    this._width = value;\n  }\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    const s = lib/* utils.sign */.P6.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._texture.orig.height;\n    this._height = value;\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    this._anchor.copyFrom(value);\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value);\n    this._tintRGB = this._tintColor.toLittleEndianNumber();\n  }\n  get tintValue() {\n    return this._tintColor.toNumber();\n  }\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this._texture === value) {\n      return;\n    }\n    if (this._texture) {\n      this._texture.off("update", this._onTextureUpdate, this);\n    }\n    this._texture = value || lib/* Texture.EMPTY */.xE.EMPTY;\n    this._cachedTint = 16777215;\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    if (value) {\n      if (value.baseTexture.valid) {\n        this._onTextureUpdate();\n      } else {\n        value.once("update", this._onTextureUpdate, this);\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=Sprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs\n\n\n\n\nconst _tempMatrix = new lib/* Matrix */.y3();\ndisplay_lib/* DisplayObject.prototype._cacheAsBitmap */.s$.prototype._cacheAsBitmap = false;\ndisplay_lib/* DisplayObject.prototype._cacheData */.s$.prototype._cacheData = null;\ndisplay_lib/* DisplayObject.prototype._cacheAsBitmapResolution */.s$.prototype._cacheAsBitmapResolution = null;\ndisplay_lib/* DisplayObject.prototype._cacheAsBitmapMultisample */.s$.prototype._cacheAsBitmapMultisample = null;\nclass CacheData {\n  constructor() {\n    this.textureCacheId = null;\n    this.originalRender = null;\n    this.originalRenderCanvas = null;\n    this.originalCalculateBounds = null;\n    this.originalGetLocalBounds = null;\n    this.originalUpdateTransform = null;\n    this.originalDestroy = null;\n    this.originalMask = null;\n    this.originalFilterArea = null;\n    this.originalContainsPoint = null;\n    this.sprite = null;\n  }\n}\nObject.defineProperties(display_lib/* DisplayObject.prototype */.s$.prototype, {\n  cacheAsBitmapResolution: {\n    get() {\n      return this._cacheAsBitmapResolution;\n    },\n    set(resolution) {\n      if (resolution === this._cacheAsBitmapResolution) {\n        return;\n      }\n      this._cacheAsBitmapResolution = resolution;\n      if (this.cacheAsBitmap) {\n        this.cacheAsBitmap = false;\n        this.cacheAsBitmap = true;\n      }\n    }\n  },\n  cacheAsBitmapMultisample: {\n    get() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set(multisample) {\n      if (multisample === this._cacheAsBitmapMultisample) {\n        return;\n      }\n      this._cacheAsBitmapMultisample = multisample;\n      if (this.cacheAsBitmap) {\n        this.cacheAsBitmap = false;\n        this.cacheAsBitmap = true;\n      }\n    }\n  },\n  cacheAsBitmap: {\n    get() {\n      return this._cacheAsBitmap;\n    },\n    set(value) {\n      if (this._cacheAsBitmap === value) {\n        return;\n      }\n      this._cacheAsBitmap = value;\n      let data;\n      if (value) {\n        if (!this._cacheData) {\n          this._cacheData = new CacheData();\n        }\n        data = this._cacheData;\n        data.originalRender = this.render;\n        data.originalRenderCanvas = this.renderCanvas;\n        data.originalUpdateTransform = this.updateTransform;\n        data.originalCalculateBounds = this.calculateBounds;\n        data.originalGetLocalBounds = this.getLocalBounds;\n        data.originalDestroy = this.destroy;\n        data.originalContainsPoint = this.containsPoint;\n        data.originalMask = this._mask;\n        data.originalFilterArea = this.filterArea;\n        this.render = this._renderCached;\n        this.renderCanvas = this._renderCachedCanvas;\n        this.destroy = this._cacheAsBitmapDestroy;\n      } else {\n        data = this._cacheData;\n        if (data.sprite) {\n          this._destroyCachedDisplayObject();\n        }\n        this.render = data.originalRender;\n        this.renderCanvas = data.originalRenderCanvas;\n        this.calculateBounds = data.originalCalculateBounds;\n        this.getLocalBounds = data.originalGetLocalBounds;\n        this.destroy = data.originalDestroy;\n        this.updateTransform = data.originalUpdateTransform;\n        this.containsPoint = data.originalContainsPoint;\n        this._mask = data.originalMask;\n        this.filterArea = data.originalFilterArea;\n      }\n    }\n  }\n});\ndisplay_lib/* DisplayObject.prototype._renderCached */.s$.prototype._renderCached = function _renderCached(renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n    return;\n  }\n  this._initCachedDisplayObject(renderer);\n  this._cacheData.sprite.transform._worldID = this.transform._worldID;\n  this._cacheData.sprite.worldAlpha = this.worldAlpha;\n  this._cacheData.sprite._render(renderer);\n};\ndisplay_lib/* DisplayObject.prototype._initCachedDisplayObject */.s$.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {\n  if (this._cacheData?.sprite) {\n    return;\n  }\n  const cacheAlpha = this.alpha;\n  this.alpha = 1;\n  renderer.batch.flush();\n  const bounds = this.getLocalBounds(null, true).clone();\n  if (this.filters?.length) {\n    const padding = this.filters[0].padding;\n    bounds.pad(padding);\n  }\n  bounds.ceil(lib/* settings.RESOLUTION */.Xd.RESOLUTION);\n  const cachedRenderTexture = renderer.renderTexture.current;\n  const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();\n  const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();\n  const cachedProjectionTransform = renderer.projection.transform;\n  const renderTexture = lib/* RenderTexture.create */.TI.create({\n    width: bounds.width,\n    height: bounds.height,\n    resolution: this.cacheAsBitmapResolution || renderer.resolution,\n    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample\n  });\n  const textureCacheId = `cacheAsBitmap_${lib/* utils.uid */.P6.uid()}`;\n  this._cacheData.textureCacheId = textureCacheId;\n  lib/* BaseTexture.addToCache */.VL.addToCache(renderTexture.baseTexture, textureCacheId);\n  lib/* Texture.addToCache */.xE.addToCache(renderTexture, textureCacheId);\n  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);\n  this.render = this._cacheData.originalRender;\n  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });\n  renderer.framebuffer.blit();\n  renderer.projection.transform = cachedProjectionTransform;\n  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);\n  this.render = this._renderCached;\n  this.updateTransform = this.displayObjectUpdateTransform;\n  this.calculateBounds = this._calculateCachedBounds;\n  this.getLocalBounds = this._getCachedLocalBounds;\n  this._mask = null;\n  this.filterArea = null;\n  this.alpha = cacheAlpha;\n  const cachedSprite = new Sprite_Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform;\n  cachedSprite.anchor.x = -(bounds.x / bounds.width);\n  cachedSprite.anchor.y = -(bounds.y / bounds.height);\n  cachedSprite.alpha = cacheAlpha;\n  cachedSprite._bounds = this._bounds;\n  this._cacheData.sprite = cachedSprite;\n  this.transform._parentID = -1;\n  if (!this.parent) {\n    this.enableTempParent();\n    this.updateTransform();\n    this.disableTempParent(null);\n  } else {\n    this.updateTransform();\n  }\n  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\ndisplay_lib/* DisplayObject.prototype._renderCachedCanvas */.s$.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n    return;\n  }\n  this._initCachedDisplayObjectCanvas(renderer);\n  this._cacheData.sprite.worldAlpha = this.worldAlpha;\n  this._cacheData.sprite._renderCanvas(renderer);\n};\ndisplay_lib/* DisplayObject.prototype._initCachedDisplayObjectCanvas */.s$.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {\n  if (this._cacheData?.sprite) {\n    return;\n  }\n  const bounds = this.getLocalBounds(null, true);\n  const cacheAlpha = this.alpha;\n  this.alpha = 1;\n  const cachedRenderTarget = renderer.canvasContext.activeContext;\n  const cachedProjectionTransform = renderer._projTransform;\n  bounds.ceil(lib/* settings.RESOLUTION */.Xd.RESOLUTION);\n  const renderTexture = lib/* RenderTexture.create */.TI.create({ width: bounds.width, height: bounds.height });\n  const textureCacheId = `cacheAsBitmap_${lib/* utils.uid */.P6.uid()}`;\n  this._cacheData.textureCacheId = textureCacheId;\n  lib/* BaseTexture.addToCache */.VL.addToCache(renderTexture.baseTexture, textureCacheId);\n  lib/* Texture.addToCache */.xE.addToCache(renderTexture, textureCacheId);\n  const m = _tempMatrix;\n  this.transform.localTransform.copyTo(m);\n  m.invert();\n  m.tx -= bounds.x;\n  m.ty -= bounds.y;\n  this.renderCanvas = this._cacheData.originalRenderCanvas;\n  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });\n  renderer.canvasContext.activeContext = cachedRenderTarget;\n  renderer._projTransform = cachedProjectionTransform;\n  this.renderCanvas = this._renderCachedCanvas;\n  this.updateTransform = this.displayObjectUpdateTransform;\n  this.calculateBounds = this._calculateCachedBounds;\n  this.getLocalBounds = this._getCachedLocalBounds;\n  this._mask = null;\n  this.filterArea = null;\n  this.alpha = cacheAlpha;\n  const cachedSprite = new Sprite_Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform;\n  cachedSprite.anchor.x = -(bounds.x / bounds.width);\n  cachedSprite.anchor.y = -(bounds.y / bounds.height);\n  cachedSprite.alpha = cacheAlpha;\n  cachedSprite._bounds = this._bounds;\n  this._cacheData.sprite = cachedSprite;\n  this.transform._parentID = -1;\n  if (!this.parent) {\n    this.parent = renderer._tempDisplayObjectParent;\n    this.updateTransform();\n    this.parent = null;\n  } else {\n    this.updateTransform();\n  }\n  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\ndisplay_lib/* DisplayObject.prototype._calculateCachedBounds */.s$.prototype._calculateCachedBounds = function _calculateCachedBounds() {\n  this._bounds.clear();\n  this._cacheData.sprite.transform._worldID = this.transform._worldID;\n  this._cacheData.sprite._calculateBounds();\n  this._bounds.updateID = this._boundsID;\n};\ndisplay_lib/* DisplayObject.prototype._getCachedLocalBounds */.s$.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\ndisplay_lib/* DisplayObject.prototype._destroyCachedDisplayObject */.s$.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {\n  this._cacheData.sprite._texture.destroy(true);\n  this._cacheData.sprite = null;\n  lib/* BaseTexture.removeFromCache */.VL.removeFromCache(this._cacheData.textureCacheId);\n  lib/* Texture.removeFromCache */.xE.removeFromCache(this._cacheData.textureCacheId);\n  this._cacheData.textureCacheId = null;\n};\ndisplay_lib/* DisplayObject.prototype._cacheAsBitmapDestroy */.s$.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {\n  this.cacheAsBitmap = false;\n  this.destroy(options);\n};\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs\n\n\ndisplay_lib/* DisplayObject.prototype.name */.s$.prototype.name = null;\ndisplay_lib/* Container.prototype.getChildByName */.W2.prototype.getChildByName = function getChildByName(name, deep) {\n  for (let i = 0, j = this.children.length; i < j; i++) {\n    if (this.children[i].name === name) {\n      return this.children[i];\n    }\n  }\n  if (deep) {\n    for (let i = 0, j = this.children.length; i < j; i++) {\n      const child = this.children[i];\n      if (!child.getChildByName) {\n        continue;\n      }\n      const target = child.getChildByName(name, true);\n      if (target) {\n        return target;\n      }\n    }\n  }\n  return null;\n};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-get-global-position/lib/index.mjs\n\n\n\ndisplay_lib/* DisplayObject.prototype.getGlobalPosition */.s$.prototype.getGlobalPosition = function getGlobalPosition(point = new lib/* Point */.E9(), skipUpdate = false) {\n  if (this.parent) {\n    this.parent.toGlobal(this.position, point, skipUpdate);\n  } else {\n    point.x = this.position.x;\n    point.y = this.position.y;\n  }\n  return point;\n};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/alpha.mjs\nvar fragment = "varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform float uAlpha;\\n\\nvoid main(void)\\n{\\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\\n}\\n";\n\n\n//# sourceMappingURL=alpha.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs\n\n\n\nclass AlphaFilter extends lib/* Filter */.wn {\n  constructor(alpha = 1) {\n    super(lib/* defaultVertex */.kP, fragment, { uAlpha: 1 });\n    this.alpha = alpha;\n  }\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n}\n\n\n//# sourceMappingURL=AlphaFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs\nconst GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n};\nconst fragTemplate = [\n  "varying vec2 vBlurTexCoords[%size%];",\n  "uniform sampler2D uSampler;",\n  "void main(void)",\n  "{",\n  "    gl_FragColor = vec4(0.0);",\n  "    %blur%",\n  "}"\n].join("\\n");\nfunction generateBlurFragSource(kernelSize) {\n  const kernel = GAUSSIAN_VALUES[kernelSize];\n  const halfLength = kernel.length;\n  let fragSource = fragTemplate;\n  let blurLoop = "";\n  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";\n  let value;\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace("%index%", i.toString());\n    value = i;\n    if (i >= halfLength) {\n      value = kernelSize - i - 1;\n    }\n    blur = blur.replace("%value%", kernel[value].toString());\n    blurLoop += blur;\n    blurLoop += "\\n";\n  }\n  fragSource = fragSource.replace("%blur%", blurLoop);\n  fragSource = fragSource.replace("%size%", kernelSize.toString());\n  return fragSource;\n}\n\n\n//# sourceMappingURL=generateBlurFragSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs\nconst vertTemplate = `\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(kernelSize, x) {\n  const halfLength = Math.ceil(kernelSize / 2);\n  let vertSource = vertTemplate;\n  let blurLoop = "";\n  let template;\n  if (x) {\n    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";\n  } else {\n    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";\n  }\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace("%index%", i.toString());\n    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);\n    blurLoop += blur;\n    blurLoop += "\\n";\n  }\n  vertSource = vertSource.replace("%blur%", blurLoop);\n  vertSource = vertSource.replace("%size%", kernelSize.toString());\n  return vertSource;\n}\n\n\n//# sourceMappingURL=generateBlurVertSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs\n\n\n\n\nclass BlurFilterPass extends lib/* Filter */.wn {\n  constructor(horizontal, strength = 8, quality = 4, resolution = lib/* Filter.defaultResolution */.wn.defaultResolution, kernelSize = 5) {\n    const vertSrc = generateBlurVertSource(kernelSize, horizontal);\n    const fragSrc = generateBlurFragSource(kernelSize);\n    super(vertSrc, fragSrc);\n    this.horizontal = horizontal;\n    this.resolution = resolution;\n    this._quality = 0;\n    this.quality = quality;\n    this.blur = strength;\n  }\n  apply(filterManager, input, output, clearMode) {\n    if (output) {\n      if (this.horizontal) {\n        this.uniforms.strength = 1 / output.width * (output.width / input.width);\n      } else {\n        this.uniforms.strength = 1 / output.height * (output.height / input.height);\n      }\n    } else {\n      if (this.horizontal) {\n        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);\n      } else {\n        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);\n      }\n    }\n    this.uniforms.strength *= this.strength;\n    this.uniforms.strength /= this.passes;\n    if (this.passes === 1) {\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      const renderTarget = filterManager.getFilterTexture();\n      const renderer = filterManager.renderer;\n      let flip = input;\n      let flop = renderTarget;\n      this.state.blend = false;\n      filterManager.applyFilter(this, flip, flop, lib/* CLEAR_MODES.CLEAR */.yl.CLEAR);\n      for (let i = 1; i < this.passes - 1; i++) {\n        filterManager.bindAndClear(flip, lib/* CLEAR_MODES.BLIT */.yl.BLIT);\n        this.uniforms.uSampler = flop;\n        const temp = flop;\n        flop = flip;\n        flip = temp;\n        renderer.shader.bind(this);\n        renderer.geometry.draw(5);\n      }\n      this.state.blend = true;\n      filterManager.applyFilter(this, flop, output, clearMode);\n      filterManager.returnFilterTexture(renderTarget);\n    }\n  }\n  get blur() {\n    return this.strength;\n  }\n  set blur(value) {\n    this.padding = 1 + Math.abs(value) * 2;\n    this.strength = value;\n  }\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = value;\n    this.passes = value;\n  }\n}\n\n\n//# sourceMappingURL=BlurFilterPass.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/BlurFilter.mjs\n\n\n\nclass BlurFilter extends lib/* Filter */.wn {\n  constructor(strength = 8, quality = 4, resolution = lib/* Filter.defaultResolution */.wn.defaultResolution, kernelSize = 5) {\n    super();\n    this._repeatEdgePixels = false;\n    this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);\n    this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);\n    this.resolution = resolution;\n    this.quality = quality;\n    this.blur = strength;\n    this.repeatEdgePixels = false;\n  }\n  apply(filterManager, input, output, clearMode) {\n    const xStrength = Math.abs(this.blurXFilter.strength);\n    const yStrength = Math.abs(this.blurYFilter.strength);\n    if (xStrength && yStrength) {\n      const renderTarget = filterManager.getFilterTexture();\n      this.blurXFilter.apply(filterManager, input, renderTarget, lib/* CLEAR_MODES.CLEAR */.yl.CLEAR);\n      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);\n      filterManager.returnFilterTexture(renderTarget);\n    } else if (yStrength) {\n      this.blurYFilter.apply(filterManager, input, output, clearMode);\n    } else {\n      this.blurXFilter.apply(filterManager, input, output, clearMode);\n    }\n  }\n  updatePadding() {\n    if (this._repeatEdgePixels) {\n      this.padding = 0;\n    } else {\n      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n    }\n  }\n  get blur() {\n    return this.blurXFilter.blur;\n  }\n  set blur(value) {\n    this.blurXFilter.blur = this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  get quality() {\n    return this.blurXFilter.quality;\n  }\n  set quality(value) {\n    this.blurXFilter.quality = this.blurYFilter.quality = value;\n  }\n  get blurX() {\n    return this.blurXFilter.blur;\n  }\n  set blurX(value) {\n    this.blurXFilter.blur = value;\n    this.updatePadding();\n  }\n  get blurY() {\n    return this.blurYFilter.blur;\n  }\n  set blurY(value) {\n    this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  get blendMode() {\n    return this.blurYFilter.blendMode;\n  }\n  set blendMode(value) {\n    this.blurYFilter.blendMode = value;\n  }\n  get repeatEdgePixels() {\n    return this._repeatEdgePixels;\n  }\n  set repeatEdgePixels(value) {\n    this._repeatEdgePixels = value;\n    this.updatePadding();\n  }\n}\n\n\n//# sourceMappingURL=BlurFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.mjs\nvar colorMatrix_fragment = "varying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\nuniform float m[20];\\nuniform float uAlpha;\\n\\nvoid main(void)\\n{\\n    vec4 c = texture2D(uSampler, vTextureCoord);\\n\\n    if (uAlpha == 0.0) {\\n        gl_FragColor = c;\\n        return;\\n    }\\n\\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (c.a > 0.0) {\\n      c.rgb /= c.a;\\n    }\\n\\n    vec4 result;\\n\\n    result.r = (m[0] * c.r);\\n        result.r += (m[1] * c.g);\\n        result.r += (m[2] * c.b);\\n        result.r += (m[3] * c.a);\\n        result.r += m[4];\\n\\n    result.g = (m[5] * c.r);\\n        result.g += (m[6] * c.g);\\n        result.g += (m[7] * c.b);\\n        result.g += (m[8] * c.a);\\n        result.g += m[9];\\n\\n    result.b = (m[10] * c.r);\\n       result.b += (m[11] * c.g);\\n       result.b += (m[12] * c.b);\\n       result.b += (m[13] * c.a);\\n       result.b += m[14];\\n\\n    result.a = (m[15] * c.r);\\n       result.a += (m[16] * c.g);\\n       result.a += (m[17] * c.b);\\n       result.a += (m[18] * c.a);\\n       result.a += m[19];\\n\\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\\n\\n    // Premultiply alpha again.\\n    rgb *= result.a;\\n\\n    gl_FragColor = vec4(rgb, result.a);\\n}\\n";\n\n\n//# sourceMappingURL=colorMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs\n\n\n\nclass ColorMatrixFilter extends lib/* Filter */.wn {\n  constructor() {\n    const uniforms = {\n      m: new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ]),\n      uAlpha: 1\n    };\n    super(lib/* defaultFilterVertex */.Y9, colorMatrix_fragment, uniforms);\n    this.alpha = 1;\n  }\n  _loadMatrix(matrix, multiply = false) {\n    let newMatrix = matrix;\n    if (multiply) {\n      this._multiply(newMatrix, this.uniforms.m, matrix);\n      newMatrix = this._colorMatrix(newMatrix);\n    }\n    this.uniforms.m = newMatrix;\n  }\n  _multiply(out, a, b) {\n    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];\n    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];\n    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];\n    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];\n    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];\n    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];\n    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];\n    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];\n    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];\n    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];\n    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];\n    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];\n    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];\n    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];\n    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];\n    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];\n    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];\n    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];\n    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];\n    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];\n    return out;\n  }\n  _colorMatrix(matrix) {\n    const m = new Float32Array(matrix);\n    m[4] /= 255;\n    m[9] /= 255;\n    m[14] /= 255;\n    m[19] /= 255;\n    return m;\n  }\n  brightness(b, multiply) {\n    const matrix = [\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  tint(color, multiply) {\n    const [r, g, b] = lib/* Color.shared.setValue */.Il.shared.setValue(color).toArray();\n    const matrix = [\n      r,\n      0,\n      0,\n      0,\n      0,\n      0,\n      g,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  greyscale(scale, multiply) {\n    const matrix = [\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  blackAndWhite(multiply) {\n    const matrix = [\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  hue(rotation, multiply) {\n    rotation = (rotation || 0) / 180 * Math.PI;\n    const cosR = Math.cos(rotation);\n    const sinR = Math.sin(rotation);\n    const sqrt = Math.sqrt;\n    const w = 1 / 3;\n    const sqrW = sqrt(w);\n    const a00 = cosR + (1 - cosR) * w;\n    const a01 = w * (1 - cosR) - sqrW * sinR;\n    const a02 = w * (1 - cosR) + sqrW * sinR;\n    const a10 = w * (1 - cosR) + sqrW * sinR;\n    const a11 = cosR + w * (1 - cosR);\n    const a12 = w * (1 - cosR) - sqrW * sinR;\n    const a20 = w * (1 - cosR) - sqrW * sinR;\n    const a21 = w * (1 - cosR) + sqrW * sinR;\n    const a22 = cosR + w * (1 - cosR);\n    const matrix = [\n      a00,\n      a01,\n      a02,\n      0,\n      0,\n      a10,\n      a11,\n      a12,\n      0,\n      0,\n      a20,\n      a21,\n      a22,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  contrast(amount, multiply) {\n    const v = (amount || 0) + 1;\n    const o = -0.5 * (v - 1);\n    const matrix = [\n      v,\n      0,\n      0,\n      0,\n      o,\n      0,\n      v,\n      0,\n      0,\n      o,\n      0,\n      0,\n      v,\n      0,\n      o,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  saturate(amount = 0, multiply) {\n    const x = amount * 2 / 3 + 1;\n    const y = (x - 1) * -0.5;\n    const matrix = [\n      x,\n      y,\n      y,\n      0,\n      0,\n      y,\n      x,\n      y,\n      0,\n      0,\n      y,\n      y,\n      x,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  desaturate() {\n    this.saturate(-1);\n  }\n  negative(multiply) {\n    const matrix = [\n      -1,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  sepia(multiply) {\n    const matrix = [\n      0.393,\n      0.7689999,\n      0.18899999,\n      0,\n      0,\n      0.349,\n      0.6859999,\n      0.16799999,\n      0,\n      0,\n      0.272,\n      0.5339999,\n      0.13099999,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  technicolor(multiply) {\n    const matrix = [\n      1.9125277891456083,\n      -0.8545344976951645,\n      -0.09155508482755585,\n      0,\n      11.793603434377337,\n      -0.3087833385928097,\n      1.7658908555458428,\n      -0.10601743074722245,\n      0,\n      -70.35205161461398,\n      -0.231103377548616,\n      -0.7501899197440212,\n      1.847597816108189,\n      0,\n      30.950940869491138,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  polaroid(multiply) {\n    const matrix = [\n      1.438,\n      -0.062,\n      -0.062,\n      0,\n      0,\n      -0.122,\n      1.378,\n      -0.122,\n      0,\n      0,\n      -0.016,\n      -0.016,\n      1.483,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  toBGR(multiply) {\n    const matrix = [\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  kodachrome(multiply) {\n    const matrix = [\n      1.1285582396593525,\n      -0.3967382283601348,\n      -0.03992559172921793,\n      0,\n      63.72958762196502,\n      -0.16404339962244616,\n      1.0835251566291304,\n      -0.05498805115633132,\n      0,\n      24.732407896706203,\n      -0.16786010706155763,\n      -0.5603416277695248,\n      1.6014850761964943,\n      0,\n      35.62982807460946,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  browni(multiply) {\n    const matrix = [\n      0.5997023498159715,\n      0.34553243048391263,\n      -0.2708298674538042,\n      0,\n      47.43192855600873,\n      -0.037703249837783157,\n      0.8609577587992641,\n      0.15059552388459913,\n      0,\n      -36.96841498319127,\n      0.24113635128153335,\n      -0.07441037908422492,\n      0.44972182064877153,\n      0,\n      -7.562075277591283,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  vintage(multiply) {\n    const matrix = [\n      0.6279345635605994,\n      0.3202183420819367,\n      -0.03965408211312453,\n      0,\n      9.651285835294123,\n      0.02578397704808868,\n      0.6441188644374771,\n      0.03259127616149294,\n      0,\n      7.462829176470591,\n      0.0466055556782719,\n      -0.0851232987247891,\n      0.5241648018700465,\n      0,\n      5.159190588235296,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  colorTone(desaturation, toned, lightColor, darkColor, multiply) {\n    desaturation = desaturation || 0.2;\n    toned = toned || 0.15;\n    lightColor = lightColor || 16770432;\n    darkColor = darkColor || 3375104;\n    const temp = lib/* Color.shared */.Il.shared;\n    const [lR, lG, lB] = temp.setValue(lightColor).toArray();\n    const [dR, dG, dB] = temp.setValue(darkColor).toArray();\n    const matrix = [\n      0.3,\n      0.59,\n      0.11,\n      0,\n      0,\n      lR,\n      lG,\n      lB,\n      desaturation,\n      0,\n      dR,\n      dG,\n      dB,\n      toned,\n      0,\n      lR - dR,\n      lG - dG,\n      lB - dB,\n      0,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  night(intensity, multiply) {\n    intensity = intensity || 0.1;\n    const matrix = [\n      intensity * -2,\n      -intensity,\n      0,\n      0,\n      0,\n      -intensity,\n      0,\n      intensity,\n      0,\n      0,\n      0,\n      intensity,\n      intensity * 2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  predator(amount, multiply) {\n    const matrix = [\n      11.224130630493164 * amount,\n      -4.794486999511719 * amount,\n      -2.8746118545532227 * amount,\n      0 * amount,\n      0.40342438220977783 * amount,\n      -3.6330697536468506 * amount,\n      9.193157196044922 * amount,\n      -2.951810836791992 * amount,\n      0 * amount,\n      -1.316135048866272 * amount,\n      -3.2184197902679443 * amount,\n      -4.2375030517578125 * amount,\n      7.476448059082031 * amount,\n      0 * amount,\n      0.8044459223747253 * amount,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  lsd(multiply) {\n    const matrix = [\n      2,\n      -0.4,\n      0.5,\n      0,\n      0,\n      -0.5,\n      2,\n      -0.4,\n      0,\n      0,\n      -0.4,\n      -0.5,\n      3,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  reset() {\n    const matrix = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, false);\n  }\n  get matrix() {\n    return this.uniforms.m;\n  }\n  set matrix(value) {\n    this.uniforms.m = value;\n  }\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n}\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\n\n\n//# sourceMappingURL=ColorMatrixFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/displacement.mjs\nvar displacement_fragment = "varying vec2 vFilterCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform vec2 scale;\\nuniform mat2 rotation;\\nuniform sampler2D uSampler;\\nuniform sampler2D mapSampler;\\n\\nuniform highp vec4 inputSize;\\nuniform vec4 inputClamp;\\n\\nvoid main(void)\\n{\\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\\n\\n  map -= 0.5;\\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\\n\\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\\n}\\n";\n\n\n//# sourceMappingURL=displacement.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/displacement2.mjs\nvar vertex = "attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 filterMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vFilterCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n\\tgl_Position = filterVertexPosition();\\n\\tvTextureCoord = filterTextureCoord();\\n\\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\\n}\\n";\n\n\n//# sourceMappingURL=displacement2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs\n\n\n\n\nclass DisplacementFilter extends lib/* Filter */.wn {\n  constructor(sprite, scale) {\n    const maskMatrix = new lib/* Matrix */.y3();\n    sprite.renderable = false;\n    super(vertex, displacement_fragment, {\n      mapSampler: sprite._texture,\n      filterMatrix: maskMatrix,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    });\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n    if (scale === null || scale === void 0) {\n      scale = 20;\n    }\n    this.scale = new lib/* Point */.E9(scale, scale);\n  }\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n    this.uniforms.scale.x = this.scale.x;\n    this.uniforms.scale.y = this.scale.y;\n    const wt = this.maskSprite.worldTransform;\n    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);\n    if (lenX !== 0 && lenY !== 0) {\n      this.uniforms.rotation[0] = wt.a / lenX;\n      this.uniforms.rotation[1] = wt.b / lenX;\n      this.uniforms.rotation[2] = wt.c / lenY;\n      this.uniforms.rotation[3] = wt.d / lenY;\n    }\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  get map() {\n    return this.uniforms.mapSampler;\n  }\n  set map(value) {\n    this.uniforms.mapSampler = value;\n  }\n}\n\n\n//# sourceMappingURL=DisplacementFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/fxaa.mjs\nvar fxaa_fragment = "varying vec2 v_rgbNW;\\nvarying vec2 v_rgbNE;\\nvarying vec2 v_rgbSW;\\nvarying vec2 v_rgbSE;\\nvarying vec2 v_rgbM;\\n\\nvarying vec2 vFragCoord;\\nuniform sampler2D uSampler;\\nuniform highp vec4 inputSize;\\n\\n\\n/**\\n Basic FXAA implementation based on the code on geeks3d.com with the\\n modification that the texture2DLod stuff was removed since it\'s\\n unsupported by WebGL.\\n\\n --\\n\\n From:\\n https://github.com/mitsuhiko/webgl-meincraft\\n\\n Copyright (c) 2011 by Armin Ronacher.\\n\\n Some rights reserved.\\n\\n Redistribution and use in source and binary forms, with or without\\n modification, are permitted provided that the following conditions are\\n met:\\n\\n * Redistributions of source code must retain the above copyright\\n notice, this list of conditions and the following disclaimer.\\n\\n * Redistributions in binary form must reproduce the above\\n copyright notice, this list of conditions and the following\\n disclaimer in the documentation and/or other materials provided\\n with the distribution.\\n\\n * The names of the contributors may not be used to endorse or\\n promote products derived from this software without specific\\n prior written permission.\\n\\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n \\"AS IS\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n#ifndef FXAA_REDUCE_MIN\\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\\n#endif\\n#ifndef FXAA_REDUCE_MUL\\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\\n#endif\\n#ifndef FXAA_SPAN_MAX\\n#define FXAA_SPAN_MAX     8.0\\n#endif\\n\\n//optimized version for mobile, where dependent\\n//texture reads can be a bottleneck\\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\\n          vec2 v_rgbNW, vec2 v_rgbNE,\\n          vec2 v_rgbSW, vec2 v_rgbSE,\\n          vec2 v_rgbM) {\\n    vec4 color;\\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\\n    vec4 texColor = texture2D(tex, v_rgbM);\\n    vec3 rgbM  = texColor.xyz;\\n    vec3 luma = vec3(0.299, 0.587, 0.114);\\n    float lumaNW = dot(rgbNW, luma);\\n    float lumaNE = dot(rgbNE, luma);\\n    float lumaSW = dot(rgbSW, luma);\\n    float lumaSE = dot(rgbSE, luma);\\n    float lumaM  = dot(rgbM,  luma);\\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\\n\\n    mediump vec2 dir;\\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n\\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\\n\\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\\n                  dir * rcpDirMin)) * inverseVP;\\n\\n    vec3 rgbA = 0.5 * (\\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\\n\\n    float lumaB = dot(rgbB, luma);\\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\\n        color = vec4(rgbA, texColor.a);\\n    else\\n        color = vec4(rgbB, texColor.a);\\n    return color;\\n}\\n\\nvoid main() {\\n\\n      vec4 color;\\n\\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\\n\\n      gl_FragColor = color;\\n}\\n";\n\n\n//# sourceMappingURL=fxaa.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/fxaa2.mjs\nvar fxaa2_vertex = "\\nattribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 v_rgbNW;\\nvarying vec2 v_rgbNE;\\nvarying vec2 v_rgbSW;\\nvarying vec2 v_rgbSE;\\nvarying vec2 v_rgbM;\\n\\nvarying vec2 vFragCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\\n               out vec2 v_rgbM) {\\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\\n    v_rgbM = vec2(fragCoord * inverseVP);\\n}\\n\\nvoid main(void) {\\n\\n   gl_Position = filterVertexPosition();\\n\\n   vFragCoord = aVertexPosition * outputFrame.zw;\\n\\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\\n}\\n";\n\n\n//# sourceMappingURL=fxaa2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs\n\n\n\n\nclass FXAAFilter extends lib/* Filter */.wn {\n  constructor() {\n    super(fxaa2_vertex, fxaa_fragment);\n  }\n}\n\n\n//# sourceMappingURL=FXAAFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/noise.mjs\nvar noise_fragment = "precision highp float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform float uNoise;\\nuniform float uSeed;\\nuniform sampler2D uSampler;\\n\\nfloat rand(vec2 co)\\n{\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture2D(uSampler, vTextureCoord);\\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\\n    float diff = (randomValue - 0.5) * uNoise;\\n\\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n    }\\n\\n    color.r += diff;\\n    color.g += diff;\\n    color.b += diff;\\n\\n    // Premultiply alpha again.\\n    color.rgb *= color.a;\\n\\n    gl_FragColor = color;\\n}\\n";\n\n\n//# sourceMappingURL=noise.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs\n\n\n\nclass NoiseFilter extends lib/* Filter */.wn {\n  constructor(noise = 0.5, seed = Math.random()) {\n    super(lib/* defaultFilterVertex */.Y9, noise_fragment, {\n      uNoise: 0,\n      uSeed: 0\n    });\n    this.noise = noise;\n    this.seed = seed;\n  }\n  get noise() {\n    return this.uniforms.uNoise;\n  }\n  set noise(value) {\n    this.uniforms.uNoise = value;\n  }\n  get seed() {\n    return this.uniforms.uSeed;\n  }\n  set seed(value) {\n    this.uniforms.uSeed = value;\n  }\n}\n\n\n//# sourceMappingURL=NoiseFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters.mjs\n\n\n\n\n\n\n\n\nconst filters = {\n  AlphaFilter: AlphaFilter,\n  BlurFilter: BlurFilter,\n  BlurFilterPass: BlurFilterPass,\n  ColorMatrixFilter: ColorMatrixFilter,\n  DisplacementFilter: DisplacementFilter,\n  FXAAFilter: FXAAFilter,\n  NoiseFilter: NoiseFilter\n};\nObject.entries(filters).forEach(([key, FilterClass]) => {\n  Object.defineProperty(filters, key, {\n    get() {\n      lib/* utils.deprecation */.P6.deprecation("7.1.0", `filters.${key} has moved to ${key}`);\n      return FilterClass;\n    }\n  });\n});\n\n\n//# sourceMappingURL=filters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventTicker.mjs\n\n\nclass EventsTickerClass {\n  constructor() {\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this.tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  init(events) {\n    this.removeTickerListener();\n    this.events = events;\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this.tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  get pauseUpdate() {\n    return this._pauseUpdate;\n  }\n  set pauseUpdate(paused) {\n    this._pauseUpdate = paused;\n  }\n  addTickerListener() {\n    if (this.tickerAdded || !this.domElement) {\n      return;\n    }\n    lib/* Ticker.system.add */.vB.system.add(this.tickerUpdate, this, lib/* UPDATE_PRIORITY.INTERACTION */.uF.INTERACTION);\n    this.tickerAdded = true;\n  }\n  removeTickerListener() {\n    if (!this.tickerAdded) {\n      return;\n    }\n    lib/* Ticker.system.remove */.vB.system.remove(this.tickerUpdate, this);\n    this.tickerAdded = false;\n  }\n  pointerMoved() {\n    this._didMove = true;\n  }\n  update() {\n    if (!this.domElement || this._pauseUpdate) {\n      return;\n    }\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    const rootPointerEvent = this.events["rootPointerEvent"];\n    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {\n      return;\n    }\n    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY\n    }));\n  }\n  tickerUpdate(deltaTime) {\n    this._deltaTime += deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this.update();\n  }\n}\nconst EventsTicker = new EventsTickerClass();\n\n\n//# sourceMappingURL=EventTicker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedEvent.mjs\n\n\nclass FederatedEvent {\n  constructor(manager) {\n    this.bubbles = true;\n    this.cancelBubble = true;\n    this.cancelable = false;\n    this.composed = false;\n    this.defaultPrevented = false;\n    this.eventPhase = FederatedEvent.prototype.NONE;\n    this.propagationStopped = false;\n    this.propagationImmediatelyStopped = false;\n    this.layer = new lib/* Point */.E9();\n    this.page = new lib/* Point */.E9();\n    this.NONE = 0;\n    this.CAPTURING_PHASE = 1;\n    this.AT_TARGET = 2;\n    this.BUBBLING_PHASE = 3;\n    this.manager = manager;\n  }\n  get layerX() {\n    return this.layer.x;\n  }\n  get layerY() {\n    return this.layer.y;\n  }\n  get pageX() {\n    return this.page.x;\n  }\n  get pageY() {\n    return this.page.y;\n  }\n  get data() {\n    return this;\n  }\n  composedPath() {\n    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {\n      this.path = this.target ? this.manager.propagationPath(this.target) : [];\n    }\n    return this.path;\n  }\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  preventDefault() {\n    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n      this.nativeEvent.preventDefault();\n    }\n    this.defaultPrevented = true;\n  }\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = true;\n  }\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\n\n//# sourceMappingURL=FederatedEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs\n\n\n\nclass FederatedMouseEvent extends FederatedEvent {\n  constructor() {\n    super(...arguments);\n    this.client = new lib/* Point */.E9();\n    this.movement = new lib/* Point */.E9();\n    this.offset = new lib/* Point */.E9();\n    this.global = new lib/* Point */.E9();\n    this.screen = new lib/* Point */.E9();\n  }\n  get clientX() {\n    return this.client.x;\n  }\n  get clientY() {\n    return this.client.y;\n  }\n  get x() {\n    return this.clientX;\n  }\n  get y() {\n    return this.clientY;\n  }\n  get movementX() {\n    return this.movement.x;\n  }\n  get movementY() {\n    return this.movement.y;\n  }\n  get offsetX() {\n    return this.offset.x;\n  }\n  get offsetY() {\n    return this.offset.y;\n  }\n  get globalX() {\n    return this.global.x;\n  }\n  get globalY() {\n    return this.global.y;\n  }\n  get screenX() {\n    return this.screen.x;\n  }\n  get screenY() {\n    return this.screen.y;\n  }\n  getLocalPosition(displayObject, point, globalPos) {\n    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  getModifierState(key) {\n    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error("Method not implemented.");\n  }\n}\n\n\n//# sourceMappingURL=FederatedMouseEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs\n\n\nclass FederatedPointerEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    this.width = 0;\n    this.height = 0;\n    this.isPrimary = false;\n  }\n  getCoalescedEvents() {\n    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {\n      return [this];\n    }\n    return [];\n  }\n  getPredictedEvents() {\n    throw new Error("getPredictedEvents is not supported!");\n  }\n}\n\n\n//# sourceMappingURL=FederatedPointerEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs\n\n\nclass FederatedWheelEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    this.DOM_DELTA_PIXEL = 0;\n    this.DOM_DELTA_LINE = 1;\n    this.DOM_DELTA_PAGE = 2;\n  }\n}\nFederatedWheelEvent.DOM_DELTA_PIXEL = 0;\nFederatedWheelEvent.DOM_DELTA_LINE = 1;\nFederatedWheelEvent.DOM_DELTA_PAGE = 2;\n\n\n//# sourceMappingURL=FederatedWheelEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventBoundary.mjs\n\n\n\n\n\n\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new lib/* Point */.E9();\nconst tempLocalMapping = new lib/* Point */.E9();\nclass EventBoundary {\n  constructor(rootTarget) {\n    this.dispatch = new lib/* utils.EventEmitter */.P6.EventEmitter();\n    this.moveOnAll = false;\n    this.enableGlobalMoveEvents = true;\n    this.mappingState = {\n      trackingData: {}\n    };\n    this.eventPool = /* @__PURE__ */ new Map();\n    this._allInteractiveElements = [];\n    this._hitElements = [];\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping("pointerdown", this.mapPointerDown);\n    this.addEventMapping("pointermove", this.mapPointerMove);\n    this.addEventMapping("pointerout", this.mapPointerOut);\n    this.addEventMapping("pointerleave", this.mapPointerOut);\n    this.addEventMapping("pointerover", this.mapPointerOver);\n    this.addEventMapping("pointerup", this.mapPointerUp);\n    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);\n    this.addEventMapping("wheel", this.mapWheel);\n  }\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n  }\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";\n    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);\n    return invertedPath && invertedPath[0];\n  }\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n  }\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach((event) => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {\n      if (!target.parent) {\n        throw new Error("Cannot find propagation path to disconnected target");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, pruneFn(currentTarget, location));\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive)\n              this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0)\n            this._hitElements = nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget)\n      this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0)\n      return null;\n    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn);\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive)\n            nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === "static" || int === "dynamic";\n  }\n  _interactivePrune(displayObject) {\n    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {\n      return true;\n    }\n    if (displayObject.eventMode === "none") {\n      return true;\n    }\n    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {\n      return true;\n    }\n    if (displayObject.isMask) {\n      return true;\n    }\n    return false;\n  }\n  hitPruneFn(displayObject, location) {\n    if (displayObject.hitArea) {\n      displayObject.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (displayObject._mask) {\n      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;\n      if (maskObject && !maskObject.containsPoint?.(location)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  hitTestFn(displayObject, location) {\n    if (displayObject.eventMode === "passive") {\n      return false;\n    }\n    if (displayObject.hitArea) {\n      return true;\n    }\n    if (displayObject.containsPoint) {\n      return displayObject.containsPoint(location);\n    }\n    return false;\n  }\n  notifyTarget(e, type) {\n    type = type ?? e.type;\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this.notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this.notifyListeners(e, type);\n    }\n  }\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, "pointerdown");\n    if (e.pointerType === "touch") {\n      this.dispatchEvent(e, "touchstart");\n    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, "pointerout");\n      if (isMouse)\n        this.dispatchEvent(outEvent, "mouseout");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse)\n            this.notifyTarget(leaveEvent, "mouseleave");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, "pointerover");\n      if (isMouse)\n        this.dispatchEvent(overEvent, "mouseover");\n      let overTargetAncestor = outTarget?.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target)\n          break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, "pointerenter");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse)\n            this.notifyTarget(enterEvent, "mouseenter");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");\n    allowGlobalPointerEvents && allMethods.push("globalpointermove");\n    if (e.pointerType === "touch") {\n      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");\n      allowGlobalPointerEvents && allMethods.push("globaltouchmove");\n    }\n    if (isMouse) {\n      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");\n      allowGlobalPointerEvents && allMethods.push("globalmousemove");\n      this.cursor = e.target?.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    this.dispatchEvent(e, "pointerover");\n    if (isMouse)\n      this.dispatchEvent(e, "mouseover");\n    if (e.pointerType === "mouse")\n      this.cursor = e.target?.cursor;\n    const enterEvent = this.clonePointerEvent(e, "pointerenter");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse)\n        this.notifyTarget(enterEvent, "mouseenter");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse)\n        this.dispatchEvent(outEvent, "mouseout");\n      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse)\n          this.notifyTarget(leaveEvent, "mouseleave");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, "pointerup");\n    if (e.pointerType === "touch") {\n      this.dispatchEvent(e, "touchend");\n    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, "pointerupoutside");\n        if (e.pointerType === "touch") {\n          this.notifyTarget(e, "touchendoutside");\n        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, "click");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === "mouse") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");\n      } else if (clickEvent.pointerType === "touch") {\n        this.dispatchEvent(clickEvent, "tap");\n      }\n      this.dispatchEvent(clickEvent, "pointertap");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, "pointerupoutside");\n        if (e.pointerType === "touch") {\n          this.notifyTarget(e, "touchendoutside");\n        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n    if (typeof type === "string") {\n      event.type = type;\n    }\n    return event;\n  }\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type ?? event.type;\n    return event;\n  }\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))\n      return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))\n      return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error("It is illegal to free an event not managed by this EventBoundary!");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners)\n      return;\n    if (!e.currentTarget.isInteractive())\n      return;\n    if ("fn" in listeners) {\n      if (listeners.once)\n        e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once)\n          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=EventBoundary.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventSystem.mjs\n\n\n\n\n\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER = {\n  touchstart: "pointerdown",\n  touchend: "pointerup",\n  touchendoutside: "pointerupoutside",\n  touchmove: "pointermove",\n  touchcancel: "pointercancel"\n};\nconst _EventSystem = class {\n  constructor(renderer) {\n    this.supportsTouchEvents = "ontouchstart" in globalThis;\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    this.domElement = null;\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary(null);\n    EventsTicker.init(this);\n    this.autoPreventDefault = true;\n    this.eventsAdded = false;\n    this.rootPointerEvent = new FederatedPointerEvent(null);\n    this.rootWheelEvent = new FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: "inherit",\n      pointer: "pointer"\n    };\n    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {\n      set: (target, key, value) => {\n        if (key === "globalMove") {\n          this.rootBoundary.enableGlobalMoveEvents = value;\n        }\n        target[key] = value;\n        return true;\n      }\n    });\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.onPointerOverOut = this.onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  static get defaultEventMode() {\n    return this._defaultEventMode;\n  }\n  init(options) {\n    const { view, resolution } = this.renderer;\n    this.setTargetElement(view);\n    this.resolution = resolution;\n    _EventSystem._defaultEventMode = options.eventMode ?? "auto";\n    Object.assign(this.features, options.eventFeatures ?? {});\n    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n  }\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  destroy() {\n    this.setTargetElement(null);\n    this.renderer = null;\n  }\n  setCursor(mode) {\n    mode = mode || "default";\n    let applyStyles = true;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    if (this.currentCursor === mode) {\n      return;\n    }\n    this.currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case "string":\n          if (applyStyles) {\n            this.domElement.style.cursor = style;\n          }\n          break;\n        case "function":\n          style(mode);\n          break;\n        case "object":\n          if (applyStyles) {\n            Object.assign(this.domElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.domElement.style.cursor = mode;\n    }\n  }\n  get pointer() {\n    return this.rootPointerEvent;\n  }\n  onPointerDown(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")\n      return;\n    const events = this.normalizeToPointerData(nativeEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);\n      if (cancelable) {\n        nativeEvent.preventDefault();\n      }\n    }\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i];\n      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerMove(nativeEvent) {\n    if (!this.features.move)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")\n      return;\n    EventsTicker.pointerMoved();\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerUp(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")\n      return;\n    let target = nativeEvent.target;\n    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n      target = nativeEvent.composedPath()[0];\n    }\n    const outside = target !== this.domElement ? "outside" : "";\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      event.type += outside;\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerOverOut(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")\n      return;\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onWheel(nativeEvent) {\n    if (!this.features.wheel)\n      return;\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    this.rootBoundary.mapEvent(wheelEvent);\n  }\n  setTargetElement(element) {\n    this.removeEvents();\n    this.domElement = element;\n    EventsTicker.domElement = element;\n    this.addEvents();\n  }\n  addEvents() {\n    if (this.eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.addTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = "none";\n        style.msTouchAction = "none";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = "none";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);\n      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);\n      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);\n      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);\n      globalThis.addEventListener("pointerup", this.onPointerUp, true);\n    } else {\n      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);\n      this.domElement.addEventListener("mousedown", this.onPointerDown, true);\n      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);\n      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);\n      globalThis.addEventListener("mouseup", this.onPointerUp, true);\n    }\n    if (this.supportsTouchEvents) {\n      this.domElement.addEventListener("touchstart", this.onPointerDown, true);\n      this.domElement.addEventListener("touchend", this.onPointerUp, true);\n      this.domElement.addEventListener("touchmove", this.onPointerMove, true);\n    }\n    this.domElement.addEventListener("wheel", this.onWheel, {\n      passive: true,\n      capture: true\n    });\n    this.eventsAdded = true;\n  }\n  removeEvents() {\n    if (!this.eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.removeTickerListener();\n    const style = this.domElement.style;\n    if (globalThis.navigator.msPointerEnabled) {\n      style.msContentZooming = "";\n      style.msTouchAction = "";\n    } else if (this.supportsPointerEvents) {\n      style.touchAction = "";\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);\n      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);\n      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);\n      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);\n      globalThis.removeEventListener("pointerup", this.onPointerUp, true);\n    } else {\n      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);\n      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);\n      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);\n      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);\n      globalThis.removeEventListener("mouseup", this.onPointerUp, true);\n    }\n    if (this.supportsTouchEvents) {\n      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);\n      this.domElement.removeEventListener("touchend", this.onPointerUp, true);\n      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);\n    }\n    this.domElement.removeEventListener("wheel", this.onWheel, true);\n    this.domElement = null;\n    this.eventsAdded = false;\n  }\n  mapPositionToPoint(point, x, y) {\n    let rect;\n    if (!this.domElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        width: this.domElement.width,\n        height: this.domElement.height,\n        left: 0,\n        top: 0\n      };\n    } else {\n      rect = this.domElement.getBoundingClientRect();\n    }\n    const resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        if (typeof touch.button === "undefined")\n          touch.button = 0;\n        if (typeof touch.buttons === "undefined")\n          touch.buttons = 1;\n        if (typeof touch.isPrimary === "undefined") {\n          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";\n        }\n        if (typeof touch.width === "undefined")\n          touch.width = touch.radiusX || 1;\n        if (typeof touch.height === "undefined")\n          touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === "undefined")\n          touch.tiltX = 0;\n        if (typeof touch.tiltY === "undefined")\n          touch.tiltY = 0;\n        if (typeof touch.pointerType === "undefined")\n          touch.pointerType = "touch";\n        if (typeof touch.pointerId === "undefined")\n          touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === "undefined")\n          touch.pressure = touch.force || 0.5;\n        if (typeof touch.twist === "undefined")\n          touch.twist = 0;\n        if (typeof touch.tangentialPressure === "undefined")\n          touch.tangentialPressure = 0;\n        if (typeof touch.layerX === "undefined")\n          touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === "undefined")\n          touch.layerY = touch.offsetY = touch.clientY;\n        touch.isNormalized = true;\n        touch.type = event.type;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      if (typeof tempEvent.isPrimary === "undefined")\n        tempEvent.isPrimary = true;\n      if (typeof tempEvent.width === "undefined")\n        tempEvent.width = 1;\n      if (typeof tempEvent.height === "undefined")\n        tempEvent.height = 1;\n      if (typeof tempEvent.tiltX === "undefined")\n        tempEvent.tiltX = 0;\n      if (typeof tempEvent.tiltY === "undefined")\n        tempEvent.tiltY = 0;\n      if (typeof tempEvent.pointerType === "undefined")\n        tempEvent.pointerType = "mouse";\n      if (typeof tempEvent.pointerId === "undefined")\n        tempEvent.pointerId = MOUSE_POINTER_ID;\n      if (typeof tempEvent.pressure === "undefined")\n        tempEvent.pressure = 0.5;\n      if (typeof tempEvent.twist === "undefined")\n        tempEvent.twist = 0;\n      if (typeof tempEvent.tangentialPressure === "undefined")\n        tempEvent.tangentialPressure = 0;\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  }\n  normalizeWheelEvent(nativeEvent) {\n    const event = this.rootWheelEvent;\n    this.transferMouseData(event, nativeEvent);\n    event.deltaX = nativeEvent.deltaX;\n    event.deltaY = nativeEvent.deltaY;\n    event.deltaZ = nativeEvent.deltaZ;\n    event.deltaMode = nativeEvent.deltaMode;\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.nativeEvent = nativeEvent;\n    event.type = nativeEvent.type;\n    return event;\n  }\n  bootstrapEvent(event, nativeEvent) {\n    event.originalEvent = null;\n    event.nativeEvent = nativeEvent;\n    event.pointerId = nativeEvent.pointerId;\n    event.width = nativeEvent.width;\n    event.height = nativeEvent.height;\n    event.isPrimary = nativeEvent.isPrimary;\n    event.pointerType = nativeEvent.pointerType;\n    event.pressure = nativeEvent.pressure;\n    event.tangentialPressure = nativeEvent.tangentialPressure;\n    event.tiltX = nativeEvent.tiltX;\n    event.tiltY = nativeEvent.tiltY;\n    event.twist = nativeEvent.twist;\n    this.transferMouseData(event, nativeEvent);\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.isTrusted = nativeEvent.isTrusted;\n    if (event.type === "pointerleave") {\n      event.type = "pointerout";\n    }\n    if (event.type.startsWith("mouse")) {\n      event.type = event.type.replace("mouse", "pointer");\n    }\n    if (event.type.startsWith("touch")) {\n      event.type = TOUCH_TO_POINTER[event.type] || event.type;\n    }\n    return event;\n  }\n  transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted;\n    event.srcElement = nativeEvent.srcElement;\n    event.timeStamp = performance.now();\n    event.type = nativeEvent.type;\n    event.altKey = nativeEvent.altKey;\n    event.button = nativeEvent.button;\n    event.buttons = nativeEvent.buttons;\n    event.client.x = nativeEvent.clientX;\n    event.client.y = nativeEvent.clientY;\n    event.ctrlKey = nativeEvent.ctrlKey;\n    event.metaKey = nativeEvent.metaKey;\n    event.movement.x = nativeEvent.movementX;\n    event.movement.y = nativeEvent.movementY;\n    event.page.x = nativeEvent.pageX;\n    event.page.y = nativeEvent.pageY;\n    event.relatedTarget = null;\n    event.shiftKey = nativeEvent.shiftKey;\n  }\n};\nlet EventSystem = _EventSystem;\nEventSystem.extension = {\n  name: "events",\n  type: [\n    lib/* ExtensionType.RendererSystem */.nw.RendererSystem,\n    lib/* ExtensionType.CanvasRendererSystem */.nw.CanvasRendererSystem\n  ]\n};\nEventSystem.defaultEventFeatures = {\n  move: true,\n  globalMove: true,\n  click: true,\n  wheel: true\n};\nlib/* extensions.add */.Rw.add(EventSystem);\n\n\n//# sourceMappingURL=EventSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/@pixi/utils/lib/index.mjs + 24 modules\nvar utils_lib = __webpack_require__(441);\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedEventTarget.mjs\n\n\n\n\n\nfunction convertEventModeToInteractiveMode(mode) {\n  return mode === "dynamic" || mode === "static";\n}\nconst FederatedDisplayObject = {\n  onclick: null,\n  onmousedown: null,\n  onmouseenter: null,\n  onmouseleave: null,\n  onmousemove: null,\n  onglobalmousemove: null,\n  onmouseout: null,\n  onmouseover: null,\n  onmouseup: null,\n  onmouseupoutside: null,\n  onpointercancel: null,\n  onpointerdown: null,\n  onpointerenter: null,\n  onpointerleave: null,\n  onpointermove: null,\n  onglobalpointermove: null,\n  onpointerout: null,\n  onpointerover: null,\n  onpointertap: null,\n  onpointerup: null,\n  onpointerupoutside: null,\n  onrightclick: null,\n  onrightdown: null,\n  onrightup: null,\n  onrightupoutside: null,\n  ontap: null,\n  ontouchcancel: null,\n  ontouchend: null,\n  ontouchendoutside: null,\n  ontouchmove: null,\n  onglobaltouchmove: null,\n  ontouchstart: null,\n  onwheel: null,\n  _internalInteractive: void 0,\n  get interactive() {\n    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);\n  },\n  set interactive(value) {\n    (0,utils_lib.deprecation)("7.2.0", `Setting interactive is deprecated, use eventMode = \'none\'/\'passive\'/\'auto\'/\'static\'/\'dynamic\' instead.`);\n    this._internalInteractive = value;\n    this.eventMode = value ? "static" : "auto";\n  },\n  _internalEventMode: void 0,\n  get eventMode() {\n    return this._internalEventMode ?? EventSystem.defaultEventMode;\n  },\n  set eventMode(value) {\n    this._internalInteractive = convertEventModeToInteractiveMode(value);\n    this._internalEventMode = value;\n  },\n  isInteractive() {\n    return this.eventMode === "static" || this.eventMode === "dynamic";\n  },\n  interactiveChildren: true,\n  hitArea: null,\n  addEventListener(type, listener, options) {\n    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;\n    const context = typeof listener === "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    listener = typeof listener === "function" ? listener : listener.handleEvent;\n    this.on(type, listener, context);\n  },\n  removeEventListener(type, listener, options) {\n    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;\n    const context = typeof listener === "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    listener = typeof listener === "function" ? listener : listener.handleEvent;\n    this.off(type, listener, context);\n  },\n  dispatchEvent(e) {\n    if (!(e instanceof FederatedEvent)) {\n      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");\n    }\n    e.defaultPrevented = false;\n    e.path = null;\n    e.target = this;\n    e.manager.dispatchEvent(e);\n    return !e.defaultPrevented;\n  }\n};\ndisplay_lib/* DisplayObject.mixin */.s$.mixin(FederatedDisplayObject);\n\n\n//# sourceMappingURL=FederatedEventTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/index.mjs\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/accessibleTarget.mjs\nconst accessibleTarget = {\n  accessible: false,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  _accessibleActive: false,\n  _accessibleDiv: null,\n  accessibleType: "button",\n  accessiblePointerEvents: "auto",\n  accessibleChildren: true,\n  renderId: -1\n};\n\n\n//# sourceMappingURL=accessibleTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs\n\n\n\n\n\ndisplay_lib/* DisplayObject.mixin */.s$.mixin(accessibleTarget);\nconst KEY_CODE_TAB = 9;\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1e3;\nconst DIV_HOOK_POS_Y = -1e3;\nconst DIV_HOOK_ZINDEX = 2;\nclass AccessibilityManager {\n  constructor(renderer) {\n    this.debug = false;\n    this._isActive = false;\n    this._isMobileAccessibility = false;\n    this.pool = [];\n    this.renderId = 0;\n    this.children = [];\n    this.androidUpdateCount = 0;\n    this.androidUpdateFrequency = 500;\n    this._hookDiv = null;\n    if (lib/* utils.isMobile.tablet */.P6.isMobile.tablet || lib/* utils.isMobile.phone */.P6.isMobile.phone) {\n      this.createTouchHook();\n    }\n    const div = document.createElement("div");\n    div.style.width = `${DIV_TOUCH_SIZE}px`;\n    div.style.height = `${DIV_TOUCH_SIZE}px`;\n    div.style.position = "absolute";\n    div.style.top = `${DIV_TOUCH_POS_X}px`;\n    div.style.left = `${DIV_TOUCH_POS_Y}px`;\n    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n    this.div = div;\n    this.renderer = renderer;\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onMouseMove = this._onMouseMove.bind(this);\n    globalThis.addEventListener("keydown", this._onKeyDown, false);\n  }\n  get isActive() {\n    return this._isActive;\n  }\n  get isMobileAccessibility() {\n    return this._isMobileAccessibility;\n  }\n  createTouchHook() {\n    const hookDiv = document.createElement("button");\n    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.position = "absolute";\n    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n    hookDiv.style.backgroundColor = "#FF0000";\n    hookDiv.title = "select to enable accessibility for this content";\n    hookDiv.addEventListener("focus", () => {\n      this._isMobileAccessibility = true;\n      this.activate();\n      this.destroyTouchHook();\n    });\n    document.body.appendChild(hookDiv);\n    this._hookDiv = hookDiv;\n  }\n  destroyTouchHook() {\n    if (!this._hookDiv) {\n      return;\n    }\n    document.body.removeChild(this._hookDiv);\n    this._hookDiv = null;\n  }\n  activate() {\n    if (this._isActive) {\n      return;\n    }\n    this._isActive = true;\n    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);\n    globalThis.removeEventListener("keydown", this._onKeyDown, false);\n    this.renderer.on("postrender", this.update, this);\n    this.renderer.view.parentNode?.appendChild(this.div);\n  }\n  deactivate() {\n    if (!this._isActive || this._isMobileAccessibility) {\n      return;\n    }\n    this._isActive = false;\n    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);\n    globalThis.addEventListener("keydown", this._onKeyDown, false);\n    this.renderer.off("postrender", this.update);\n    this.div.parentNode?.removeChild(this.div);\n  }\n  updateAccessibleObjects(displayObject) {\n    if (!displayObject.visible || !displayObject.accessibleChildren) {\n      return;\n    }\n    if (displayObject.accessible && displayObject.isInteractive()) {\n      if (!displayObject._accessibleActive) {\n        this.addChild(displayObject);\n      }\n      displayObject.renderId = this.renderId;\n    }\n    const children = displayObject.children;\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        this.updateAccessibleObjects(children[i]);\n      }\n    }\n  }\n  update() {\n    const now = performance.now();\n    if (lib/* utils.isMobile.android.device */.P6.isMobile.android.device && now < this.androidUpdateCount) {\n      return;\n    }\n    this.androidUpdateCount = now + this.androidUpdateFrequency;\n    if (!this.renderer.renderingToScreen) {\n      return;\n    }\n    if (this.renderer.lastObjectRendered) {\n      this.updateAccessibleObjects(this.renderer.lastObjectRendered);\n    }\n    const { x, y, width, height } = this.renderer.view.getBoundingClientRect();\n    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;\n    const sx = width / viewWidth * resolution;\n    const sy = height / viewHeight * resolution;\n    let div = this.div;\n    div.style.left = `${x}px`;\n    div.style.top = `${y}px`;\n    div.style.width = `${viewWidth}px`;\n    div.style.height = `${viewHeight}px`;\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (child.renderId !== this.renderId) {\n        child._accessibleActive = false;\n        lib/* utils.removeItems */.P6.removeItems(this.children, i, 1);\n        this.div.removeChild(child._accessibleDiv);\n        this.pool.push(child._accessibleDiv);\n        child._accessibleDiv = null;\n        i--;\n      } else {\n        div = child._accessibleDiv;\n        let hitArea = child.hitArea;\n        const wt = child.worldTransform;\n        if (child.hitArea) {\n          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;\n          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;\n          div.style.width = `${hitArea.width * wt.a * sx}px`;\n          div.style.height = `${hitArea.height * wt.d * sy}px`;\n        } else {\n          hitArea = child.getBounds();\n          this.capHitArea(hitArea);\n          div.style.left = `${hitArea.x * sx}px`;\n          div.style.top = `${hitArea.y * sy}px`;\n          div.style.width = `${hitArea.width * sx}px`;\n          div.style.height = `${hitArea.height * sy}px`;\n          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {\n            div.title = child.accessibleTitle;\n          }\n          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {\n            div.setAttribute("aria-label", child.accessibleHint);\n          }\n        }\n        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {\n          div.title = child.accessibleTitle;\n          div.tabIndex = child.tabIndex;\n          if (this.debug)\n            this.updateDebugHTML(div);\n        }\n      }\n    }\n    this.renderId++;\n  }\n  updateDebugHTML(div) {\n    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n  }\n  capHitArea(hitArea) {\n    if (hitArea.x < 0) {\n      hitArea.width += hitArea.x;\n      hitArea.x = 0;\n    }\n    if (hitArea.y < 0) {\n      hitArea.height += hitArea.y;\n      hitArea.y = 0;\n    }\n    const { width: viewWidth, height: viewHeight } = this.renderer;\n    if (hitArea.x + hitArea.width > viewWidth) {\n      hitArea.width = viewWidth - hitArea.x;\n    }\n    if (hitArea.y + hitArea.height > viewHeight) {\n      hitArea.height = viewHeight - hitArea.y;\n    }\n  }\n  addChild(displayObject) {\n    let div = this.pool.pop();\n    if (!div) {\n      div = document.createElement("button");\n      div.style.width = `${DIV_TOUCH_SIZE}px`;\n      div.style.height = `${DIV_TOUCH_SIZE}px`;\n      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";\n      div.style.position = "absolute";\n      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      div.style.borderStyle = "none";\n      if (navigator.userAgent.toLowerCase().includes("chrome")) {\n        div.setAttribute("aria-live", "off");\n      } else {\n        div.setAttribute("aria-live", "polite");\n      }\n      if (navigator.userAgent.match(/rv:.*Gecko\\//)) {\n        div.setAttribute("aria-relevant", "additions");\n      } else {\n        div.setAttribute("aria-relevant", "text");\n      }\n      div.addEventListener("click", this._onClick.bind(this));\n      div.addEventListener("focus", this._onFocus.bind(this));\n      div.addEventListener("focusout", this._onFocusOut.bind(this));\n    }\n    div.style.pointerEvents = displayObject.accessiblePointerEvents;\n    div.type = displayObject.accessibleType;\n    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {\n      div.title = displayObject.accessibleTitle;\n    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {\n      div.title = `displayObject ${displayObject.tabIndex}`;\n    }\n    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {\n      div.setAttribute("aria-label", displayObject.accessibleHint);\n    }\n    if (this.debug)\n      this.updateDebugHTML(div);\n    displayObject._accessibleActive = true;\n    displayObject._accessibleDiv = div;\n    div.displayObject = displayObject;\n    this.children.push(displayObject);\n    this.div.appendChild(displayObject._accessibleDiv);\n    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;\n  }\n  _dispatchEvent(e, type) {\n    const { displayObject: target } = e.target;\n    const boundry = this.renderer.events.rootBoundary;\n    const event = Object.assign(new FederatedEvent(boundry), { target });\n    boundry.rootTarget = this.renderer.lastObjectRendered;\n    type.forEach((type2) => boundry.dispatchEvent(event, type2));\n  }\n  _onClick(e) {\n    this._dispatchEvent(e, ["click", "pointertap", "tap"]);\n  }\n  _onFocus(e) {\n    if (!e.target.getAttribute("aria-live")) {\n      e.target.setAttribute("aria-live", "assertive");\n    }\n    this._dispatchEvent(e, ["mouseover"]);\n  }\n  _onFocusOut(e) {\n    if (!e.target.getAttribute("aria-live")) {\n      e.target.setAttribute("aria-live", "polite");\n    }\n    this._dispatchEvent(e, ["mouseout"]);\n  }\n  _onKeyDown(e) {\n    if (e.keyCode !== KEY_CODE_TAB) {\n      return;\n    }\n    this.activate();\n  }\n  _onMouseMove(e) {\n    if (e.movementX === 0 && e.movementY === 0) {\n      return;\n    }\n    this.deactivate();\n  }\n  destroy() {\n    this.destroyTouchHook();\n    this.div = null;\n    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);\n    globalThis.removeEventListener("keydown", this._onKeyDown);\n    this.pool = null;\n    this.children = null;\n    this.renderer = null;\n  }\n}\nAccessibilityManager.extension = {\n  name: "accessibility",\n  type: [\n    lib/* ExtensionType.RendererPlugin */.nw.RendererPlugin,\n    lib/* ExtensionType.CanvasRendererPlugin */.nw.CanvasRendererPlugin\n  ]\n};\nlib/* extensions.add */.Rw.add(AccessibilityManager);\n\n\n//# sourceMappingURL=AccessibilityManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/Application.mjs\n\n\n\nconst _Application = class {\n  constructor(options) {\n    this.stage = new display_lib/* Container */.W2();\n    options = Object.assign({\n      forceCanvas: false\n    }, options);\n    this.renderer = (0,lib/* autoDetectRenderer */.e6)(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  render() {\n    this.renderer.render(this.stage);\n  }\n  get view() {\n    return this.renderer.view;\n  }\n  get screen() {\n    return this.renderer.screen;\n  }\n  destroy(removeView, stageOptions) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(stageOptions);\n    this.stage = null;\n    this.renderer.destroy(removeView);\n    this.renderer = null;\n  }\n};\nlet Application = _Application;\nApplication._plugins = [];\nlib/* extensions.handleByList */.Rw.handleByList(lib/* ExtensionType.Application */.nw.Application, Application._plugins);\n\n\n//# sourceMappingURL=Application.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/ResizePlugin.mjs\n\n\nclass ResizePlugin {\n  static init(options) {\n    Object.defineProperty(this, "resizeTo", {\n      set(dom) {\n        globalThis.removeEventListener("resize", this.queueResize);\n        this._resizeTo = dom;\n        if (dom) {\n          globalThis.addEventListener("resize", this.queueResize);\n          this.resize();\n        }\n      },\n      get() {\n        return this._resizeTo;\n      }\n    });\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this.cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this.cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this.cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  static destroy() {\n    globalThis.removeEventListener("resize", this.queueResize);\n    this.cancelResize();\n    this.cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\nResizePlugin.extension = lib/* ExtensionType.Application */.nw.Application;\nlib/* extensions.add */.Rw.add(ResizePlugin);\n\n\n//# sourceMappingURL=ResizePlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/AssetExtension.mjs\n\n\nconst assetKeyMap = {\n  loader: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n  resolver: lib/* ExtensionType.ResolveParser */.nw.ResolveParser,\n  cache: lib/* ExtensionType.CacheParser */.nw.CacheParser,\n  detection: lib/* ExtensionType.DetectionParser */.nw.DetectionParser\n};\nlib/* extensions.handle */.Rw.handle(lib/* ExtensionType.Asset */.nw.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => lib/* extensions.add */.Rw.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => lib/* extensions.remove */.Rw.remove(ref[key]));\n});\n//# sourceMappingURL=AssetExtension.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/BackgroundLoader.mjs\nclass BackgroundLoader {\n  constructor(loader, verbose = false) {\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    });\n    if (this.verbose)\n      console.log("[BackgroundLoader] assets: ", this._assetList);\n    if (this._isActive && !this._isLoading) {\n      this._next();\n    }\n  }\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      this._next();\n    }\n  }\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value)\n      return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      this._next();\n    }\n  }\n}\n\n\n//# sourceMappingURL=BackgroundLoader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/checkExtension.mjs\n\n\nfunction checkExtension(url, extension) {\n  const tempURL = url.split("?")[0];\n  const ext = lib/* utils.path.extname */.P6.path.extname(tempURL).toLowerCase();\n  if (Array.isArray(extension)) {\n    return extension.includes(ext);\n  }\n  return ext === extension;\n}\n\n\n//# sourceMappingURL=checkExtension.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/convertToList.mjs\nconst convertToList = (input, transform) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === "string") {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\n\n//# sourceMappingURL=convertToList.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/Cache.mjs\n\n\n\n\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  has(key) {\n    return this._cache.has(key);\n  }\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    if (!cacheableAssets) {\n      cacheableAssets = {};\n      keys.forEach((key2) => {\n        cacheableAssets[key2] = value;\n      });\n    }\n    const cacheKeys = Object.keys(cacheableAssets);\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      if (this._cache.has(key2) && this._cache.get(key2) !== value) {\n        console.warn("[Cache] already has key:", key2);\n      }\n      this._cache.set(key2, cacheableAssets[key2]);\n    });\n    if (value instanceof lib/* Texture */.xE) {\n      const texture = value;\n      keys.forEach((key2) => {\n        if (texture.baseTexture !== lib/* Texture.EMPTY.baseTexture */.xE.EMPTY.baseTexture) {\n          lib/* BaseTexture.addToCache */.VL.addToCache(texture.baseTexture, key2);\n        }\n        lib/* Texture.addToCache */.xE.addToCache(texture, key2);\n      });\n    }\n  }\n  remove(key) {\n    this._cacheMap.get(key);\n    if (!this._cacheMap.has(key)) {\n      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\n\n//# sourceMappingURL=Cache.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs\nconst isSingleItem = (item) => !Array.isArray(item);\n\n\n//# sourceMappingURL=isSingleItem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/Loader.mjs\n\n\n\n\n\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    this.promiseCache = {};\n  }\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          console.warn(`[Assets] ${url} could not be loaded as we don\'t know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({\n      src: item\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = lib/* utils.path.toAbsolute */.P6.path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = lib/* utils.path.toAbsolute */.P6.path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        loadPromise.parser?.unload?.(loadedAsset, asset, this);\n        delete this.promiseCache[url];\n      }\n    });\n    await Promise.all(promises);\n  }\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (hash[parser.name]) {\n        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\n\n//# sourceMappingURL=Loader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";\n  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";\n  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\n\n//# sourceMappingURL=LoaderParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes) {\n      if (url.startsWith(`data:${mime}`))\n        return true;\n    }\n    return false;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\n\n//# sourceMappingURL=checkDataUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs\n\n\n\n\n\nconst validJSONExtension = ".json";\nconst validJSONMIME = "application/json";\nconst loadJson = {\n  extension: {\n    type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: "loadJson",\n  test(url) {\n    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    const response = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(url);\n    const json = await response.json();\n    return json;\n  }\n};\nlib/* extensions.add */.Rw.add(loadJson);\n\n\n//# sourceMappingURL=loadJson.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs\n\n\n\n\n\nconst validTXTExtension = ".txt";\nconst validTXTMIME = "text/plain";\nconst loadTxt = {\n  name: "loadTxt",\n  extension: {\n    type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  test(url) {\n    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    const response = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(url);\n    const txt = await response.text();\n    return txt;\n  }\n};\nlib/* extensions.add */.Rw.add(loadTxt);\n\n\n//# sourceMappingURL=loadTxt.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs\n\n\n\n\n\nconst validWeights = [\n  "normal",\n  "bold",\n  "100",\n  "200",\n  "300",\n  "400",\n  "500",\n  "600",\n  "700",\n  "800",\n  "900"\n];\nconst validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];\nconst validFontMIMEs = [\n  "font/ttf",\n  "font/otf",\n  "font/woff",\n  "font/woff2"\n];\nfunction getFontFamilyName(url) {\n  const ext = lib/* utils.path.extname */.P6.path.extname(url);\n  const name = lib/* utils.path.basename */.P6.path.basename(url, ext);\n  const nameWithSpaces = name.replace(/(-|_)/g, " ");\n  const nameTitleCase = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");\n  return nameTitleCase;\n}\nconst loadWebFont = {\n  extension: {\n    type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: "loadWebFont",\n  test(url) {\n    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = lib/* settings.ADAPTER.getFontFaceSet */.Xd.ADAPTER.getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [];\n      const name = options.data?.family ?? getFontFamilyName(url);\n      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];\n      const data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i];\n        const font = new FontFace(name, `url(${encodeURI(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load();\n        fonts.add(font);\n        fontFaces.push(font);\n      }\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");\n    return null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => lib/* settings.ADAPTER.getFontFaceSet */.Xd.ADAPTER.getFontFaceSet().delete(t));\n  }\n};\nlib/* extensions.add */.Rw.add(loadWebFont);\n\n\n//# sourceMappingURL=loadWebFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs\nlet UUID = 0;\nlet MAX_WORKERS;\nconst WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";\nconst checkImageBitmapCode = {\n  id: "checkImageBitmap",\n  code: `\n    async function checkImageBitmap()\n    {\n        try\n        {\n            if (typeof createImageBitmap !== \'function\') return false;\n\n            const response = await fetch(\'${WHITE_PNG}\');\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n\n            return imageBitmap.width === 1 && imageBitmap.height === 1;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    }\n    checkImageBitmap().then((result) => { self.postMessage(result); });\n    `\n};\nconst workerCode = {\n  id: "loadImageBitmap",\n  code: `\n    async function loadImageBitmap(url)\n    {\n        const response = await fetch(url);\n\n        if (!response.ok)\n        {\n            throw new Error(\\`[WorkerManager.loadImageBitmap] Failed to fetch \\${url}: \\`\n                + \\`\\${response.status} \\${response.statusText}\\`);\n        }\n\n        const imageBlob =  await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n\n        return imageBitmap;\n    }\n    self.onmessage = async (event) =>\n    {\n        try\n        {\n            const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }\n        catch(e)\n        {\n            self.postMessage({\n                error: e,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        }\n    };`\n};\nlet workerURL;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = false;\n    this._createdWorkers = 0;\n    this.workerPool = [];\n    this.queue = [];\n    this.resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    if (this._isImageBitmapSupported !== void 0)\n      return this._isImageBitmapSupported;\n    this._isImageBitmapSupported = new Promise((resolve) => {\n      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));\n      const worker = new Worker(workerURL2);\n      worker.addEventListener("message", (event) => {\n        worker.terminate();\n        URL.revokeObjectURL(workerURL2);\n        resolve(event.data);\n      });\n    });\n    return this._isImageBitmapSupported;\n  }\n  loadImageBitmap(src) {\n    return this._run("loadImageBitmap", [src]);\n  }\n  async _initWorkers() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n  }\n  getWorker() {\n    if (MAX_WORKERS === void 0) {\n      MAX_WORKERS = navigator.hardwareConcurrency || 4;\n    }\n    let worker = this.workerPool.pop();\n    if (!worker && this._createdWorkers < MAX_WORKERS) {\n      if (!workerURL) {\n        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));\n      }\n      this._createdWorkers++;\n      worker = new Worker(workerURL);\n      worker.addEventListener("message", (event) => {\n        this.complete(event.data);\n        this.returnWorker(event.target);\n        this.next();\n      });\n    }\n    return worker;\n  }\n  returnWorker(worker) {\n    this.workerPool.push(worker);\n  }\n  complete(data) {\n    if (data.error !== void 0) {\n      this.resolveHash[data.uuid].reject(data.error);\n    } else {\n      this.resolveHash[data.uuid].resolve(data.data);\n    }\n    this.resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({ id, arguments: args, resolve, reject });\n    });\n    this.next();\n    return promise;\n  }\n  next() {\n    if (!this.queue.length)\n      return;\n    const worker = this.getWorker();\n    if (!worker) {\n      return;\n    }\n    const toDo = this.queue.pop();\n    const id = toDo.id;\n    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n    worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\n\n//# sourceMappingURL=WorkerManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs\n\n\nfunction createTexture(base, loader, url) {\n  const texture = new lib/* Texture */.xE(base);\n  texture.baseTexture.on("dispose", () => {\n    delete loader.promiseCache[url];\n  });\n  return texture;\n}\n\n\n//# sourceMappingURL=createTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs\n\n\n\n\n\n\n\nconst validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];\nconst validImageMIMEs = [\n  "image/jpeg",\n  "image/png",\n  "image/webp",\n  "image/avif"\n];\nasync function loadImageBitmap(url) {\n  const response = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  const imageBitmap = await createImageBitmap(imageBlob);\n  return imageBitmap;\n}\nconst loadTextures = {\n  name: "loadTextures",\n  extension: {\n    type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: "anonymous"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.loadImageBitmap(url);\n      } else {\n        src = await loadImageBitmap(url);\n      }\n    } else {\n      src = await new Promise((resolve) => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new lib/* BaseTexture */.VL(src, {\n      resolution: lib/* utils.getResolutionOfUrl */.P6.getResolutionOfUrl(url),\n      ...asset.data\n    });\n    base.resource.src = url;\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\nlib/* extensions.add */.Rw.add(loadTextures);\n\n\n//# sourceMappingURL=loadTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs\n\n\n\n\n\n\n\nconst validSVGExtension = ".svg";\nconst validSVGMIME = "image/svg+xml";\nconst loadSVG = {\n  extension: {\n    type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadSVG",\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async testParse(data) {\n    return lib/* SVGResource.test */.pX.test(data);\n  },\n  async parse(asset, data, loader) {\n    const src = new lib/* SVGResource */.pX(asset, data?.data?.resourceOptions);\n    const base = new lib/* BaseTexture */.VL(src, {\n      resolution: lib/* utils.getResolutionOfUrl */.P6.getResolutionOfUrl(asset),\n      ...data?.data\n    });\n    base.resource.src = asset;\n    const texture = createTexture(base, loader, asset);\n    if (!data?.data?.resourceOptions?.autoLoad) {\n      await src.load();\n    }\n    return texture;\n  },\n  async load(url, _options) {\n    const response = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(url);\n    return response.text();\n  },\n  unload: loadTextures.unload\n};\nlib/* extensions.add */.Rw.add(loadSVG);\n\n\n//# sourceMappingURL=loadSVG.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(",");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\n\n//# sourceMappingURL=createStringVariations.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/Resolver.mjs\n\n\n\n\n\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: "-",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")\n    };\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {\n      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");\n    }\n  }\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  get parsers() {\n    return this._parsers;\n  }\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === "string") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");\n    }\n  }\n  addManifest(manifest) {\n    if (this._manifest) {\n      console.warn("[Resolver] Manifest already exists, this will be overwritten");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    if (Array.isArray(assets)) {\n      assets.forEach((asset) => {\n        if (typeof asset.name === "string") {\n          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);\n          assetNames.push(bundleAssetId);\n          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);\n        } else {\n          const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));\n          bundleIds.forEach((bundleId2) => {\n            assetNames.push(bundleId2);\n          });\n          this.add([...asset.name, ...bundleIds], asset.srcs);\n        }\n      });\n    } else {\n      Object.keys(assets).forEach((key) => {\n        assetNames.push(this._createBundleAssetId(bundleId, key));\n        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);\n      });\n    }\n    this._bundles[bundleId] = assetNames;\n  }\n  add(keysIn, assetsIn, data) {\n    const keys = convertToList(keysIn);\n    keys.forEach((key) => {\n      if (this.hasKey(key)) {\n        console.warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    });\n    if (!Array.isArray(assetsIn)) {\n      if (typeof assetsIn === "string") {\n        assetsIn = createStringVariations(assetsIn);\n      } else {\n        assetsIn = [assetsIn];\n      }\n    }\n    const assetMap = assetsIn.map((asset) => {\n      let formattedAsset = asset;\n      if (typeof asset === "string") {\n        let parsed = false;\n        for (let i = 0; i < this._parsers.length; i++) {\n          const parser = this._parsers[i];\n          if (parser.test(asset)) {\n            formattedAsset = parser.parse(asset);\n            parsed = true;\n            break;\n          }\n        }\n        if (!parsed) {\n          formattedAsset = {\n            src: asset\n          };\n        }\n      }\n      if (!formattedAsset.format) {\n        formattedAsset.format = formattedAsset.src.split(".").pop();\n      }\n      if (!formattedAsset.alias) {\n        formattedAsset.alias = keys;\n      }\n      if (this._basePath || this._rootPath) {\n        formattedAsset.src = lib/* utils.path.toAbsolute */.P6.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n      }\n      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n      formattedAsset.data = formattedAsset.data ?? data;\n      return formattedAsset;\n    });\n    keys.forEach((key) => {\n      this._assetMap[key] = assetMap;\n    });\n  }\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== "string") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          const bestAsset = assets[0];\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0] ?? bestAsset;\n        } else {\n          let src = key;\n          if (this._basePath || this._rootPath) {\n            src = lib/* utils.path.toAbsolute */.P6.path.toAbsolute(src, this._basePath, this._rootPath);\n          }\n          src = this._appendDefaultSearchParams(src);\n          this._resolverHash[key] = {\n            src\n          };\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? "&" : "?";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n}\n\n\n//# sourceMappingURL=Resolver.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/Assets.mjs\n\n\n\n\n\n\n\n\n\n\n\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver();\n    this.loader = new Loader();\n    this.cache = Cache;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  async init(options = {}) {\n    if (this._initialized) {\n      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === "string") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;\n    let formats = [];\n    if (options.texturePreference?.format) {\n      const formatPref = options.texturePreference?.format;\n      formats = typeof formatPref === "string" ? [formatPref] : formatPref;\n      for (const detection of this._detections) {\n        if (!await detection.test()) {\n          formats = await detection.remove(formats);\n        }\n      }\n    } else {\n      for (const detection of this._detections) {\n        if (await detection.test()) {\n          formats = await detection.add(formats);\n        }\n      }\n    }\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  add(keysIn, assetsIn, data) {\n    this.resolver.add(keysIn, assetsIn, data);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem(urls);\n    const urlArray = convertToList(urls).map((url) => {\n      if (typeof url !== "string") {\n        this.resolver.add(url.src, url);\n        return url.src;\n      }\n      if (!this.resolver.hasKey(url)) {\n        this.resolver.add(url, url);\n      }\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === "string") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === "string") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === "string") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === "string") {\n      return Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = Object.values(resolveResults);\n    const resolveKeys = Object.keys(resolveResults);\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult, i) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      out[resolveKeys[i]] = asset;\n      Cache.set(keys, asset);\n    });\n    return out;\n  }\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  get detections() {\n    return this._detections;\n  }\n  get preferWorkers() {\n    return loadTextures.config.preferWorkers;\n  }\n  set preferWorkers(value) {\n    (0,utils_lib.deprecation)("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");\n    this.setPreferences({ preferWorkers: value });\n  }\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nlib/* extensions.handleByList */.Rw.handleByList(lib/* ExtensionType.LoadParser */.nw.LoadParser, Assets.loader.parsers).handleByList(lib/* ExtensionType.ResolveParser */.nw.ResolveParser, Assets.resolver.parsers).handleByList(lib/* ExtensionType.CacheParser */.nw.CacheParser, Assets.cache.parsers).handleByList(lib/* ExtensionType.DetectionParser */.nw.DetectionParser, Assets.detections);\n\n\n//# sourceMappingURL=Assets.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs\n\n\nconst cacheTextureArray = {\n  extension: lib/* ExtensionType.CacheParser */.nw.CacheParser,\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof lib/* Texture */.xE),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? "" : i + 1)] = item;\n      });\n    });\n    return out;\n  }\n};\nlib/* extensions.add */.Rw.add(cacheTextureArray);\n\n\n//# sourceMappingURL=cacheTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/parsers/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs\n\n\nconst detectAvif = {\n  extension: {\n    type: lib/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: 1\n  },\n  test: async () => {\n    if (!globalThis.createImageBitmap)\n      return false;\n    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";\n    const blob = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(avifData).then((r) => r.blob());\n    return createImageBitmap(blob).then(() => true, () => false);\n  },\n  add: async (formats) => [...formats, "avif"],\n  remove: async (formats) => formats.filter((f) => f !== "avif")\n};\nlib/* extensions.add */.Rw.add(detectAvif);\n\n\n//# sourceMappingURL=detectAvif.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs\n\n\nconst detectWebp = {\n  extension: {\n    type: lib/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => {\n    if (!globalThis.createImageBitmap)\n      return false;\n    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";\n    const blob = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(webpData).then((r) => r.blob());\n    return createImageBitmap(blob).then(() => true, () => false);\n  },\n  add: async (formats) => [...formats, "webp"],\n  remove: async (formats) => formats.filter((f) => f !== "webp")\n};\nlib/* extensions.add */.Rw.add(detectWebp);\n\n\n//# sourceMappingURL=detectWebp.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs\n\n\nconst imageFormats = ["png", "jpg", "jpeg"];\nconst detectDefaults = {\n  extension: {\n    type: lib/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(true),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\nlib/* extensions.add */.Rw.add(detectDefaults);\n\n\n//# sourceMappingURL=detectDefaults.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs\n\n\n\n\nconst resolveTextureUrl = {\n  extension: lib/* ExtensionType.ResolveParser */.nw.ResolveParser,\n  test: loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(lib/* settings.RETINA_PREFIX.exec */.Xd.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n    format: value.split(".").pop(),\n    src: value\n  })\n};\nlib/* extensions.add */.Rw.add(resolveTextureUrl);\n\n\n//# sourceMappingURL=resolveTextureUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/parsers/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/copySearchParams.mjs\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split("?")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\n\n//# sourceMappingURL=copySearchParams.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/const.mjs\nvar INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";\n  return INTERNAL_FORMATS2;\n})(INTERNAL_FORMATS || {});\nconst INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {\n  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: 0.5,\n  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: 0.5,\n  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: 1,\n  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: 1,\n  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: 0.5,\n  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: 0.5,\n  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: 1,\n  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: 1,\n  [37488 /* COMPRESSED_R11_EAC */]: 0.5,\n  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: 0.5,\n  [37490 /* COMPRESSED_RG11_EAC */]: 1,\n  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: 1,\n  [37492 /* COMPRESSED_RGB8_ETC2 */]: 0.5,\n  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: 1,\n  [37493 /* COMPRESSED_SRGB8_ETC2 */]: 0.5,\n  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: 1,\n  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,\n  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,\n  [35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */]: 0.5,\n  [35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */]: 0.5,\n  [35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */]: 0.25,\n  [35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */]: 0.25,\n  [36196 /* COMPRESSED_RGB_ETC1_WEBGL */]: 0.5,\n  [35986 /* COMPRESSED_RGB_ATC_WEBGL */]: 0.5,\n  [35986 /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */]: 1,\n  [34798 /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */]: 1,\n  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: 1\n};\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.mjs\n\n//# sourceMappingURL=compressedTextureExtensions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs\n\n\nlet storedGl;\nlet extensions;\nfunction getCompressedTextureExtensions() {\n  extensions = {\n    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),\n    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),\n    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),\n    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),\n    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),\n    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),\n    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")\n  };\n}\nconst detectCompressedTextures = {\n  extension: {\n    type: lib/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: 2\n  },\n  test: async () => {\n    const canvas = lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n    const gl = canvas.getContext("webgl");\n    if (!gl) {\n      console.warn("WebGL not available for compressed textures.");\n      return false;\n    }\n    storedGl = gl;\n    return true;\n  },\n  add: async (formats) => {\n    if (!extensions)\n      getCompressedTextureExtensions();\n    const textureFormats = [];\n    for (const extensionName in extensions) {\n      const extension = extensions[extensionName];\n      if (!extension) {\n        continue;\n      }\n      textureFormats.push(extensionName);\n    }\n    return [...textureFormats, ...formats];\n  },\n  remove: async (formats) => {\n    if (!extensions)\n      getCompressedTextureExtensions();\n    return formats.filter((f) => !(f in extensions));\n  }\n};\nlib/* extensions.add */.Rw.add(detectCompressedTextures);\n\n\n//# sourceMappingURL=detectCompressedTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs\n\n\nclass BlobResource extends lib/* BufferResource */.qm {\n  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {\n    let origin;\n    let data;\n    if (typeof source === "string") {\n      origin = source;\n      data = new Uint8Array();\n    } else {\n      origin = null;\n      data = source;\n    }\n    super(data, options);\n    this.origin = origin;\n    this.buffer = data ? new lib/* ViewableBuffer */.Rv(data) : null;\n    if (this.origin && options.autoLoad !== false) {\n      this.load();\n    }\n    if (data?.length) {\n      this.loaded = true;\n      this.onBlobLoaded(this.buffer.rawBinaryData);\n    }\n  }\n  onBlobLoaded(_data) {\n  }\n  async load() {\n    const response = await fetch(this.origin);\n    const blob = await response.blob();\n    const arrayBuffer = await blob.arrayBuffer();\n    this.data = new Uint32Array(arrayBuffer);\n    this.buffer = new lib/* ViewableBuffer */.Rv(arrayBuffer);\n    this.loaded = true;\n    this.onBlobLoaded(arrayBuffer);\n    this.update();\n    return this;\n  }\n}\n\n\n//# sourceMappingURL=BlobResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs\n\n\n\nclass CompressedTextureResource extends BlobResource {\n  constructor(source, options) {\n    super(source, options);\n    this.format = options.format;\n    this.levels = options.levels || 1;\n    this._width = options.width;\n    this._height = options.height;\n    this._extension = CompressedTextureResource._formatToExtension(this.format);\n    if (options.levelBuffers || this.buffer) {\n      this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);\n    }\n  }\n  upload(renderer, _texture, _glTexture) {\n    const gl = renderer.gl;\n    const extension = renderer.context.extensions[this._extension];\n    if (!extension) {\n      throw new Error(`${this._extension} textures are not supported on the current machine`);\n    }\n    if (!this._levelBuffers) {\n      return false;\n    }\n    for (let i = 0, j = this.levels; i < j; i++) {\n      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];\n      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);\n    }\n    return true;\n  }\n  onBlobLoaded() {\n    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);\n  }\n  static _formatToExtension(format) {\n    if (format >= 33776 && format <= 33779) {\n      return "s3tc";\n    } else if (format >= 37488 && format <= 37497) {\n      return "etc";\n    } else if (format >= 35840 && format <= 35843) {\n      return "pvrtc";\n    } else if (format >= 36196) {\n      return "etc1";\n    } else if (format >= 35986 && format <= 34798) {\n      return "atc";\n    }\n    throw new Error("Invalid (compressed) texture format given!");\n  }\n  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {\n    const buffers = new Array(levels);\n    let offset = buffer.byteOffset;\n    let levelWidth = imageWidth;\n    let levelHeight = imageHeight;\n    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);\n    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);\n    let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n    for (let i = 0; i < levels; i++) {\n      buffers[i] = {\n        levelID: i,\n        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,\n        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,\n        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)\n      };\n      offset += levelSize;\n      levelWidth = levelWidth >> 1 || 1;\n      levelHeight = levelHeight >> 1 || 1;\n      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);\n      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);\n      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n    }\n    return buffers;\n  }\n}\n\n\n//# sourceMappingURL=CompressedTextureResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs\n\n\n\n\nconst DDS_MAGIC_SIZE = 4;\nconst DDS_HEADER_SIZE = 124;\nconst DDS_HEADER_PF_SIZE = 32;\nconst DDS_HEADER_DX10_SIZE = 20;\nconst DDS_MAGIC = 542327876;\nconst DDS_FIELDS = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n};\nconst DDS_PF_FIELDS = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n};\nconst DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n};\nvar DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";\n  return DXGI_FORMAT2;\n})(DXGI_FORMAT || {});\nvar D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";\n  return D3D10_RESOURCE_DIMENSION2;\n})(D3D10_RESOURCE_DIMENSION || {});\nconst PF_FLAGS = 1;\nconst DDPF_ALPHA = 2;\nconst DDPF_FOURCC = 4;\nconst DDPF_RGB = 64;\nconst DDPF_YUV = 512;\nconst DDPF_LUMINANCE = 131072;\nconst FOURCC_DXT1 = 827611204;\nconst FOURCC_DXT3 = 861165636;\nconst FOURCC_DXT5 = 894720068;\nconst FOURCC_DX10 = 808540228;\nconst DDS_RESOURCE_MISC_TEXTURECUBE = 4;\nconst FOURCC_TO_FORMAT = {\n  [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n};\nconst DXGI_TO_FORMAT = {\n  [70 /* DXGI_FORMAT_BC1_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  [71 /* DXGI_FORMAT_BC1_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  [73 /* DXGI_FORMAT_BC2_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  [74 /* DXGI_FORMAT_BC2_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  [76 /* DXGI_FORMAT_BC3_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  [77 /* DXGI_FORMAT_BC3_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n  [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n  [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n};\nfunction parseDDS(arrayBuffer) {\n  const data = new Uint32Array(arrayBuffer);\n  const magicWord = data[0];\n  if (magicWord !== DDS_MAGIC) {\n    throw new Error("Invalid DDS file magic word");\n  }\n  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n  const height = header[DDS_FIELDS.HEIGHT];\n  const width = header[DDS_FIELDS.WIDTH];\n  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];\n  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n  const formatFlags = pixelFormat[PF_FLAGS];\n  if (formatFlags & DDPF_FOURCC) {\n    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];\n    if (fourCC !== FOURCC_DX10) {\n      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];\n      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;\n      const texData = new Uint8Array(arrayBuffer, dataOffset2);\n      const resource = new CompressedTextureResource(texData, {\n        format: internalFormat2,\n        width,\n        height,\n        levels: mipmapCount\n      });\n      return [resource];\n    }\n    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;\n    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];\n    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];\n    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];\n    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];\n    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];\n    if (internalFormat === void 0) {\n      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);\n    }\n    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {\n      throw new Error("DDSParser does not support cubemap textures");\n    }\n    if (resourceDimension === 6 /* DDS_DIMENSION_TEXTURE3D */) {\n      throw new Error("DDSParser does not supported 3D texture data");\n    }\n    const imageBuffers = new Array();\n    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n    if (arraySize === 1) {\n      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));\n    } else {\n      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];\n      let imageSize = 0;\n      let levelWidth = width;\n      let levelHeight = height;\n      for (let i = 0; i < mipmapCount; i++) {\n        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);\n        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);\n        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;\n        imageSize += levelSize;\n        levelWidth = levelWidth >>> 1;\n        levelHeight = levelHeight >>> 1;\n      }\n      let imageOffset = dataOffset;\n      for (let i = 0; i < arraySize; i++) {\n        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));\n        imageOffset += imageSize;\n      }\n    }\n    return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {\n      format: internalFormat,\n      width,\n      height,\n      levels: mipmapCount\n    }));\n  }\n  if (formatFlags & DDPF_RGB) {\n    throw new Error("DDSParser does not support uncompressed texture data.");\n  }\n  if (formatFlags & DDPF_YUV) {\n    throw new Error("DDSParser does not supported YUV uncompressed texture data.");\n  }\n  if (formatFlags & DDPF_LUMINANCE) {\n    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");\n  }\n  if (formatFlags & DDPF_ALPHA) {\n    throw new Error("DDSParser does not support single-channel (alpha) texture data!");\n  }\n  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");\n}\n\n\n//# sourceMappingURL=parseDDS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs\n\n\n\n\n\nconst FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];\nconst ENDIANNESS = 67305985;\nconst KTX_FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n};\nconst FILE_HEADER_SIZE = 64;\nconst TYPES_TO_BYTES_PER_COMPONENT = {\n  [lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE]: 1,\n  [lib/* TYPES.UNSIGNED_SHORT */.vK.UNSIGNED_SHORT]: 2,\n  [lib/* TYPES.INT */.vK.INT]: 4,\n  [lib/* TYPES.UNSIGNED_INT */.vK.UNSIGNED_INT]: 4,\n  [lib/* TYPES.FLOAT */.vK.FLOAT]: 4,\n  [lib/* TYPES.HALF_FLOAT */.vK.HALF_FLOAT]: 8\n};\nconst FORMATS_TO_COMPONENTS = {\n  [lib/* FORMATS.RGBA */.I2.RGBA]: 4,\n  [lib/* FORMATS.RGB */.I2.RGB]: 3,\n  [lib/* FORMATS.RG */.I2.RG]: 2,\n  [lib/* FORMATS.RED */.I2.RED]: 1,\n  [lib/* FORMATS.LUMINANCE */.I2.LUMINANCE]: 1,\n  [lib/* FORMATS.LUMINANCE_ALPHA */.I2.LUMINANCE_ALPHA]: 2,\n  [lib/* FORMATS.ALPHA */.I2.ALPHA]: 1\n};\nconst TYPES_TO_BYTES_PER_PIXEL = {\n  [lib/* TYPES.UNSIGNED_SHORT_4_4_4_4 */.vK.UNSIGNED_SHORT_4_4_4_4]: 2,\n  [lib/* TYPES.UNSIGNED_SHORT_5_5_5_1 */.vK.UNSIGNED_SHORT_5_5_5_1]: 2,\n  [lib/* TYPES.UNSIGNED_SHORT_5_6_5 */.vK.UNSIGNED_SHORT_5_6_5]: 2\n};\nfunction parseKTX(url, arrayBuffer, loadKeyValueData = false) {\n  const dataView = new DataView(arrayBuffer);\n  if (!validate(url, dataView)) {\n    return null;\n  }\n  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;\n  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);\n  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);\n  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);\n  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);\n  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;\n  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;\n  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;\n  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);\n  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);\n  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n  if (pixelHeight === 0 || pixelDepth !== 1) {\n    throw new Error("Only 2D textures are supported");\n  }\n  if (numberOfFaces !== 1) {\n    throw new Error("CubeTextures are not supported by KTXLoader yet!");\n  }\n  if (numberOfArrayElements !== 1) {\n    throw new Error("WebGL does not support array textures");\n  }\n  const blockWidth = 4;\n  const blockHeight = 4;\n  const alignedWidth = pixelWidth + 3 & ~3;\n  const alignedHeight = pixelHeight + 3 & ~3;\n  const imageBuffers = new Array(numberOfArrayElements);\n  let imagePixels = pixelWidth * pixelHeight;\n  if (glType === 0) {\n    imagePixels = alignedWidth * alignedHeight;\n  }\n  let imagePixelByteSize;\n  if (glType !== 0) {\n    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {\n      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];\n    } else {\n      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];\n    }\n  } else {\n    imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];\n  }\n  if (imagePixelByteSize === void 0) {\n    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");\n  }\n  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;\n  const imageByteSize = imagePixels * imagePixelByteSize;\n  let mipByteSize = imageByteSize;\n  let mipWidth = pixelWidth;\n  let mipHeight = pixelHeight;\n  let alignedMipWidth = alignedWidth;\n  let alignedMipHeight = alignedHeight;\n  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;\n  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {\n    const imageSize = dataView.getUint32(imageOffset, littleEndian);\n    let elementOffset = imageOffset + 4;\n    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {\n      let mips = imageBuffers[arrayElement];\n      if (!mips) {\n        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);\n      }\n      mips[mipmapLevel] = {\n        levelID: mipmapLevel,\n        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,\n        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,\n        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)\n      };\n      elementOffset += mipByteSize;\n    }\n    imageOffset += imageSize + 4;\n    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;\n    mipWidth = mipWidth >> 1 || 1;\n    mipHeight = mipHeight >> 1 || 1;\n    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);\n    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);\n    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n  }\n  if (glType !== 0) {\n    return {\n      uncompressed: imageBuffers.map((levelBuffers) => {\n        let buffer = levelBuffers[0].levelBuffer;\n        let convertToInt = false;\n        if (glType === lib/* TYPES.FLOAT */.vK.FLOAT) {\n          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n        } else if (glType === lib/* TYPES.UNSIGNED_INT */.vK.UNSIGNED_INT) {\n          convertToInt = true;\n          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n        } else if (glType === lib/* TYPES.INT */.vK.INT) {\n          convertToInt = true;\n          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n        }\n        return {\n          resource: new lib/* BufferResource */.qm(buffer, {\n            width: levelBuffers[0].levelWidth,\n            height: levelBuffers[0].levelHeight\n          }),\n          type: glType,\n          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat\n        };\n      }),\n      kvData\n    };\n  }\n  return {\n    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {\n      format: glInternalFormat,\n      width: pixelWidth,\n      height: pixelHeight,\n      levels: numberOfMipmapLevels,\n      levelBuffers\n    })),\n    kvData\n  };\n}\nfunction validate(url, dataView) {\n  for (let i = 0; i < FILE_IDENTIFIER.length; i++) {\n    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {\n      console.error(`${url} is not a valid *.ktx file!`);\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertFormatToInteger(format) {\n  switch (format) {\n    case lib/* FORMATS.RGBA */.I2.RGBA:\n      return lib/* FORMATS.RGBA_INTEGER */.I2.RGBA_INTEGER;\n    case lib/* FORMATS.RGB */.I2.RGB:\n      return lib/* FORMATS.RGB_INTEGER */.I2.RGB_INTEGER;\n    case lib/* FORMATS.RG */.I2.RG:\n      return lib/* FORMATS.RG_INTEGER */.I2.RG_INTEGER;\n    case lib/* FORMATS.RED */.I2.RED:\n      return lib/* FORMATS.RED_INTEGER */.I2.RED_INTEGER;\n    default:\n      return format;\n  }\n}\nfunction parseKvData(dataView, bytesOfKeyValueData, littleEndian) {\n  const kvData = /* @__PURE__ */ new Map();\n  let bytesIntoKeyValueData = 0;\n  while (bytesIntoKeyValueData < bytesOfKeyValueData) {\n    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);\n    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;\n    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;\n    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {\n      console.error("KTXLoader: keyAndValueByteSize out of bounds");\n      break;\n    }\n    let keyNulByte = 0;\n    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {\n      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {\n        break;\n      }\n    }\n    if (keyNulByte === -1) {\n      console.error("KTXLoader: Failed to find null byte terminating kvData key");\n      break;\n    }\n    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));\n    const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);\n    kvData.set(key, value);\n    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;\n  }\n  return kvData;\n}\n\n\n//# sourceMappingURL=parseKTX.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs\n\n\n\n\n\nconst loadDDS = {\n  extension: {\n    type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadDDS",\n  test(url) {\n    return checkExtension(url, ".dds");\n  },\n  async load(url, asset, loader) {\n    const response = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const resources = parseDDS(arrayBuffer);\n    const textures = resources.map((resource) => {\n      const base = new lib/* BaseTexture */.VL(resource, {\n        mipmap: lib/* MIPMAP_MODES.OFF */.KI.OFF,\n        alphaMode: lib/* ALPHA_MODES.NO_PREMULTIPLIED_ALPHA */.iw.NO_PREMULTIPLIED_ALPHA,\n        resolution: lib/* utils.getResolutionOfUrl */.P6.getResolutionOfUrl(url),\n        ...asset.data\n      });\n      return createTexture(base, loader, url);\n    });\n    return textures.length === 1 ? textures[0] : textures;\n  },\n  unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach((t) => t.destroy(true));\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\nlib/* extensions.add */.Rw.add(loadDDS);\n\n\n//# sourceMappingURL=loadDDS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs\n\n\n\n\n\nconst loadKTX = {\n  extension: {\n    type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadKTX",\n  test(url) {\n    return checkExtension(url, ".ktx");\n  },\n  async load(url, asset, loader) {\n    const response = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const { compressed, uncompressed, kvData } = parseKTX(url, arrayBuffer);\n    const resources = compressed ?? uncompressed;\n    const options = {\n      mipmap: lib/* MIPMAP_MODES.OFF */.KI.OFF,\n      alphaMode: lib/* ALPHA_MODES.NO_PREMULTIPLIED_ALPHA */.iw.NO_PREMULTIPLIED_ALPHA,\n      resolution: lib/* utils.getResolutionOfUrl */.P6.getResolutionOfUrl(url),\n      ...asset.data\n    };\n    const textures = resources.map((resource) => {\n      if (resources === uncompressed) {\n        Object.assign(options, {\n          type: resource.type,\n          format: resource.format\n        });\n      }\n      const base = new lib/* BaseTexture */.VL(resource, options);\n      base.ktxKeyValueData = kvData;\n      return createTexture(base, loader, url);\n    });\n    return textures.length === 1 ? textures[0] : textures;\n  },\n  unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach((t) => t.destroy(true));\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\nlib/* extensions.add */.Rw.add(loadKTX);\n\n\n//# sourceMappingURL=loadKTX.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs\n\n\nconst resolveCompressedTextureUrl = {\n  extension: lib/* ExtensionType.ResolveParser */.nw.ResolveParser,\n  test: (value) => {\n    const temp = value.split("?")[0];\n    const extension = temp.split(".").pop();\n    return ["basis", "ktx", "dds"].includes(extension);\n  },\n  parse: (value) => {\n    const temp = value.split("?")[0];\n    const extension = temp.split(".").pop();\n    if (extension === "ktx") {\n      const extensions2 = [\n        ".s3tc.ktx",\n        ".s3tc_sRGB.ktx",\n        ".etc.ktx",\n        ".etc1.ktx",\n        ".pvrt.ktx",\n        ".atc.ktx",\n        ".astc.ktx"\n      ];\n      if (extensions2.some((ext) => value.endsWith(ext))) {\n        return {\n          resolution: parseFloat(lib/* settings.RETINA_PREFIX.exec */.Xd.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n          format: extensions2.find((ext) => value.endsWith(ext)),\n          src: value\n        };\n      }\n    }\n    return {\n      resolution: parseFloat(lib/* settings.RETINA_PREFIX.exec */.Xd.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n      format: value.split(".").pop(),\n      src: value\n    };\n  }\n};\nlib/* extensions.add */.Rw.add(resolveCompressedTextureUrl);\n\n\n//# sourceMappingURL=resolveCompressedTextureUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/extract/lib/Extract.mjs\n\n\nconst TEMP_RECT = new lib/* Rectangle */.Ae();\nconst BYTES_PER_PIXEL = 4;\nconst _Extract = class {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  async image(target, format, quality) {\n    const image = new Image();\n    image.src = await this.base64(target, format, quality);\n    return image;\n  }\n  async base64(target, format, quality) {\n    const canvas = this.canvas(target);\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(format, quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: format, quality });\n      return await new Promise((resolve) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error("Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented");\n  }\n  canvas(target, frame) {\n    const { pixels, width, height, flipY } = this._rawPixels(target, frame);\n    let canvasBuffer = new lib/* utils.CanvasRenderTarget */.P6.CanvasRenderTarget(width, height, 1);\n    const canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n    _Extract.arrayPostDivide(pixels, canvasData.data);\n    canvasBuffer.context.putImageData(canvasData, 0, 0);\n    if (flipY) {\n      const target2 = new lib/* utils.CanvasRenderTarget */.P6.CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);\n      target2.context.scale(1, -1);\n      target2.context.drawImage(canvasBuffer.canvas, 0, -height);\n      canvasBuffer.destroy();\n      canvasBuffer = target2;\n    }\n    return canvasBuffer.canvas;\n  }\n  pixels(target, frame) {\n    const { pixels } = this._rawPixels(target, frame);\n    _Extract.arrayPostDivide(pixels, pixels);\n    return pixels;\n  }\n  _rawPixels(target, frame) {\n    const renderer = this.renderer;\n    if (!renderer) {\n      throw new Error("The Extract has already been destroyed");\n    }\n    let resolution;\n    let flipY = false;\n    let renderTexture;\n    let generated = false;\n    if (target) {\n      if (target instanceof lib/* RenderTexture */.TI) {\n        renderTexture = target;\n      } else {\n        const multisample = renderer.context.webGLVersion >= 2 ? renderer.multisample : lib/* MSAA_QUALITY.NONE */.G5.NONE;\n        renderTexture = renderer.generateTexture(target, { multisample });\n        if (multisample !== lib/* MSAA_QUALITY.NONE */.G5.NONE) {\n          const resolvedTexture = lib/* RenderTexture.create */.TI.create({\n            width: renderTexture.width,\n            height: renderTexture.height\n          });\n          renderer.framebuffer.bind(renderTexture.framebuffer);\n          renderer.framebuffer.blit(resolvedTexture.framebuffer);\n          renderer.framebuffer.bind();\n          renderTexture.destroy(true);\n          renderTexture = resolvedTexture;\n        }\n        generated = true;\n      }\n    }\n    if (renderTexture) {\n      resolution = renderTexture.baseTexture.resolution;\n      frame = frame ?? renderTexture.frame;\n      flipY = false;\n      renderer.renderTexture.bind(renderTexture);\n    } else {\n      resolution = renderer.resolution;\n      if (!frame) {\n        frame = TEMP_RECT;\n        frame.width = renderer.width;\n        frame.height = renderer.height;\n      }\n      flipY = true;\n      renderer.renderTexture.bind();\n    }\n    const width = Math.round(frame.width * resolution);\n    const height = Math.round(frame.height * resolution);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const gl = renderer.gl;\n    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    if (generated) {\n      renderTexture?.destroy(true);\n    }\n    return { pixels, width, height, flipY };\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  static arrayPostDivide(pixels, out) {\n    for (let i = 0; i < pixels.length; i += 4) {\n      const alpha = out[i + 3] = pixels[i + 3];\n      if (alpha !== 0) {\n        out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));\n        out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));\n        out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));\n      } else {\n        out[i] = pixels[i];\n        out[i + 1] = pixels[i + 1];\n        out[i + 2] = pixels[i + 2];\n      }\n    }\n  }\n};\nlet Extract = _Extract;\nExtract.extension = {\n  name: "extract",\n  type: lib/* ExtensionType.RendererSystem */.nw.RendererSystem\n};\nlib/* extensions.add */.Rw.add(Extract);\n\n\n//# sourceMappingURL=Extract.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/extract/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs\n\n\nconst buildCircle = {\n  build(graphicsData) {\n    const points = graphicsData.points;\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (graphicsData.type === lib/* SHAPES.CIRC */.HS.CIRC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === lib/* SHAPES.ELIP */.HS.ELIP) {\n      const ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      const roundedRect = graphicsData.shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    {\n      const x0 = dx + rx;\n      const y0 = dy;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        const y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x0 = dx + Math.cos(a) * rx;\n      const y0 = dy + Math.sin(a) * ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      points[j3++] = x2;\n      points[j3++] = y2;\n      points[--j4] = y2;\n      points[--j4] = x1;\n    }\n    {\n      const x0 = dx;\n      const y0 = dy + ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x1;\n      if (dx) {\n        points[j1++] = x2;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x2;\n      }\n    }\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points;\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    if (points.length === 0) {\n      return;\n    }\n    let vertPos = verts.length / 2;\n    const center = vertPos;\n    let x;\n    let y;\n    if (graphicsData.type !== lib/* SHAPES.RREC */.HS.RREC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      const roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    const matrix = graphicsData.matrix;\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (let i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\n\n\n//# sourceMappingURL=buildCircle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs\n\n\nfunction fixOrientation(points, hole = false) {\n  const m = points.length;\n  if (m < 6) {\n    return;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (!hole && area > 0 || hole && area <= 0) {\n    const n = m / 2;\n    for (let i = n + n % 2; i < m; i += 2) {\n      const i1 = m - i - 2;\n      const i2 = m - i - 1;\n      const i3 = i;\n      const i4 = i + 1;\n      [points[i1], points[i3]] = [points[i3], points[i1]];\n      [points[i2], points[i4]] = [points[i4], points[i2]];\n    }\n  }\n}\nconst buildPoly = {\n  build(graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    let points = graphicsData.points;\n    const holes = graphicsData.holes;\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    if (points.length >= 6) {\n      fixOrientation(points, false);\n      const holeArray = [];\n      for (let i = 0; i < holes.length; i++) {\n        const hole = holes[i];\n        fixOrientation(hole.points, true);\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      }\n      const triangles = lib/* utils.earcut */.P6.earcut(points, holeArray, 2);\n      if (!triangles) {\n        return;\n      }\n      const vertPos = verts.length / 2;\n      for (let i = 0; i < triangles.length; i += 3) {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i + 1] + vertPos);\n        indices.push(triangles[i + 2] + vertPos);\n      }\n      for (let i = 0; i < points.length; i++) {\n        verts.push(points[i]);\n      }\n    }\n  }\n};\n\n\n//# sourceMappingURL=buildPoly.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs\nconst buildRectangle = {\n  build(graphicsData) {\n    const rectData = graphicsData.shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    const points = graphicsData.points;\n    points.length = 0;\n    if (!(width >= 0 && height >= 0)) {\n      return;\n    }\n    points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points;\n    const verts = graphicsGeometry.points;\n    if (points.length === 0) {\n      return;\n    }\n    const vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\n\n\n//# sourceMappingURL=buildRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs\n\n\nconst buildRoundedRectangle = {\n  build(graphicsData) {\n    buildCircle.build(graphicsData);\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    buildCircle.triangulate(graphicsData, graphicsGeometry);\n  }\n};\n\n\n//# sourceMappingURL=buildRoundedRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/const.mjs\nvar LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {\n  LINE_JOIN2["MITER"] = "miter";\n  LINE_JOIN2["BEVEL"] = "bevel";\n  LINE_JOIN2["ROUND"] = "round";\n  return LINE_JOIN2;\n})(LINE_JOIN || {});\nvar LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {\n  LINE_CAP2["BUTT"] = "butt";\n  LINE_CAP2["ROUND"] = "round";\n  LINE_CAP2["SQUARE"] = "square";\n  return LINE_CAP2;\n})(LINE_CAP || {});\nconst curves = {\n  adaptive: true,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount(length, defaultSegments = 20) {\n    if (!this.adaptive || !length || isNaN(length)) {\n      return defaultSegments;\n    }\n    let result = Math.ceil(length / this.maxLength);\n    if (result < this.minSegments) {\n      result = this.minSegments;\n    } else if (result > this.maxSegments) {\n      result = this.maxSegments;\n    }\n    return result;\n  }\n};\nconst GRAPHICS_CURVES = (/* unused pure expression or super */ null && (curves));\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs\n\n\n\nclass ArcUtils {\n  static curveTo(x1, y1, x2, y2, radius, points) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n      return null;\n    }\n    const dd = a1 * a1 + b1 * b1;\n    const cc = a2 * a2 + b2 * b2;\n    const tt = a1 * a2 + b1 * b2;\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = k1 * b2 + k2 * b1;\n    const cy = k1 * a2 + k2 * a1;\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n    return {\n      cx: cx + x1,\n      cy: cy + y1,\n      radius,\n      startAngle,\n      endAngle,\n      anticlockwise: b1 * a2 > b2 * a1\n    };\n  }\n  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {\n    const sweep = endAngle - startAngle;\n    const n = curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / lib/* PI_2 */._b) * 40);\n    const theta = sweep / (n * 2);\n    const theta2 = theta * 2;\n    const cTheta = Math.cos(theta);\n    const sTheta = Math.sin(theta);\n    const segMinus = n - 1;\n    const remainder = segMinus % 1 / segMinus;\n    for (let i = 0; i <= segMinus; ++i) {\n      const real = i + remainder * i;\n      const angle = theta + startAngle + theta2 * real;\n      const c = Math.cos(angle);\n      const s = -Math.sin(angle);\n      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ArcUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs\n\n\nclass BezierUtils {\n  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    const n = 10;\n    let result = 0;\n    let t = 0;\n    let t2 = 0;\n    let t3 = 0;\n    let nt = 0;\n    let nt2 = 0;\n    let nt3 = 0;\n    let x = 0;\n    let y = 0;\n    let dx = 0;\n    let dy = 0;\n    let prevX = fromX;\n    let prevY = fromY;\n    for (let i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  }\n  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    points.length -= 2;\n    const n = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n    points.push(fromX, fromY);\n    for (let i = 1, j = 0; i <= n; ++i) {\n      j = i / n;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  }\n}\n\n\n//# sourceMappingURL=BezierUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildLine.mjs\n\n\n\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy, eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy, sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy, ex, ey);\n  } else {\n    verts.push(sx, sy, cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);\n    }\n    verts.push(ex, ey, cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  const shape = graphicsData.shape;\n  let points = graphicsData.points || shape.points.slice();\n  const eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = graphicsData.lineStyle;\n  const firstPoint = new lib/* Point */.E9(points[0], points[1]);\n  const lastPoint = new lib/* Point */.E9(points[points.length - 2], points[points.length - 1]);\n  const closedShape = shape.type !== lib/* SHAPES.POLY */.HS.POLY || shape.closeStroke;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = graphicsGeometry.points;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpx = -(y0 - y1);\n  let perpy = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  const ratio = style.alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      if (dot >= 0) {\n        if (style.join === LINE_JOIN.ROUND) {\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n      }\n      continue;\n    }\n    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    let join = style.join;\n    if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {\n      join = LINE_JOIN.BEVEL;\n    }\n    if (insideMiterOk) {\n      switch (join) {\n        case LINE_JOIN.MITER: {\n          verts.push(imx, imy, omx, omy);\n          break;\n        }\n        case LINE_JOIN.BEVEL: {\n          if (clockwise) {\n            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n          } else {\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);\n          }\n          indexCount += 2;\n          break;\n        }\n        case LINE_JOIN.ROUND: {\n          if (clockwise) {\n            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n          } else {\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);\n            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);\n          }\n          break;\n        }\n      }\n    } else {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      switch (join) {\n        case LINE_JOIN.MITER: {\n          if (clockwise) {\n            verts.push(omx, omy, omx, omy);\n          } else {\n            verts.push(imx, imy, imx, imy);\n          }\n          indexCount += 2;\n          break;\n        }\n        case LINE_JOIN.ROUND: {\n          if (clockwise) {\n            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n          } else {\n            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n          }\n          break;\n        }\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const indices = graphicsGeometry.indices;\n  const eps2 = curves.epsilon * curves.epsilon;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  let i = 0;\n  const shape = graphicsData.shape;\n  const points = graphicsData.points || shape.points;\n  const closedShape = shape.type !== lib/* SHAPES.POLY */.HS.POLY || shape.closeStroke;\n  if (points.length === 0)\n    return;\n  const verts = graphicsGeometry.points;\n  const indices = graphicsGeometry.indices;\n  const length = points.length / 2;\n  const startIndex = verts.length / 2;\n  let currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\n\n\n//# sourceMappingURL=buildLine.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs\n\n\nclass QuadraticUtils {\n  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {\n    const ax = fromX - 2 * cpX + toX;\n    const ay = fromY - 2 * cpY + toY;\n    const bx = 2 * cpX - 2 * fromX;\n    const by = 2 * cpY - 2 * fromY;\n    const a = 4 * (ax * ax + ay * ay);\n    const b = 4 * (ax * bx + ay * by);\n    const c = bx * bx + by * by;\n    const s = 2 * Math.sqrt(a + b + c);\n    const a2 = Math.sqrt(a);\n    const a32 = 2 * a * a2;\n    const c2 = 2 * Math.sqrt(c);\n    const ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);\n  }\n  static curveTo(cpX, cpY, toX, toY, points) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const n = curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));\n    let xa = 0;\n    let ya = 0;\n    for (let i = 1; i <= n; ++i) {\n      const j = i / n;\n      xa = fromX + (cpX - fromX) * j;\n      ya = fromY + (cpY - fromY) * j;\n      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n    }\n  }\n}\n\n\n//# sourceMappingURL=QuadraticUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst FILL_COMMANDS = {\n  [lib/* SHAPES.POLY */.HS.POLY]: buildPoly,\n  [lib/* SHAPES.CIRC */.HS.CIRC]: buildCircle,\n  [lib/* SHAPES.ELIP */.HS.ELIP]: buildCircle,\n  [lib/* SHAPES.RECT */.HS.RECT]: buildRectangle,\n  [lib/* SHAPES.RREC */.HS.RREC]: buildRoundedRectangle\n};\nconst BATCH_POOL = [];\nconst DRAW_CALL_POOL = [];\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/GraphicsData.mjs\nclass GraphicsData {\n  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {\n    this.points = [];\n    this.holes = [];\n    this.shape = shape;\n    this.lineStyle = lineStyle;\n    this.fillStyle = fillStyle;\n    this.matrix = matrix;\n    this.type = shape.type;\n  }\n  clone() {\n    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  }\n  destroy() {\n    this.shape = null;\n    this.holes.length = 0;\n    this.holes = null;\n    this.points.length = 0;\n    this.points = null;\n    this.lineStyle = null;\n    this.fillStyle = null;\n  }\n}\n\n\n//# sourceMappingURL=GraphicsData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs\nclass BatchPart {\n  constructor() {\n    this.reset();\n  }\n  begin(style, startIndex, attribStart) {\n    this.reset();\n    this.style = style;\n    this.start = startIndex;\n    this.attribStart = attribStart;\n  }\n  end(endIndex, endAttrib) {\n    this.attribSize = endAttrib - this.attribStart;\n    this.size = endIndex - this.start;\n  }\n  reset() {\n    this.style = null;\n    this.size = 0;\n    this.start = 0;\n    this.attribStart = 0;\n    this.attribSize = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchPart.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs\n\n\n\n\n\n\n\n\nconst tmpPoint = new lib/* Point */.E9();\nconst _GraphicsGeometry = class extends lib/* BatchGeometry */.JZ {\n  constructor() {\n    super();\n    this.closePointEps = 1e-4;\n    this.boundsPadding = 0;\n    this.uvsFloat32 = null;\n    this.indicesUint16 = null;\n    this.batchable = false;\n    this.points = [];\n    this.colors = [];\n    this.uvs = [];\n    this.indices = [];\n    this.textureIds = [];\n    this.graphicsData = [];\n    this.drawCalls = [];\n    this.batchDirty = -1;\n    this.batches = [];\n    this.dirty = 0;\n    this.cacheDirty = -1;\n    this.clearDirty = 0;\n    this.shapeIndex = 0;\n    this._bounds = new display_lib/* Bounds */.YZ();\n    this.boundsDirty = -1;\n  }\n  get bounds() {\n    this.updateBatches();\n    if (this.boundsDirty !== this.dirty) {\n      this.boundsDirty = this.dirty;\n      this.calculateBounds();\n    }\n    return this._bounds;\n  }\n  invalidate() {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n    for (let i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    for (let i = 0; i < this.batches.length; i++) {\n      const batchPart = this.batches[i];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  }\n  clear() {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    return this;\n  }\n  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {\n    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  }\n  drawHole(shape, matrix = null) {\n    if (!this.graphicsData.length) {\n      return null;\n    }\n    const data = new GraphicsData(shape, null, null, matrix);\n    const lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  }\n  containsPoint(point) {\n    const graphicsData = this.graphicsData;\n    for (let i = 0; i < graphicsData.length; ++i) {\n      const data = graphicsData[i];\n      if (!data.fillStyle.visible) {\n        continue;\n      }\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          let hitHole = false;\n          if (data.holes) {\n            for (let i2 = 0; i2 < data.holes.length; i2++) {\n              const hole = data.holes[i2];\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  updateBatches() {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n    if (!this.validateBatching()) {\n      return;\n    }\n    this.cacheDirty = this.dirty;\n    const uvs = this.uvs;\n    const graphicsData = this.graphicsData;\n    let batchPart = null;\n    let currentStyle = null;\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n    for (let i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      const data = graphicsData[i];\n      const fillStyle = data.fillStyle;\n      const lineStyle = data.lineStyle;\n      const command = FILL_COMMANDS[data.type];\n      command.build(data);\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n      if (fillStyle.visible || lineStyle.visible) {\n        this.processHoles(data.holes);\n      }\n      for (let j = 0; j < 2; j++) {\n        const style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible)\n          continue;\n        const nextTexture = style.texture.baseTexture;\n        const index2 = this.indices.length;\n        const attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = lib/* WRAP_MODES.REPEAT */.Nt.REPEAT;\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n        const size = this.points.length / 2 - attribIndex;\n        if (size === 0)\n          continue;\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index2, attribIndex);\n          batchPart = null;\n        }\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index2, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n    const index = this.indices.length;\n    const attrib = this.points.length / 2;\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n    if (this.batches.length === 0) {\n      this.batchable = true;\n      return;\n    }\n    const need32 = attrib > 65535;\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    }\n    this.batchable = this.isBatchable();\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  }\n  _compareStyles(styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n    return true;\n  }\n  validateBatching() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n    for (let i = 0, l = this.graphicsData.length; i < l; i++) {\n      const data = this.graphicsData[i];\n      const fill = data.fillStyle;\n      const line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid)\n        return false;\n      if (line && !line.texture.baseTexture.valid)\n        return false;\n    }\n    return true;\n  }\n  packBatches() {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    const batches = this.batches;\n    for (let i = 0, l = batches.length; i < l; i++) {\n      const batch = batches[i];\n      for (let j = 0; j < batch.size; j++) {\n        const index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  }\n  isBatchable() {\n    if (this.points.length > 65535 * 2) {\n      return false;\n    }\n    const batches = this.batches;\n    for (let i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;\n  }\n  buildDrawCalls() {\n    let TICK = ++lib/* BaseTexture._globalBatch */.VL._globalBatch;\n    for (let i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    const colors = this.colors;\n    const textureIds = this.textureIds;\n    let currentGroup = DRAW_CALL_POOL.pop();\n    if (!currentGroup) {\n      currentGroup = new lib/* BatchDrawCall */.a$();\n      currentGroup.texArray = new lib/* BatchTextureArray */.Ie();\n    }\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = lib/* DRAW_MODES.TRIANGLES */.lg.TRIANGLES;\n    let textureCount = 0;\n    let currentTexture = null;\n    let textureId = 0;\n    let native = false;\n    let drawMode = lib/* DRAW_MODES.TRIANGLES */.lg.TRIANGLES;\n    let index = 0;\n    this.drawCalls.push(currentGroup);\n    for (let i = 0; i < this.batches.length; i++) {\n      const data = this.batches[i];\n      const maxTextures = 8;\n      const style = data.style;\n      const nextTexture = style.texture.baseTexture;\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? lib/* DRAW_MODES.LINES */.lg.LINES : lib/* DRAW_MODES.TRIANGLES */.lg.TRIANGLES;\n        currentTexture = null;\n        textureCount = maxTextures;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === maxTextures) {\n            TICK++;\n            textureCount = 0;\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n              if (!currentGroup) {\n                currentGroup = new lib/* BatchDrawCall */.a$();\n                currentGroup.texArray = new lib/* BatchTextureArray */.Ie();\n              }\n              this.drawCalls.push(currentGroup);\n            }\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          }\n          nextTexture.touched = 1;\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = lib/* WRAP_MODES.REPEAT */.Nt.REPEAT;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    lib/* BaseTexture._globalBatch */.VL._globalBatch = TICK;\n    this.packAttributes();\n  }\n  packAttributes() {\n    const verts = this.points;\n    const uvs = this.uvs;\n    const colors = this.colors;\n    const textureIds = this.textureIds;\n    const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    const f32 = new Float32Array(glPoints);\n    const u32 = new Uint32Array(glPoints);\n    let p = 0;\n    for (let i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n    this._buffer.update(glPoints);\n    this._indexBuffer.update(this.indicesUint16);\n  }\n  processFill(data) {\n    if (data.holes.length) {\n      buildPoly.triangulate(data, this);\n    } else {\n      const command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  }\n  processLine(data) {\n    buildLine(data, this);\n    for (let i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  }\n  processHoles(holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  }\n  calculateBounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    bounds.addVertexData(this.points, 0, this.points.length);\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  }\n  transformPoints(points, matrix) {\n    for (let i = 0; i < points.length / 2; i++) {\n      const x = points[i * 2];\n      const y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  }\n  addColors(colors, color, alpha, size, offset = 0) {\n    const bgr = lib/* Color.shared.setValue */.Il.shared.setValue(color).toLittleEndianNumber();\n    const result = lib/* Color.shared.setValue */.Il.shared.setValue(bgr).toPremultiplied(alpha);\n    colors.length = Math.max(colors.length, offset + size);\n    for (let i = 0; i < size; i++) {\n      colors[offset + i] = result;\n    }\n  }\n  addTextureIds(textureIds, id, size, offset = 0) {\n    textureIds.length = Math.max(textureIds.length, offset + size);\n    for (let i = 0; i < size; i++) {\n      textureIds[offset + i] = id;\n    }\n  }\n  addUvs(verts, uvs, texture, start, size, matrix = null) {\n    let index = 0;\n    const uvsStart = uvs.length;\n    const frame = texture.frame;\n    while (index < size) {\n      let x = verts[(start + index) * 2];\n      let y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        const nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n    const baseTexture = texture.baseTexture;\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  }\n  adjustUvs(uvs, texture, start, size) {\n    const baseTexture = texture.baseTexture;\n    const eps = 1e-6;\n    const finish = start + size * 2;\n    const frame = texture.frame;\n    const scaleX = frame.width / baseTexture.width;\n    const scaleY = frame.height / baseTexture.height;\n    let offsetX = frame.x / frame.width;\n    let offsetY = frame.y / frame.height;\n    let minX = Math.floor(uvs[start] + eps);\n    let minY = Math.floor(uvs[start + 1] + eps);\n    for (let i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n    offsetX -= minX;\n    offsetY -= minY;\n    for (let i = start; i < finish; i += 2) {\n      uvs[i] = (uvs[i] + offsetX) * scaleX;\n      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n    }\n  }\n};\nlet GraphicsGeometry = _GraphicsGeometry;\nGraphicsGeometry.BATCHABLE_SIZE = 100;\n\n\n//# sourceMappingURL=GraphicsGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs\n\n\nclass FillStyle {\n  constructor() {\n    this.color = 16777215;\n    this.alpha = 1;\n    this.texture = lib/* Texture.WHITE */.xE.WHITE;\n    this.matrix = null;\n    this.visible = false;\n    this.reset();\n  }\n  clone() {\n    const obj = new FillStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    return obj;\n  }\n  reset() {\n    this.color = 16777215;\n    this.alpha = 1;\n    this.texture = lib/* Texture.WHITE */.xE.WHITE;\n    this.matrix = null;\n    this.visible = false;\n  }\n  destroy() {\n    this.texture = null;\n    this.matrix = null;\n  }\n}\n\n\n//# sourceMappingURL=FillStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/styles/LineStyle.mjs\n\n\n\nclass LineStyle extends FillStyle {\n  constructor() {\n    super(...arguments);\n    this.width = 0;\n    this.alignment = 0.5;\n    this.native = false;\n    this.cap = LINE_CAP.BUTT;\n    this.join = LINE_JOIN.MITER;\n    this.miterLimit = 10;\n  }\n  clone() {\n    const obj = new LineStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    obj.width = this.width;\n    obj.alignment = this.alignment;\n    obj.native = this.native;\n    obj.cap = this.cap;\n    obj.join = this.join;\n    obj.miterLimit = this.miterLimit;\n    return obj;\n  }\n  reset() {\n    super.reset();\n    this.color = 0;\n    this.alignment = 0.5;\n    this.width = 0;\n    this.native = false;\n  }\n}\n\n\n//# sourceMappingURL=LineStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/Graphics.mjs\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_SHADERS = {};\nconst _Graphics = class extends display_lib/* Container */.W2 {\n  constructor(geometry = null) {\n    super();\n    this.shader = null;\n    this.pluginName = "batch";\n    this.currentPath = null;\n    this.batches = [];\n    this.batchTint = -1;\n    this.batchDirty = -1;\n    this.vertexData = null;\n    this._fillStyle = new FillStyle();\n    this._lineStyle = new LineStyle();\n    this._matrix = null;\n    this._holeMode = false;\n    this.state = lib/* State.for2d */.ZM.for2d();\n    this._geometry = geometry || new GraphicsGeometry();\n    this._geometry.refCount++;\n    this._transformID = -1;\n    this._tintColor = new lib/* Color */.Il(16777215);\n    this.blendMode = lib/* BLEND_MODES.NORMAL */.T$.NORMAL;\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  clone() {\n    this.finishPoly();\n    return new _Graphics(this._geometry);\n  }\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value);\n  }\n  get fill() {\n    return this._fillStyle;\n  }\n  get line() {\n    return this._lineStyle;\n  }\n  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {\n    if (typeof options === "number") {\n      options = { width: options, color, alpha, alignment, native };\n    }\n    return this.lineTextureStyle(options);\n  }\n  lineTextureStyle(options) {\n    const defaultLineStyleOptions = {\n      width: 0,\n      texture: lib/* Texture.WHITE */.xE.WHITE,\n      color: options?.texture ? 16777215 : 0,\n      matrix: null,\n      alignment: 0.5,\n      native: false,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    };\n    options = Object.assign(defaultLineStyleOptions, options);\n    this.normalizeColor(options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    const visible = options.width > 0 && options.alpha > 0;\n    if (!visible) {\n      this._lineStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._lineStyle, { visible }, options);\n    }\n    return this;\n  }\n  startPoly() {\n    if (this.currentPath) {\n      const points = this.currentPath.points;\n      const len = this.currentPath.points.length;\n      if (len > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = new lib/* Polygon */.mg();\n        this.currentPath.closeStroke = false;\n        this.currentPath.points.push(points[len - 2], points[len - 1]);\n      }\n    } else {\n      this.currentPath = new lib/* Polygon */.mg();\n      this.currentPath.closeStroke = false;\n    }\n  }\n  finishPoly() {\n    if (this.currentPath) {\n      if (this.currentPath.points.length > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = null;\n      } else {\n        this.currentPath.points.length = 0;\n      }\n    }\n  }\n  moveTo(x, y) {\n    this.startPoly();\n    this.currentPath.points[0] = x;\n    this.currentPath.points[1] = y;\n    return this;\n  }\n  lineTo(x, y) {\n    if (!this.currentPath) {\n      this.moveTo(0, 0);\n    }\n    const points = this.currentPath.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  _initCurve(x = 0, y = 0) {\n    if (this.currentPath) {\n      if (this.currentPath.points.length === 0) {\n        this.currentPath.points = [x, y];\n      }\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  quadraticCurveTo(cpX, cpY, toX, toY) {\n    this._initCurve();\n    const points = this.currentPath.points;\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n    return this;\n  }\n  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._initCurve();\n    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n    return this;\n  }\n  arcTo(x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n    const points = this.currentPath.points;\n    const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n    if (result) {\n      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;\n      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);\n    }\n    return this;\n  }\n  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {\n    if (startAngle === endAngle) {\n      return this;\n    }\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += lib/* PI_2 */._b;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += lib/* PI_2 */._b;\n    }\n    const sweep = endAngle - startAngle;\n    if (sweep === 0) {\n      return this;\n    }\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const eps = this._geometry.closePointEps;\n    let points = this.currentPath ? this.currentPath.points : null;\n    if (points) {\n      const xDiff = Math.abs(points[points.length - 2] - startX);\n      const yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < eps && yDiff < eps) {\n      } else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.points;\n    }\n    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n    return this;\n  }\n  beginFill(color = 0, alpha) {\n    return this.beginTextureFill({ texture: lib/* Texture.WHITE */.xE.WHITE, color, alpha });\n  }\n  normalizeColor(options) {\n    const temp = lib/* Color.shared.setValue */.Il.shared.setValue(options.color ?? 0);\n    options.color = temp.toNumber();\n    options.alpha ?? (options.alpha = temp.alpha);\n  }\n  beginTextureFill(options) {\n    const defaultOptions = {\n      texture: lib/* Texture.WHITE */.xE.WHITE,\n      color: 16777215,\n      matrix: null\n    };\n    options = Object.assign(defaultOptions, options);\n    this.normalizeColor(options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    const visible = options.alpha > 0;\n    if (!visible) {\n      this._fillStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._fillStyle, { visible }, options);\n    }\n    return this;\n  }\n  endFill() {\n    this.finishPoly();\n    this._fillStyle.reset();\n    return this;\n  }\n  drawRect(x, y, width, height) {\n    return this.drawShape(new lib/* Rectangle */.Ae(x, y, width, height));\n  }\n  drawRoundedRect(x, y, width, height, radius) {\n    return this.drawShape(new lib/* RoundedRectangle */.c9(x, y, width, height, radius));\n  }\n  drawCircle(x, y, radius) {\n    return this.drawShape(new lib/* Circle */.Cd(x, y, radius));\n  }\n  drawEllipse(x, y, width, height) {\n    return this.drawShape(new lib/* Ellipse */.Pj(x, y, width, height));\n  }\n  drawPolygon(...path) {\n    let points;\n    let closeStroke = true;\n    const poly = path[0];\n    if (poly.points) {\n      closeStroke = poly.closeStroke;\n      points = poly.points;\n    } else if (Array.isArray(path[0])) {\n      points = path[0];\n    } else {\n      points = path;\n    }\n    const shape = new lib/* Polygon */.mg(points);\n    shape.closeStroke = closeStroke;\n    this.drawShape(shape);\n    return this;\n  }\n  drawShape(shape) {\n    if (!this._holeMode) {\n      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n    } else {\n      this._geometry.drawHole(shape, this._matrix);\n    }\n    return this;\n  }\n  clear() {\n    this._geometry.clear();\n    this._lineStyle.reset();\n    this._fillStyle.reset();\n    this._boundsID++;\n    this._matrix = null;\n    this._holeMode = false;\n    this.currentPath = null;\n    return this;\n  }\n  isFastRect() {\n    const data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === lib/* SHAPES.RECT */.HS.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  }\n  _render(renderer) {\n    this.finishPoly();\n    const geometry = this._geometry;\n    geometry.updateBatches();\n    if (geometry.batchable) {\n      if (this.batchDirty !== geometry.batchDirty) {\n        this._populateBatches();\n      }\n      this._renderBatched(renderer);\n    } else {\n      renderer.batch.flush();\n      this._renderDirect(renderer);\n    }\n  }\n  _populateBatches() {\n    const geometry = this._geometry;\n    const blendMode = this.blendMode;\n    const len = geometry.batches.length;\n    this.batchTint = -1;\n    this._transformID = -1;\n    this.batchDirty = geometry.batchDirty;\n    this.batches.length = len;\n    this.vertexData = new Float32Array(geometry.points);\n    for (let i = 0; i < len; i++) {\n      const gI = geometry.batches[i];\n      const color = gI.style.color;\n      const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      const indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n      const batch = {\n        vertexData,\n        blendMode,\n        indices,\n        uvs,\n        _batchRGB: lib/* Color.shared.setValue */.Il.shared.setValue(color).toRgbArray(),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  }\n  _renderBatched(renderer) {\n    if (!this.batches.length) {\n      return;\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    this.calculateVertices();\n    this.calculateTints();\n    for (let i = 0, l = this.batches.length; i < l; i++) {\n      const batch = this.batches[i];\n      batch.worldAlpha = this.worldAlpha * batch.alpha;\n      renderer.plugins[this.pluginName].render(batch);\n    }\n  }\n  _renderDirect(renderer) {\n    const shader = this._resolveDirectShader(renderer);\n    const geometry = this._geometry;\n    const worldAlpha = this.worldAlpha;\n    const uniforms = shader.uniforms;\n    const drawCalls = geometry.drawCalls;\n    uniforms.translationMatrix = this.transform.worldTransform;\n    lib/* Color.shared.setValue */.Il.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader);\n    renderer.state.set(this.state);\n    for (let i = 0, l = drawCalls.length; i < l; i++) {\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n    }\n  }\n  _renderDrawCallDirect(renderer, drawCall) {\n    const { texArray, type, size, start } = drawCall;\n    const groupTextureCount = texArray.count;\n    for (let j = 0; j < groupTextureCount; j++) {\n      renderer.texture.bind(texArray.elements[j], j);\n    }\n    renderer.geometry.draw(type, size, start);\n  }\n  _resolveDirectShader(renderer) {\n    let shader = this.shader;\n    const pluginName = this.pluginName;\n    if (!shader) {\n      if (!DEFAULT_SHADERS[pluginName]) {\n        const { maxTextures } = renderer.plugins[pluginName];\n        const sampleValues = new Int32Array(maxTextures);\n        for (let i = 0; i < maxTextures; i++) {\n          sampleValues[i] = i;\n        }\n        const uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new lib/* Matrix */.y3(),\n          default: lib/* UniformGroup.from */.oo.from({ uSamplers: sampleValues }, true)\n        };\n        const program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new lib/* Shader */.ex(program, uniforms);\n      }\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n    return shader;\n  }\n  _calculateBounds() {\n    this.finishPoly();\n    const geometry = this._geometry;\n    if (!geometry.graphicsData.length) {\n      return;\n    }\n    const { minX, minY, maxX, maxY } = geometry.bounds;\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  }\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);\n    return this._geometry.containsPoint(_Graphics._TEMP_POINT);\n  }\n  calculateTints() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this._tintColor.toNumber();\n      for (let i = 0; i < this.batches.length; i++) {\n        const batch = this.batches[i];\n        batch._tintRGB = lib/* Color.shared.setValue */.Il.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();\n      }\n    }\n  }\n  calculateVertices() {\n    const wtID = this.transform._worldID;\n    if (this._transformID === wtID) {\n      return;\n    }\n    this._transformID = wtID;\n    const wt = this.transform.worldTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const data = this._geometry.points;\n    const vertexData = this.vertexData;\n    let count = 0;\n    for (let i = 0; i < data.length; i += 2) {\n      const x = data[i];\n      const y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx;\n      vertexData[count++] = d * y + b * x + ty;\n    }\n  }\n  closePath() {\n    const currentPath = this.currentPath;\n    if (currentPath) {\n      currentPath.closeStroke = true;\n      this.finishPoly();\n    }\n    return this;\n  }\n  setMatrix(matrix) {\n    this._matrix = matrix;\n    return this;\n  }\n  beginHole() {\n    this.finishPoly();\n    this._holeMode = true;\n    return this;\n  }\n  endHole() {\n    this.finishPoly();\n    this._holeMode = false;\n    return this;\n  }\n  destroy(options) {\n    this._geometry.refCount--;\n    if (this._geometry.refCount === 0) {\n      this._geometry.dispose();\n    }\n    this._matrix = null;\n    this.currentPath = null;\n    this._lineStyle.destroy();\n    this._lineStyle = null;\n    this._fillStyle.destroy();\n    this._fillStyle = null;\n    this._geometry = null;\n    this.shader = null;\n    this.vertexData = null;\n    this.batches.length = 0;\n    this.batches = null;\n    super.destroy(options);\n  }\n};\nlet Graphics = _Graphics;\nGraphics.curves = curves;\nGraphics._TEMP_POINT = new lib/* Point */.E9();\n\n\n//# sourceMappingURL=Graphics.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst graphicsUtils = {\n  buildPoly: buildPoly,\n  buildCircle: buildCircle,\n  buildRectangle: buildRectangle,\n  buildRoundedRectangle: buildRoundedRectangle,\n  buildLine: buildLine,\n  ArcUtils: ArcUtils,\n  BezierUtils: BezierUtils,\n  QuadraticUtils: QuadraticUtils,\n  BatchPart: BatchPart,\n  FILL_COMMANDS: FILL_COMMANDS,\n  BATCH_POOL: BATCH_POOL,\n  DRAW_CALL_POOL: DRAW_CALL_POOL\n};\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs\nclass MeshBatchUvs {\n  constructor(uvBuffer, uvMatrix) {\n    this.uvBuffer = uvBuffer;\n    this.uvMatrix = uvMatrix;\n    this.data = null;\n    this._bufferUpdateId = -1;\n    this._textureUpdateId = -1;\n    this._updateID = 0;\n  }\n  update(forceUpdate) {\n    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {\n      return;\n    }\n    this._bufferUpdateId = this.uvBuffer._updateID;\n    this._textureUpdateId = this.uvMatrix._updateID;\n    const data = this.uvBuffer.data;\n    if (!this.data || this.data.length !== data.length) {\n      this.data = new Float32Array(data.length);\n    }\n    this.uvMatrix.multiplyUvs(data, this.data);\n    this._updateID++;\n  }\n}\n\n\n//# sourceMappingURL=MeshBatchUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/Mesh.mjs\n\n\n\n\nconst Mesh_tempPoint = new lib/* Point */.E9();\nconst tempPolygon = new lib/* Polygon */.mg();\nconst _Mesh = class extends display_lib/* Container */.W2 {\n  constructor(geometry, shader, state, drawMode = lib/* DRAW_MODES.TRIANGLES */.lg.TRIANGLES) {\n    super();\n    this.geometry = geometry;\n    this.shader = shader;\n    this.state = state || lib/* State.for2d */.ZM.for2d();\n    this.drawMode = drawMode;\n    this.start = 0;\n    this.size = 0;\n    this.uvs = null;\n    this.indices = null;\n    this.vertexData = new Float32Array(1);\n    this.vertexDirty = -1;\n    this._transformID = -1;\n    this._roundPixels = lib/* settings.ROUND_PIXELS */.Xd.ROUND_PIXELS;\n    this.batchUvs = null;\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  set geometry(value) {\n    if (this._geometry === value) {\n      return;\n    }\n    if (this._geometry) {\n      this._geometry.refCount--;\n      if (this._geometry.refCount === 0) {\n        this._geometry.dispose();\n      }\n    }\n    this._geometry = value;\n    if (this._geometry) {\n      this._geometry.refCount++;\n    }\n    this.vertexDirty = -1;\n  }\n  get uvBuffer() {\n    return this.geometry.buffers[1];\n  }\n  get verticesBuffer() {\n    return this.geometry.buffers[0];\n  }\n  set material(value) {\n    this.shader = value;\n  }\n  get material() {\n    return this.shader;\n  }\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  set roundPixels(value) {\n    if (this._roundPixels !== value) {\n      this._transformID = -1;\n    }\n    this._roundPixels = value;\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  get tint() {\n    return "tint" in this.shader ? this.shader.tint : null;\n  }\n  set tint(value) {\n    this.shader.tint = value;\n  }\n  get tintValue() {\n    return this.shader.tintValue;\n  }\n  get texture() {\n    return "texture" in this.shader ? this.shader.texture : null;\n  }\n  set texture(value) {\n    this.shader.texture = value;\n  }\n  _render(renderer) {\n    const vertices = this.geometry.buffers[0].data;\n    const shader = this.shader;\n    if (shader.batchable && this.drawMode === lib/* DRAW_MODES.TRIANGLES */.lg.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {\n      this._renderToBatch(renderer);\n    } else {\n      this._renderDefault(renderer);\n    }\n  }\n  _renderDefault(renderer) {\n    const shader = this.shader;\n    shader.alpha = this.worldAlpha;\n    if (shader.update) {\n      shader.update();\n    }\n    renderer.batch.flush();\n    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n    renderer.shader.bind(shader);\n    renderer.state.set(this.state);\n    renderer.geometry.bind(this.geometry, shader);\n    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  }\n  _renderToBatch(renderer) {\n    const geometry = this.geometry;\n    const shader = this.shader;\n    if (shader.uvMatrix) {\n      shader.uvMatrix.update();\n      this.calculateUvs();\n    }\n    this.calculateVertices();\n    this.indices = geometry.indexBuffer.data;\n    this._tintRGB = shader._tintRGB;\n    this._texture = shader.texture;\n    const pluginName = this.material.pluginName;\n    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n    renderer.plugins[pluginName].render(this);\n  }\n  calculateVertices() {\n    const geometry = this.geometry;\n    const verticesBuffer = geometry.buffers[0];\n    const vertices = verticesBuffer.data;\n    const vertexDirtyId = verticesBuffer._updateID;\n    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {\n      return;\n    }\n    this._transformID = this.transform._worldID;\n    if (this.vertexData.length !== vertices.length) {\n      this.vertexData = new Float32Array(vertices.length);\n    }\n    const wt = this.transform.worldTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const vertexData = this.vertexData;\n    for (let i = 0; i < vertexData.length / 2; i++) {\n      const x = vertices[i * 2];\n      const y = vertices[i * 2 + 1];\n      vertexData[i * 2] = a * x + c * y + tx;\n      vertexData[i * 2 + 1] = b * x + d * y + ty;\n    }\n    if (this._roundPixels) {\n      const resolution = lib/* settings.RESOLUTION */.Xd.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i) {\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n      }\n    }\n    this.vertexDirty = vertexDirtyId;\n  }\n  calculateUvs() {\n    const geomUvs = this.geometry.buffers[1];\n    const shader = this.shader;\n    if (!shader.uvMatrix.isSimple) {\n      if (!this.batchUvs) {\n        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n      }\n      this.batchUvs.update();\n      this.uvs = this.batchUvs.data;\n    } else {\n      this.uvs = geomUvs.data;\n    }\n  }\n  _calculateBounds() {\n    this.calculateVertices();\n    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  }\n  containsPoint(point) {\n    if (!this.getBounds().contains(point.x, point.y)) {\n      return false;\n    }\n    this.worldTransform.applyInverse(point, Mesh_tempPoint);\n    const vertices = this.geometry.getBuffer("aVertexPosition").data;\n    const points = tempPolygon.points;\n    const indices = this.geometry.getIndex().data;\n    const len = indices.length;\n    const step = this.drawMode === 4 ? 3 : 1;\n    for (let i = 0; i + 2 < len; i += step) {\n      const ind0 = indices[i] * 2;\n      const ind1 = indices[i + 1] * 2;\n      const ind2 = indices[i + 2] * 2;\n      points[0] = vertices[ind0];\n      points[1] = vertices[ind0 + 1];\n      points[2] = vertices[ind1];\n      points[3] = vertices[ind1 + 1];\n      points[4] = vertices[ind2];\n      points[5] = vertices[ind2 + 1];\n      if (tempPolygon.contains(Mesh_tempPoint.x, Mesh_tempPoint.y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  destroy(options) {\n    super.destroy(options);\n    if (this._cachedTexture) {\n      this._cachedTexture.destroy();\n      this._cachedTexture = null;\n    }\n    this.geometry = null;\n    this.shader = null;\n    this.state = null;\n    this.uvs = null;\n    this.indices = null;\n    this.vertexData = null;\n  }\n};\nlet Mesh_Mesh = _Mesh;\nMesh_Mesh.BATCHABLE_SIZE = 100;\n\n\n//# sourceMappingURL=Mesh.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshGeometry.mjs\n\n\nclass MeshGeometry_MeshGeometry extends lib/* Geometry */.wG {\n  constructor(vertices, uvs, index) {\n    super();\n    const verticesBuffer = new lib/* Buffer */.lW(vertices);\n    const uvsBuffer = new lib/* Buffer */.lW(uvs, true);\n    const indexBuffer = new lib/* Buffer */.lW(index, true, true);\n    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, lib/* TYPES.FLOAT */.vK.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, lib/* TYPES.FLOAT */.vK.FLOAT).addIndex(indexBuffer);\n    this._updateId = -1;\n  }\n  get vertexDirtyId() {\n    return this.buffers[0]._updateID;\n  }\n}\n\n\n//# sourceMappingURL=MeshGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/shader/mesh.mjs\nvar mesh_fragment = "varying vec2 vTextureCoord;\\nuniform vec4 uColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=mesh.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/shader/mesh2.mjs\nvar mesh2_vertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTextureMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\n}\\n";\n\n\n//# sourceMappingURL=mesh2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshMaterial.mjs\n\n\n\n\nclass MeshMaterial_MeshMaterial extends lib/* Shader */.ex {\n  constructor(uSampler, options) {\n    const uniforms = {\n      uSampler,\n      alpha: 1,\n      uTextureMatrix: lib/* Matrix.IDENTITY */.y3.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    options = Object.assign({\n      tint: 16777215,\n      alpha: 1,\n      pluginName: "batch"\n    }, options);\n    if (options.uniforms) {\n      Object.assign(uniforms, options.uniforms);\n    }\n    super(options.program || lib/* Program.from */.$r.from(mesh2_vertex, mesh_fragment), uniforms);\n    this._colorDirty = false;\n    this.uvMatrix = new lib/* TextureMatrix */.UX(uSampler);\n    this.batchable = options.program === void 0;\n    this.pluginName = options.pluginName;\n    this._tintColor = new lib/* Color */.Il(options.tint);\n    this._tintRGB = this._tintColor.toLittleEndianNumber();\n    this._colorDirty = true;\n    this.alpha = options.alpha;\n  }\n  get texture() {\n    return this.uniforms.uSampler;\n  }\n  set texture(value) {\n    if (this.uniforms.uSampler !== value) {\n      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {\n        this._colorDirty = true;\n      }\n      this.uniforms.uSampler = value;\n      this.uvMatrix.texture = value;\n    }\n  }\n  set alpha(value) {\n    if (value === this._alpha)\n      return;\n    this._alpha = value;\n    this._colorDirty = true;\n  }\n  get alpha() {\n    return this._alpha;\n  }\n  set tint(value) {\n    if (value === this.tint)\n      return;\n    this._tintColor.setValue(value);\n    this._tintRGB = this._tintColor.toLittleEndianNumber();\n    this._colorDirty = true;\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  get tintValue() {\n    return this._tintColor.toNumber();\n  }\n  update() {\n    if (this._colorDirty) {\n      this._colorDirty = false;\n      const baseTexture = this.texture.baseTexture;\n      const applyToChannels = baseTexture.alphaMode;\n      lib/* Color.shared.setValue */.Il.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);\n    }\n    if (this.uvMatrix.update()) {\n      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n    }\n  }\n}\n\n\n//# sourceMappingURL=MeshMaterial.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs\n\n\nclass PlaneGeometry_PlaneGeometry extends (/* unused pure expression or super */ null && (MeshGeometry)) {\n  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {\n    super();\n    this.segWidth = segWidth;\n    this.segHeight = segHeight;\n    this.width = width;\n    this.height = height;\n    this.build();\n  }\n  build() {\n    const total = this.segWidth * this.segHeight;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const segmentsX = this.segWidth - 1;\n    const segmentsY = this.segHeight - 1;\n    const sizeX = this.width / segmentsX;\n    const sizeY = this.height / segmentsY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.segWidth;\n      const y = i / this.segWidth | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / segmentsX, y / segmentsY);\n    }\n    const totalSub = segmentsX * segmentsY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % segmentsX;\n      const ypos = i / segmentsX | 0;\n      const value = ypos * this.segWidth + xpos;\n      const value2 = ypos * this.segWidth + xpos + 1;\n      const value3 = (ypos + 1) * this.segWidth + xpos;\n      const value4 = (ypos + 1) * this.segWidth + xpos + 1;\n      indices.push(value, value2, value3, value2, value4, value3);\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint16Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n}\n\n\n//# sourceMappingURL=PlaneGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs\n\n\nclass RopeGeometry_RopeGeometry extends (/* unused pure expression or super */ null && (MeshGeometry)) {\n  constructor(width = 200, points, textureScale = 0) {\n    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));\n    this.points = points;\n    this._width = width;\n    this.textureScale = textureScale;\n    this.build();\n  }\n  get width() {\n    return this._width;\n  }\n  build() {\n    const points = this.points;\n    if (!points)\n      return;\n    const vertexBuffer = this.getBuffer("aVertexPosition");\n    const uvBuffer = this.getBuffer("aTextureCoord");\n    const indexBuffer = this.getIndex();\n    if (points.length < 1) {\n      return;\n    }\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n    }\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    let amount = 0;\n    let prev = points[0];\n    const textureWidth = this._width * this.textureScale;\n    const total = points.length;\n    for (let i = 0; i < total; i++) {\n      const index = i * 4;\n      if (this.textureScale > 0) {\n        const dx = prev.x - points[i].x;\n        const dy = prev.y - points[i].y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        prev = points[i];\n        amount += distance / textureWidth;\n      } else {\n        amount = i / (total - 1);\n      }\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n    let indexCount = 0;\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n    uvBuffer.update();\n    indexBuffer.update();\n    this.updateVertices();\n  }\n  updateVertices() {\n    const points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    let lastPoint = points[0];\n    let nextPoint;\n    let perpX = 0;\n    let perpY = 0;\n    const vertices = this.buffers[0].data;\n    const total = points.length;\n    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n    for (let i = 0; i < total; i++) {\n      const point = points[i];\n      const index = i * 4;\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      let ratio = (1 - i / (total - 1)) * 10;\n      if (ratio > 1) {\n        ratio = 1;\n      }\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      if (perpLength < 1e-6) {\n        perpX = 0;\n        perpY = 0;\n      } else {\n        perpX /= perpLength;\n        perpY /= perpLength;\n        perpX *= halfWidth;\n        perpY *= halfWidth;\n      }\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n    this.buffers[0].update();\n  }\n  update() {\n    if (this.textureScale > 0) {\n      this.build();\n    } else {\n      this.updateVertices();\n    }\n  }\n}\n\n\n//# sourceMappingURL=RopeGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs\n\n\n\n\nclass SimplePlane_SimplePlane extends (/* unused pure expression or super */ null && (Mesh)) {\n  constructor(texture, verticesX, verticesY) {\n    const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);\n    const meshMaterial = new MeshMaterial(Texture.WHITE);\n    super(planeGeometry, meshMaterial);\n    this.texture = texture;\n    this.autoResize = true;\n  }\n  textureUpdated() {\n    this._textureID = this.shader.texture._updateID;\n    const geometry = this.geometry;\n    const { width, height } = this.shader.texture;\n    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {\n      geometry.width = this.shader.texture.width;\n      geometry.height = this.shader.texture.height;\n      geometry.build();\n    }\n  }\n  set texture(value) {\n    if (this.shader.texture === value) {\n      return;\n    }\n    this.shader.texture = value;\n    this._textureID = -1;\n    if (value.baseTexture.valid) {\n      this.textureUpdated();\n    } else {\n      value.once("update", this.textureUpdated, this);\n    }\n  }\n  get texture() {\n    return this.shader.texture;\n  }\n  _render(renderer) {\n    if (this._textureID !== this.shader.texture._updateID) {\n      this.textureUpdated();\n    }\n    super._render(renderer);\n  }\n  destroy(options) {\n    this.shader.texture.off("update", this.textureUpdated, this);\n    super.destroy(options);\n  }\n}\n\n\n//# sourceMappingURL=SimplePlane.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs\n\n\n\nconst DEFAULT_BORDER_SIZE = 10;\nclass NineSlicePlane extends (/* unused pure expression or super */ null && (SimplePlane)) {\n  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {\n    super(Texture.WHITE, 4, 4);\n    this._origWidth = texture.orig.width;\n    this._origHeight = texture.orig.height;\n    this._width = this._origWidth;\n    this._height = this._origHeight;\n    this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;\n    this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;\n    this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;\n    this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;\n    this.texture = texture;\n  }\n  textureUpdated() {\n    this._textureID = this.shader.texture._updateID;\n    this._refresh();\n  }\n  get vertices() {\n    return this.geometry.getBuffer("aVertexPosition").data;\n  }\n  set vertices(value) {\n    this.geometry.getBuffer("aVertexPosition").data = value;\n  }\n  updateHorizontalVertices() {\n    const vertices = this.vertices;\n    const scale = this._getMinScale();\n    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;\n    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;\n    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;\n  }\n  updateVerticalVertices() {\n    const vertices = this.vertices;\n    const scale = this._getMinScale();\n    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;\n    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;\n    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;\n  }\n  _getMinScale() {\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this._width > w ? 1 : this._width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this._height > h ? 1 : this._height / h;\n    const scale = Math.min(scaleW, scaleH);\n    return scale;\n  }\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value;\n    this._refresh();\n  }\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value;\n    this._refresh();\n  }\n  get leftWidth() {\n    return this._leftWidth;\n  }\n  set leftWidth(value) {\n    this._leftWidth = value;\n    this._refresh();\n  }\n  get rightWidth() {\n    return this._rightWidth;\n  }\n  set rightWidth(value) {\n    this._rightWidth = value;\n    this._refresh();\n  }\n  get topHeight() {\n    return this._topHeight;\n  }\n  set topHeight(value) {\n    this._topHeight = value;\n    this._refresh();\n  }\n  get bottomHeight() {\n    return this._bottomHeight;\n  }\n  set bottomHeight(value) {\n    this._bottomHeight = value;\n    this._refresh();\n  }\n  _refresh() {\n    const texture = this.texture;\n    const uvs = this.geometry.buffers[1].data;\n    this._origWidth = texture.orig.width;\n    this._origHeight = texture.orig.height;\n    const _uvw = 1 / this._origWidth;\n    const _uvh = 1 / this._origHeight;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.updateHorizontalVertices();\n    this.updateVerticalVertices();\n    this.geometry.buffers[0].update();\n    this.geometry.buffers[1].update();\n  }\n}\n\n\n//# sourceMappingURL=NineSlicePlane.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs\n\n\n\nclass SimpleMesh extends (/* unused pure expression or super */ null && (Mesh)) {\n  constructor(texture = Texture.EMPTY, vertices, uvs, indices, drawMode) {\n    const geometry = new MeshGeometry(vertices, uvs, indices);\n    geometry.getBuffer("aVertexPosition").static = false;\n    const meshMaterial = new MeshMaterial(texture);\n    super(geometry, meshMaterial, null, drawMode);\n    this.autoUpdate = true;\n  }\n  get vertices() {\n    return this.geometry.getBuffer("aVertexPosition").data;\n  }\n  set vertices(value) {\n    this.geometry.getBuffer("aVertexPosition").data = value;\n  }\n  _render(renderer) {\n    if (this.autoUpdate) {\n      this.geometry.getBuffer("aVertexPosition").update();\n    }\n    super._render(renderer);\n  }\n}\n\n\n//# sourceMappingURL=SimpleMesh.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs\n\n\n\n\nclass SimpleRope extends (/* unused pure expression or super */ null && (Mesh)) {\n  constructor(texture, points, textureScale = 0) {\n    const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);\n    const meshMaterial = new MeshMaterial(texture);\n    if (textureScale > 0) {\n      texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n    }\n    super(ropeGeometry, meshMaterial);\n    this.autoUpdate = true;\n  }\n  _render(renderer) {\n    const geometry = this.geometry;\n    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {\n      geometry._width = this.shader.texture.height;\n      geometry.update();\n    }\n    super._render(renderer);\n  }\n}\n\n\n//# sourceMappingURL=SimpleRope.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleContainer.mjs\n\n\n\nclass ParticleContainer extends (/* unused pure expression or super */ null && (Container)) {\n  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {\n    super();\n    const maxBatchSize = 16384;\n    if (batchSize > maxBatchSize) {\n      batchSize = maxBatchSize;\n    }\n    this._properties = [false, true, false, false, false];\n    this._maxSize = maxSize;\n    this._batchSize = batchSize;\n    this._buffers = null;\n    this._bufferUpdateIDs = [];\n    this._updateID = 0;\n    this.interactiveChildren = false;\n    this.blendMode = BLEND_MODES.NORMAL;\n    this.autoResize = autoResize;\n    this.roundPixels = true;\n    this.baseTexture = null;\n    this.setProperties(properties);\n    this._tintColor = new Color(0);\n    this.tintRgb = new Float32Array(3);\n    this.tint = 16777215;\n  }\n  setProperties(properties) {\n    if (properties) {\n      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];\n      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];\n      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];\n      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];\n      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];\n    }\n  }\n  updateTransform() {\n    this.displayObjectUpdateTransform();\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value);\n    this._tintColor.toRgbArray(this.tintRgb);\n  }\n  render(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n      return;\n    }\n    if (!this.baseTexture) {\n      this.baseTexture = this.children[0]._texture.baseTexture;\n      if (!this.baseTexture.valid) {\n        this.baseTexture.once("update", () => this.onChildrenChange(0));\n      }\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins.particle);\n    renderer.plugins.particle.render(this);\n  }\n  onChildrenChange(smallestChildIndex) {\n    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n    while (this._bufferUpdateIDs.length < bufferIndex) {\n      this._bufferUpdateIDs.push(0);\n    }\n    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n  }\n  dispose() {\n    if (this._buffers) {\n      for (let i = 0; i < this._buffers.length; ++i) {\n        this._buffers[i].destroy();\n      }\n      this._buffers = null;\n    }\n  }\n  destroy(options) {\n    super.destroy(options);\n    this.dispose();\n    this._properties = null;\n    this._buffers = null;\n    this._bufferUpdateIDs = null;\n  }\n}\n\n\n//# sourceMappingURL=ParticleContainer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs\n\n\nclass ParticleBuffer {\n  constructor(properties, dynamicPropertyFlags, size) {\n    this.geometry = new lib/* Geometry */.wG();\n    this.indexBuffer = null;\n    this.size = size;\n    this.dynamicProperties = [];\n    this.staticProperties = [];\n    for (let i = 0; i < properties.length; ++i) {\n      let property = properties[i];\n      property = {\n        attributeName: property.attributeName,\n        size: property.size,\n        uploadFunction: property.uploadFunction,\n        type: property.type || lib/* TYPES.FLOAT */.vK.FLOAT,\n        offset: property.offset\n      };\n      if (dynamicPropertyFlags[i]) {\n        this.dynamicProperties.push(property);\n      } else {\n        this.staticProperties.push(property);\n      }\n    }\n    this.staticStride = 0;\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n    this.dynamicStride = 0;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this._updateID = 0;\n    this.initBuffers();\n  }\n  initBuffers() {\n    const geometry = this.geometry;\n    let dynamicOffset = 0;\n    this.indexBuffer = new lib/* Buffer */.lW(lib/* utils.createIndicesForQuads */.P6.createIndicesForQuads(this.size), true, true);\n    geometry.addIndex(this.indexBuffer);\n    this.dynamicStride = 0;\n    for (let i = 0; i < this.dynamicProperties.length; ++i) {\n      const property = this.dynamicProperties[i];\n      property.offset = dynamicOffset;\n      dynamicOffset += property.size;\n      this.dynamicStride += property.size;\n    }\n    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n    this.dynamicData = new Float32Array(dynBuffer);\n    this.dynamicDataUint32 = new Uint32Array(dynBuffer);\n    this.dynamicBuffer = new lib/* Buffer */.lW(this.dynamicData, false, false);\n    let staticOffset = 0;\n    this.staticStride = 0;\n    for (let i = 0; i < this.staticProperties.length; ++i) {\n      const property = this.staticProperties[i];\n      property.offset = staticOffset;\n      staticOffset += property.size;\n      this.staticStride += property.size;\n    }\n    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n    this.staticData = new Float32Array(statBuffer);\n    this.staticDataUint32 = new Uint32Array(statBuffer);\n    this.staticBuffer = new lib/* Buffer */.lW(this.staticData, true, false);\n    for (let i = 0; i < this.dynamicProperties.length; ++i) {\n      const property = this.dynamicProperties[i];\n      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);\n    }\n    for (let i = 0; i < this.staticProperties.length; ++i) {\n      const property = this.staticProperties[i];\n      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);\n    }\n  }\n  uploadDynamic(children, startIndex, amount) {\n    for (let i = 0; i < this.dynamicProperties.length; i++) {\n      const property = this.dynamicProperties[i];\n      property.uploadFunction(children, startIndex, amount, property.type === lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);\n    }\n    this.dynamicBuffer._updateID++;\n  }\n  uploadStatic(children, startIndex, amount) {\n    for (let i = 0; i < this.staticProperties.length; i++) {\n      const property = this.staticProperties[i];\n      property.uploadFunction(children, startIndex, amount, property.type === lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);\n    }\n    this.staticBuffer._updateID++;\n  }\n  destroy() {\n    this.indexBuffer = null;\n    this.dynamicProperties = null;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this.staticProperties = null;\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n    this.geometry.destroy();\n  }\n}\n\n\n//# sourceMappingURL=ParticleBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/particles.mjs\nvar particles_fragment = "varying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\\n    gl_FragColor = color;\\n}";\n\n\n//# sourceMappingURL=particles.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/particles2.mjs\nvar particles2_vertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPositionCoord;\\nattribute float aRotation;\\n\\nuniform mat3 translationMatrix;\\nuniform vec4 uColor;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nvoid main(void){\\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPositionCoord;\\n\\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vColor = aColor * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=particles2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs\n\n\n\n\n\nclass ParticleRenderer extends lib/* ObjectRenderer */.bO {\n  constructor(renderer) {\n    super(renderer);\n    this.shader = null;\n    this.properties = null;\n    this.tempMatrix = new lib/* Matrix */.y3();\n    this.properties = [\n      {\n        attributeName: "aVertexPosition",\n        size: 2,\n        uploadFunction: this.uploadVertices,\n        offset: 0\n      },\n      {\n        attributeName: "aPositionCoord",\n        size: 2,\n        uploadFunction: this.uploadPosition,\n        offset: 0\n      },\n      {\n        attributeName: "aRotation",\n        size: 1,\n        uploadFunction: this.uploadRotation,\n        offset: 0\n      },\n      {\n        attributeName: "aTextureCoord",\n        size: 2,\n        uploadFunction: this.uploadUvs,\n        offset: 0\n      },\n      {\n        attributeName: "aColor",\n        size: 1,\n        type: lib/* TYPES.UNSIGNED_BYTE */.vK.UNSIGNED_BYTE,\n        uploadFunction: this.uploadTint,\n        offset: 0\n      }\n    ];\n    this.shader = lib/* Shader.from */.ex.from(particles2_vertex, particles_fragment, {});\n    this.state = lib/* State.for2d */.ZM.for2d();\n  }\n  render(container) {\n    const children = container.children;\n    const maxSize = container._maxSize;\n    const batchSize = container._batchSize;\n    const renderer = this.renderer;\n    let totalChildren = children.length;\n    if (totalChildren === 0) {\n      return;\n    } else if (totalChildren > maxSize && !container.autoResize) {\n      totalChildren = maxSize;\n    }\n    let buffers = container._buffers;\n    if (!buffers) {\n      buffers = container._buffers = this.generateBuffers(container);\n    }\n    const baseTexture = children[0]._texture.baseTexture;\n    const premultiplied = baseTexture.alphaMode > 0;\n    this.state.blendMode = lib/* utils.correctBlendMode */.P6.correctBlendMode(container.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    const gl = renderer.gl;\n    const m = container.worldTransform.copyTo(this.tempMatrix);\n    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n    this.shader.uniforms.translationMatrix = m.toArray(true);\n    this.shader.uniforms.uColor = lib/* Color.shared.setValue */.Il.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);\n    this.shader.uniforms.uSampler = baseTexture;\n    this.renderer.shader.bind(this.shader);\n    let updateStatic = false;\n    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n      let amount = totalChildren - i;\n      if (amount > batchSize) {\n        amount = batchSize;\n      }\n      if (j >= buffers.length) {\n        buffers.push(this._generateOneMoreBuffer(container));\n      }\n      const buffer = buffers[j];\n      buffer.uploadDynamic(children, i, amount);\n      const bid = container._bufferUpdateIDs[j] || 0;\n      updateStatic = updateStatic || buffer._updateID < bid;\n      if (updateStatic) {\n        buffer._updateID = container._updateID;\n        buffer.uploadStatic(children, i, amount);\n      }\n      renderer.geometry.bind(buffer.geometry);\n      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n    }\n  }\n  generateBuffers(container) {\n    const buffers = [];\n    const size = container._maxSize;\n    const batchSize = container._batchSize;\n    const dynamicPropertyFlags = container._properties;\n    for (let i = 0; i < size; i += batchSize) {\n      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n    }\n    return buffers;\n  }\n  _generateOneMoreBuffer(container) {\n    const batchSize = container._batchSize;\n    const dynamicPropertyFlags = container._properties;\n    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n  }\n  uploadVertices(children, startIndex, amount, array, stride, offset) {\n    let w0 = 0;\n    let w1 = 0;\n    let h0 = 0;\n    let h1 = 0;\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i];\n      const texture = sprite._texture;\n      const sx = sprite.scale.x;\n      const sy = sprite.scale.y;\n      const trim = texture.trim;\n      const orig = texture.orig;\n      if (trim) {\n        w1 = trim.x - sprite.anchor.x * orig.width;\n        w0 = w1 + trim.width;\n        h1 = trim.y - sprite.anchor.y * orig.height;\n        h0 = h1 + trim.height;\n      } else {\n        w0 = orig.width * (1 - sprite.anchor.x);\n        w1 = orig.width * -sprite.anchor.x;\n        h0 = orig.height * (1 - sprite.anchor.y);\n        h1 = orig.height * -sprite.anchor.y;\n      }\n      array[offset] = w1 * sx;\n      array[offset + 1] = h1 * sy;\n      array[offset + stride] = w0 * sx;\n      array[offset + stride + 1] = h1 * sy;\n      array[offset + stride * 2] = w0 * sx;\n      array[offset + stride * 2 + 1] = h0 * sy;\n      array[offset + stride * 3] = w1 * sx;\n      array[offset + stride * 3 + 1] = h0 * sy;\n      offset += stride * 4;\n    }\n  }\n  uploadPosition(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spritePosition = children[startIndex + i].position;\n      array[offset] = spritePosition.x;\n      array[offset + 1] = spritePosition.y;\n      array[offset + stride] = spritePosition.x;\n      array[offset + stride + 1] = spritePosition.y;\n      array[offset + stride * 2] = spritePosition.x;\n      array[offset + stride * 2 + 1] = spritePosition.y;\n      array[offset + stride * 3] = spritePosition.x;\n      array[offset + stride * 3 + 1] = spritePosition.y;\n      offset += stride * 4;\n    }\n  }\n  uploadRotation(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spriteRotation = children[startIndex + i].rotation;\n      array[offset] = spriteRotation;\n      array[offset + stride] = spriteRotation;\n      array[offset + stride * 2] = spriteRotation;\n      array[offset + stride * 3] = spriteRotation;\n      offset += stride * 4;\n    }\n  }\n  uploadUvs(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const textureUvs = children[startIndex + i]._texture._uvs;\n      if (textureUvs) {\n        array[offset] = textureUvs.x0;\n        array[offset + 1] = textureUvs.y0;\n        array[offset + stride] = textureUvs.x1;\n        array[offset + stride + 1] = textureUvs.y1;\n        array[offset + stride * 2] = textureUvs.x2;\n        array[offset + stride * 2 + 1] = textureUvs.y2;\n        array[offset + stride * 3] = textureUvs.x3;\n        array[offset + stride * 3 + 1] = textureUvs.y3;\n        offset += stride * 4;\n      } else {\n        array[offset] = 0;\n        array[offset + 1] = 0;\n        array[offset + stride] = 0;\n        array[offset + stride + 1] = 0;\n        array[offset + stride * 2] = 0;\n        array[offset + stride * 2 + 1] = 0;\n        array[offset + stride * 3] = 0;\n        array[offset + stride * 3 + 1] = 0;\n        offset += stride * 4;\n      }\n    }\n  }\n  uploadTint(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i];\n      const result = lib/* Color.shared.setValue */.Il.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha);\n      array[offset] = result;\n      array[offset + stride] = result;\n      array[offset + stride * 2] = result;\n      array[offset + stride * 3] = result;\n      offset += stride * 4;\n    }\n  }\n  destroy() {\n    super.destroy();\n    if (this.shader) {\n      this.shader.destroy();\n      this.shader = null;\n    }\n    this.tempMatrix = null;\n  }\n}\nParticleRenderer.extension = {\n  name: "particle",\n  type: lib/* ExtensionType.RendererPlugin */.nw.RendererPlugin\n};\nlib/* extensions.add */.Rw.add(ParticleRenderer);\n\n\n//# sourceMappingURL=ParticleRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/const.mjs\nvar TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {\n  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";\n  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";\n  return TEXT_GRADIENT2;\n})(TEXT_GRADIENT || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/TextMetrics.mjs\n\n\nconst contextSettings = {\n  willReadFrequently: true\n};\nconst _TextMetrics = class {\n  static get experimentalLetterSpacingSupported() {\n    let result = _TextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = lib/* settings.ADAPTER.getCanvasRenderingContext2D */.Xd.ADAPTER.getCanvasRenderingContext2D().prototype;\n      result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;\n    }\n    return result;\n  }\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {\n    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;\n    const font = style.toFontString();\n    const fontProperties = _TextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = canvas.getContext("2d", contextSettings);\n    context.font = font;\n    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _TextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    let width = maxLineWidth + style.strokeThickness;\n    if (style.dropShadow) {\n      width += style.dropShadowDistance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadowDistance;\n    }\n    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_TextMetrics.experimentalLetterSpacingSupported) {\n      if (_TextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  static wordWrap(text, style, canvas = _TextMetrics._canvas) {\n    const context = canvas.getContext("2d", contextSettings);\n    let width = 0;\n    let line = "";\n    let lines = "";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);\n    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _TextMetrics.tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_TextMetrics.isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _TextMetrics.addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = "";\n          width = 0;\n          continue;\n        }\n        token = " ";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== "") {\n          lines += _TextMetrics.addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (_TextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _TextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _TextMetrics.addLine(line);\n              canPrependSpaces = false;\n              line = "";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _TextMetrics.addLine(line);\n            line = "";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _TextMetrics.addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = "";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _TextMetrics.addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _TextMetrics.addLine(line, false);\n    return lines;\n  }\n  static addLine(line, newLine = true) {\n    line = _TextMetrics.trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  static getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== "number") {\n      width = _TextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  static collapseSpaces(whiteSpace) {\n    return whiteSpace === "normal" || whiteSpace === "pre-line";\n  }\n  static collapseNewlines(whiteSpace) {\n    return whiteSpace === "normal";\n  }\n  static trimRight(text) {\n    if (typeof text !== "string") {\n      return "";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_TextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  static isNewline(char) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _TextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  static tokenize(text) {\n    const tokens = [];\n    let token = "";\n    if (typeof text !== "string") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {\n        if (token !== "") {\n          tokens.push(token);\n          token = "";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== "") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  static wordWrapSplit(token) {\n    return _TextMetrics.graphemeSegmenter(token);\n  }\n  static measureFont(font) {\n    if (_TextMetrics._fonts[font]) {\n      return _TextMetrics._fonts[font];\n    }\n    const properties = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    };\n    const canvas = _TextMetrics._canvas;\n    const context = _TextMetrics._context;\n    context.font = font;\n    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;\n    const width = Math.ceil(context.measureText(metricsString).width);\n    let baseline = Math.ceil(context.measureText(_TextMetrics.BASELINE_SYMBOL).width);\n    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);\n    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;\n    if (width === 0 || height === 0) {\n      _TextMetrics._fonts[font] = properties;\n      return properties;\n    }\n    canvas.width = width;\n    canvas.height = height;\n    context.fillStyle = "#f00";\n    context.fillRect(0, 0, width, height);\n    context.font = font;\n    context.textBaseline = "alphabetic";\n    context.fillStyle = "#000";\n    context.fillText(metricsString, 0, baseline);\n    const imagedata = context.getImageData(0, 0, width, height).data;\n    const pixels = imagedata.length;\n    const line = width * 4;\n    let i = 0;\n    let idx = 0;\n    let stop = false;\n    for (i = 0; i < baseline; ++i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n    properties.ascent = baseline - i;\n    idx = pixels - line;\n    stop = false;\n    for (i = height; i > baseline; --i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n    properties.descent = i - baseline;\n    properties.fontSize = properties.ascent + properties.descent;\n    _TextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  static clearMetrics(font = "") {\n    if (font) {\n      delete _TextMetrics._fonts[font];\n    } else {\n      _TextMetrics._fonts = {};\n    }\n  }\n  static get _canvas() {\n    if (!_TextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext("2d", contextSettings);\n        if (context?.measureText) {\n          _TextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n      } catch (ex) {\n        canvas = lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _TextMetrics.__canvas = canvas;\n    }\n    return _TextMetrics.__canvas;\n  }\n  static get _context() {\n    if (!_TextMetrics.__context) {\n      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);\n    }\n    return _TextMetrics.__context;\n  }\n};\nlet TextMetrics = _TextMetrics;\nTextMetrics.METRICS_STRING = "|\\xC9q\\xC5";\nTextMetrics.BASELINE_SYMBOL = "M";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics.HEIGHT_MULTIPLIER = 2;\nTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === "function") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\nTextMetrics.experimentalLetterSpacing = false;\nTextMetrics._fonts = {};\nTextMetrics._newlines = [\n  10,\n  13\n];\nTextMetrics._breakingSpaces = [\n  9,\n  32,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8200,\n  8201,\n  8202,\n  8287,\n  12288\n];\n\n\n//# sourceMappingURL=TextMetrics.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/TextStyle.mjs\n\n\n\nconst genericFontFamilies = [\n  "serif",\n  "sans-serif",\n  "monospace",\n  "cursive",\n  "fantasy",\n  "system-ui"\n];\nconst _TextStyle = class {\n  constructor(style) {\n    this.styleID = 0;\n    this.reset();\n    deepCopyProperties(this, style, style);\n  }\n  clone() {\n    const clonedProperties = {};\n    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);\n    return new _TextStyle(clonedProperties);\n  }\n  reset() {\n    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);\n  }\n  get align() {\n    return this._align;\n  }\n  set align(align) {\n    if (this._align !== align) {\n      this._align = align;\n      this.styleID++;\n    }\n  }\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(breakWords) {\n    if (this._breakWords !== breakWords) {\n      this._breakWords = breakWords;\n      this.styleID++;\n    }\n  }\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(dropShadow) {\n    if (this._dropShadow !== dropShadow) {\n      this._dropShadow = dropShadow;\n      this.styleID++;\n    }\n  }\n  get dropShadowAlpha() {\n    return this._dropShadowAlpha;\n  }\n  set dropShadowAlpha(dropShadowAlpha) {\n    if (this._dropShadowAlpha !== dropShadowAlpha) {\n      this._dropShadowAlpha = dropShadowAlpha;\n      this.styleID++;\n    }\n  }\n  get dropShadowAngle() {\n    return this._dropShadowAngle;\n  }\n  set dropShadowAngle(dropShadowAngle) {\n    if (this._dropShadowAngle !== dropShadowAngle) {\n      this._dropShadowAngle = dropShadowAngle;\n      this.styleID++;\n    }\n  }\n  get dropShadowBlur() {\n    return this._dropShadowBlur;\n  }\n  set dropShadowBlur(dropShadowBlur) {\n    if (this._dropShadowBlur !== dropShadowBlur) {\n      this._dropShadowBlur = dropShadowBlur;\n      this.styleID++;\n    }\n  }\n  get dropShadowColor() {\n    return this._dropShadowColor;\n  }\n  set dropShadowColor(dropShadowColor) {\n    const outputColor = getColor(dropShadowColor);\n    if (this._dropShadowColor !== outputColor) {\n      this._dropShadowColor = outputColor;\n      this.styleID++;\n    }\n  }\n  get dropShadowDistance() {\n    return this._dropShadowDistance;\n  }\n  set dropShadowDistance(dropShadowDistance) {\n    if (this._dropShadowDistance !== dropShadowDistance) {\n      this._dropShadowDistance = dropShadowDistance;\n      this.styleID++;\n    }\n  }\n  get fill() {\n    return this._fill;\n  }\n  set fill(fill) {\n    const outputColor = getColor(fill);\n    if (this._fill !== outputColor) {\n      this._fill = outputColor;\n      this.styleID++;\n    }\n  }\n  get fillGradientType() {\n    return this._fillGradientType;\n  }\n  set fillGradientType(fillGradientType) {\n    if (this._fillGradientType !== fillGradientType) {\n      this._fillGradientType = fillGradientType;\n      this.styleID++;\n    }\n  }\n  get fillGradientStops() {\n    return this._fillGradientStops;\n  }\n  set fillGradientStops(fillGradientStops) {\n    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {\n      this._fillGradientStops = fillGradientStops;\n      this.styleID++;\n    }\n  }\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(fontFamily) {\n    if (this.fontFamily !== fontFamily) {\n      this._fontFamily = fontFamily;\n      this.styleID++;\n    }\n  }\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(fontSize) {\n    if (this._fontSize !== fontSize) {\n      this._fontSize = fontSize;\n      this.styleID++;\n    }\n  }\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(fontStyle) {\n    if (this._fontStyle !== fontStyle) {\n      this._fontStyle = fontStyle;\n      this.styleID++;\n    }\n  }\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(fontVariant) {\n    if (this._fontVariant !== fontVariant) {\n      this._fontVariant = fontVariant;\n      this.styleID++;\n    }\n  }\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(fontWeight) {\n    if (this._fontWeight !== fontWeight) {\n      this._fontWeight = fontWeight;\n      this.styleID++;\n    }\n  }\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(letterSpacing) {\n    if (this._letterSpacing !== letterSpacing) {\n      this._letterSpacing = letterSpacing;\n      this.styleID++;\n    }\n  }\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(lineHeight) {\n    if (this._lineHeight !== lineHeight) {\n      this._lineHeight = lineHeight;\n      this.styleID++;\n    }\n  }\n  get leading() {\n    return this._leading;\n  }\n  set leading(leading) {\n    if (this._leading !== leading) {\n      this._leading = leading;\n      this.styleID++;\n    }\n  }\n  get lineJoin() {\n    return this._lineJoin;\n  }\n  set lineJoin(lineJoin) {\n    if (this._lineJoin !== lineJoin) {\n      this._lineJoin = lineJoin;\n      this.styleID++;\n    }\n  }\n  get miterLimit() {\n    return this._miterLimit;\n  }\n  set miterLimit(miterLimit) {\n    if (this._miterLimit !== miterLimit) {\n      this._miterLimit = miterLimit;\n      this.styleID++;\n    }\n  }\n  get padding() {\n    return this._padding;\n  }\n  set padding(padding) {\n    if (this._padding !== padding) {\n      this._padding = padding;\n      this.styleID++;\n    }\n  }\n  get stroke() {\n    return this._stroke;\n  }\n  set stroke(stroke) {\n    const outputColor = getColor(stroke);\n    if (this._stroke !== outputColor) {\n      this._stroke = outputColor;\n      this.styleID++;\n    }\n  }\n  get strokeThickness() {\n    return this._strokeThickness;\n  }\n  set strokeThickness(strokeThickness) {\n    if (this._strokeThickness !== strokeThickness) {\n      this._strokeThickness = strokeThickness;\n      this.styleID++;\n    }\n  }\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(textBaseline) {\n    if (this._textBaseline !== textBaseline) {\n      this._textBaseline = textBaseline;\n      this.styleID++;\n    }\n  }\n  get trim() {\n    return this._trim;\n  }\n  set trim(trim) {\n    if (this._trim !== trim) {\n      this._trim = trim;\n      this.styleID++;\n    }\n  }\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(whiteSpace) {\n    if (this._whiteSpace !== whiteSpace) {\n      this._whiteSpace = whiteSpace;\n      this.styleID++;\n    }\n  }\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(wordWrap) {\n    if (this._wordWrap !== wordWrap) {\n      this._wordWrap = wordWrap;\n      this.styleID++;\n    }\n  }\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(wordWrapWidth) {\n    if (this._wordWrapWidth !== wordWrapWidth) {\n      this._wordWrapWidth = wordWrapWidth;\n      this.styleID++;\n    }\n  }\n  toFontString() {\n    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;\n    let fontFamilies = this.fontFamily;\n    if (!Array.isArray(this.fontFamily)) {\n      fontFamilies = this.fontFamily.split(",");\n    }\n    for (let i = fontFamilies.length - 1; i >= 0; i--) {\n      let fontFamily = fontFamilies[i].trim();\n      if (!/([\\"\\\'])[^\\\'\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n        fontFamily = `"${fontFamily}"`;\n      }\n      fontFamilies[i] = fontFamily;\n    }\n    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;\n  }\n};\nlet TextStyle = _TextStyle;\nTextStyle.defaultStyle = {\n  align: "left",\n  breakWords: false,\n  dropShadow: false,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: "black",\n  dropShadowDistance: 5,\n  fill: "black",\n  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n  fillGradientStops: [],\n  fontFamily: "Arial",\n  fontSize: 26,\n  fontStyle: "normal",\n  fontVariant: "normal",\n  fontWeight: "normal",\n  leading: 0,\n  letterSpacing: 0,\n  lineHeight: 0,\n  lineJoin: "miter",\n  miterLimit: 10,\n  padding: 0,\n  stroke: "black",\n  strokeThickness: 0,\n  textBaseline: "alphabetic",\n  trim: false,\n  whiteSpace: "pre",\n  wordWrap: false,\n  wordWrapWidth: 100\n};\nfunction getColor(color) {\n  const temp = lib/* Color.shared */.Il.shared;\n  if (!Array.isArray(color)) {\n    return temp.setValue(color).toHex();\n  } else {\n    return color.map((c) => temp.setValue(c).toHex());\n  }\n}\nfunction areArraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    return false;\n  }\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction deepCopyProperties(target, source, propertyObj) {\n  for (const prop in propertyObj) {\n    if (Array.isArray(source[prop])) {\n      target[prop] = source[prop].slice();\n    } else {\n      target[prop] = source[prop];\n    }\n  }\n}\n\n\n//# sourceMappingURL=TextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/Text.mjs\n\n\n\n\n\n\nconst defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\nconst _Text = class extends Sprite_Sprite {\n  constructor(text, style, canvas) {\n    let ownCanvas = false;\n    if (!canvas) {\n      canvas = lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n      ownCanvas = true;\n    }\n    canvas.width = 3;\n    canvas.height = 3;\n    const texture = lib/* Texture.from */.xE.from(canvas);\n    texture.orig = new lib/* Rectangle */.Ae();\n    texture.trim = new lib/* Rectangle */.Ae();\n    super(texture);\n    this._ownCanvas = ownCanvas;\n    this.canvas = canvas;\n    this.context = canvas.getContext("2d", {\n      willReadFrequently: true\n    });\n    this._resolution = _Text.defaultResolution ?? lib/* settings.RESOLUTION */.Xd.RESOLUTION;\n    this._autoResolution = _Text.defaultAutoResolution;\n    this._text = null;\n    this._style = null;\n    this._styleListener = null;\n    this._font = "";\n    this.text = text;\n    this.style = style;\n    this.localStyleID = -1;\n  }\n  static get experimentalLetterSpacing() {\n    return TextMetrics.experimentalLetterSpacing;\n  }\n  static set experimentalLetterSpacing(value) {\n    lib/* utils.deprecation */.P6.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");\n    TextMetrics.experimentalLetterSpacing = value;\n  }\n  updateText(respectDirty) {\n    const style = this._style;\n    if (this.localStyleID !== style.styleID) {\n      this.dirty = true;\n      this.localStyleID = style.styleID;\n    }\n    if (!this.dirty && respectDirty) {\n      return;\n    }\n    this._font = this._style.toFontString();\n    const context = this.context;\n    const measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);\n    const width = measured.width;\n    const height = measured.height;\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);\n    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);\n    context.scale(this._resolution, this._resolution);\n    context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    context.font = this._font;\n    context.lineWidth = style.strokeThickness;\n    context.textBaseline = style.textBaseline;\n    context.lineJoin = style.lineJoin;\n    context.miterLimit = style.miterLimit;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * this._resolution;\n      if (isShadowPass) {\n        context.fillStyle = "black";\n        context.strokeStyle = "black";\n        const dropShadowColor = style.dropShadowColor;\n        const dropShadowBlur = style.dropShadowBlur * this._resolution;\n        const dropShadowDistance = style.dropShadowDistance * this._resolution;\n        context.shadowColor = lib/* Color.shared.setValue */.Il.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.fillStyle = this._generateFillStyle(style, lines, measured);\n        context.strokeStyle = style.stroke;\n        context.shadowColor = "black";\n        context.shadowBlur = 0;\n        context.shadowOffsetX = 0;\n        context.shadowOffsetY = 0;\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = style.strokeThickness / 2;\n        linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === "right") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === "center") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style.stroke && style.strokeThickness) {\n          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n        }\n        if (style.fill) {\n          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n        }\n      }\n    }\n    this.updateTexture();\n  }\n  drawLetterSpacing(text, x, y, isStroke = false) {\n    const style = this._style;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (TextMetrics.experimentalLetterSpacingSupported) {\n      if (TextMetrics.experimentalLetterSpacing) {\n        this.context.letterSpacing = `${letterSpacing}px`;\n        this.context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        this.context.letterSpacing = "0px";\n        this.context.textLetterSpacing = "0px";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        this.context.strokeText(text, x, y);\n      } else {\n        this.context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = TextMetrics.graphemeSegmenter(text);\n    let previousWidth = this.context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        this.context.strokeText(currentChar, currentPosition, y);\n      } else {\n        this.context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = "";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = this.context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  updateTexture() {\n    const canvas = this.canvas;\n    if (this._style.trim) {\n      const trimmed = lib/* utils.trimCanvas */.P6.trimCanvas(canvas);\n      if (trimmed.data) {\n        canvas.width = trimmed.width;\n        canvas.height = trimmed.height;\n        this.context.putImageData(trimmed.data, 0, 0);\n      }\n    }\n    const texture = this._texture;\n    const style = this._style;\n    const padding = style.trim ? 0 : style.padding;\n    const baseTexture = texture.baseTexture;\n    texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n    texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n    texture.trim.x = -padding;\n    texture.trim.y = -padding;\n    texture.orig.width = texture._frame.width - padding * 2;\n    texture.orig.height = texture._frame.height - padding * 2;\n    this._onTextureUpdate();\n    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n    texture.updateUvs();\n    this.dirty = false;\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    super._render(renderer);\n  }\n  updateTransform() {\n    this.updateText(true);\n    super.updateTransform();\n  }\n  getBounds(skipUpdate, rect) {\n    this.updateText(true);\n    if (this._textureID === -1) {\n      skipUpdate = false;\n    }\n    return super.getBounds(skipUpdate, rect);\n  }\n  getLocalBounds(rect) {\n    this.updateText(true);\n    return super.getLocalBounds.call(this, rect);\n  }\n  _calculateBounds() {\n    this.calculateVertices();\n    this._bounds.addQuad(this.vertexData);\n  }\n  _generateFillStyle(style, lines, metrics) {\n    const fillStyle = style.fill;\n    if (!Array.isArray(fillStyle)) {\n      return fillStyle;\n    } else if (fillStyle.length === 1) {\n      return fillStyle[0];\n    }\n    let gradient;\n    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;\n    const padding = style.padding || 0;\n    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;\n    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;\n    const fill = fillStyle.slice();\n    const fillGradientStops = style.fillGradientStops.slice();\n    if (!fillGradientStops.length) {\n      const lengthPlus1 = fill.length + 1;\n      for (let i = 1; i < lengthPlus1; ++i) {\n        fillGradientStops.push(i / lengthPlus1);\n      }\n    }\n    fill.unshift(fillStyle[0]);\n    fillGradientStops.unshift(0);\n    fill.push(fillStyle[fillStyle.length - 1]);\n    fillGradientStops.push(1);\n    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n      for (let i = 0; i < lines.length; i++) {\n        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;\n        const thisLineTop = metrics.lineHeight * i;\n        let thisLineGradientStart = thisLineTop;\n        if (i > 0 && lastLineBottom > thisLineTop) {\n          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n        }\n        const thisLineBottom = thisLineTop + textHeight;\n        const nextLineTop = metrics.lineHeight * (i + 1);\n        let thisLineGradientEnd = thisLineBottom;\n        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {\n          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n        }\n        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n        for (let j = 0; j < fill.length; j++) {\n          let lineStop = 0;\n          if (typeof fillGradientStops[j] === "number") {\n            lineStop = fillGradientStops[j];\n          } else {\n            lineStop = j / fill.length;\n          }\n          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));\n          globalStop = Number(globalStop.toFixed(5));\n          gradient.addColorStop(globalStop, fill[j]);\n        }\n      }\n    } else {\n      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n      const totalIterations = fill.length + 1;\n      let currentIteration = 1;\n      for (let i = 0; i < fill.length; i++) {\n        let stop;\n        if (typeof fillGradientStops[i] === "number") {\n          stop = fillGradientStops[i];\n        } else {\n          stop = currentIteration / totalIterations;\n        }\n        gradient.addColorStop(stop, fill[i]);\n        currentIteration++;\n      }\n    }\n    return gradient;\n  }\n  destroy(options) {\n    if (typeof options === "boolean") {\n      options = { children: options };\n    }\n    options = Object.assign({}, defaultDestroyOptions, options);\n    super.destroy(options);\n    if (this._ownCanvas) {\n      this.canvas.height = this.canvas.width = 0;\n    }\n    this.context = null;\n    this.canvas = null;\n    this._style = null;\n  }\n  get width() {\n    this.updateText(true);\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this.updateText(true);\n    const s = lib/* utils.sign */.P6.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._texture.orig.width;\n    this._width = value;\n  }\n  get height() {\n    this.updateText(true);\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this.updateText(true);\n    const s = lib/* utils.sign */.P6.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._texture.orig.height;\n    this._height = value;\n  }\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    style = style || {};\n    if (style instanceof TextStyle) {\n      this._style = style;\n    } else {\n      this._style = new TextStyle(style);\n    }\n    this.localStyleID = -1;\n    this.dirty = true;\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === null || text === void 0 ? "" : text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n};\nlet Text = _Text;\nText.defaultAutoResolution = true;\n\n\n//# sourceMappingURL=Text.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/CountLimiter.mjs\nclass CountLimiter {\n  constructor(maxItemsPerFrame) {\n    this.maxItemsPerFrame = maxItemsPerFrame;\n    this.itemsLeft = 0;\n  }\n  beginFrame() {\n    this.itemsLeft = this.maxItemsPerFrame;\n  }\n  allowedToUpload() {\n    return this.itemsLeft-- > 0;\n  }\n}\n\n\n//# sourceMappingURL=CountLimiter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/BasePrepare.mjs\n\n\n\n\n\nfunction findMultipleBaseTextures(item, queue) {\n  let result = false;\n  if (item?._textures?.length) {\n    for (let i = 0; i < item._textures.length; i++) {\n      if (item._textures[i] instanceof lib/* Texture */.xE) {\n        const baseTexture = item._textures[i].baseTexture;\n        if (!queue.includes(baseTexture)) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction findBaseTexture(item, queue) {\n  if (item.baseTexture instanceof lib/* BaseTexture */.VL) {\n    const texture = item.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof lib/* Texture */.xE) {\n    const texture = item._texture.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction drawText(_helper, item) {\n  if (item instanceof Text) {\n    item.updateText(true);\n    return true;\n  }\n  return false;\n}\nfunction calculateTextStyle(_helper, item) {\n  if (item instanceof TextStyle) {\n    const font = item.toFontString();\n    TextMetrics.measureFont(font);\n    return true;\n  }\n  return false;\n}\nfunction findText(item, queue) {\n  if (item instanceof Text) {\n    if (!queue.includes(item.style)) {\n      queue.push(item.style);\n    }\n    if (!queue.includes(item)) {\n      queue.push(item);\n    }\n    const texture = item._texture.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction findTextStyle(item, queue) {\n  if (item instanceof TextStyle) {\n    if (!queue.includes(item)) {\n      queue.push(item);\n    }\n    return true;\n  }\n  return false;\n}\nconst _BasePrepare = class {\n  constructor(renderer) {\n    this.limiter = new CountLimiter(_BasePrepare.uploadsPerFrame);\n    this.renderer = renderer;\n    this.uploadHookHelper = null;\n    this.queue = [];\n    this.addHooks = [];\n    this.uploadHooks = [];\n    this.completes = [];\n    this.ticking = false;\n    this.delayedTick = () => {\n      if (!this.queue) {\n        return;\n      }\n      this.prepareItems();\n    };\n    this.registerFindHook(findText);\n    this.registerFindHook(findTextStyle);\n    this.registerFindHook(findMultipleBaseTextures);\n    this.registerFindHook(findBaseTexture);\n    this.registerFindHook(findTexture);\n    this.registerUploadHook(drawText);\n    this.registerUploadHook(calculateTextStyle);\n  }\n  upload(item) {\n    return new Promise((resolve) => {\n      if (item) {\n        this.add(item);\n      }\n      if (this.queue.length) {\n        this.completes.push(resolve);\n        if (!this.ticking) {\n          this.ticking = true;\n          lib/* Ticker.system.addOnce */.vB.system.addOnce(this.tick, this, lib/* UPDATE_PRIORITY.UTILITY */.uF.UTILITY);\n        }\n      } else {\n        resolve();\n      }\n    });\n  }\n  tick() {\n    setTimeout(this.delayedTick, 0);\n  }\n  prepareItems() {\n    this.limiter.beginFrame();\n    while (this.queue.length && this.limiter.allowedToUpload()) {\n      const item = this.queue[0];\n      let uploaded = false;\n      if (item && !item._destroyed) {\n        for (let i = 0, len = this.uploadHooks.length; i < len; i++) {\n          if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n            this.queue.shift();\n            uploaded = true;\n            break;\n          }\n        }\n      }\n      if (!uploaded) {\n        this.queue.shift();\n      }\n    }\n    if (!this.queue.length) {\n      this.ticking = false;\n      const completes = this.completes.slice(0);\n      this.completes.length = 0;\n      for (let i = 0, len = completes.length; i < len; i++) {\n        completes[i]();\n      }\n    } else {\n      lib/* Ticker.system.addOnce */.vB.system.addOnce(this.tick, this, lib/* UPDATE_PRIORITY.UTILITY */.uF.UTILITY);\n    }\n  }\n  registerFindHook(addHook) {\n    if (addHook) {\n      this.addHooks.push(addHook);\n    }\n    return this;\n  }\n  registerUploadHook(uploadHook) {\n    if (uploadHook) {\n      this.uploadHooks.push(uploadHook);\n    }\n    return this;\n  }\n  add(item) {\n    for (let i = 0, len = this.addHooks.length; i < len; i++) {\n      if (this.addHooks[i](item, this.queue)) {\n        break;\n      }\n    }\n    if (item instanceof display_lib/* Container */.W2) {\n      for (let i = item.children.length - 1; i >= 0; i--) {\n        this.add(item.children[i]);\n      }\n    }\n    return this;\n  }\n  destroy() {\n    if (this.ticking) {\n      lib/* Ticker.system.remove */.vB.system.remove(this.tick, this);\n    }\n    this.ticking = false;\n    this.addHooks = null;\n    this.uploadHooks = null;\n    this.renderer = null;\n    this.completes = null;\n    this.queue = null;\n    this.limiter = null;\n    this.uploadHookHelper = null;\n  }\n};\nlet BasePrepare = _BasePrepare;\nBasePrepare.uploadsPerFrame = 4;\n\n\n//# sourceMappingURL=BasePrepare.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/settings.mjs\n\n\n\n\nObject.defineProperties(lib/* settings */.Xd, {\n  UPLOADS_PER_FRAME: {\n    get() {\n      return BasePrepare.uploadsPerFrame;\n    },\n    set(value) {\n      lib/* utils.deprecation */.P6.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");\n      BasePrepare.uploadsPerFrame = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/Prepare.mjs\n\n\n\n\nfunction uploadBaseTextures(renderer, item) {\n  if (item instanceof lib/* BaseTexture */.VL) {\n    if (!item._glTextures[renderer.CONTEXT_UID]) {\n      renderer.texture.bind(item);\n    }\n    return true;\n  }\n  return false;\n}\nfunction uploadGraphics(renderer, item) {\n  if (!(item instanceof Graphics)) {\n    return false;\n  }\n  const { geometry } = item;\n  item.finishPoly();\n  geometry.updateBatches();\n  const { batches } = geometry;\n  for (let i = 0; i < batches.length; i++) {\n    const { texture } = batches[i].style;\n    if (texture) {\n      uploadBaseTextures(renderer, texture.baseTexture);\n    }\n  }\n  if (!geometry.batchable) {\n    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));\n  }\n  return true;\n}\nfunction findGraphics(item, queue) {\n  if (item instanceof Graphics) {\n    queue.push(item);\n    return true;\n  }\n  return false;\n}\nclass Prepare extends BasePrepare {\n  constructor(renderer) {\n    super(renderer);\n    this.uploadHookHelper = this.renderer;\n    this.registerFindHook(findGraphics);\n    this.registerUploadHook(uploadBaseTextures);\n    this.registerUploadHook(uploadGraphics);\n  }\n}\nPrepare.extension = {\n  name: "prepare",\n  type: lib/* ExtensionType.RendererSystem */.nw.RendererSystem\n};\nlib/* extensions.add */.Rw.add(Prepare);\n\n\n//# sourceMappingURL=Prepare.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs\n\n\n\nclass AnimatedSprite extends (/* unused pure expression or super */ null && (Sprite)) {\n  constructor(textures, autoUpdate = true) {\n    super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);\n    this._textures = null;\n    this._durations = null;\n    this._autoUpdate = autoUpdate;\n    this._isConnectedToTicker = false;\n    this.animationSpeed = 1;\n    this.loop = true;\n    this.updateAnchor = false;\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n    this._currentTime = 0;\n    this._playing = false;\n    this._previousFrame = null;\n    this.textures = textures;\n  }\n  stop() {\n    if (!this._playing) {\n      return;\n    }\n    this._playing = false;\n    if (this._autoUpdate && this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  play() {\n    if (this._playing) {\n      return;\n    }\n    this._playing = true;\n    if (this._autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n      this._isConnectedToTicker = true;\n    }\n  }\n  gotoAndStop(frameNumber) {\n    this.stop();\n    this.currentFrame = frameNumber;\n  }\n  gotoAndPlay(frameNumber) {\n    this.currentFrame = frameNumber;\n    this.play();\n  }\n  update(deltaTime) {\n    if (!this._playing) {\n      return;\n    }\n    const elapsed = this.animationSpeed * deltaTime;\n    const previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1e3;\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n      const sign = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign;\n        this._currentTime += sign;\n      }\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n    if (this._currentTime < 0 && !this.loop) {\n      this.gotoAndStop(0);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this.gotoAndStop(this._textures.length - 1);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n      this.updateTexture();\n    }\n  }\n  updateTexture() {\n    const currentFrame = this.currentFrame;\n    if (this._previousFrame === currentFrame) {\n      return;\n    }\n    this._previousFrame = currentFrame;\n    this._texture = this._textures[currentFrame];\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 16777215;\n    this.uvs = this._texture._uvs.uvsFloat32;\n    if (this.updateAnchor) {\n      this._anchor.copyFrom(this._texture.defaultAnchor);\n    }\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  }\n  destroy(options) {\n    this.stop();\n    super.destroy(options);\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  }\n  static fromFrames(frames) {\n    const textures = [];\n    for (let i = 0; i < frames.length; ++i) {\n      textures.push(Texture.from(frames[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  static fromImages(images) {\n    const textures = [];\n    for (let i = 0; i < images.length; ++i) {\n      textures.push(Texture.from(images[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  get totalFrames() {\n    return this._textures.length;\n  }\n  get textures() {\n    return this._textures;\n  }\n  set textures(value) {\n    if (value[0] instanceof Texture) {\n      this._textures = value;\n      this._durations = null;\n    } else {\n      this._textures = [];\n      this._durations = [];\n      for (let i = 0; i < value.length; i++) {\n        this._textures.push(value[i].texture);\n        this._durations.push(value[i].time);\n      }\n    }\n    this._previousFrame = null;\n    this.gotoAndStop(0);\n    this.updateTexture();\n  }\n  get currentFrame() {\n    let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n    if (currentFrame < 0) {\n      currentFrame += this._textures.length;\n    }\n    return currentFrame;\n  }\n  set currentFrame(value) {\n    if (value < 0 || value > this.totalFrames - 1) {\n      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);\n    }\n    const previousFrame = this.currentFrame;\n    this._currentTime = value;\n    if (previousFrame !== this.currentFrame) {\n      this.updateTexture();\n    }\n  }\n  get playing() {\n    return this._playing;\n  }\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=AnimatedSprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-animated/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs\n\n\n\nconst TilingSprite_tempPoint = new lib/* Point */.E9();\nclass TilingSprite extends (/* unused pure expression or super */ null && (Sprite)) {\n  constructor(texture, width = 100, height = 100) {\n    super(texture);\n    this.tileTransform = new Transform();\n    this._width = width;\n    this._height = height;\n    this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);\n    this.pluginName = "tilingSprite";\n    this.uvRespectAnchor = false;\n  }\n  get clampMargin() {\n    return this.uvMatrix.clampMargin;\n  }\n  set clampMargin(value) {\n    this.uvMatrix.clampMargin = value;\n    this.uvMatrix.update(true);\n  }\n  get tileScale() {\n    return this.tileTransform.scale;\n  }\n  set tileScale(value) {\n    this.tileTransform.scale.copyFrom(value);\n  }\n  get tilePosition() {\n    return this.tileTransform.position;\n  }\n  set tilePosition(value) {\n    this.tileTransform.position.copyFrom(value);\n  }\n  _onTextureUpdate() {\n    if (this.uvMatrix) {\n      this.uvMatrix.texture = this._texture;\n    }\n    this._cachedTint = 16777215;\n  }\n  _render(renderer) {\n    const texture = this._texture;\n    if (!texture || !texture.valid) {\n      return;\n    }\n    this.tileTransform.updateLocalTransform();\n    this.uvMatrix.update();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  }\n  _calculateBounds() {\n    const minX = this._width * -this._anchor._x;\n    const minY = this._height * -this._anchor._y;\n    const maxX = this._width * (1 - this._anchor._x);\n    const maxY = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  }\n  getLocalBounds(rect) {\n    if (this.children.length === 0) {\n      this._bounds.minX = this._width * -this._anchor._x;\n      this._bounds.minY = this._height * -this._anchor._y;\n      this._bounds.maxX = this._width * (1 - this._anchor._x);\n      this._bounds.maxY = this._height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._bounds.getRectangle(rect);\n    }\n    return super.getLocalBounds.call(this, rect);\n  }\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, TilingSprite_tempPoint);\n    const width = this._width;\n    const height = this._height;\n    const x1 = -width * this.anchor._x;\n    if (TilingSprite_tempPoint.x >= x1 && TilingSprite_tempPoint.x < x1 + width) {\n      const y1 = -height * this.anchor._y;\n      if (TilingSprite_tempPoint.y >= y1 && TilingSprite_tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  destroy(options) {\n    super.destroy(options);\n    this.tileTransform = null;\n    this.uvMatrix = null;\n  }\n  static from(source, options) {\n    const texture = source instanceof Texture ? source : Texture.from(source, options);\n    return new TilingSprite(texture, options.width, options.height);\n  }\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value;\n  }\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value;\n  }\n}\n\n\n//# sourceMappingURL=TilingSprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.mjs\nvar gl2FragmentSrc = "#version 300 es\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nin vec2 vTextureCoord;\\n\\nout vec4 fragmentColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\\n\\n    fragmentColor = texSample * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.mjs\nvar gl2VertexSrc = "#version 300 es\\n#define SHADER_NAME Tiling-Sprite-300\\n\\nprecision lowp float;\\n\\nin vec2 aVertexPosition;\\nin vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nout vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs\nvar gl1FragmentSrc = "#version 100\\n#ifdef GL_EXT_shader_texture_lod\\n    #extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    #ifdef GL_EXT_shader_texture_lod\\n        vec4 texSample = unclamped == coord\\n            ? texture2D(uSampler, coord) \\n            : texture2DLodEXT(uSampler, coord, 0);\\n    #else\\n        vec4 texSample = texture2D(uSampler, coord);\\n    #endif\\n\\n    gl_FragColor = texSample * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling-fallback.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs\nvar gl1VertexSrc = "#version 100\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling-fallback2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs\nvar fragmentSimpleSrc = "#version 100\\n#define SHADER_NAME Tiling-Sprite-Simple-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = texSample * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling-simple.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs\n\n\n\n\n\n\n\nconst tempMat = new lib/* Matrix */.y3();\nclass TilingSpriteRenderer extends lib/* ObjectRenderer */.bO {\n  constructor(renderer) {\n    super(renderer);\n    renderer.runners.contextChange.add(this);\n    this.quad = new lib/* QuadUv */.ud();\n    this.state = lib/* State.for2d */.ZM.for2d();\n  }\n  contextChange() {\n    const renderer = this.renderer;\n    const uniforms = { globals: renderer.globalUniforms };\n    this.simpleShader = lib/* Shader.from */.ex.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n    this.shader = renderer.context.webGLVersion > 1 ? lib/* Shader.from */.ex.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : lib/* Shader.from */.ex.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  }\n  render(ts) {\n    const renderer = this.renderer;\n    const quad = this.quad;\n    let vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs;\n    vertices[0] = vertices[6] = -anchorX;\n    vertices[1] = vertices[3] = -anchorY;\n    vertices[2] = vertices[4] = 1 - anchorX;\n    vertices[5] = vertices[7] = 1 - anchorY;\n    quad.invalidate();\n    const tex = ts._texture;\n    const baseTex = tex.baseTexture;\n    const premultiplied = baseTex.alphaMode > 0;\n    const lt = ts.tileTransform.localTransform;\n    const uv = ts.uvMatrix;\n    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === lib/* WRAP_MODES.CLAMP */.Nt.CLAMP) {\n          baseTex.wrapMode = lib/* WRAP_MODES.REPEAT */.Nt.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== lib/* WRAP_MODES.CLAMP */.Nt.CLAMP;\n      }\n    }\n    const shader = isSimple ? this.simpleShader : this.shader;\n    const w = tex.width;\n    const h = tex.height;\n    const W = ts._width;\n    const H = ts._height;\n    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n    tempMat.invert();\n    if (isSimple) {\n      tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n    shader.uniforms.uTransform = tempMat.toArray(true);\n    shader.uniforms.uColor = lib/* Color.shared.setValue */.Il.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = tex;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(quad);\n    this.state.blendMode = lib/* utils.correctBlendMode */.P6.correctBlendMode(ts.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }\n}\nTilingSpriteRenderer.extension = {\n  name: "tilingSprite",\n  type: lib/* ExtensionType.RendererPlugin */.nw.RendererPlugin\n};\nlib/* extensions.add */.Rw.add(TilingSpriteRenderer);\n\n\n//# sourceMappingURL=TilingSpriteRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/Spritesheet.mjs\n\n\nconst _Spritesheet = class {\n  constructor(texture, data, resolutionFilename = null) {\n    this.linkedSheets = [];\n    this._texture = texture instanceof lib/* Texture */.xE ? texture : null;\n    this.baseTexture = texture instanceof lib/* BaseTexture */.VL ? texture : this._texture.baseTexture;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  _updateResolution(resolutionFilename = null) {\n    const { scale } = this.data.meta;\n    let resolution = lib/* utils.getResolutionOfUrl */.P6.getResolutionOfUrl(resolutionFilename, null);\n    if (resolution === null) {\n      resolution = parseFloat(scale ?? "1");\n    }\n    if (resolution !== 1) {\n      this.baseTexture.setResolution(resolution);\n    }\n    return resolution;\n  }\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new lib/* Rectangle */.Ae(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n        if (data.rotated) {\n          frame = new lib/* Rectangle */.Ae(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n        } else {\n          frame = new lib/* Rectangle */.Ae(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new lib/* Rectangle */.Ae(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        this.textures[i] = new lib/* Texture */.xE(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor, data.borders);\n        lib/* Texture.addToCache */.xE.addToCache(this.textures[i], i);\n      }\n      frameIndex++;\n    }\n  }\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.baseTexture.destroy();\n    }\n    this._texture = null;\n    this.baseTexture = null;\n    this.linkedSheets = [];\n  }\n};\nlet Spritesheet = _Spritesheet;\nSpritesheet.BATCH_SIZE = 1e3;\n\n\n//# sourceMappingURL=Spritesheet.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs\n\n\n\n\nconst validImages = ["jpg", "png", "jpeg", "avif", "webp"];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = lib/* utils.path.dirname */.P6.path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: lib/* ExtensionType.Asset */.nw.Asset,\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  resolver: {\n    test: (value) => {\n      const tempURL = value.split("?")[0];\n      const split = tempURL.split(".");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === "json" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(".");\n      return {\n        resolution: parseFloat(lib/* settings.RETINA_PREFIX.exec */.Xd.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  loader: {\n    name: "spritesheetLoader",\n    extension: {\n      type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n      priority: LoaderParserPriority.Normal\n    },\n    async testParse(asset, options) {\n      return lib/* utils.path.extname */.P6.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      let basePath = lib/* utils.path.dirname */.P6.path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {\n        basePath += "/";\n      }\n      let imagePath = basePath + asset.meta.image;\n      imagePath = copySearchParams(imagePath, options.src);\n      const assets = await loader.load([imagePath]);\n      const texture = assets[imagePath];\n      const spritesheet = new Spritesheet(texture.baseTexture, asset, options.src);\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== "string") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    unload(spritesheet) {\n      spritesheet.destroy(true);\n    }\n  }\n};\nlib/* extensions.add */.Rw.add(spritesheetAsset);\n\n\n//# sourceMappingURL=spritesheetAsset.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs\nclass BitmapFontData {\n  constructor() {\n    this.info = [];\n    this.common = [];\n    this.page = [];\n    this.char = [];\n    this.kerning = [];\n    this.distanceField = [];\n  }\n}\n\n\n//# sourceMappingURL=BitmapFontData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs\n\n\nclass TextFormat {\n  static test(data) {\n    return typeof data === "string" && data.startsWith("info face=");\n  }\n  static parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s"\']+|"([^"]*)")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split("=");\n        const key = split[0];\n        const strValue = split[1].replace(/"/gm, "");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = new BitmapFontData();\n    rawData.info.forEach((info) => font.info.push({\n      face: info.face,\n      size: parseInt(info.size, 10)\n    }));\n    rawData.common.forEach((common) => font.common.push({\n      lineHeight: parseInt(common.lineHeight, 10)\n    }));\n    rawData.page.forEach((page) => font.page.push({\n      id: parseInt(page.id, 10),\n      file: page.file\n    }));\n    rawData.char.forEach((char) => font.char.push({\n      id: parseInt(char.id, 10),\n      page: parseInt(char.page, 10),\n      x: parseInt(char.x, 10),\n      y: parseInt(char.y, 10),\n      width: parseInt(char.width, 10),\n      height: parseInt(char.height, 10),\n      xoffset: parseInt(char.xoffset, 10),\n      yoffset: parseInt(char.yoffset, 10),\n      xadvance: parseInt(char.xadvance, 10)\n    }));\n    rawData.kerning.forEach((kerning) => font.kerning.push({\n      first: parseInt(kerning.first, 10),\n      second: parseInt(kerning.second, 10),\n      amount: parseInt(kerning.amount, 10)\n    }));\n    rawData.distanceField.forEach((df) => font.distanceField.push({\n      distanceRange: parseInt(df.distanceRange, 10),\n      fieldType: df.fieldType\n    }));\n    return font;\n  }\n}\n\n\n//# sourceMappingURL=TextFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs\n\n\nclass XMLFormat {\n  static test(data) {\n    const xml = data;\n    return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;\n  }\n  static parse(xml) {\n    const data = new BitmapFontData();\n    const info = xml.getElementsByTagName("info");\n    const common = xml.getElementsByTagName("common");\n    const page = xml.getElementsByTagName("page");\n    const char = xml.getElementsByTagName("char");\n    const kerning = xml.getElementsByTagName("kerning");\n    const distanceField = xml.getElementsByTagName("distanceField");\n    for (let i = 0; i < info.length; i++) {\n      data.info.push({\n        face: info[i].getAttribute("face"),\n        size: parseInt(info[i].getAttribute("size"), 10)\n      });\n    }\n    for (let i = 0; i < common.length; i++) {\n      data.common.push({\n        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)\n      });\n    }\n    for (let i = 0; i < page.length; i++) {\n      data.page.push({\n        id: parseInt(page[i].getAttribute("id"), 10) || 0,\n        file: page[i].getAttribute("file")\n      });\n    }\n    for (let i = 0; i < char.length; i++) {\n      const letter = char[i];\n      data.char.push({\n        id: parseInt(letter.getAttribute("id"), 10),\n        page: parseInt(letter.getAttribute("page"), 10) || 0,\n        x: parseInt(letter.getAttribute("x"), 10),\n        y: parseInt(letter.getAttribute("y"), 10),\n        width: parseInt(letter.getAttribute("width"), 10),\n        height: parseInt(letter.getAttribute("height"), 10),\n        xoffset: parseInt(letter.getAttribute("xoffset"), 10),\n        yoffset: parseInt(letter.getAttribute("yoffset"), 10),\n        xadvance: parseInt(letter.getAttribute("xadvance"), 10)\n      });\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      data.kerning.push({\n        first: parseInt(kerning[i].getAttribute("first"), 10),\n        second: parseInt(kerning[i].getAttribute("second"), 10),\n        amount: parseInt(kerning[i].getAttribute("amount"), 10)\n      });\n    }\n    for (let i = 0; i < distanceField.length; i++) {\n      data.distanceField.push({\n        fieldType: distanceField[i].getAttribute("fieldType"),\n        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)\n      });\n    }\n    return data;\n  }\n}\n\n\n//# sourceMappingURL=XMLFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs\n\n\n\nclass XMLStringFormat {\n  static test(data) {\n    if (typeof data === "string" && data.includes("<font>")) {\n      return XMLFormat.test(lib/* settings.ADAPTER.parseXML */.Xd.ADAPTER.parseXML(data));\n    }\n    return false;\n  }\n  static parse(xmlTxt) {\n    return XMLFormat.parse(lib/* settings.ADAPTER.parseXML */.Xd.ADAPTER.parseXML(xmlTxt));\n  }\n}\n\n\n//# sourceMappingURL=XMLStringFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/index.mjs\n\n\n\n\n\n\n\nconst formats = [\n  TextFormat,\n  XMLFormat,\n  XMLStringFormat\n];\nfunction autoDetectFormat(data) {\n  for (let i = 0; i < formats.length; i++) {\n    if (formats[i].test(data)) {\n      return formats[i];\n    }\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs\n\n\nfunction generateFillStyle(canvas, context, style, resolution, lines, metrics) {\n  const fillStyle = style.fill;\n  if (!Array.isArray(fillStyle)) {\n    return fillStyle;\n  } else if (fillStyle.length === 1) {\n    return fillStyle[0];\n  }\n  let gradient;\n  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;\n  const padding = style.padding || 0;\n  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;\n  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;\n  const fill = fillStyle.slice();\n  const fillGradientStops = style.fillGradientStops.slice();\n  if (!fillGradientStops.length) {\n    const lengthPlus1 = fill.length + 1;\n    for (let i = 1; i < lengthPlus1; ++i) {\n      fillGradientStops.push(i / lengthPlus1);\n    }\n  }\n  fill.unshift(fillStyle[0]);\n  fillGradientStops.unshift(0);\n  fill.push(fillStyle[fillStyle.length - 1]);\n  fillGradientStops.push(1);\n  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n    let lastIterationStop = 0;\n    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n    const gradStopLineHeight = textHeight / height;\n    for (let i = 0; i < lines.length; i++) {\n      const thisLineTop = metrics.lineHeight * i;\n      for (let j = 0; j < fill.length; j++) {\n        let lineStop = 0;\n        if (typeof fillGradientStops[j] === "number") {\n          lineStop = fillGradientStops[j];\n        } else {\n          lineStop = j / fill.length;\n        }\n        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;\n        let clampedStop = Math.max(lastIterationStop, globalStop);\n        clampedStop = Math.min(clampedStop, 1);\n        gradient.addColorStop(clampedStop, fill[j]);\n        lastIterationStop = clampedStop;\n      }\n    }\n  } else {\n    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n    const totalIterations = fill.length + 1;\n    let currentIteration = 1;\n    for (let i = 0; i < fill.length; i++) {\n      let stop;\n      if (typeof fillGradientStops[i] === "number") {\n        stop = fillGradientStops[i];\n      } else {\n        stop = currentIteration / totalIterations;\n      }\n      gradient.addColorStop(stop, fill[i]);\n      currentIteration++;\n    }\n  }\n  return gradient;\n}\n\n\n//# sourceMappingURL=generateFillStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs\n\n\n\nfunction drawGlyph(canvas, context, metrics, x, y, resolution, style) {\n  const char = metrics.text;\n  const fontProperties = metrics.fontProperties;\n  context.translate(x, y);\n  context.scale(resolution, resolution);\n  const tx = style.strokeThickness / 2;\n  const ty = -(style.strokeThickness / 2);\n  context.font = style.toFontString();\n  context.lineWidth = style.strokeThickness;\n  context.textBaseline = style.textBaseline;\n  context.lineJoin = style.lineJoin;\n  context.miterLimit = style.miterLimit;\n  context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);\n  context.strokeStyle = style.stroke;\n  if (style.dropShadow) {\n    const dropShadowColor = style.dropShadowColor;\n    const dropShadowBlur = style.dropShadowBlur * resolution;\n    const dropShadowDistance = style.dropShadowDistance * resolution;\n    context.shadowColor = lib/* Color.shared.setValue */.Il.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();\n    context.shadowBlur = dropShadowBlur;\n    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;\n  } else {\n    context.shadowColor = "black";\n    context.shadowBlur = 0;\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n  }\n  if (style.stroke && style.strokeThickness) {\n    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n  }\n  if (style.fill) {\n    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n  }\n  context.setTransform(1, 0, 0, 1, 0, 0);\n  context.fillStyle = "rgba(0, 0, 0, 0)";\n}\n\n\n//# sourceMappingURL=drawGlyph.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs\nfunction splitTextToCharacters(text) {\n  return Array.from ? Array.from(text) : text.split("");\n}\n\n\n//# sourceMappingURL=splitTextToCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs\n\n\nfunction resolveCharacters(chars) {\n  if (typeof chars === "string") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error("[BitmapFont]: Invalid character range.");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...splitTextToCharacters(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs\nfunction extractCharCode(str) {\n  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);\n}\n\n\n//# sourceMappingURL=extractCharCode.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs\n\n\n\n\n\n\n\n\n\nconst _BitmapFont = class {\n  constructor(data, textures, ownsTextures) {\n    const [info] = data.info;\n    const [common] = data.common;\n    const [page] = data.page;\n    const [distanceField] = data.distanceField;\n    const res = lib/* utils.getResolutionOfUrl */.P6.getResolutionOfUrl(page.file);\n    const pageTextures = {};\n    this._ownsTextures = ownsTextures;\n    this.font = info.face;\n    this.size = info.size;\n    this.lineHeight = common.lineHeight / res;\n    this.chars = {};\n    this.pageTextures = pageTextures;\n    for (let i = 0; i < data.page.length; i++) {\n      const { id, file } = data.page[i];\n      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n      if (distanceField?.fieldType && distanceField.fieldType !== "none") {\n        pageTextures[id].baseTexture.alphaMode = lib/* ALPHA_MODES.NO_PREMULTIPLIED_ALPHA */.iw.NO_PREMULTIPLIED_ALPHA;\n        pageTextures[id].baseTexture.mipmap = lib/* MIPMAP_MODES.OFF */.KI.OFF;\n      }\n    }\n    for (let i = 0; i < data.char.length; i++) {\n      const { id, page: page2 } = data.char[i];\n      let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];\n      x /= res;\n      y /= res;\n      width /= res;\n      height /= res;\n      xoffset /= res;\n      yoffset /= res;\n      xadvance /= res;\n      const rect = new lib/* Rectangle */.Ae(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);\n      this.chars[id] = {\n        xOffset: xoffset,\n        yOffset: yoffset,\n        xAdvance: xadvance,\n        kerning: {},\n        texture: new lib/* Texture */.xE(pageTextures[page2].baseTexture, rect),\n        page: page2\n      };\n    }\n    for (let i = 0; i < data.kerning.length; i++) {\n      let { first, second, amount } = data.kerning[i];\n      first /= res;\n      second /= res;\n      amount /= res;\n      if (this.chars[second]) {\n        this.chars[second].kerning[first] = amount;\n      }\n    }\n    this.distanceFieldRange = distanceField?.distanceRange;\n    this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";\n  }\n  destroy() {\n    for (const id in this.chars) {\n      this.chars[id].texture.destroy();\n      this.chars[id].texture = null;\n    }\n    for (const id in this.pageTextures) {\n      if (this._ownsTextures) {\n        this.pageTextures[id].destroy(true);\n      }\n      this.pageTextures[id] = null;\n    }\n    this.chars = null;\n    this.pageTextures = null;\n  }\n  static install(data, textures, ownsTextures) {\n    let fontData;\n    if (data instanceof BitmapFontData) {\n      fontData = data;\n    } else {\n      const format = autoDetectFormat(data);\n      if (!format) {\n        throw new Error("Unrecognized data format for font.");\n      }\n      fontData = format.parse(data);\n    }\n    if (textures instanceof lib/* Texture */.xE) {\n      textures = [textures];\n    }\n    const font = new _BitmapFont(fontData, textures, ownsTextures);\n    _BitmapFont.available[font.font] = font;\n    return font;\n  }\n  static uninstall(name) {\n    const font = _BitmapFont.available[name];\n    if (!font) {\n      throw new Error(`No font found named \'${name}\'`);\n    }\n    font.destroy();\n    delete _BitmapFont.available[name];\n  }\n  static from(name, textStyle, options) {\n    if (!name) {\n      throw new Error("[BitmapFont] Property `name` is required.");\n    }\n    const {\n      chars,\n      padding,\n      resolution,\n      textureWidth,\n      textureHeight,\n      ...baseOptions\n    } = Object.assign({}, _BitmapFont.defaultOptions, options);\n    const charsList = resolveCharacters(chars);\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const lineWidth = textureWidth;\n    const fontData = new BitmapFontData();\n    fontData.info[0] = {\n      face: style.fontFamily,\n      size: style.fontSize\n    };\n    fontData.common[0] = {\n      lineHeight: style.fontSize\n    };\n    let positionX = 0;\n    let positionY = 0;\n    let canvas;\n    let context;\n    let baseTexture;\n    let maxCharHeight = 0;\n    const baseTextures = [];\n    const textures = [];\n    for (let i = 0; i < charsList.length; i++) {\n      if (!canvas) {\n        canvas = lib/* settings.ADAPTER.createCanvas */.Xd.ADAPTER.createCanvas();\n        canvas.width = textureWidth;\n        canvas.height = textureHeight;\n        context = canvas.getContext("2d");\n        baseTexture = new lib/* BaseTexture */.VL(canvas, { resolution, ...baseOptions });\n        baseTextures.push(baseTexture);\n        textures.push(new lib/* Texture */.xE(baseTexture));\n        fontData.page.push({\n          id: textures.length - 1,\n          file: ""\n        });\n      }\n      const character = charsList[i];\n      const metrics = TextMetrics.measureText(character, style, false, canvas);\n      const width = metrics.width;\n      const height = Math.ceil(metrics.height);\n      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);\n      if (positionY >= textureHeight - height * resolution) {\n        if (positionY === 0) {\n          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: \'${style.fontFamily}\', fontSize: ${style.fontSize}px, char: \'${character}\')`);\n        }\n        --i;\n        canvas = null;\n        context = null;\n        baseTexture = null;\n        positionY = 0;\n        positionX = 0;\n        maxCharHeight = 0;\n        continue;\n      }\n      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n      if (textureGlyphWidth * resolution + positionX >= lineWidth) {\n        if (positionX === 0) {\n          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: \'${style.fontFamily}\', fontSize: ${style.fontSize}px, char: \'${character}\')`);\n        }\n        --i;\n        positionY += maxCharHeight * resolution;\n        positionY = Math.ceil(positionY);\n        positionX = 0;\n        maxCharHeight = 0;\n        continue;\n      }\n      drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n      const id = extractCharCode(metrics.text);\n      fontData.char.push({\n        id,\n        page: textures.length - 1,\n        x: positionX / resolution,\n        y: positionY / resolution,\n        width: textureGlyphWidth,\n        height,\n        xoffset: 0,\n        yoffset: 0,\n        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)\n      });\n      positionX += (textureGlyphWidth + 2 * padding) * resolution;\n      positionX = Math.ceil(positionX);\n    }\n    for (let i = 0, len = charsList.length; i < len; i++) {\n      const first = charsList[i];\n      for (let j = 0; j < len; j++) {\n        const second = charsList[j];\n        const c1 = context.measureText(first).width;\n        const c2 = context.measureText(second).width;\n        const total = context.measureText(first + second).width;\n        const amount = total - (c1 + c2);\n        if (amount) {\n          fontData.kerning.push({\n            first: extractCharCode(first),\n            second: extractCharCode(second),\n            amount\n          });\n        }\n      }\n    }\n    const font = new _BitmapFont(fontData, textures, true);\n    if (_BitmapFont.available[name] !== void 0) {\n      _BitmapFont.uninstall(name);\n    }\n    _BitmapFont.available[name] = font;\n    return font;\n  }\n};\nlet BitmapFont = _BitmapFont;\nBitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];\nBitmapFont.NUMERIC = [["0", "9"]];\nBitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];\nBitmapFont.ASCII = [[" ", "~"]];\nBitmapFont.defaultOptions = {\n  resolution: 1,\n  textureWidth: 512,\n  textureHeight: 512,\n  padding: 4,\n  chars: _BitmapFont.ALPHANUMERIC\n};\nBitmapFont.available = {};\n\n\n//# sourceMappingURL=BitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/shader/msdf.mjs\nvar msdfFrag = "// Pixi texture info\\r\\nvarying vec2 vTextureCoord;\\r\\nuniform sampler2D uSampler;\\r\\n\\r\\n// Tint\\r\\nuniform vec4 uColor;\\r\\n\\r\\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\\nuniform float uFWidth;\\r\\n\\r\\nvoid main(void) {\\r\\n\\r\\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\\n\\r\\n  // MSDF\\r\\n  float median = texColor.r + texColor.g + texColor.b -\\r\\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\\n  // SDF\\r\\n  median = min(median, texColor.a);\\r\\n\\r\\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\\n  if (median < 0.01) {\\r\\n    alpha = 0.0;\\r\\n  } else if (median > 0.99) {\\r\\n    alpha = 1.0;\\r\\n  }\\r\\n\\r\\n  // Gamma correction for coverage-like alpha\\r\\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\\r\\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\\r\\n  float coverage = pow(uColor.a * alpha, gamma);  \\r\\n\\r\\n  // NPM Textures, NPM outputs\\r\\n  gl_FragColor = vec4(uColor.rgb, coverage);\\r\\n}\\r\\n";\n\n\n//# sourceMappingURL=msdf.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/shader/msdf2.mjs\nvar msdfVert = "// Mesh material default fragment\\r\\nattribute vec2 aVertexPosition;\\r\\nattribute vec2 aTextureCoord;\\r\\n\\r\\nuniform mat3 projectionMatrix;\\r\\nuniform mat3 translationMatrix;\\r\\nuniform mat3 uTextureMatrix;\\r\\n\\r\\nvarying vec2 vTextureCoord;\\r\\n\\r\\nvoid main(void)\\r\\n{\\r\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n\\r\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\\n}\\r\\n";\n\n\n//# sourceMappingURL=msdf2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapText.mjs\n\n\n\n\n\n\n\n\n\n\nconst pageMeshDataDefaultPageMeshData = [];\nconst pageMeshDataMSDFPageMeshData = [];\nconst charRenderDataPool = [];\nconst _BitmapText = class extends display_lib/* Container */.W2 {\n  constructor(text, style = {}) {\n    super();\n    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);\n    if (!BitmapFont.available[fontName]) {\n      throw new Error(`Missing BitmapFont "${fontName}"`);\n    }\n    this._activePagesMeshData = [];\n    this._textWidth = 0;\n    this._textHeight = 0;\n    this._align = align;\n    this._tintColor = new lib/* Color */.Il(tint);\n    this._font = void 0;\n    this._fontName = fontName;\n    this._fontSize = fontSize;\n    this.text = text;\n    this._maxWidth = maxWidth;\n    this._maxLineHeight = 0;\n    this._letterSpacing = letterSpacing;\n    this._anchor = new lib/* ObservablePoint */.AB(() => {\n      this.dirty = true;\n    }, this, 0, 0);\n    this._roundPixels = lib/* settings.ROUND_PIXELS */.Xd.ROUND_PIXELS;\n    this.dirty = true;\n    this._resolution = lib/* settings.RESOLUTION */.Xd.RESOLUTION;\n    this._autoResolution = true;\n    this._textureCache = {};\n  }\n  updateText() {\n    const data = BitmapFont.available[this._fontName];\n    const fontSize = this.fontSize;\n    const scale = fontSize / data.size;\n    const pos = new lib/* Point */.E9();\n    const chars = [];\n    const lineWidths = [];\n    const lineSpaces = [];\n    const text = this._text.replace(/(?:\\r\\n|\\r)/g, "\\n") || " ";\n    const charsInput = splitTextToCharacters(text);\n    const maxWidth = this._maxWidth * data.size / fontSize;\n    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    let prevCharCode = null;\n    let lastLineWidth = 0;\n    let maxLineWidth = 0;\n    let line = 0;\n    let lastBreakPos = -1;\n    let lastBreakWidth = 0;\n    let spacesRemoved = 0;\n    let maxLineHeight = 0;\n    let spaceCount = 0;\n    for (let i = 0; i < charsInput.length; i++) {\n      const char = charsInput[i];\n      const charCode = extractCharCode(char);\n      if (/(?:\\s)/.test(char)) {\n        lastBreakPos = i;\n        lastBreakWidth = lastLineWidth;\n        spaceCount++;\n      }\n      if (char === "\\r" || char === "\\n") {\n        lineWidths.push(lastLineWidth);\n        lineSpaces.push(-1);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        ++line;\n        ++spacesRemoved;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n        continue;\n      }\n      const charData = data.chars[charCode];\n      if (!charData) {\n        continue;\n      }\n      if (prevCharCode && charData.kerning[prevCharCode]) {\n        pos.x += charData.kerning[prevCharCode];\n      }\n      const charRenderData = charRenderDataPool.pop() || {\n        texture: lib/* Texture.EMPTY */.xE.EMPTY,\n        line: 0,\n        charCode: 0,\n        prevSpaces: 0,\n        position: new lib/* Point */.E9()\n      };\n      charRenderData.texture = charData.texture;\n      charRenderData.line = line;\n      charRenderData.charCode = charCode;\n      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);\n      charRenderData.position.y = Math.round(pos.y + charData.yOffset);\n      charRenderData.prevSpaces = spaceCount;\n      chars.push(charRenderData);\n      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n      pos.x += charData.xAdvance + this._letterSpacing;\n      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n      prevCharCode = charCode;\n      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n        ++spacesRemoved;\n        lib/* utils.removeItems */.P6.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n        i = lastBreakPos;\n        lastBreakPos = -1;\n        lineWidths.push(lastBreakWidth);\n        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n        line++;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n      }\n    }\n    const lastChar = charsInput[charsInput.length - 1];\n    if (lastChar !== "\\r" && lastChar !== "\\n") {\n      if (/(?:\\s)/.test(lastChar)) {\n        lastLineWidth = lastBreakWidth;\n      }\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n      lineSpaces.push(-1);\n    }\n    const lineAlignOffsets = [];\n    for (let i = 0; i <= line; i++) {\n      let alignOffset = 0;\n      if (this._align === "right") {\n        alignOffset = maxLineWidth - lineWidths[i];\n      } else if (this._align === "center") {\n        alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n      } else if (this._align === "justify") {\n        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n      }\n      lineAlignOffsets.push(alignOffset);\n    }\n    const lenChars = chars.length;\n    const pagesMeshData = {};\n    const newPagesMeshData = [];\n    const activePagesMeshData = this._activePagesMeshData;\n    pageMeshDataPool.push(...activePagesMeshData);\n    for (let i = 0; i < lenChars; i++) {\n      const texture = chars[i].texture;\n      const baseTextureUid = texture.baseTexture.uid;\n      if (!pagesMeshData[baseTextureUid]) {\n        let pageMeshData = pageMeshDataPool.pop();\n        if (!pageMeshData) {\n          const geometry = new MeshGeometry_MeshGeometry();\n          let material;\n          let meshBlendMode;\n          if (data.distanceFieldType === "none") {\n            material = new MeshMaterial_MeshMaterial(lib/* Texture.EMPTY */.xE.EMPTY);\n            meshBlendMode = lib/* BLEND_MODES.NORMAL */.T$.NORMAL;\n          } else {\n            material = new MeshMaterial_MeshMaterial(lib/* Texture.EMPTY */.xE.EMPTY, { program: lib/* Program.from */.$r.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });\n            meshBlendMode = lib/* BLEND_MODES.NORMAL_NPM */.T$.NORMAL_NPM;\n          }\n          const mesh = new Mesh_Mesh(geometry, material);\n          mesh.blendMode = meshBlendMode;\n          pageMeshData = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        pageMeshData.index = 0;\n        pageMeshData.indexCount = 0;\n        pageMeshData.vertexCount = 0;\n        pageMeshData.uvsCount = 0;\n        pageMeshData.total = 0;\n        const { _textureCache } = this;\n        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new lib/* Texture */.xE(texture.baseTexture);\n        pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n        pageMeshData.mesh.tint = this._tintColor.value;\n        newPagesMeshData.push(pageMeshData);\n        pagesMeshData[baseTextureUid] = pageMeshData;\n      }\n      pagesMeshData[baseTextureUid].total++;\n    }\n    for (let i = 0; i < activePagesMeshData.length; i++) {\n      if (!newPagesMeshData.includes(activePagesMeshData[i])) {\n        this.removeChild(activePagesMeshData[i].mesh);\n      }\n    }\n    for (let i = 0; i < newPagesMeshData.length; i++) {\n      if (newPagesMeshData[i].mesh.parent !== this) {\n        this.addChild(newPagesMeshData[i].mesh);\n      }\n    }\n    this._activePagesMeshData = newPagesMeshData;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i];\n      const total = pageMeshData.total;\n      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh_Mesh.BATCHABLE_SIZE * 2) {\n        pageMeshData.vertices = new Float32Array(4 * 2 * total);\n        pageMeshData.uvs = new Float32Array(4 * 2 * total);\n        pageMeshData.indices = new Uint16Array(6 * total);\n      } else {\n        const total2 = pageMeshData.total;\n        const vertices = pageMeshData.vertices;\n        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {\n          vertices[i2] = 0;\n        }\n      }\n      pageMeshData.mesh.size = 6 * total;\n    }\n    for (let i = 0; i < lenChars; i++) {\n      const char = chars[i];\n      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);\n      if (this._roundPixels) {\n        offset = Math.round(offset);\n      }\n      const xPos = offset * scale;\n      const yPos = char.position.y * scale;\n      const texture = char.texture;\n      const pageMesh = pagesMeshData[texture.baseTexture.uid];\n      const textureFrame = texture.frame;\n      const textureUvs = texture._uvs;\n      const index = pageMesh.index++;\n      pageMesh.indices[index * 6 + 0] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 1] = 1 + index * 4;\n      pageMesh.indices[index * 6 + 2] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 3] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 4] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 5] = 3 + index * 4;\n      pageMesh.vertices[index * 8 + 0] = xPos;\n      pageMesh.vertices[index * 8 + 1] = yPos;\n      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 3] = yPos;\n      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;\n      pageMesh.vertices[index * 8 + 6] = xPos;\n      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;\n      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;\n      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;\n      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;\n      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;\n      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;\n      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;\n      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;\n      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n    }\n    this._textWidth = maxLineWidth * scale;\n    this._textHeight = (pos.y + data.lineHeight) * scale;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n        let vertexCount = 0;\n        const anchorOffsetX = this._textWidth * this.anchor.x;\n        const anchorOffsetY = this._textHeight * this.anchor.y;\n        for (let i2 = 0; i2 < pageMeshData.total; i2++) {\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n        }\n      }\n      this._maxLineHeight = maxLineHeight * scale;\n      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");\n      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");\n      const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n      vertexBuffer.data = pageMeshData.vertices;\n      textureBuffer.data = pageMeshData.uvs;\n      indexBuffer.data = pageMeshData.indices;\n      vertexBuffer.update();\n      textureBuffer.update();\n      indexBuffer.update();\n    }\n    for (let i = 0; i < chars.length; i++) {\n      charRenderDataPool.push(chars[i]);\n    }\n    this._font = data;\n    this.dirty = false;\n  }\n  updateTransform() {\n    this.validate();\n    this.containerUpdateTransform();\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];\n    if (distanceFieldType !== "none") {\n      const { a, b, c, d } = this.worldTransform;\n      const dx = Math.sqrt(a * a + b * b);\n      const dy = Math.sqrt(c * c + d * d);\n      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n      const fontScale = this.fontSize / size;\n      const resolution = renderer._view.resolution;\n      for (const mesh of this._activePagesMeshData) {\n        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n      }\n    }\n    super._render(renderer);\n  }\n  getLocalBounds() {\n    this.validate();\n    return super.getLocalBounds();\n  }\n  validate() {\n    const font = BitmapFont.available[this._fontName];\n    if (!font) {\n      throw new Error(`Missing BitmapFont "${this._fontName}"`);\n    }\n    if (this._font !== font) {\n      this.dirty = true;\n    }\n    if (this.dirty) {\n      this.updateText();\n    }\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    if (this.tint === value)\n      return;\n    this._tintColor.setValue(value);\n    for (let i = 0; i < this._activePagesMeshData.length; i++) {\n      this._activePagesMeshData[i].mesh.tint = value;\n    }\n  }\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    if (this._align !== value) {\n      this._align = value;\n      this.dirty = true;\n    }\n  }\n  get fontName() {\n    return this._fontName;\n  }\n  set fontName(value) {\n    if (!BitmapFont.available[value]) {\n      throw new Error(`Missing BitmapFont "${value}"`);\n    }\n    if (this._fontName !== value) {\n      this._fontName = value;\n      this.dirty = true;\n    }\n  }\n  get fontSize() {\n    return this._fontSize ?? BitmapFont.available[this._fontName].size;\n  }\n  set fontSize(value) {\n    if (this._fontSize !== value) {\n      this._fontSize = value;\n      this.dirty = true;\n    }\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    if (typeof value === "number") {\n      this._anchor.set(value);\n    } else {\n      this._anchor.copyFrom(value);\n    }\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === null || text === void 0 ? "" : text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get maxWidth() {\n    return this._maxWidth;\n  }\n  set maxWidth(value) {\n    if (this._maxWidth === value) {\n      return;\n    }\n    this._maxWidth = value;\n    this.dirty = true;\n  }\n  get maxLineHeight() {\n    this.validate();\n    return this._maxLineHeight;\n  }\n  get textWidth() {\n    this.validate();\n    return this._textWidth;\n  }\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    if (this._letterSpacing !== value) {\n      this._letterSpacing = value;\n      this.dirty = true;\n    }\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  set roundPixels(value) {\n    if (value !== this._roundPixels) {\n      this._roundPixels = value;\n      this.dirty = true;\n    }\n  }\n  get textHeight() {\n    this.validate();\n    return this._textHeight;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n  destroy(options) {\n    const { _textureCache } = this;\n    const data = BitmapFont.available[this._fontName];\n    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    pageMeshDataPool.push(...this._activePagesMeshData);\n    for (const pageMeshData of this._activePagesMeshData) {\n      this.removeChild(pageMeshData.mesh);\n    }\n    this._activePagesMeshData = [];\n    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {\n      page.mesh.texture = lib/* Texture.EMPTY */.xE.EMPTY;\n    });\n    for (const id in _textureCache) {\n      const texture = _textureCache[id];\n      texture.destroy();\n      delete _textureCache[id];\n    }\n    this._font = null;\n    this._tintColor = null;\n    this._textureCache = null;\n    super.destroy(options);\n  }\n};\nlet BitmapText = _BitmapText;\nBitmapText.styleDefaults = {\n  align: "left",\n  tint: 16777215,\n  maxWidth: 0,\n  letterSpacing: 0\n};\n\n\n//# sourceMappingURL=BitmapText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs\n\n\n\n\n\n\n\nconst validExtensions = [".xml", ".fnt"];\nconst loadBitmapFont = {\n  extension: {\n    type: lib/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParserPriority.Normal\n  },\n  name: "loadBitmapFont",\n  test(url) {\n    return validExtensions.includes(lib/* utils.path.extname */.P6.path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return TextFormat.test(data) || XMLStringFormat.test(data);\n  },\n  async parse(asset, data, loader) {\n    const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);\n    const { src } = data;\n    const { page: pages } = fontData;\n    const textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = lib/* utils.path.join */.P6.path.join(lib/* utils.path.dirname */.P6.path.dirname(src), pageFile);\n      imagePath = copySearchParams(imagePath, src);\n      textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url]);\n    return BitmapFont.install(fontData, textures, true);\n  },\n  async load(url, _options) {\n    const response = await lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(url);\n    return response.text();\n  },\n  unload(bitmapFont) {\n    bitmapFont.destroy();\n  }\n};\nlib/* extensions.add */.Rw.add(loadBitmapFont);\n\n\n//# sourceMappingURL=loadBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/index.mjs\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs\n\n\n\nconst _HTMLTextStyle = class extends TextStyle {\n  constructor() {\n    super(...arguments);\n    this._fonts = [];\n    this._overrides = [];\n    this._stylesheet = "";\n    this.fontsDirty = false;\n  }\n  static from(originalStyle) {\n    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));\n  }\n  cleanFonts() {\n    if (this._fonts.length > 0) {\n      this._fonts.forEach((font) => {\n        URL.revokeObjectURL(font.src);\n        font.refs--;\n        if (font.refs === 0) {\n          if (font.fontFace) {\n            document.fonts.delete(font.fontFace);\n          }\n          delete _HTMLTextStyle.availableFonts[font.originalUrl];\n        }\n      });\n      this.fontFamily = "Arial";\n      this._fonts.length = 0;\n      this.styleID++;\n      this.fontsDirty = true;\n    }\n  }\n  loadFont(url, options = {}) {\n    const { availableFonts } = _HTMLTextStyle;\n    if (availableFonts[url]) {\n      const font = availableFonts[url];\n      this._fonts.push(font);\n      font.refs++;\n      this.styleID++;\n      this.fontsDirty = true;\n      return Promise.resolve();\n    }\n    return lib/* settings.ADAPTER.fetch */.Xd.ADAPTER.fetch(url).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {\n      const src = URL.createObjectURL(blob);\n      const reader = new FileReader();\n      reader.onload = () => resolve([src, reader.result]);\n      reader.onerror = reject;\n      reader.readAsDataURL(blob);\n    })).then(async ([src, dataSrc]) => {\n      const font = Object.assign({\n        family: lib/* utils.path.basename */.P6.path.basename(url, lib/* utils.path.extname */.P6.path.extname(url)),\n        weight: "normal",\n        style: "normal",\n        src,\n        dataSrc,\n        refs: 1,\n        originalUrl: url,\n        fontFace: null\n      }, options);\n      availableFonts[url] = font;\n      this._fonts.push(font);\n      this.styleID++;\n      const fontFace = new FontFace(font.family, `url(${font.src})`, {\n        weight: font.weight,\n        style: font.style\n      });\n      font.fontFace = fontFace;\n      await fontFace.load();\n      document.fonts.add(fontFace);\n      await document.fonts.ready;\n      this.styleID++;\n      this.fontsDirty = true;\n    });\n  }\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this._overrides.includes(v));\n    if (toAdd.length > 0) {\n      this._overrides.push(...toAdd);\n      this.styleID++;\n    }\n  }\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this._overrides.includes(v));\n    if (toRemove.length > 0) {\n      this._overrides = this._overrides.filter((v) => !toRemove.includes(v));\n      this.styleID++;\n    }\n  }\n  toCSS(scale) {\n    return [\n      `transform: scale(${scale})`,\n      `transform-origin: top left`,\n      "display: inline-block",\n      `color: ${this.normalizeColor(this.fill)}`,\n      `font-size: ${this.fontSize}px`,\n      `font-family: ${this.fontFamily}`,\n      `font-weight: ${this.fontWeight}`,\n      `font-style: ${this.fontStyle}`,\n      `font-variant: ${this.fontVariant}`,\n      `letter-spacing: ${this.letterSpacing}px`,\n      `text-align: ${this.align}`,\n      `padding: ${this.padding}px`,\n      `white-space: ${this.whiteSpace}`,\n      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],\n      ...this.wordWrap ? [\n        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,\n        `max-width: ${this.wordWrapWidth}px`\n      ] : [],\n      ...this.strokeThickness ? [\n        `-webkit-text-stroke-width: ${this.strokeThickness}px`,\n        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,\n        `text-stroke-width: ${this.strokeThickness}px`,\n        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,\n        "paint-order: stroke"\n      ] : [],\n      ...this.dropShadow ? [this.dropShadowToCSS()] : [],\n      ...this._overrides\n    ].join(";");\n  }\n  toGlobalCSS() {\n    return this._fonts.reduce((result, font) => `${result}\n            @font-face {\n                font-family: "${font.family}";\n                src: url(\'${font.dataSrc}\');\n                font-weight: ${font.weight};\n                font-style: ${font.style}; \n            }`, this._stylesheet);\n  }\n  get stylesheet() {\n    return this._stylesheet;\n  }\n  set stylesheet(value) {\n    if (this._stylesheet !== value) {\n      this._stylesheet = value;\n      this.styleID++;\n    }\n  }\n  normalizeColor(color) {\n    if (Array.isArray(color)) {\n      color = lib/* utils.rgb2hex */.P6.rgb2hex(color);\n    }\n    if (typeof color === "number") {\n      return lib/* utils.hex2string */.P6.hex2string(color);\n    }\n    return color;\n  }\n  dropShadowToCSS() {\n    let color = this.normalizeColor(this.dropShadowColor);\n    const alpha = this.dropShadowAlpha;\n    const x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);\n    const y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);\n    if (color.startsWith("#") && alpha < 1) {\n      color += (alpha * 255 | 0).toString(16).padStart(2, "0");\n    }\n    const position = `${x}px ${y}px`;\n    if (this.dropShadowBlur > 0) {\n      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color}`;\n    }\n    return `text-shadow: ${position} ${color}`;\n  }\n  reset() {\n    Object.assign(this, _HTMLTextStyle.defaultOptions);\n  }\n  onBeforeDraw() {\n    const { fontsDirty: prevFontsDirty } = this;\n    this.fontsDirty = false;\n    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {\n      return new Promise((resolve) => setTimeout(resolve, 100));\n    }\n    return Promise.resolve();\n  }\n  get isSafari() {\n    const { userAgent } = lib/* settings.ADAPTER.getNavigator */.Xd.ADAPTER.getNavigator();\n    return /^((?!chrome|android).)*safari/i.test(userAgent);\n  }\n  set fillGradientStops(_value) {\n    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");\n  }\n  get fillGradientStops() {\n    return super.fillGradientStops;\n  }\n  set fillGradientType(_value) {\n    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");\n  }\n  get fillGradientType() {\n    return super.fillGradientType;\n  }\n  set miterLimit(_value) {\n    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");\n  }\n  get miterLimit() {\n    return super.miterLimit;\n  }\n  set trim(_value) {\n    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");\n  }\n  get trim() {\n    return super.trim;\n  }\n  set textBaseline(_value) {\n    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");\n  }\n  get textBaseline() {\n    return super.textBaseline;\n  }\n  set leading(_value) {\n    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");\n  }\n  get leading() {\n    return super.leading;\n  }\n  set lineJoin(_value) {\n    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");\n  }\n  get lineJoin() {\n    return super.lineJoin;\n  }\n};\nlet HTMLTextStyle = _HTMLTextStyle;\nHTMLTextStyle.availableFonts = {};\nHTMLTextStyle.defaultOptions = {\n  align: "left",\n  breakWords: false,\n  dropShadow: false,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: "black",\n  dropShadowDistance: 5,\n  fill: "black",\n  fontFamily: "Arial",\n  fontSize: 26,\n  fontStyle: "normal",\n  fontVariant: "normal",\n  fontWeight: "normal",\n  letterSpacing: 0,\n  lineHeight: 0,\n  padding: 0,\n  stroke: "black",\n  strokeThickness: 0,\n  whiteSpace: "normal",\n  wordWrap: false,\n  wordWrapWidth: 100\n};\n\n\n//# sourceMappingURL=HTMLTextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/HTMLText.mjs\n\n\n\n\n\nconst _HTMLText = class extends Sprite_Sprite {\n  constructor(text = "", style = {}) {\n    super(lib/* Texture.EMPTY */.xE.EMPTY);\n    this._text = null;\n    this._style = null;\n    this._autoResolution = true;\n    this._loading = false;\n    this.localStyleID = -1;\n    this.dirty = false;\n    this.ownsStyle = false;\n    const image = new Image();\n    const texture = lib/* Texture.from */.xE.from(image, {\n      scaleMode: lib/* settings.SCALE_MODE */.Xd.SCALE_MODE,\n      resourceOptions: {\n        autoLoad: false\n      }\n    });\n    texture.orig = new lib/* Rectangle */.Ae();\n    texture.trim = new lib/* Rectangle */.Ae();\n    this.texture = texture;\n    const nssvg = "http://www.w3.org/2000/svg";\n    const nsxhtml = "http://www.w3.org/1999/xhtml";\n    const svgRoot = document.createElementNS(nssvg, "svg");\n    const foreignObject = document.createElementNS(nssvg, "foreignObject");\n    const domElement = document.createElementNS(nsxhtml, "div");\n    const styleElement = document.createElementNS(nsxhtml, "style");\n    foreignObject.setAttribute("width", "10000");\n    foreignObject.setAttribute("height", "10000");\n    foreignObject.style.overflow = "hidden";\n    svgRoot.appendChild(foreignObject);\n    this.maxWidth = _HTMLText.defaultMaxWidth;\n    this.maxHeight = _HTMLText.defaultMaxHeight;\n    this._domElement = domElement;\n    this._styleElement = styleElement;\n    this._svgRoot = svgRoot;\n    this._foreignObject = foreignObject;\n    this._foreignObject.appendChild(styleElement);\n    this._foreignObject.appendChild(domElement);\n    this._image = image;\n    this._loadImage = new Image();\n    this._autoResolution = _HTMLText.defaultAutoResolution;\n    this._resolution = _HTMLText.defaultResolution ?? lib/* settings.RESOLUTION */.Xd.RESOLUTION;\n    this.text = text;\n    this.style = style;\n  }\n  measureText(overrides) {\n    const { text, style, resolution } = Object.assign({\n      text: this._text,\n      style: this._style,\n      resolution: this._resolution\n    }, overrides);\n    Object.assign(this._domElement, {\n      innerHTML: text,\n      style: style.toCSS(resolution)\n    });\n    this._styleElement.textContent = style.toGlobalCSS();\n    document.body.appendChild(this._svgRoot);\n    const contentBounds = this._domElement.getBoundingClientRect();\n    this._svgRoot.remove();\n    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));\n    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));\n    this._svgRoot.setAttribute("width", contentWidth.toString());\n    this._svgRoot.setAttribute("height", contentHeight.toString());\n    if (text !== this._text) {\n      this._domElement.innerHTML = this._text;\n    }\n    if (style !== this._style) {\n      Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });\n      this._styleElement.textContent = this._style?.toGlobalCSS();\n    }\n    return {\n      width: contentWidth + style.padding * 2,\n      height: contentHeight + style.padding * 2\n    };\n  }\n  async updateText(respectDirty = true) {\n    const { style, _image: image, _loadImage: loadImage } = this;\n    if (this.localStyleID !== style.styleID) {\n      this.dirty = true;\n      this.localStyleID = style.styleID;\n    }\n    if (!this.dirty && respectDirty) {\n      return;\n    }\n    const { width, height } = this.measureText();\n    image.width = loadImage.width = Math.ceil(Math.max(1, width));\n    image.height = loadImage.height = Math.ceil(Math.max(1, height));\n    if (!this._loading) {\n      this._loading = true;\n      await new Promise((resolve) => {\n        loadImage.onload = async () => {\n          await style.onBeforeDraw();\n          this._loading = false;\n          image.src = loadImage.src;\n          loadImage.onload = null;\n          loadImage.src = "";\n          this.updateTexture();\n          resolve();\n        };\n        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);\n        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;\n      });\n    }\n  }\n  get source() {\n    return this._image;\n  }\n  updateTexture() {\n    const { style, texture, _image: image, resolution } = this;\n    const { padding } = style;\n    const { baseTexture } = texture;\n    texture.trim.width = texture._frame.width = image.width / resolution;\n    texture.trim.height = texture._frame.height = image.height / resolution;\n    texture.trim.x = -padding;\n    texture.trim.y = -padding;\n    texture.orig.width = texture._frame.width - padding * 2;\n    texture.orig.height = texture._frame.height - padding * 2;\n    this._onTextureUpdate();\n    baseTexture.setRealSize(image.width, image.height, resolution);\n    this.dirty = false;\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    super._render(renderer);\n  }\n  _renderCanvas(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    super._renderCanvas(renderer);\n  }\n  getLocalBounds(rect) {\n    this.updateText(true);\n    return super.getLocalBounds(rect);\n  }\n  _calculateBounds() {\n    this.updateText(true);\n    this.calculateVertices();\n    this._bounds.addQuad(this.vertexData);\n  }\n  _onStyleChange() {\n    this.dirty = true;\n  }\n  destroy(options) {\n    if (typeof options === "boolean") {\n      options = { children: options };\n    }\n    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);\n    super.destroy(options);\n    const forceClear = null;\n    if (this.ownsStyle) {\n      this._style?.cleanFonts();\n    }\n    this._style = forceClear;\n    this._svgRoot?.remove();\n    this._svgRoot = forceClear;\n    this._domElement?.remove();\n    this._domElement = forceClear;\n    this._foreignObject?.remove();\n    this._foreignObject = forceClear;\n    this._styleElement?.remove();\n    this._styleElement = forceClear;\n    this._loadImage.src = "";\n    this._loadImage.onload = null;\n    this._loadImage = forceClear;\n    this._image.src = "";\n    this._image = forceClear;\n  }\n  get width() {\n    this.updateText(true);\n    return Math.abs(this.scale.x) * this._image.width / this.resolution;\n  }\n  set width(value) {\n    this.updateText(true);\n    const s = lib/* utils.sign */.P6.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._image.width / this.resolution;\n    this._width = value;\n  }\n  get height() {\n    this.updateText(true);\n    return Math.abs(this.scale.y) * this._image.height / this.resolution;\n  }\n  set height(value) {\n    this.updateText(true);\n    const s = lib/* utils.sign */.P6.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._image.height / this.resolution;\n    this._height = value;\n  }\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    if (this._style === style) {\n      return;\n    }\n    style = style || {};\n    if (style instanceof HTMLTextStyle) {\n      this.ownsStyle = false;\n      this._style = style;\n    } else if (style instanceof TextStyle) {\n      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");\n      this.ownsStyle = true;\n      this._style = HTMLTextStyle.from(style);\n    } else {\n      this.ownsStyle = true;\n      this._style = new HTMLTextStyle(style);\n    }\n    this.localStyleID = -1;\n    this.dirty = true;\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === "" || text === null || text === void 0 ? " " : text);\n    text = this.sanitiseText(text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n  sanitiseText(text) {\n    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");\n  }\n};\nlet HTMLText = _HTMLText;\nHTMLText.defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\nHTMLText.defaultMaxWidth = 2024;\nHTMLText.defaultMaxHeight = 2024;\nHTMLText.defaultAutoResolution = true;\n\n\n//# sourceMappingURL=HTMLText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUE0QjtBQUNo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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0NBQWtDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNyQzs7O0FDMUVrRDtBQUMwQjtBQUM1RTs7O0FDRm9GO0FBQ3BEO0FBQ3VEOztBQUV2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQTZCO0FBQzlDLFFBQVE7QUFDUixpQkFBaUIsOERBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkI7OztBQ2xZNEM7QUFDVDs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLGNBQWMsMkJBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNLDBCQUEwQixTQUFTO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLE1BQU07QUFDTjtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFlBQVk7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEI7OztBQ25RMEM7QUFDVTtBQUNwRDs7O0FDRnFDO0FBQ0U7QUFDRTtBQUNEO0FBQ0o7QUFDVjtBQUNHO0FBQ2E7QUFDZjtBQUNHO0FBQ0Q7QUFDQztBQUNLO0FBQ0Q7QUFDUTtBQUNBO0FBQ1I7QUFDQztBQUNKO0FBQ0o7QUFDTztBQUNPO0FBQ1g7QUFDRDtBQUNTO0FBQ0Y7QUFDRjtBQUNQO0FBQ087QUFDRjtBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUvbGliL1Nwcml0ZS5tanM/NTc5OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlL2xpYi9pbmRleC5tanM/OTc4NSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWl4aW4tY2FjaGUtYXMtYml0bWFwL2xpYi9pbmRleC5tanM/ODYxZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWl4aW4tZ2V0LWNoaWxkLWJ5LW5hbWUvbGliL2luZGV4Lm1qcz84Nzc4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9taXhpbi1nZXQtZ2xvYmFsLXBvc2l0aW9uL2xpYi9pbmRleC5tanM/ZGUxMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9hbHBoYS5tanM/NmNlMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9BbHBoYUZpbHRlci5tanM/YTExMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9pbmRleC5tanM/OTIzMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWJsdXIvbGliL2dlbmVyYXRlQmx1ckZyYWdTb3VyY2UubWpzPzI2MzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlLm1qcz8zZDFmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvQmx1ckZpbHRlclBhc3MubWpzPzQwNzMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9CbHVyRmlsdGVyLm1qcz81MTdiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvaW5kZXgubWpzPzc0MGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXgvbGliL2NvbG9yTWF0cml4Lm1qcz8yNDIzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItY29sb3ItbWF0cml4L2xpYi9Db2xvck1hdHJpeEZpbHRlci5tanM/YmFkNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeC9saWIvaW5kZXgubWpzPzY2MjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnQvbGliL2Rpc3BsYWNlbWVudC5tanM/OWU1ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudC9saWIvZGlzcGxhY2VtZW50Mi5tanM/N2IyOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudC9saWIvRGlzcGxhY2VtZW50RmlsdGVyLm1qcz85OGY4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50L2xpYi9pbmRleC5tanM/YTQ0ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWZ4YWEvbGliL2Z4YWEubWpzP2VlMDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9meGFhMi5tanM/NDNhZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWZ4YWEvbGliL0ZYQUFGaWx0ZXIubWpzPzg0ZGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9pbmRleC5tanM/YTYwZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9ub2lzZS5tanM/Y2M1MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9Ob2lzZUZpbHRlci5tanM/NzU5YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9pbmRleC5tanM/MTgzNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy5tanM/YjBlOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9FdmVudFRpY2tlci5tanM/MDhhYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRFdmVudC5tanM/Y2YxOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcz80NDc3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanM/N2U1ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRXaGVlbEV2ZW50Lm1qcz81ZWQ3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0V2ZW50Qm91bmRhcnkubWpzP2M1ODIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRXZlbnRTeXN0ZW0ubWpzP2Y0ZjIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRmVkZXJhdGVkRXZlbnRUYXJnZXQubWpzPzJiZTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvaW5kZXgubWpzPzFlOTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FjY2Vzc2liaWxpdHkvbGliL2FjY2Vzc2libGVUYXJnZXQubWpzPzg0YzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FjY2Vzc2liaWxpdHkvbGliL0FjY2Vzc2liaWxpdHlNYW5hZ2VyLm1qcz8wZmM4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hY2Nlc3NpYmlsaXR5L2xpYi9pbmRleC5tanM/NGNkOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXBwL2xpYi9BcHBsaWNhdGlvbi5tanM/ZWRiMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXBwL2xpYi9SZXNpemVQbHVnaW4ubWpzP2I4NWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FwcC9saWIvaW5kZXgubWpzPzliNDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvQXNzZXRFeHRlbnNpb24ubWpzPzk3YTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvQmFja2dyb3VuZExvYWRlci5tanM/NTYwNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9jaGVja0V4dGVuc2lvbi5tanM/MjY2ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9pbmRleC5tanM/MTc4NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9jb252ZXJ0VG9MaXN0Lm1qcz85OWQ3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL0NhY2hlLm1qcz8zMGZmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2lzU2luZ2xlSXRlbS5tanM/YWI4OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvTG9hZGVyLm1qcz84NDljIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL0xvYWRlclBhcnNlci5tanM/YzMwNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9jaGVja0RhdGFVcmwubWpzPzA0NjAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvbG9hZEpzb24ubWpzP2U4NzQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvbG9hZFR4dC5tanM/ZDA3MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9sb2FkV2ViRm9udC5tanM/MTE2MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9Xb3JrZXJNYW5hZ2VyLm1qcz85YWMwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzP2M1YjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qcz9iYmZjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRTVkcubWpzPzRhMWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvdXRpbHMvaW5kZXgubWpzP2M5NTkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvaW5kZXgubWpzPzhiMjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvaW5kZXgubWpzPzEzODMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvdXRpbHMvY3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5tanM/MzQzOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9SZXNvbHZlci5tanM/ZjIyZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9Bc3NldHMubWpzPzk5Y2MiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvY2FjaGUvcGFyc2Vycy9jYWNoZVRleHR1cmVBcnJheS5tanM/NTZiNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9jYWNoZS9wYXJzZXJzL2luZGV4Lm1qcz9lNjQ5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL2luZGV4Lm1qcz8yZGEzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLm1qcz82OWEzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qcz9kZTBjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3REZWZhdWx0cy5tanM/ZDFjOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3BhcnNlcnMvaW5kZXgubWpzPzg4ZWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy9pbmRleC5tanM/YTk4MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvaW5kZXgubWpzPzdjZjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlVGV4dHVyZVVybC5tanM/MTBhMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9wYXJzZXJzL2luZGV4Lm1qcz84MDFlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3Jlc29sdmVyL2luZGV4Lm1qcz9hZjUxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMubWpzPzM2ZTAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvaW5kZXgubWpzPzg1MWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2NvbnN0Lm1qcz8yYTRkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2NvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5tanM/MDUyNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMubWpzPzQwOWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3Jlc291cmNlcy9CbG9iUmVzb3VyY2UubWpzP2JhMzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcz80NGRlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9yZXNvdXJjZXMvaW5kZXgubWpzPzk5OTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvcGFyc2VERFMubWpzP2ZmNDAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvcGFyc2VLVFgubWpzP2Q5YzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvaW5kZXgubWpzP2FhM2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvbG9hZEREUy5tanM/NWY5YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9sb2FkS1RYLm1qcz83ODFhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL3Jlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybC5tanM/ZDk1NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9pbmRleC5tanM/ODRkZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvaW5kZXgubWpzPzFiOTAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V4dHJhY3QvbGliL0V4dHJhY3QubWpzPzExZDkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V4dHJhY3QvbGliL2luZGV4Lm1qcz9lNTU5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvYnVpbGRDaXJjbGUubWpzP2UyMjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZFBvbHkubWpzPzkwNWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZFJlY3RhbmdsZS5tanM/OTcyOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2J1aWxkUm91bmRlZFJlY3RhbmdsZS5tanM/NmI2MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL2NvbnN0Lm1qcz9kZDkzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvQXJjVXRpbHMubWpzP2ZjMmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9CZXppZXJVdGlscy5tanM/N2RjNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2J1aWxkTGluZS5tanM/YTA3NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL1F1YWRyYXRpY1V0aWxzLm1qcz9jMTEyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvaW5kZXgubWpzP2RlOWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljc0RhdGEubWpzPzYxYzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9CYXRjaFBhcnQubWpzP2VlMTAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljc0dlb21ldHJ5Lm1qcz8xNmIyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvc3R5bGVzL0ZpbGxTdHlsZS5tanM/ODM4OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3N0eWxlcy9MaW5lU3R5bGUubWpzPzE4ZGUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljcy5tanM/NTI3YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL2luZGV4Lm1qcz83NjViIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9NZXNoQmF0Y2hVdnMubWpzP2ZkM2MiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL01lc2gubWpzPzU0ZTUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL01lc2hHZW9tZXRyeS5tanM/YzNhZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvc2hhZGVyL21lc2gubWpzPzllMGQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL3NoYWRlci9tZXNoMi5tanM/MmEzOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvTWVzaE1hdGVyaWFsLm1qcz8xNjc1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9pbmRleC5tanM/YjljMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL2dlb21ldHJ5L1BsYW5lR2VvbWV0cnkubWpzP2E2MmQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9nZW9tZXRyeS9Sb3BlR2VvbWV0cnkubWpzPzU4MzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9TaW1wbGVQbGFuZS5tanM/YzU0MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL05pbmVTbGljZVBsYW5lLm1qcz84N2I4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvU2ltcGxlTWVzaC5tanM/NzJmNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL1NpbXBsZVJvcGUubWpzPzRkMjciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9pbmRleC5tanM/NWUyZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9QYXJ0aWNsZUNvbnRhaW5lci5tanM/ZWM1NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9QYXJ0aWNsZUJ1ZmZlci5tanM/MzQyNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9wYXJ0aWNsZXMubWpzPzFhNDUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvcGFydGljbGVzMi5tanM/OGJjMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9QYXJ0aWNsZVJlbmRlcmVyLm1qcz9hYTYwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL2luZGV4Lm1qcz9lZjFkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0L2xpYi9jb25zdC5tanM/OTBmOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvVGV4dE1ldHJpY3MubWpzPzAwZDkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL1RleHRTdHlsZS5tanM/MDg2MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvVGV4dC5tanM/MWYzOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvaW5kZXgubWpzPzc1MzciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL0NvdW50TGltaXRlci5tanM/NzU4YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvcHJlcGFyZS9saWIvQmFzZVByZXBhcmUubWpzPzQwNTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL3NldHRpbmdzLm1qcz82NTAyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9QcmVwYXJlLm1qcz8zZmJhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9pbmRleC5tanM/OTA1ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLWFuaW1hdGVkL2xpYi9BbmltYXRlZFNwcml0ZS5tanM/YmQ1MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLWFuaW1hdGVkL2xpYi9pbmRleC5tanM/MDc3YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvVGlsaW5nU3ByaXRlLm1qcz8zNjZlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLm1qcz8zNDE2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nMi5tanM/NjMzMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy1mYWxsYmFjay5tanM/OTJmZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy1mYWxsYmFjazIubWpzP2Q0MjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS10aWxpbmcvbGliL3Nwcml0ZS10aWxpbmctc2ltcGxlLm1qcz84M2QzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9UaWxpbmdTcHJpdGVSZW5kZXJlci5tanM/MTA4MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvaW5kZXgubWpzP2I3MWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZXNoZWV0L2xpYi9TcHJpdGVzaGVldC5tanM/NDRjYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlc2hlZXQvbGliL3Nwcml0ZXNoZWV0QXNzZXQubWpzPzBlMjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZXNoZWV0L2xpYi9pbmRleC5tanM/YjEzNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL0JpdG1hcEZvbnREYXRhLm1qcz9hYmI4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9UZXh0Rm9ybWF0Lm1qcz81NGI4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9YTUxGb3JtYXQubWpzPzZjMjciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9mb3JtYXRzL1hNTFN0cmluZ0Zvcm1hdC5tanM/OGNlYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL2Zvcm1hdHMvaW5kZXgubWpzP2Q3N2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9nZW5lcmF0ZUZpbGxTdHlsZS5tanM/N2E5MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3V0aWxzL2RyYXdHbHlwaC5tanM/ODdiNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3V0aWxzL2luZGV4Lm1qcz84Yzk3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qcz9kOWMyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvcmVzb2x2ZUNoYXJhY3RlcnMubWpzPzdmYzAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9leHRyYWN0Q2hhckNvZGUubWpzP2Q2M2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9CaXRtYXBGb250Lm1qcz8zYTlkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvc2hhZGVyL21zZGYubWpzPzhiODIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9zaGFkZXIvbXNkZjIubWpzP2E1NDQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9CaXRtYXBUZXh0Lm1qcz9iMzRiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvbG9hZEJpdG1hcEZvbnQubWpzP2JiYjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9pbmRleC5tanM/MzEyMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1odG1sL2xpYi9IVE1MVGV4dFN0eWxlLm1qcz82ODY1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWh0bWwvbGliL0hUTUxUZXh0Lm1qcz8wMGQ3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWh0bWwvbGliL2luZGV4Lm1qcz9kMTljIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9pbmRleC5tanM/MzY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCwgT2JzZXJ2YWJsZVBvaW50LCBDb2xvciwgQkxFTkRfTU9ERVMsIFRleHR1cmUsIHNldHRpbmdzLCB1dGlscywgUmVjdGFuZ2xlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBDb250YWluZXIsIEJvdW5kcyB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuXG5jb25zdCB0ZW1wUG9pbnQgPSBuZXcgUG9pbnQoKTtcbmNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbmNsYXNzIFNwcml0ZSBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2FuY2hvciA9IG5ldyBPYnNlcnZhYmxlUG9pbnQodGhpcy5fb25BbmNob3JVcGRhdGUsIHRoaXMsIHRleHR1cmUgPyB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueCA6IDAsIHRleHR1cmUgPyB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueSA6IDApO1xuICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBDb2xvcigxNjc3NzIxNSk7XG4gICAgdGhpcy5fdGludFJHQiA9IG51bGw7XG4gICAgdGhpcy50aW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgdGhpcy5fY2FjaGVkVGludCA9IDE2Nzc3MjE1O1xuICAgIHRoaXMudXZzID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlIHx8IFRleHR1cmUuRU1QVFk7XG4gICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgICB0aGlzLnZlcnRleFRyaW1tZWREYXRhID0gbnVsbDtcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuICAgIHRoaXMucGx1Z2luTmFtZSA9IFwiYmF0Y2hcIjtcbiAgICB0aGlzLmlzU3ByaXRlID0gdHJ1ZTtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHNldHRpbmdzLlJPVU5EX1BJWEVMUztcbiAgfVxuICBfb25UZXh0dXJlVXBkYXRlKCkge1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gICAgaWYgKHRoaXMuX3dpZHRoKSB7XG4gICAgICB0aGlzLnNjYWxlLnggPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgKiB0aGlzLl93aWR0aCAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2hlaWdodCkge1xuICAgICAgdGhpcy5zY2FsZS55ID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpICogdGhpcy5faGVpZ2h0IC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB9XG4gIH1cbiAgX29uQW5jaG9yVXBkYXRlKCkge1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTE7XG4gIH1cbiAgY2FsY3VsYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCAmJiB0aGlzLl90ZXh0dXJlSUQgPT09IHRleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl90ZXh0dXJlSUQgIT09IHRleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICB0aGlzLnV2cyA9IHRoaXMuX3RleHR1cmUuX3V2cy51dnNGbG9hdDMyO1xuICAgIH1cbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IHRleHR1cmUuX3VwZGF0ZUlEO1xuICAgIGNvbnN0IHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgY29uc3QgYSA9IHd0LmE7XG4gICAgY29uc3QgYiA9IHd0LmI7XG4gICAgY29uc3QgYyA9IHd0LmM7XG4gICAgY29uc3QgZCA9IHd0LmQ7XG4gICAgY29uc3QgdHggPSB3dC50eDtcbiAgICBjb25zdCB0eSA9IHd0LnR5O1xuICAgIGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgY29uc3QgdHJpbSA9IHRleHR1cmUudHJpbTtcbiAgICBjb25zdCBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcbiAgICBsZXQgdzAgPSAwO1xuICAgIGxldCB3MSA9IDA7XG4gICAgbGV0IGgwID0gMDtcbiAgICBsZXQgaDEgPSAwO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB3MSA9IHRyaW0ueCAtIGFuY2hvci5feCAqIG9yaWcud2lkdGg7XG4gICAgICB3MCA9IHcxICsgdHJpbS53aWR0aDtcbiAgICAgIGgxID0gdHJpbS55IC0gYW5jaG9yLl95ICogb3JpZy5oZWlnaHQ7XG4gICAgICBoMCA9IGgxICsgdHJpbS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcxID0gLWFuY2hvci5feCAqIG9yaWcud2lkdGg7XG4gICAgICB3MCA9IHcxICsgb3JpZy53aWR0aDtcbiAgICAgIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xuICAgICAgaDAgPSBoMSArIG9yaWcuaGVpZ2h0O1xuICAgIH1cbiAgICB2ZXJ0ZXhEYXRhWzBdID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgdmVydGV4RGF0YVsxXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuICAgIHZlcnRleERhdGFbMl0gPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0ZXhEYXRhWzNdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG4gICAgdmVydGV4RGF0YVs0XSA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgIHZlcnRleERhdGFbNV0gPSBkICogaDAgKyBiICogdzAgKyB0eTtcbiAgICB2ZXJ0ZXhEYXRhWzZdID0gYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGV4RGF0YVs3XSA9IGQgKiBoMCArIGIgKiB3MSArIHR5O1xuICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmVydGV4RGF0YVtpXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpXSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlVHJpbW1lZFZlcnRpY2VzKCkge1xuICAgIGlmICghdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSkge1xuICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEICYmIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPT09IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xuICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRDtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YTtcbiAgICBjb25zdCBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCB3MSA9IC1hbmNob3IuX3ggKiBvcmlnLndpZHRoO1xuICAgIGNvbnN0IHcwID0gdzEgKyBvcmlnLndpZHRoO1xuICAgIGNvbnN0IGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xuICAgIGNvbnN0IGgwID0gaDEgKyBvcmlnLmhlaWdodDtcbiAgICB2ZXJ0ZXhEYXRhWzBdID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgdmVydGV4RGF0YVsxXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuICAgIHZlcnRleERhdGFbMl0gPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0ZXhEYXRhWzNdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG4gICAgdmVydGV4RGF0YVs0XSA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgIHZlcnRleERhdGFbNV0gPSBkICogaDAgKyBiICogdzAgKyB0eTtcbiAgICB2ZXJ0ZXhEYXRhWzZdID0gYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGV4RGF0YVs3XSA9IGQgKiBoMCArIGIgKiB3MSArIHR5O1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdKTtcbiAgICByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICB9XG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgY29uc3QgdHJpbSA9IHRoaXMuX3RleHR1cmUudHJpbTtcbiAgICBjb25zdCBvcmlnID0gdGhpcy5fdGV4dHVyZS5vcmlnO1xuICAgIGlmICghdHJpbSB8fCB0cmltLndpZHRoID09PSBvcmlnLndpZHRoICYmIHRyaW0uaGVpZ2h0ID09PSBvcmlnLmhlaWdodCkge1xuICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKTtcbiAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4VHJpbW1lZERhdGEpO1xuICAgIH1cbiAgfVxuICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsQm91bmRzID0gbmV3IEJvdW5kcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9jYWxCb3VuZHMubWluWCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aCAqIC10aGlzLl9hbmNob3IuX3g7XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kcy5taW5ZID0gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCAqIC10aGlzLl9hbmNob3IuX3k7XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kcy5tYXhYID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuICAgICAgdGhpcy5fbG9jYWxCb3VuZHMubWF4WSA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSk7XG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9sb2NhbEJvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIGNvbnN0IHgxID0gLXdpZHRoICogdGhpcy5hbmNob3IueDtcbiAgICBsZXQgeTEgPSAwO1xuICAgIGlmICh0ZW1wUG9pbnQueCA+PSB4MSAmJiB0ZW1wUG9pbnQueCA8IHgxICsgd2lkdGgpIHtcbiAgICAgIHkxID0gLWhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XG4gICAgICBpZiAodGVtcFBvaW50LnkgPj0geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgdGhpcy5fdGV4dHVyZS5vZmYoXCJ1cGRhdGVcIiwgdGhpcy5fb25UZXh0dXJlVXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLl9hbmNob3IgPSBudWxsO1xuICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmU7XG4gICAgaWYgKGRlc3Ryb3lUZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXN0cm95QmFzZVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8uYmFzZVRleHR1cmU7XG4gICAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koISFkZXN0cm95QmFzZVRleHR1cmUpO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgZnJvbShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gc291cmNlIGluc3RhbmNlb2YgVGV4dHVyZSA/IHNvdXJjZSA6IFRleHR1cmUuZnJvbShzb3VyY2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgU3ByaXRlKHRleHR1cmUpO1xuICB9XG4gIHNldCByb3VuZFBpeGVscyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgfVxuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueCkgKiB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IHV0aWxzLnNpZ24odGhpcy5zY2FsZS54KSB8fCAxO1xuICAgIHRoaXMuc2NhbGUueCA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBzID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3I7XG4gIH1cbiAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIHRoaXMuX3RpbnRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5fdGludFJHQiA9IHRoaXMuX3RpbnRDb2xvci50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICB9XG4gIGdldCB0aW50VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci50b051bWJlcigpO1xuICB9XG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3RleHR1cmUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWUgfHwgVGV4dHVyZS5FTVBUWTtcbiAgICB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUub25jZShcInVwZGF0ZVwiLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBTcHJpdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZS5tanMubWFwXG4iLCJleHBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL1Nwcml0ZS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4LCBzZXR0aW5ncywgUmVuZGVyVGV4dHVyZSwgdXRpbHMsIEJhc2VUZXh0dXJlLCBUZXh0dXJlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBEaXNwbGF5T2JqZWN0IH0gZnJvbSAnQHBpeGkvZGlzcGxheSc7XG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tICdAcGl4aS9zcHJpdGUnO1xuXG5jb25zdCBfdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVEYXRhID0gbnVsbDtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwUmVzb2x1dGlvbiA9IG51bGw7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlID0gbnVsbDtcbmNsYXNzIENhY2hlRGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGV4dHVyZUNhY2hlSWQgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxSZW5kZXIgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxSZW5kZXJDYW52YXMgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxDYWxjdWxhdGVCb3VuZHMgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbERlc3Ryb3kgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxNYXNrID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsRmlsdGVyQXJlYSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbENvbnRhaW5zUG9pbnQgPSBudWxsO1xuICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHtcbiAgY2FjaGVBc0JpdG1hcFJlc29sdXRpb246IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVBc0JpdG1hcFJlc29sdXRpb247XG4gICAgfSxcbiAgICBzZXQocmVzb2x1dGlvbikge1xuICAgICAgaWYgKHJlc29sdXRpb24gPT09IHRoaXMuX2NhY2hlQXNCaXRtYXBSZXNvbHV0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXBSZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgIGlmICh0aGlzLmNhY2hlQXNCaXRtYXApIHtcbiAgICAgICAgdGhpcy5jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGVBc0JpdG1hcCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjYWNoZUFzQml0bWFwTXVsdGlzYW1wbGU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlO1xuICAgIH0sXG4gICAgc2V0KG11bHRpc2FtcGxlKSB7XG4gICAgICBpZiAobXVsdGlzYW1wbGUgPT09IHRoaXMuX2NhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZUFzQml0bWFwTXVsdGlzYW1wbGUgPSBtdWx0aXNhbXBsZTtcbiAgICAgIGlmICh0aGlzLmNhY2hlQXNCaXRtYXApIHtcbiAgICAgICAgdGhpcy5jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGVBc0JpdG1hcCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjYWNoZUFzQml0bWFwOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlQXNCaXRtYXA7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoZUFzQml0bWFwID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gdmFsdWU7XG4gICAgICBsZXQgZGF0YTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlRGF0YSkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlRGF0YSA9IG5ldyBDYWNoZURhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fY2FjaGVEYXRhO1xuICAgICAgICBkYXRhLm9yaWdpbmFsUmVuZGVyID0gdGhpcy5yZW5kZXI7XG4gICAgICAgIGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXMgPSB0aGlzLnJlbmRlckNhbnZhcztcbiAgICAgICAgZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzID0gdGhpcy5jYWxjdWxhdGVCb3VuZHM7XG4gICAgICAgIGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHM7XG4gICAgICAgIGRhdGEub3JpZ2luYWxEZXN0cm95ID0gdGhpcy5kZXN0cm95O1xuICAgICAgICBkYXRhLm9yaWdpbmFsQ29udGFpbnNQb2ludCA9IHRoaXMuY29udGFpbnNQb2ludDtcbiAgICAgICAgZGF0YS5vcmlnaW5hbE1hc2sgPSB0aGlzLl9tYXNrO1xuICAgICAgICBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYSA9IHRoaXMuZmlsdGVyQXJlYTtcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJDYWNoZWQ7XG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzO1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9jYWNoZUFzQml0bWFwRGVzdHJveTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLl9jYWNoZURhdGE7XG4gICAgICAgIGlmIChkYXRhLnNwcml0ZSkge1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXIgPSBkYXRhLm9yaWdpbmFsUmVuZGVyO1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyA9IGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXM7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gZGF0YS5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcztcbiAgICAgICAgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcztcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZGF0YS5vcmlnaW5hbERlc3Ryb3k7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5jb250YWluc1BvaW50ID0gZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQ7XG4gICAgICAgIHRoaXMuX21hc2sgPSBkYXRhLm9yaWdpbmFsTWFzaztcbiAgICAgICAgdGhpcy5maWx0ZXJBcmVhID0gZGF0YS5vcmlnaW5hbEZpbHRlckFyZWE7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZW5kZXJDYWNoZWQgPSBmdW5jdGlvbiBfcmVuZGVyQ2FjaGVkKHJlbmRlcmVyKSB7XG4gIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5faW5pdENhY2hlZERpc3BsYXlPYmplY3QocmVuZGVyZXIpO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLnRyYW5zZm9ybS5fd29ybGRJRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3JlbmRlcihyZW5kZXJlcik7XG59O1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKSB7XG4gIGlmICh0aGlzLl9jYWNoZURhdGE/LnNwcml0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjYWNoZUFscGhhID0gdGhpcy5hbHBoYTtcbiAgdGhpcy5hbHBoYSA9IDE7XG4gIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMobnVsbCwgdHJ1ZSkuY2xvbmUoKTtcbiAgaWYgKHRoaXMuZmlsdGVycz8ubGVuZ3RoKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuZmlsdGVyc1swXS5wYWRkaW5nO1xuICAgIGJvdW5kcy5wYWQocGFkZGluZyk7XG4gIH1cbiAgYm91bmRzLmNlaWwoc2V0dGluZ3MuUkVTT0xVVElPTik7XG4gIGNvbnN0IGNhY2hlZFJlbmRlclRleHR1cmUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnQ7XG4gIGNvbnN0IGNhY2hlZFNvdXJjZUZyYW1lID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5zb3VyY2VGcmFtZS5jbG9uZSgpO1xuICBjb25zdCBjYWNoZWREZXN0aW5hdGlvbkZyYW1lID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5kZXN0aW5hdGlvbkZyYW1lLmNsb25lKCk7XG4gIGNvbnN0IGNhY2hlZFByb2plY3Rpb25UcmFuc2Zvcm0gPSByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybTtcbiAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmUuY3JlYXRlKHtcbiAgICB3aWR0aDogYm91bmRzLndpZHRoLFxuICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICByZXNvbHV0aW9uOiB0aGlzLmNhY2hlQXNCaXRtYXBSZXNvbHV0aW9uIHx8IHJlbmRlcmVyLnJlc29sdXRpb24sXG4gICAgbXVsdGlzYW1wbGU6IHRoaXMuY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlID8/IHJlbmRlcmVyLm11bHRpc2FtcGxlXG4gIH0pO1xuICBjb25zdCB0ZXh0dXJlQ2FjaGVJZCA9IGBjYWNoZUFzQml0bWFwXyR7dXRpbHMudWlkKCl9YDtcbiAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gdGV4dHVyZUNhY2hlSWQ7XG4gIEJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xuICBUZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xuICBjb25zdCBtID0gdGhpcy50cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm0uY29weVRvKF90ZW1wTWF0cml4KS5pbnZlcnQoKS50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuICB0aGlzLnJlbmRlciA9IHRoaXMuX2NhY2hlRGF0YS5vcmlnaW5hbFJlbmRlcjtcbiAgcmVuZGVyZXIucmVuZGVyKHRoaXMsIHsgcmVuZGVyVGV4dHVyZSwgY2xlYXI6IHRydWUsIHRyYW5zZm9ybTogbSwgc2tpcFVwZGF0ZVRyYW5zZm9ybTogZmFsc2UgfSk7XG4gIHJlbmRlcmVyLmZyYW1lYnVmZmVyLmJsaXQoKTtcbiAgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBjYWNoZWRQcm9qZWN0aW9uVHJhbnNmb3JtO1xuICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoY2FjaGVkUmVuZGVyVGV4dHVyZSwgY2FjaGVkU291cmNlRnJhbWUsIGNhY2hlZERlc3RpbmF0aW9uRnJhbWUpO1xuICB0aGlzLnJlbmRlciA9IHRoaXMuX3JlbmRlckNhY2hlZDtcbiAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm07XG4gIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzO1xuICB0aGlzLmdldExvY2FsQm91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHM7XG4gIHRoaXMuX21hc2sgPSBudWxsO1xuICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICB0aGlzLmFscGhhID0gY2FjaGVBbHBoYTtcbiAgY29uc3QgY2FjaGVkU3ByaXRlID0gbmV3IFNwcml0ZShyZW5kZXJUZXh0dXJlKTtcbiAgY2FjaGVkU3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICBjYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKGJvdW5kcy54IC8gYm91bmRzLndpZHRoKTtcbiAgY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpO1xuICBjYWNoZWRTcHJpdGUuYWxwaGEgPSBjYWNoZUFscGhhO1xuICBjYWNoZWRTcHJpdGUuX2JvdW5kcyA9IHRoaXMuX2JvdW5kcztcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IGNhY2hlZFNwcml0ZTtcbiAgdGhpcy50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aGlzLmVuYWJsZVRlbXBQYXJlbnQoKTtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIHRoaXMuZGlzYWJsZVRlbXBQYXJlbnQobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuICB0aGlzLmNvbnRhaW5zUG9pbnQgPSBjYWNoZWRTcHJpdGUuY29udGFpbnNQb2ludC5iaW5kKGNhY2hlZFNwcml0ZSk7XG59O1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhY2hlZENhbnZhcyA9IGZ1bmN0aW9uIF9yZW5kZXJDYWNoZWRDYW52YXMocmVuZGVyZXIpIHtcbiAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyhyZW5kZXJlcik7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fcmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5faW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMgPSBmdW5jdGlvbiBfaW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMocmVuZGVyZXIpIHtcbiAgaWYgKHRoaXMuX2NhY2hlRGF0YT8uc3ByaXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMobnVsbCwgdHJ1ZSk7XG4gIGNvbnN0IGNhY2hlQWxwaGEgPSB0aGlzLmFscGhhO1xuICB0aGlzLmFscGhhID0gMTtcbiAgY29uc3QgY2FjaGVkUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuY2FudmFzQ29udGV4dC5hY3RpdmVDb250ZXh0O1xuICBjb25zdCBjYWNoZWRQcm9qZWN0aW9uVHJhbnNmb3JtID0gcmVuZGVyZXIuX3Byb2pUcmFuc2Zvcm07XG4gIGJvdW5kcy5jZWlsKHNldHRpbmdzLlJFU09MVVRJT04pO1xuICBjb25zdCByZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZS5jcmVhdGUoeyB3aWR0aDogYm91bmRzLndpZHRoLCBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgfSk7XG4gIGNvbnN0IHRleHR1cmVDYWNoZUlkID0gYGNhY2hlQXNCaXRtYXBfJHt1dGlscy51aWQoKX1gO1xuICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSB0ZXh0dXJlQ2FjaGVJZDtcbiAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gIFRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gIGNvbnN0IG0gPSBfdGVtcE1hdHJpeDtcbiAgdGhpcy50cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm0uY29weVRvKG0pO1xuICBtLmludmVydCgpO1xuICBtLnR4IC09IGJvdW5kcy54O1xuICBtLnR5IC09IGJvdW5kcy55O1xuICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX2NhY2hlRGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcztcbiAgcmVuZGVyZXIucmVuZGVyKHRoaXMsIHsgcmVuZGVyVGV4dHVyZSwgY2xlYXI6IHRydWUsIHRyYW5zZm9ybTogbSwgc2tpcFVwZGF0ZVRyYW5zZm9ybTogZmFsc2UgfSk7XG4gIHJlbmRlcmVyLmNhbnZhc0NvbnRleHQuYWN0aXZlQ29udGV4dCA9IGNhY2hlZFJlbmRlclRhcmdldDtcbiAgcmVuZGVyZXIuX3Byb2pUcmFuc2Zvcm0gPSBjYWNoZWRQcm9qZWN0aW9uVHJhbnNmb3JtO1xuICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX3JlbmRlckNhY2hlZENhbnZhcztcbiAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm07XG4gIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzO1xuICB0aGlzLmdldExvY2FsQm91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHM7XG4gIHRoaXMuX21hc2sgPSBudWxsO1xuICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICB0aGlzLmFscGhhID0gY2FjaGVBbHBoYTtcbiAgY29uc3QgY2FjaGVkU3ByaXRlID0gbmV3IFNwcml0ZShyZW5kZXJUZXh0dXJlKTtcbiAgY2FjaGVkU3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICBjYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKGJvdW5kcy54IC8gYm91bmRzLndpZHRoKTtcbiAgY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpO1xuICBjYWNoZWRTcHJpdGUuYWxwaGEgPSBjYWNoZUFscGhhO1xuICBjYWNoZWRTcHJpdGUuX2JvdW5kcyA9IHRoaXMuX2JvdW5kcztcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IGNhY2hlZFNwcml0ZTtcbiAgdGhpcy50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aGlzLnBhcmVudCA9IHJlbmRlcmVyLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIHRoaXMuY29udGFpbnNQb2ludCA9IGNhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQoY2FjaGVkU3ByaXRlKTtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzID0gZnVuY3Rpb24gX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcygpIHtcbiAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUudHJhbnNmb3JtLl93b3JsZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX2NhbGN1bGF0ZUJvdW5kcygpO1xuICB0aGlzLl9ib3VuZHMudXBkYXRlSUQgPSB0aGlzLl9ib3VuZHNJRDtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0Q2FjaGVkTG9jYWxCb3VuZHMoKSB7XG4gIHJldHVybiB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLmdldExvY2FsQm91bmRzKG51bGwpO1xufTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9kZXN0cm95Q2FjaGVkRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uIF9kZXN0cm95Q2FjaGVkRGlzcGxheU9iamVjdCgpIHtcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gbnVsbDtcbiAgQmFzZVRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCk7XG4gIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCk7XG4gIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IG51bGw7XG59O1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2NhY2hlQXNCaXRtYXBEZXN0cm95ID0gZnVuY3Rpb24gX2NhY2hlQXNCaXRtYXBEZXN0cm95KG9wdGlvbnMpIHtcbiAgdGhpcy5jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gIHRoaXMuZGVzdHJveShvcHRpb25zKTtcbn07XG5cbmV4cG9ydCB7IENhY2hlRGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgRGlzcGxheU9iamVjdCwgQ29udGFpbmVyIH0gZnJvbSAnQHBpeGkvZGlzcGxheSc7XG5cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLm5hbWUgPSBudWxsO1xuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uIGdldENoaWxkQnlOYW1lKG5hbWUsIGRlZXApIHtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xuICAgIH1cbiAgfVxuICBpZiAoZGVlcCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmICghY2hpbGQuZ2V0Q2hpbGRCeU5hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXQgPSBjaGlsZC5nZXRDaGlsZEJ5TmFtZShuYW1lLCB0cnVlKTtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IERpc3BsYXlPYmplY3QgfSBmcm9tICdAcGl4aS9kaXNwbGF5JztcblxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2V0R2xvYmFsUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRHbG9iYWxQb3NpdGlvbihwb2ludCA9IG5ldyBQb2ludCgpLCBza2lwVXBkYXRlID0gZmFsc2UpIHtcbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQudG9HbG9iYWwodGhpcy5wb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHBvaW50LnggPSB0aGlzLnBvc2l0aW9uLng7XG4gICAgcG9pbnQueSA9IHRoaXMucG9zaXRpb24ueTtcbiAgfVxuICByZXR1cm4gcG9pbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IHVBbHBoYTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHVBbHBoYTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFscGhhLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgZGVmYXVsdFZlcnRleCB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vYWxwaGEubWpzJztcblxuY2xhc3MgQWxwaGFGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihhbHBoYSA9IDEpIHtcbiAgICBzdXBlcihkZWZhdWx0VmVydGV4LCBmcmFnbWVudCwgeyB1QWxwaGE6IDEgfSk7XG4gICAgdGhpcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51QWxwaGE7XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51QWxwaGEgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBBbHBoYUZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWxwaGFGaWx0ZXIubWpzLm1hcFxuIiwiZXhwb3J0IHsgQWxwaGFGaWx0ZXIgfSBmcm9tICcuL0FscGhhRmlsdGVyLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjb25zdCBHQVVTU0lBTl9WQUxVRVMgPSB7XG4gIDU6IFswLjE1MzM4OCwgMC4yMjE0NjEsIDAuMjUwMzAxXSxcbiAgNzogWzAuMDcxMzAzLCAwLjEzMTUxNCwgMC4xODk4NzksIDAuMjE0NjA3XSxcbiAgOTogWzAuMDI4NTMyLCAwLjA2NzIzNCwgMC4xMjQwMDksIDAuMTc5MDQ0LCAwLjIwMjM2XSxcbiAgMTE6IFs5M2UtNCwgMC4wMjgwMDIsIDAuMDY1OTg0LCAwLjEyMTcwMywgMC4xNzU3MTMsIDAuMTk4NTk2XSxcbiAgMTM6IFsyNDA2ZS02LCA5MjU1ZS02LCAwLjAyNzg2NywgMC4wNjU2NjYsIDAuMTIxMTE3LCAwLjE3NDg2OCwgMC4xOTc2NDFdLFxuICAxNTogWzQ4OWUtNiwgMjQwM2UtNiwgOTI0NmUtNiwgMC4wMjc4NCwgMC4wNjU2MDIsIDAuMTIwOTk5LCAwLjE3NDY5NywgMC4xOTc0NDhdXG59O1xuY29uc3QgZnJhZ1RlbXBsYXRlID0gW1xuICBcInZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1slc2l6ZSVdO1wiLFxuICBcInVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1wiLFxuICBcInZvaWQgbWFpbih2b2lkKVwiLFxuICBcIntcIixcbiAgXCIgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1wiLFxuICBcIiAgICAlYmx1ciVcIixcbiAgXCJ9XCJcbl0uam9pbihcIlxcblwiKTtcbmZ1bmN0aW9uIGdlbmVyYXRlQmx1ckZyYWdTb3VyY2Uoa2VybmVsU2l6ZSkge1xuICBjb25zdCBrZXJuZWwgPSBHQVVTU0lBTl9WQUxVRVNba2VybmVsU2l6ZV07XG4gIGNvbnN0IGhhbGZMZW5ndGggPSBrZXJuZWwubGVuZ3RoO1xuICBsZXQgZnJhZ1NvdXJjZSA9IGZyYWdUZW1wbGF0ZTtcbiAgbGV0IGJsdXJMb29wID0gXCJcIjtcbiAgY29uc3QgdGVtcGxhdGUgPSBcImdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyVpbmRleCVdKSAqICV2YWx1ZSU7XCI7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICBsZXQgYmx1ciA9IHRlbXBsYXRlLnJlcGxhY2UoXCIlaW5kZXglXCIsIGkudG9TdHJpbmcoKSk7XG4gICAgdmFsdWUgPSBpO1xuICAgIGlmIChpID49IGhhbGZMZW5ndGgpIHtcbiAgICAgIHZhbHVlID0ga2VybmVsU2l6ZSAtIGkgLSAxO1xuICAgIH1cbiAgICBibHVyID0gYmx1ci5yZXBsYWNlKFwiJXZhbHVlJVwiLCBrZXJuZWxbdmFsdWVdLnRvU3RyaW5nKCkpO1xuICAgIGJsdXJMb29wICs9IGJsdXI7XG4gICAgYmx1ckxvb3AgKz0gXCJcXG5cIjtcbiAgfVxuICBmcmFnU291cmNlID0gZnJhZ1NvdXJjZS5yZXBsYWNlKFwiJWJsdXIlXCIsIGJsdXJMb29wKTtcbiAgZnJhZ1NvdXJjZSA9IGZyYWdTb3VyY2UucmVwbGFjZShcIiVzaXplJVwiLCBrZXJuZWxTaXplLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gZnJhZ1NvdXJjZTtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5tanMubWFwXG4iLCJjb25zdCB2ZXJ0VGVtcGxhdGUgPSBgXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuXG4gICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWyVzaXplJV07XG5cbiAgICB1bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xuICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcblxuICAgIHZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxuICAgIHtcbiAgICAgICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XG5cbiAgICAgICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xuICAgIH1cblxuICAgIHZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcbiAgICB7XG4gICAgICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbih2b2lkKVxuICAgIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xuXG4gICAgICAgIHZlYzIgdGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XG4gICAgICAgICVibHVyJVxuICAgIH1gO1xuZnVuY3Rpb24gZ2VuZXJhdGVCbHVyVmVydFNvdXJjZShrZXJuZWxTaXplLCB4KSB7XG4gIGNvbnN0IGhhbGZMZW5ndGggPSBNYXRoLmNlaWwoa2VybmVsU2l6ZSAvIDIpO1xuICBsZXQgdmVydFNvdXJjZSA9IHZlcnRUZW1wbGF0ZTtcbiAgbGV0IGJsdXJMb29wID0gXCJcIjtcbiAgbGV0IHRlbXBsYXRlO1xuICBpZiAoeCkge1xuICAgIHRlbXBsYXRlID0gXCJ2Qmx1clRleENvb3Jkc1slaW5kZXglXSA9ICB0ZXh0dXJlQ29vcmQgKyB2ZWMyKCVzYW1wbGVJbmRleCUgKiBzdHJlbmd0aCwgMC4wKTtcIjtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IFwidkJsdXJUZXhDb29yZHNbJWluZGV4JV0gPSAgdGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICVzYW1wbGVJbmRleCUgKiBzdHJlbmd0aCk7XCI7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICBsZXQgYmx1ciA9IHRlbXBsYXRlLnJlcGxhY2UoXCIlaW5kZXglXCIsIGkudG9TdHJpbmcoKSk7XG4gICAgYmx1ciA9IGJsdXIucmVwbGFjZShcIiVzYW1wbGVJbmRleCVcIiwgYCR7aSAtIChoYWxmTGVuZ3RoIC0gMSl9LjBgKTtcbiAgICBibHVyTG9vcCArPSBibHVyO1xuICAgIGJsdXJMb29wICs9IFwiXFxuXCI7XG4gIH1cbiAgdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZShcIiVibHVyJVwiLCBibHVyTG9vcCk7XG4gIHZlcnRTb3VyY2UgPSB2ZXJ0U291cmNlLnJlcGxhY2UoXCIlc2l6ZSVcIiwga2VybmVsU2l6ZS50b1N0cmluZygpKTtcbiAgcmV0dXJuIHZlcnRTb3VyY2U7XG59XG5cbmV4cG9ydCB7IGdlbmVyYXRlQmx1clZlcnRTb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlQmx1clZlcnRTb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBDTEVBUl9NT0RFUyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZSB9IGZyb20gJy4vZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVCbHVyVmVydFNvdXJjZSB9IGZyb20gJy4vZ2VuZXJhdGVCbHVyVmVydFNvdXJjZS5tanMnO1xuXG5jbGFzcyBCbHVyRmlsdGVyUGFzcyBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKGhvcml6b250YWwsIHN0cmVuZ3RoID0gOCwgcXVhbGl0eSA9IDQsIHJlc29sdXRpb24gPSBGaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24sIGtlcm5lbFNpemUgPSA1KSB7XG4gICAgY29uc3QgdmVydFNyYyA9IGdlbmVyYXRlQmx1clZlcnRTb3VyY2Uoa2VybmVsU2l6ZSwgaG9yaXpvbnRhbCk7XG4gICAgY29uc3QgZnJhZ1NyYyA9IGdlbmVyYXRlQmx1ckZyYWdTb3VyY2Uoa2VybmVsU2l6ZSk7XG4gICAgc3VwZXIodmVydFNyYywgZnJhZ1NyYyk7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gaG9yaXpvbnRhbDtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIHRoaXMuX3F1YWxpdHkgPSAwO1xuICAgIHRoaXMucXVhbGl0eSA9IHF1YWxpdHk7XG4gICAgdGhpcy5ibHVyID0gc3RyZW5ndGg7XG4gIH1cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgaWYgKG91dHB1dCkge1xuICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIG91dHB1dC53aWR0aCAqIChvdXRwdXQud2lkdGggLyBpbnB1dC53aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIG91dHB1dC5oZWlnaHQgKiAob3V0cHV0LmhlaWdodCAvIGlucHV0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9IDEgLyBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLndpZHRoICogKGZpbHRlck1hbmFnZXIucmVuZGVyZXIud2lkdGggLyBpbnB1dC53aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIGZpbHRlck1hbmFnZXIucmVuZGVyZXIuaGVpZ2h0ICogKGZpbHRlck1hbmFnZXIucmVuZGVyZXIuaGVpZ2h0IC8gaW5wdXQuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCAqPSB0aGlzLnN0cmVuZ3RoO1xuICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggLz0gdGhpcy5wYXNzZXM7XG4gICAgaWYgKHRoaXMucGFzc2VzID09PSAxKSB7XG4gICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IGZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyVGV4dHVyZSgpO1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyO1xuICAgICAgbGV0IGZsaXAgPSBpbnB1dDtcbiAgICAgIGxldCBmbG9wID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgdGhpcy5zdGF0ZS5ibGVuZCA9IGZhbHNlO1xuICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBmbGlwLCBmbG9wLCBDTEVBUl9NT0RFUy5DTEVBUik7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucGFzc2VzIC0gMTsgaSsrKSB7XG4gICAgICAgIGZpbHRlck1hbmFnZXIuYmluZEFuZENsZWFyKGZsaXAsIENMRUFSX01PREVTLkJMSVQpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyID0gZmxvcDtcbiAgICAgICAgY29uc3QgdGVtcCA9IGZsb3A7XG4gICAgICAgIGZsb3AgPSBmbGlwO1xuICAgICAgICBmbGlwID0gdGVtcDtcbiAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoNSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLmJsZW5kID0gdHJ1ZTtcbiAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgZmxvcCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgICAgZmlsdGVyTWFuYWdlci5yZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRhcmdldCk7XG4gICAgfVxuICB9XG4gIGdldCBibHVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVuZ3RoO1xuICB9XG4gIHNldCBibHVyKHZhbHVlKSB7XG4gICAgdGhpcy5wYWRkaW5nID0gMSArIE1hdGguYWJzKHZhbHVlKSAqIDI7XG4gICAgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xuICB9XG4gIGdldCBxdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9xdWFsaXR5O1xuICB9XG4gIHNldCBxdWFsaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5fcXVhbGl0eSA9IHZhbHVlO1xuICAgIHRoaXMucGFzc2VzID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmx1ckZpbHRlclBhc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsdXJGaWx0ZXJQYXNzLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgQ0xFQVJfTU9ERVMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IEJsdXJGaWx0ZXJQYXNzIH0gZnJvbSAnLi9CbHVyRmlsdGVyUGFzcy5tanMnO1xuXG5jbGFzcyBCbHVyRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZW5ndGggPSA4LCBxdWFsaXR5ID0gNCwgcmVzb2x1dGlvbiA9IEZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbiwga2VybmVsU2l6ZSA9IDUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLmJsdXJYRmlsdGVyID0gbmV3IEJsdXJGaWx0ZXJQYXNzKHRydWUsIHN0cmVuZ3RoLCBxdWFsaXR5LCByZXNvbHV0aW9uLCBrZXJuZWxTaXplKTtcbiAgICB0aGlzLmJsdXJZRmlsdGVyID0gbmV3IEJsdXJGaWx0ZXJQYXNzKGZhbHNlLCBzdHJlbmd0aCwgcXVhbGl0eSwgcmVzb2x1dGlvbiwga2VybmVsU2l6ZSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICB0aGlzLnF1YWxpdHkgPSBxdWFsaXR5O1xuICAgIHRoaXMuYmx1ciA9IHN0cmVuZ3RoO1xuICAgIHRoaXMucmVwZWF0RWRnZVBpeGVscyA9IGZhbHNlO1xuICB9XG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGNvbnN0IHhTdHJlbmd0aCA9IE1hdGguYWJzKHRoaXMuYmx1clhGaWx0ZXIuc3RyZW5ndGgpO1xuICAgIGNvbnN0IHlTdHJlbmd0aCA9IE1hdGguYWJzKHRoaXMuYmx1cllGaWx0ZXIuc3RyZW5ndGgpO1xuICAgIGlmICh4U3RyZW5ndGggJiYgeVN0cmVuZ3RoKSB7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBmaWx0ZXJNYW5hZ2VyLmdldEZpbHRlclRleHR1cmUoKTtcbiAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIHJlbmRlclRhcmdldCwgQ0xFQVJfTU9ERVMuQ0xFQVIpO1xuICAgICAgdGhpcy5ibHVyWUZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCByZW5kZXJUYXJnZXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgICAgIGZpbHRlck1hbmFnZXIucmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoeVN0cmVuZ3RoKSB7XG4gICAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFkZGluZygpIHtcbiAgICBpZiAodGhpcy5fcmVwZWF0RWRnZVBpeGVscykge1xuICAgICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWRkaW5nID0gTWF0aC5tYXgoTWF0aC5hYnModGhpcy5ibHVyWEZpbHRlci5zdHJlbmd0aCksIE1hdGguYWJzKHRoaXMuYmx1cllGaWx0ZXIuc3RyZW5ndGgpKSAqIDI7XG4gICAgfVxuICB9XG4gIGdldCBibHVyKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICBnZXQgcXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5xdWFsaXR5O1xuICB9XG4gIHNldCBxdWFsaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWEZpbHRlci5xdWFsaXR5ID0gdGhpcy5ibHVyWUZpbHRlci5xdWFsaXR5ID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJsdXJYKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXJYKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gIH1cbiAgZ2V0IGJsdXJZKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXJZKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGU7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1cllGaWx0ZXIuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHJlcGVhdEVkZ2VQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHM7XG4gIH1cbiAgc2V0IHJlcGVhdEVkZ2VQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yZXBlYXRFZGdlUGl4ZWxzID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmx1ckZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qmx1ckZpbHRlci5tanMubWFwXG4iLCJleHBvcnQgeyBCbHVyRmlsdGVyIH0gZnJvbSAnLi9CbHVyRmlsdGVyLm1qcyc7XG5leHBvcnQgeyBCbHVyRmlsdGVyUGFzcyB9IGZyb20gJy4vQmx1ckZpbHRlclBhc3MubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCBtWzIwXTtcXG51bmlmb3JtIGZsb2F0IHVBbHBoYTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgYyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGlmICh1QWxwaGEgPT0gMC4wKSB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIFVuLXByZW11bHRpcGx5IGFscGhhIGJlZm9yZSBhcHBseWluZyB0aGUgY29sb3IgbWF0cml4LiBTZWUgaXNzdWUgIzM1MzkuXFxuICAgIGlmIChjLmEgPiAwLjApIHtcXG4gICAgICBjLnJnYiAvPSBjLmE7XFxuICAgIH1cXG5cXG4gICAgdmVjNCByZXN1bHQ7XFxuXFxuICAgIHJlc3VsdC5yID0gKG1bMF0gKiBjLnIpO1xcbiAgICAgICAgcmVzdWx0LnIgKz0gKG1bMV0gKiBjLmcpO1xcbiAgICAgICAgcmVzdWx0LnIgKz0gKG1bMl0gKiBjLmIpO1xcbiAgICAgICAgcmVzdWx0LnIgKz0gKG1bM10gKiBjLmEpO1xcbiAgICAgICAgcmVzdWx0LnIgKz0gbVs0XTtcXG5cXG4gICAgcmVzdWx0LmcgPSAobVs1XSAqIGMucik7XFxuICAgICAgICByZXN1bHQuZyArPSAobVs2XSAqIGMuZyk7XFxuICAgICAgICByZXN1bHQuZyArPSAobVs3XSAqIGMuYik7XFxuICAgICAgICByZXN1bHQuZyArPSAobVs4XSAqIGMuYSk7XFxuICAgICAgICByZXN1bHQuZyArPSBtWzldO1xcblxcbiAgICByZXN1bHQuYiA9IChtWzEwXSAqIGMucik7XFxuICAgICAgIHJlc3VsdC5iICs9IChtWzExXSAqIGMuZyk7XFxuICAgICAgIHJlc3VsdC5iICs9IChtWzEyXSAqIGMuYik7XFxuICAgICAgIHJlc3VsdC5iICs9IChtWzEzXSAqIGMuYSk7XFxuICAgICAgIHJlc3VsdC5iICs9IG1bMTRdO1xcblxcbiAgICByZXN1bHQuYSA9IChtWzE1XSAqIGMucik7XFxuICAgICAgIHJlc3VsdC5hICs9IChtWzE2XSAqIGMuZyk7XFxuICAgICAgIHJlc3VsdC5hICs9IChtWzE3XSAqIGMuYik7XFxuICAgICAgIHJlc3VsdC5hICs9IChtWzE4XSAqIGMuYSk7XFxuICAgICAgIHJlc3VsdC5hICs9IG1bMTldO1xcblxcbiAgICB2ZWMzIHJnYiA9IG1peChjLnJnYiwgcmVzdWx0LnJnYiwgdUFscGhhKTtcXG5cXG4gICAgLy8gUHJlbXVsdGlwbHkgYWxwaGEgYWdhaW4uXFxuICAgIHJnYiAqPSByZXN1bHQuYTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyZ2IsIHJlc3VsdC5hKTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yTWF0cml4Lm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgZGVmYXVsdEZpbHRlclZlcnRleCwgQ29sb3IgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL2NvbG9yTWF0cml4Lm1qcyc7XG5cbmNsYXNzIENvbG9yTWF0cml4RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICBtOiBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMFxuICAgICAgXSksXG4gICAgICB1QWxwaGE6IDFcbiAgICB9O1xuICAgIHN1cGVyKGRlZmF1bHRGaWx0ZXJWZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3Jtcyk7XG4gICAgdGhpcy5hbHBoYSA9IDE7XG4gIH1cbiAgX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSA9IGZhbHNlKSB7XG4gICAgbGV0IG5ld01hdHJpeCA9IG1hdHJpeDtcbiAgICBpZiAobXVsdGlwbHkpIHtcbiAgICAgIHRoaXMuX211bHRpcGx5KG5ld01hdHJpeCwgdGhpcy51bmlmb3Jtcy5tLCBtYXRyaXgpO1xuICAgICAgbmV3TWF0cml4ID0gdGhpcy5fY29sb3JNYXRyaXgobmV3TWF0cml4KTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5tID0gbmV3TWF0cml4O1xuICB9XG4gIF9tdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXSArIGFbMV0gKiBiWzVdICsgYVsyXSAqIGJbMTBdICsgYVszXSAqIGJbMTVdO1xuICAgIG91dFsxXSA9IGFbMF0gKiBiWzFdICsgYVsxXSAqIGJbNl0gKyBhWzJdICogYlsxMV0gKyBhWzNdICogYlsxNl07XG4gICAgb3V0WzJdID0gYVswXSAqIGJbMl0gKyBhWzFdICogYls3XSArIGFbMl0gKiBiWzEyXSArIGFbM10gKiBiWzE3XTtcbiAgICBvdXRbM10gPSBhWzBdICogYlszXSArIGFbMV0gKiBiWzhdICsgYVsyXSAqIGJbMTNdICsgYVszXSAqIGJbMThdO1xuICAgIG91dFs0XSA9IGFbMF0gKiBiWzRdICsgYVsxXSAqIGJbOV0gKyBhWzJdICogYlsxNF0gKyBhWzNdICogYlsxOV0gKyBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gKiBiWzBdICsgYVs2XSAqIGJbNV0gKyBhWzddICogYlsxMF0gKyBhWzhdICogYlsxNV07XG4gICAgb3V0WzZdID0gYVs1XSAqIGJbMV0gKyBhWzZdICogYls2XSArIGFbN10gKiBiWzExXSArIGFbOF0gKiBiWzE2XTtcbiAgICBvdXRbN10gPSBhWzVdICogYlsyXSArIGFbNl0gKiBiWzddICsgYVs3XSAqIGJbMTJdICsgYVs4XSAqIGJbMTddO1xuICAgIG91dFs4XSA9IGFbNV0gKiBiWzNdICsgYVs2XSAqIGJbOF0gKyBhWzddICogYlsxM10gKyBhWzhdICogYlsxOF07XG4gICAgb3V0WzldID0gYVs1XSAqIGJbNF0gKyBhWzZdICogYls5XSArIGFbN10gKiBiWzE0XSArIGFbOF0gKiBiWzE5XSArIGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdICogYlswXSArIGFbMTFdICogYls1XSArIGFbMTJdICogYlsxMF0gKyBhWzEzXSAqIGJbMTVdO1xuICAgIG91dFsxMV0gPSBhWzEwXSAqIGJbMV0gKyBhWzExXSAqIGJbNl0gKyBhWzEyXSAqIGJbMTFdICsgYVsxM10gKiBiWzE2XTtcbiAgICBvdXRbMTJdID0gYVsxMF0gKiBiWzJdICsgYVsxMV0gKiBiWzddICsgYVsxMl0gKiBiWzEyXSArIGFbMTNdICogYlsxN107XG4gICAgb3V0WzEzXSA9IGFbMTBdICogYlszXSArIGFbMTFdICogYls4XSArIGFbMTJdICogYlsxM10gKyBhWzEzXSAqIGJbMThdO1xuICAgIG91dFsxNF0gPSBhWzEwXSAqIGJbNF0gKyBhWzExXSAqIGJbOV0gKyBhWzEyXSAqIGJbMTRdICsgYVsxM10gKiBiWzE5XSArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XSAqIGJbMF0gKyBhWzE2XSAqIGJbNV0gKyBhWzE3XSAqIGJbMTBdICsgYVsxOF0gKiBiWzE1XTtcbiAgICBvdXRbMTZdID0gYVsxNV0gKiBiWzFdICsgYVsxNl0gKiBiWzZdICsgYVsxN10gKiBiWzExXSArIGFbMThdICogYlsxNl07XG4gICAgb3V0WzE3XSA9IGFbMTVdICogYlsyXSArIGFbMTZdICogYls3XSArIGFbMTddICogYlsxMl0gKyBhWzE4XSAqIGJbMTddO1xuICAgIG91dFsxOF0gPSBhWzE1XSAqIGJbM10gKyBhWzE2XSAqIGJbOF0gKyBhWzE3XSAqIGJbMTNdICsgYVsxOF0gKiBiWzE4XTtcbiAgICBvdXRbMTldID0gYVsxNV0gKiBiWzRdICsgYVsxNl0gKiBiWzldICsgYVsxN10gKiBiWzE0XSArIGFbMThdICogYlsxOV0gKyBhWzE5XTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIF9jb2xvck1hdHJpeChtYXRyaXgpIHtcbiAgICBjb25zdCBtID0gbmV3IEZsb2F0MzJBcnJheShtYXRyaXgpO1xuICAgIG1bNF0gLz0gMjU1O1xuICAgIG1bOV0gLz0gMjU1O1xuICAgIG1bMTRdIC89IDI1NTtcbiAgICBtWzE5XSAvPSAyNTU7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgYnJpZ2h0bmVzcyhiLCBtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIGIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHRpbnQoY29sb3IsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbG9yKS50b0FycmF5KCk7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgcixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgZyxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgZ3JleXNjYWxlKHNjYWxlLCBtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGJsYWNrQW5kV2hpdGUobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAwLjMsXG4gICAgICAwLjYsXG4gICAgICAwLjEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAuMyxcbiAgICAgIDAuNixcbiAgICAgIDAuMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMC4zLFxuICAgICAgMC42LFxuICAgICAgMC4xLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBodWUocm90YXRpb24sIG11bHRpcGx5KSB7XG4gICAgcm90YXRpb24gPSAocm90YXRpb24gfHwgMCkgLyAxODAgKiBNYXRoLlBJO1xuICAgIGNvbnN0IGNvc1IgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgY29uc3Qgc2luUiA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIGNvbnN0IHcgPSAxIC8gMztcbiAgICBjb25zdCBzcXJXID0gc3FydCh3KTtcbiAgICBjb25zdCBhMDAgPSBjb3NSICsgKDEgLSBjb3NSKSAqIHc7XG4gICAgY29uc3QgYTAxID0gdyAqICgxIC0gY29zUikgLSBzcXJXICogc2luUjtcbiAgICBjb25zdCBhMDIgPSB3ICogKDEgLSBjb3NSKSArIHNxclcgKiBzaW5SO1xuICAgIGNvbnN0IGExMCA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblI7XG4gICAgY29uc3QgYTExID0gY29zUiArIHcgKiAoMSAtIGNvc1IpO1xuICAgIGNvbnN0IGExMiA9IHcgKiAoMSAtIGNvc1IpIC0gc3FyVyAqIHNpblI7XG4gICAgY29uc3QgYTIwID0gdyAqICgxIC0gY29zUikgLSBzcXJXICogc2luUjtcbiAgICBjb25zdCBhMjEgPSB3ICogKDEgLSBjb3NSKSArIHNxclcgKiBzaW5SO1xuICAgIGNvbnN0IGEyMiA9IGNvc1IgKyB3ICogKDEgLSBjb3NSKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICBhMDAsXG4gICAgICBhMDEsXG4gICAgICBhMDIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGExMCxcbiAgICAgIGExMSxcbiAgICAgIGExMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYTIwLFxuICAgICAgYTIxLFxuICAgICAgYTIyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBjb250cmFzdChhbW91bnQsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgdiA9IChhbW91bnQgfHwgMCkgKyAxO1xuICAgIGNvbnN0IG8gPSAtMC41ICogKHYgLSAxKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgbyxcbiAgICAgIDAsXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBvLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIG8sXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBzYXR1cmF0ZShhbW91bnQgPSAwLCBtdWx0aXBseSkge1xuICAgIGNvbnN0IHggPSBhbW91bnQgKiAyIC8gMyArIDE7XG4gICAgY29uc3QgeSA9ICh4IC0gMSkgKiAtMC41O1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgeSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB5LFxuICAgICAgeSxcbiAgICAgIHgsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGRlc2F0dXJhdGUoKSB7XG4gICAgdGhpcy5zYXR1cmF0ZSgtMSk7XG4gIH1cbiAgbmVnYXRpdmUobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAtMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTEsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0xLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBzZXBpYShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuMzkzLFxuICAgICAgMC43Njg5OTk5LFxuICAgICAgMC4xODg5OTk5OSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMC4zNDksXG4gICAgICAwLjY4NTk5OTksXG4gICAgICAwLjE2Nzk5OTk5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLjI3MixcbiAgICAgIDAuNTMzOTk5OSxcbiAgICAgIDAuMTMwOTk5OTksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHRlY2huaWNvbG9yKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMS45MTI1Mjc3ODkxNDU2MDgzLFxuICAgICAgLTAuODU0NTM0NDk3Njk1MTY0NSxcbiAgICAgIC0wLjA5MTU1NTA4NDgyNzU1NTg1LFxuICAgICAgMCxcbiAgICAgIDExLjc5MzYwMzQzNDM3NzMzNyxcbiAgICAgIC0wLjMwODc4MzMzODU5MjgwOTcsXG4gICAgICAxLjc2NTg5MDg1NTU0NTg0MjgsXG4gICAgICAtMC4xMDYwMTc0MzA3NDcyMjI0NSxcbiAgICAgIDAsXG4gICAgICAtNzAuMzUyMDUxNjE0NjEzOTgsXG4gICAgICAtMC4yMzExMDMzNzc1NDg2MTYsXG4gICAgICAtMC43NTAxODk5MTk3NDQwMjEyLFxuICAgICAgMS44NDc1OTc4MTYxMDgxODksXG4gICAgICAwLFxuICAgICAgMzAuOTUwOTQwODY5NDkxMTM4LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgcG9sYXJvaWQobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxLjQzOCxcbiAgICAgIC0wLjA2MixcbiAgICAgIC0wLjA2MixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTAuMTIyLFxuICAgICAgMS4zNzgsXG4gICAgICAtMC4xMjIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0wLjAxNixcbiAgICAgIC0wLjAxNixcbiAgICAgIDEuNDgzLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICB0b0JHUihtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGtvZGFjaHJvbWUobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxLjEyODU1ODIzOTY1OTM1MjUsXG4gICAgICAtMC4zOTY3MzgyMjgzNjAxMzQ4LFxuICAgICAgLTAuMDM5OTI1NTkxNzI5MjE3OTMsXG4gICAgICAwLFxuICAgICAgNjMuNzI5NTg3NjIxOTY1MDIsXG4gICAgICAtMC4xNjQwNDMzOTk2MjI0NDYxNixcbiAgICAgIDEuMDgzNTI1MTU2NjI5MTMwNCxcbiAgICAgIC0wLjA1NDk4ODA1MTE1NjMzMTMyLFxuICAgICAgMCxcbiAgICAgIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLFxuICAgICAgLTAuNTYwMzQxNjI3NzY5NTI0OCxcbiAgICAgIDEuNjAxNDg1MDc2MTk2NDk0MyxcbiAgICAgIDAsXG4gICAgICAzNS42Mjk4MjgwNzQ2MDk0NixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGJyb3duaShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuNTk5NzAyMzQ5ODE1OTcxNSxcbiAgICAgIDAuMzQ1NTMyNDMwNDgzOTEyNjMsXG4gICAgICAtMC4yNzA4Mjk4Njc0NTM4MDQyLFxuICAgICAgMCxcbiAgICAgIDQ3LjQzMTkyODU1NjAwODczLFxuICAgICAgLTAuMDM3NzAzMjQ5ODM3NzgzMTU3LFxuICAgICAgMC44NjA5NTc3NTg3OTkyNjQxLFxuICAgICAgMC4xNTA1OTU1MjM4ODQ1OTkxMyxcbiAgICAgIDAsXG4gICAgICAtMzYuOTY4NDE0OTgzMTkxMjcsXG4gICAgICAwLjI0MTEzNjM1MTI4MTUzMzM1LFxuICAgICAgLTAuMDc0NDEwMzc5MDg0MjI0OTIsXG4gICAgICAwLjQ0OTcyMTgyMDY0ODc3MTUzLFxuICAgICAgMCxcbiAgICAgIC03LjU2MjA3NTI3NzU5MTI4MyxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHZpbnRhZ2UobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAwLjYyNzkzNDU2MzU2MDU5OTQsXG4gICAgICAwLjMyMDIxODM0MjA4MTkzNjcsXG4gICAgICAtMC4wMzk2NTQwODIxMTMxMjQ1MyxcbiAgICAgIDAsXG4gICAgICA5LjY1MTI4NTgzNTI5NDEyMyxcbiAgICAgIDAuMDI1NzgzOTc3MDQ4MDg4NjgsXG4gICAgICAwLjY0NDExODg2NDQzNzQ3NzEsXG4gICAgICAwLjAzMjU5MTI3NjE2MTQ5Mjk0LFxuICAgICAgMCxcbiAgICAgIDcuNDYyODI5MTc2NDcwNTkxLFxuICAgICAgMC4wNDY2MDU1NTU2NzgyNzE5LFxuICAgICAgLTAuMDg1MTIzMjk4NzI0Nzg5MSxcbiAgICAgIDAuNTI0MTY0ODAxODcwMDQ2NSxcbiAgICAgIDAsXG4gICAgICA1LjE1OTE5MDU4ODIzNTI5NixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGNvbG9yVG9uZShkZXNhdHVyYXRpb24sIHRvbmVkLCBsaWdodENvbG9yLCBkYXJrQ29sb3IsIG11bHRpcGx5KSB7XG4gICAgZGVzYXR1cmF0aW9uID0gZGVzYXR1cmF0aW9uIHx8IDAuMjtcbiAgICB0b25lZCA9IHRvbmVkIHx8IDAuMTU7XG4gICAgbGlnaHRDb2xvciA9IGxpZ2h0Q29sb3IgfHwgMTY3NzA0MzI7XG4gICAgZGFya0NvbG9yID0gZGFya0NvbG9yIHx8IDMzNzUxMDQ7XG4gICAgY29uc3QgdGVtcCA9IENvbG9yLnNoYXJlZDtcbiAgICBjb25zdCBbbFIsIGxHLCBsQl0gPSB0ZW1wLnNldFZhbHVlKGxpZ2h0Q29sb3IpLnRvQXJyYXkoKTtcbiAgICBjb25zdCBbZFIsIGRHLCBkQl0gPSB0ZW1wLnNldFZhbHVlKGRhcmtDb2xvcikudG9BcnJheSgpO1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuMyxcbiAgICAgIDAuNTksXG4gICAgICAwLjExLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBsUixcbiAgICAgIGxHLFxuICAgICAgbEIsXG4gICAgICBkZXNhdHVyYXRpb24sXG4gICAgICAwLFxuICAgICAgZFIsXG4gICAgICBkRyxcbiAgICAgIGRCLFxuICAgICAgdG9uZWQsXG4gICAgICAwLFxuICAgICAgbFIgLSBkUixcbiAgICAgIGxHIC0gZEcsXG4gICAgICBsQiAtIGRCLFxuICAgICAgMCxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgbmlnaHQoaW50ZW5zaXR5LCBtdWx0aXBseSkge1xuICAgIGludGVuc2l0eSA9IGludGVuc2l0eSB8fCAwLjE7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgaW50ZW5zaXR5ICogLTIsXG4gICAgICAtaW50ZW5zaXR5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLWludGVuc2l0eSxcbiAgICAgIDAsXG4gICAgICBpbnRlbnNpdHksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBpbnRlbnNpdHksXG4gICAgICBpbnRlbnNpdHkgKiAyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBwcmVkYXRvcihhbW91bnQsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMTEuMjI0MTMwNjMwNDkzMTY0ICogYW1vdW50LFxuICAgICAgLTQuNzk0NDg2OTk5NTExNzE5ICogYW1vdW50LFxuICAgICAgLTIuODc0NjExODU0NTUzMjIyNyAqIGFtb3VudCxcbiAgICAgIDAgKiBhbW91bnQsXG4gICAgICAwLjQwMzQyNDM4MjIwOTc3NzgzICogYW1vdW50LFxuICAgICAgLTMuNjMzMDY5NzUzNjQ2ODUwNiAqIGFtb3VudCxcbiAgICAgIDkuMTkzMTU3MTk2MDQ0OTIyICogYW1vdW50LFxuICAgICAgLTIuOTUxODEwODM2NzkxOTkyICogYW1vdW50LFxuICAgICAgMCAqIGFtb3VudCxcbiAgICAgIC0xLjMxNjEzNTA0ODg2NjI3MiAqIGFtb3VudCxcbiAgICAgIC0zLjIxODQxOTc5MDI2Nzk0NDMgKiBhbW91bnQsXG4gICAgICAtNC4yMzc1MDMwNTE3NTc4MTI1ICogYW1vdW50LFxuICAgICAgNy40NzY0NDgwNTkwODIwMzEgKiBhbW91bnQsXG4gICAgICAwICogYW1vdW50LFxuICAgICAgMC44MDQ0NDU5MjIzNzQ3MjUzICogYW1vdW50LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgbHNkKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMixcbiAgICAgIC0wLjQsXG4gICAgICAwLjUsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0wLjUsXG4gICAgICAyLFxuICAgICAgLTAuNCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTAuNCxcbiAgICAgIC0wLjUsXG4gICAgICAzLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIGZhbHNlKTtcbiAgfVxuICBnZXQgbWF0cml4KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm07XG4gIH1cbiAgc2V0IG1hdHJpeCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubSA9IHZhbHVlO1xuICB9XG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51QWxwaGE7XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51QWxwaGEgPSB2YWx1ZTtcbiAgfVxufVxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmdyYXlzY2FsZSA9IENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5ncmV5c2NhbGU7XG5cbmV4cG9ydCB7IENvbG9yTWF0cml4RmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck1hdHJpeEZpbHRlci5tanMubWFwXG4iLCJleHBvcnQgeyBDb2xvck1hdHJpeEZpbHRlciB9IGZyb20gJy4vQ29sb3JNYXRyaXhGaWx0ZXIubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZGaWx0ZXJDb29yZDtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHZlYzIgc2NhbGU7XFxudW5pZm9ybSBtYXQyIHJvdGF0aW9uO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcFNhbXBsZXI7XFxuXFxudW5pZm9ybSBoaWdocCB2ZWM0IGlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgaW5wdXRDbGFtcDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICB2ZWM0IG1hcCA9ICB0ZXh0dXJlMkQobWFwU2FtcGxlciwgdkZpbHRlckNvb3JkKTtcXG5cXG4gIG1hcCAtPSAwLjU7XFxuICBtYXAueHkgPSBzY2FsZSAqIGlucHV0U2l6ZS56dyAqIChyb3RhdGlvbiAqIG1hcC54eSk7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNsYW1wKHZlYzIodlRleHR1cmVDb29yZC54ICsgbWFwLngsIHZUZXh0dXJlQ29vcmQueSArIG1hcC55KSwgaW5wdXRDbGFtcC54eSwgaW5wdXRDbGFtcC56dykpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcGxhY2VtZW50Lm1qcy5tYXBcbiIsInZhciB2ZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgZmlsdGVyTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMiB2RmlsdGVyQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxuXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxue1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbn1cXG5cXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxue1xcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcblxcdGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXG5cXHR2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxuXFx0dkZpbHRlckNvb3JkID0gKCBmaWx0ZXJNYXRyaXggKiB2ZWMzKCB2VGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgdmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3BsYWNlbWVudDIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBNYXRyaXgsIFBvaW50IH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9kaXNwbGFjZW1lbnQubWpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi9kaXNwbGFjZW1lbnQyLm1qcyc7XG5cbmNsYXNzIERpc3BsYWNlbWVudEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKHNwcml0ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXNrTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHNwcml0ZS5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgc3VwZXIodmVydGV4LCBmcmFnbWVudCwge1xuICAgICAgbWFwU2FtcGxlcjogc3ByaXRlLl90ZXh0dXJlLFxuICAgICAgZmlsdGVyTWF0cml4OiBtYXNrTWF0cml4LFxuICAgICAgc2NhbGU6IHsgeDogMSwgeTogMSB9LFxuICAgICAgcm90YXRpb246IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDFdKVxuICAgIH0pO1xuICAgIHRoaXMubWFza1Nwcml0ZSA9IHNwcml0ZTtcbiAgICB0aGlzLm1hc2tNYXRyaXggPSBtYXNrTWF0cml4O1xuICAgIGlmIChzY2FsZSA9PT0gbnVsbCB8fCBzY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzY2FsZSA9IDIwO1xuICAgIH1cbiAgICB0aGlzLnNjYWxlID0gbmV3IFBvaW50KHNjYWxlLCBzY2FsZSk7XG4gIH1cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5maWx0ZXJNYXRyaXggPSBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCh0aGlzLm1hc2tNYXRyaXgsIHRoaXMubWFza1Nwcml0ZSk7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS54ID0gdGhpcy5zY2FsZS54O1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUueSA9IHRoaXMuc2NhbGUueTtcbiAgICBjb25zdCB3dCA9IHRoaXMubWFza1Nwcml0ZS53b3JsZFRyYW5zZm9ybTtcbiAgICBjb25zdCBsZW5YID0gTWF0aC5zcXJ0KHd0LmEgKiB3dC5hICsgd3QuYiAqIHd0LmIpO1xuICAgIGNvbnN0IGxlblkgPSBNYXRoLnNxcnQod3QuYyAqIHd0LmMgKyB3dC5kICogd3QuZCk7XG4gICAgaWYgKGxlblggIT09IDAgJiYgbGVuWSAhPT0gMCkge1xuICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblswXSA9IHd0LmEgLyBsZW5YO1xuICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsxXSA9IHd0LmIgLyBsZW5YO1xuICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsyXSA9IHd0LmMgLyBsZW5ZO1xuICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblszXSA9IHd0LmQgLyBsZW5ZO1xuICAgIH1cbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXBTYW1wbGVyO1xuICB9XG4gIHNldCBtYXAodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm1hcFNhbXBsZXIgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBEaXNwbGFjZW1lbnRGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc3BsYWNlbWVudEZpbHRlci5tanMubWFwXG4iLCJleHBvcnQgeyBEaXNwbGFjZW1lbnRGaWx0ZXIgfSBmcm9tICcuL0Rpc3BsYWNlbWVudEZpbHRlci5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdl9yZ2JOVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JORTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTRTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JNO1xcblxcbnZhcnlpbmcgdmVjMiB2RnJhZ0Nvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gaGlnaHAgdmVjNCBpbnB1dFNpemU7XFxuXFxuXFxuLyoqXFxuIEJhc2ljIEZYQUEgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIGNvZGUgb24gZ2Vla3MzZC5jb20gd2l0aCB0aGVcXG4gbW9kaWZpY2F0aW9uIHRoYXQgdGhlIHRleHR1cmUyRExvZCBzdHVmZiB3YXMgcmVtb3ZlZCBzaW5jZSBpdCdzXFxuIHVuc3VwcG9ydGVkIGJ5IFdlYkdMLlxcblxcbiAtLVxcblxcbiBGcm9tOlxcbiBodHRwczovL2dpdGh1Yi5jb20vbWl0c3VoaWtvL3dlYmdsLW1laW5jcmFmdFxcblxcbiBDb3B5cmlnaHQgKGMpIDIwMTEgYnkgQXJtaW4gUm9uYWNoZXIuXFxuXFxuIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxcblxcbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxcbiBtZXQ6XFxuXFxuICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcXG4gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcXG4gZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXFxuIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4gKiBUaGUgbmFtZXMgb2YgdGhlIGNvbnRyaWJ1dG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvclxcbiBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcXG4gcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxcblxcbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXFxuIFxcXCJBUyBJU1xcXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXFxuIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxcbiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxcbiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcXG4gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcXG4gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXFxuIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcXG4gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXFxuIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXFxuICovXFxuXFxuI2lmbmRlZiBGWEFBX1JFRFVDRV9NSU5cXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvIDEyOC4wKVxcbiNlbmRpZlxcbiNpZm5kZWYgRlhBQV9SRURVQ0VfTVVMXFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NVUwgICAoMS4wIC8gOC4wKVxcbiNlbmRpZlxcbiNpZm5kZWYgRlhBQV9TUEFOX01BWFxcbiNkZWZpbmUgRlhBQV9TUEFOX01BWCAgICAgOC4wXFxuI2VuZGlmXFxuXFxuLy9vcHRpbWl6ZWQgdmVyc2lvbiBmb3IgbW9iaWxlLCB3aGVyZSBkZXBlbmRlbnRcXG4vL3RleHR1cmUgcmVhZHMgY2FuIGJlIGEgYm90dGxlbmVja1xcbnZlYzQgZnhhYShzYW1wbGVyMkQgdGV4LCB2ZWMyIGZyYWdDb29yZCwgdmVjMiBpbnZlcnNlVlAsXFxuICAgICAgICAgIHZlYzIgdl9yZ2JOVywgdmVjMiB2X3JnYk5FLFxcbiAgICAgICAgICB2ZWMyIHZfcmdiU1csIHZlYzIgdl9yZ2JTRSxcXG4gICAgICAgICAgdmVjMiB2X3JnYk0pIHtcXG4gICAgdmVjNCBjb2xvcjtcXG4gICAgdmVjMyByZ2JOVyA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTlcpLnh5ejtcXG4gICAgdmVjMyByZ2JORSA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTkUpLnh5ejtcXG4gICAgdmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiU1cpLnh5ejtcXG4gICAgdmVjMyByZ2JTRSA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiU0UpLnh5ejtcXG4gICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTSk7XFxuICAgIHZlYzMgcmdiTSAgPSB0ZXhDb2xvci54eXo7XFxuICAgIHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuICAgIGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNICA9IGRvdChyZ2JNLCAgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuICAgIGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxuICAgIG1lZGl1bXAgdmVjMiBkaXI7XFxuICAgIGRpci54ID0gLSgobHVtYU5XICsgbHVtYU5FKSAtIChsdW1hU1cgKyBsdW1hU0UpKTtcXG4gICAgZGlyLnkgPSAgKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1xcblxcbiAgICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLCBGWEFBX1JFRFVDRV9NSU4pO1xcblxcbiAgICBmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcXG4gICAgZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksXFxuICAgICAgICAgICAgICBtYXgodmVjMigtRlhBQV9TUEFOX01BWCwgLUZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgICAgIGRpciAqIHJjcERpck1pbikpICogaW52ZXJzZVZQO1xcblxcbiAgICB2ZWMzIHJnYkEgPSAwLjUgKiAoXFxuICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkueHl6ICtcXG4gICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKS54eXopO1xcbiAgICB2ZWMzIHJnYkIgPSByZ2JBICogMC41ICsgMC4yNSAqIChcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogLTAuNSkueHl6ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogMC41KS54eXopO1xcblxcbiAgICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcXG4gICAgaWYgKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkEsIHRleENvbG9yLmEpO1xcbiAgICBlbHNlXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQiwgdGV4Q29sb3IuYSk7XFxuICAgIHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICAgIHZlYzQgY29sb3I7XFxuXFxuICAgICAgY29sb3IgPSBmeGFhKHVTYW1wbGVyLCB2RnJhZ0Nvb3JkLCBpbnB1dFNpemUuencsIHZfcmdiTlcsIHZfcmdiTkUsIHZfcmdiU1csIHZfcmdiU0UsIHZfcmdiTSk7XFxuXFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1meGFhLm1qcy5tYXBcbiIsInZhciB2ZXJ0ZXggPSBcIlxcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9yZ2JOVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JORTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTRTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JNO1xcblxcbnZhcnlpbmcgdmVjMiB2RnJhZ0Nvb3JkO1xcblxcbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XFxudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xcblxcbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxcbntcXG4gICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XFxuXFxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG59XFxuXFxudm9pZCB0ZXhjb29yZHModmVjMiBmcmFnQ29vcmQsIHZlYzIgaW52ZXJzZVZQLFxcbiAgICAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiTlcsIG91dCB2ZWMyIHZfcmdiTkUsXFxuICAgICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JTVywgb3V0IHZlYzIgdl9yZ2JTRSxcXG4gICAgICAgICAgICAgICBvdXQgdmVjMiB2X3JnYk0pIHtcXG4gICAgdl9yZ2JOVyA9IChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIC0xLjApKSAqIGludmVyc2VWUDtcXG4gICAgdl9yZ2JORSA9IChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgLTEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYlNXID0gKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiBpbnZlcnNlVlA7XFxuICAgIHZfcmdiU0UgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIDEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYk0gPSB2ZWMyKGZyYWdDb29yZCAqIGludmVyc2VWUCk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcblxcbiAgIHZGcmFnQ29vcmQgPSBhVmVydGV4UG9zaXRpb24gKiBvdXRwdXRGcmFtZS56dztcXG5cXG4gICB0ZXhjb29yZHModkZyYWdDb29yZCwgaW5wdXRTaXplLnp3LCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgdmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ4YWEyLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vZnhhYS5tanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuL2Z4YWEyLm1qcyc7XG5cbmNsYXNzIEZYQUFGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih2ZXJ0ZXgsIGZyYWdtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgeyBGWEFBRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GWEFBRmlsdGVyLm1qcy5tYXBcbiIsImV4cG9ydCB7IEZYQUFGaWx0ZXIgfSBmcm9tICcuL0ZYQUFGaWx0ZXIubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudW5pZm9ybSBmbG9hdCB1Tm9pc2U7XFxudW5pZm9ybSBmbG9hdCB1U2VlZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG5mbG9hdCByYW5kKHZlYzIgY28pXFxue1xcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcXG59XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICBmbG9hdCByYW5kb21WYWx1ZSA9IHJhbmQoZ2xfRnJhZ0Nvb3JkLnh5ICogdVNlZWQpO1xcbiAgICBmbG9hdCBkaWZmID0gKHJhbmRvbVZhbHVlIC0gMC41KSAqIHVOb2lzZTtcXG5cXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cXG4gICAgaWYgKGNvbG9yLmEgPiAwLjApIHtcXG4gICAgICAgIGNvbG9yLnJnYiAvPSBjb2xvci5hO1xcbiAgICB9XFxuXFxuICAgIGNvbG9yLnIgKz0gZGlmZjtcXG4gICAgY29sb3IuZyArPSBkaWZmO1xcbiAgICBjb2xvci5iICs9IGRpZmY7XFxuXFxuICAgIC8vIFByZW11bHRpcGx5IGFscGhhIGFnYWluLlxcbiAgICBjb2xvci5yZ2IgKj0gY29sb3IuYTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2lzZS5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIGRlZmF1bHRGaWx0ZXJWZXJ0ZXggfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL25vaXNlLm1qcyc7XG5cbmNsYXNzIE5vaXNlRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3Iobm9pc2UgPSAwLjUsIHNlZWQgPSBNYXRoLnJhbmRvbSgpKSB7XG4gICAgc3VwZXIoZGVmYXVsdEZpbHRlclZlcnRleCwgZnJhZ21lbnQsIHtcbiAgICAgIHVOb2lzZTogMCxcbiAgICAgIHVTZWVkOiAwXG4gICAgfSk7XG4gICAgdGhpcy5ub2lzZSA9IG5vaXNlO1xuICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gIH1cbiAgZ2V0IG5vaXNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVOb2lzZTtcbiAgfVxuICBzZXQgbm9pc2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVOb2lzZSA9IHZhbHVlO1xuICB9XG4gIGdldCBzZWVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTZWVkO1xuICB9XG4gIHNldCBzZWVkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U2VlZCA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCB7IE5vaXNlRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob2lzZUZpbHRlci5tanMubWFwXG4iLCJleHBvcnQgeyBOb2lzZUZpbHRlciB9IGZyb20gJy4vTm9pc2VGaWx0ZXIubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBBbHBoYUZpbHRlciB9IGZyb20gJ0BwaXhpL2ZpbHRlci1hbHBoYSc7XG5pbXBvcnQgeyBCbHVyRmlsdGVyLCBCbHVyRmlsdGVyUGFzcyB9IGZyb20gJ0BwaXhpL2ZpbHRlci1ibHVyJztcbmltcG9ydCB7IENvbG9yTWF0cml4RmlsdGVyIH0gZnJvbSAnQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeCc7XG5pbXBvcnQgeyBEaXNwbGFjZW1lbnRGaWx0ZXIgfSBmcm9tICdAcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50JztcbmltcG9ydCB7IEZYQUFGaWx0ZXIgfSBmcm9tICdAcGl4aS9maWx0ZXItZnhhYSc7XG5pbXBvcnQgeyBOb2lzZUZpbHRlciB9IGZyb20gJ0BwaXhpL2ZpbHRlci1ub2lzZSc7XG5cbmNvbnN0IGZpbHRlcnMgPSB7XG4gIEFscGhhRmlsdGVyLFxuICBCbHVyRmlsdGVyLFxuICBCbHVyRmlsdGVyUGFzcyxcbiAgQ29sb3JNYXRyaXhGaWx0ZXIsXG4gIERpc3BsYWNlbWVudEZpbHRlcixcbiAgRlhBQUZpbHRlcixcbiAgTm9pc2VGaWx0ZXJcbn07XG5PYmplY3QuZW50cmllcyhmaWx0ZXJzKS5mb3JFYWNoKChba2V5LCBGaWx0ZXJDbGFzc10pID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbHRlcnMsIGtleSwge1xuICAgIGdldCgpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgYGZpbHRlcnMuJHtrZXl9IGhhcyBtb3ZlZCB0byAke2tleX1gKTtcbiAgICAgIHJldHVybiBGaWx0ZXJDbGFzcztcbiAgICB9XG4gIH0pO1xufSk7XG5cbmV4cG9ydCB7IGZpbHRlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlcnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGlja2VyLCBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICdAcGl4aS9jb3JlJztcblxuY2xhc3MgRXZlbnRzVGlja2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gMTA7XG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLl9kaWRNb3ZlID0gZmFsc2U7XG4gICAgdGhpcy50aWNrZXJBZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhdXNlVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBpbml0KGV2ZW50cykge1xuICAgIHRoaXMucmVtb3ZlVGlja2VyTGlzdGVuZXIoKTtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gMTA7XG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLl9kaWRNb3ZlID0gZmFsc2U7XG4gICAgdGhpcy50aWNrZXJBZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhdXNlVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBnZXQgcGF1c2VVcGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlVXBkYXRlO1xuICB9XG4gIHNldCBwYXVzZVVwZGF0ZShwYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZVVwZGF0ZSA9IHBhdXNlZDtcbiAgfVxuICBhZGRUaWNrZXJMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy50aWNrZXJBZGRlZCB8fCAhdGhpcy5kb21FbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFRpY2tlci5zeXN0ZW0uYWRkKHRoaXMudGlja2VyVXBkYXRlLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuSU5URVJBQ1RJT04pO1xuICAgIHRoaXMudGlja2VyQWRkZWQgPSB0cnVlO1xuICB9XG4gIHJlbW92ZVRpY2tlckxpc3RlbmVyKCkge1xuICAgIGlmICghdGhpcy50aWNrZXJBZGRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUaWNrZXIuc3lzdGVtLnJlbW92ZSh0aGlzLnRpY2tlclVwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy50aWNrZXJBZGRlZCA9IGZhbHNlO1xuICB9XG4gIHBvaW50ZXJNb3ZlZCgpIHtcbiAgICB0aGlzLl9kaWRNb3ZlID0gdHJ1ZTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbUVsZW1lbnQgfHwgdGhpcy5fcGF1c2VVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpZE1vdmUpIHtcbiAgICAgIHRoaXMuX2RpZE1vdmUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdFBvaW50ZXJFdmVudCA9IHRoaXMuZXZlbnRzW1wicm9vdFBvaW50ZXJFdmVudFwiXTtcbiAgICBpZiAodGhpcy5ldmVudHMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiByb290UG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBQb2ludGVyRXZlbnQoXCJwb2ludGVybW92ZVwiLCB7XG4gICAgICBjbGllbnRYOiByb290UG9pbnRlckV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiByb290UG9pbnRlckV2ZW50LmNsaWVudFlcbiAgICB9KSk7XG4gIH1cbiAgdGlja2VyVXBkYXRlKGRlbHRhVGltZSkge1xuICAgIHRoaXMuX2RlbHRhVGltZSArPSBkZWx0YVRpbWU7XG4gICAgaWYgKHRoaXMuX2RlbHRhVGltZSA8IHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG59XG5jb25zdCBFdmVudHNUaWNrZXIgPSBuZXcgRXZlbnRzVGlja2VyQ2xhc3MoKTtcblxuZXhwb3J0IHsgRXZlbnRzVGlja2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFRpY2tlci5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jbGFzcyBGZWRlcmF0ZWRFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICB0aGlzLmJ1YmJsZXMgPSB0cnVlO1xuICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXBvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgdGhpcy5ldmVudFBoYXNlID0gRmVkZXJhdGVkRXZlbnQucHJvdG90eXBlLk5PTkU7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5sYXllciA9IG5ldyBQb2ludCgpO1xuICAgIHRoaXMucGFnZSA9IG5ldyBQb2ludCgpO1xuICAgIHRoaXMuTk9ORSA9IDA7XG4gICAgdGhpcy5DQVBUVVJJTkdfUEhBU0UgPSAxO1xuICAgIHRoaXMuQVRfVEFSR0VUID0gMjtcbiAgICB0aGlzLkJVQkJMSU5HX1BIQVNFID0gMztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICB9XG4gIGdldCBsYXllclgoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXIueDtcbiAgfVxuICBnZXQgbGF5ZXJZKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyLnk7XG4gIH1cbiAgZ2V0IHBhZ2VYKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UueDtcbiAgfVxuICBnZXQgcGFnZVkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS55O1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbXBvc2VkUGF0aCgpIHtcbiAgICBpZiAodGhpcy5tYW5hZ2VyICYmICghdGhpcy5wYXRoIHx8IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0gIT09IHRoaXMudGFyZ2V0KSkge1xuICAgICAgdGhpcy5wYXRoID0gdGhpcy50YXJnZXQgPyB0aGlzLm1hbmFnZXIucHJvcGFnYXRpb25QYXRoKHRoaXMudGFyZ2V0KSA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9XG4gIGluaXRFdmVudChfdHlwZSwgX2J1YmJsZXMsIF9jYW5jZWxhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5pdEV2ZW50KCkgaXMgYSBsZWdhY3kgRE9NIEFQSS4gSXQgaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSS5cIik7XG4gIH1cbiAgaW5pdFVJRXZlbnQoX3R5cGVBcmcsIF9idWJibGVzQXJnLCBfY2FuY2VsYWJsZUFyZywgX3ZpZXdBcmcsIF9kZXRhaWxBcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0VUlFdmVudCgpIGlzIGEgbGVnYWN5IERPTSBBUEkuIEl0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUEkuXCIpO1xuICB9XG4gIHByZXZlbnREZWZhdWx0KCkge1xuICAgIGlmICh0aGlzLm5hdGl2ZUV2ZW50IGluc3RhbmNlb2YgRXZlbnQgJiYgdGhpcy5uYXRpdmVFdmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICB0aGlzLm5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gIH1cbiAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSB0cnVlO1xuICB9XG4gIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmVkZXJhdGVkRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZEV2ZW50Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkRXZlbnQubWpzJztcblxuY2xhc3MgRmVkZXJhdGVkTW91c2VFdmVudCBleHRlbmRzIEZlZGVyYXRlZEV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBQb2ludCgpO1xuICAgIHRoaXMubW92ZW1lbnQgPSBuZXcgUG9pbnQoKTtcbiAgICB0aGlzLm9mZnNldCA9IG5ldyBQb2ludCgpO1xuICAgIHRoaXMuZ2xvYmFsID0gbmV3IFBvaW50KCk7XG4gICAgdGhpcy5zY3JlZW4gPSBuZXcgUG9pbnQoKTtcbiAgfVxuICBnZXQgY2xpZW50WCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQueDtcbiAgfVxuICBnZXQgY2xpZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQueTtcbiAgfVxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRYO1xuICB9XG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudFk7XG4gIH1cbiAgZ2V0IG1vdmVtZW50WCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC54O1xuICB9XG4gIGdldCBtb3ZlbWVudFkoKSB7XG4gICAgcmV0dXJuIHRoaXMubW92ZW1lbnQueTtcbiAgfVxuICBnZXQgb2Zmc2V0WCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQueDtcbiAgfVxuICBnZXQgb2Zmc2V0WSgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQueTtcbiAgfVxuICBnZXQgZ2xvYmFsWCgpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWwueDtcbiAgfVxuICBnZXQgZ2xvYmFsWSgpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWwueTtcbiAgfVxuICBnZXQgc2NyZWVuWCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4ueDtcbiAgfVxuICBnZXQgc2NyZWVuWSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4ueTtcbiAgfVxuICBnZXRMb2NhbFBvc2l0aW9uKGRpc3BsYXlPYmplY3QsIHBvaW50LCBnbG9iYWxQb3MpIHtcbiAgICByZXR1cm4gZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UoZ2xvYmFsUG9zIHx8IHRoaXMuZ2xvYmFsLCBwb2ludCk7XG4gIH1cbiAgZ2V0TW9kaWZpZXJTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gXCJnZXRNb2RpZmllclN0YXRlXCIgaW4gdGhpcy5uYXRpdmVFdmVudCAmJiB0aGlzLm5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5KTtcbiAgfVxuICBpbml0TW91c2VFdmVudChfdHlwZUFyZywgX2NhbkJ1YmJsZUFyZywgX2NhbmNlbGFibGVBcmcsIF92aWV3QXJnLCBfZGV0YWlsQXJnLCBfc2NyZWVuWEFyZywgX3NjcmVlbllBcmcsIF9jbGllbnRYQXJnLCBfY2xpZW50WUFyZywgX2N0cmxLZXlBcmcsIF9hbHRLZXlBcmcsIF9zaGlmdEtleUFyZywgX21ldGFLZXlBcmcsIF9idXR0b25BcmcsIF9yZWxhdGVkVGFyZ2V0QXJnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmVkZXJhdGVkTW91c2VFdmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkTW91c2VFdmVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5cbmNsYXNzIEZlZGVyYXRlZFBvaW50ZXJFdmVudCBleHRlbmRzIEZlZGVyYXRlZE1vdXNlRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xuICB9XG4gIGdldENvYWxlc2NlZEV2ZW50cygpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSBcInBvaW50ZXJtb3ZlXCIgfHwgdGhpcy50eXBlID09PSBcIm1vdXNlbW92ZVwiIHx8IHRoaXMudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIikge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldFByZWRpY3RlZEV2ZW50cygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRQcmVkaWN0ZWRFdmVudHMgaXMgbm90IHN1cHBvcnRlZCFcIik7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRQb2ludGVyRXZlbnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmVkZXJhdGVkTW91c2VFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkTW91c2VFdmVudC5tanMnO1xuXG5jbGFzcyBGZWRlcmF0ZWRXaGVlbEV2ZW50IGV4dGVuZHMgRmVkZXJhdGVkTW91c2VFdmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5ET01fREVMVEFfUElYRUwgPSAwO1xuICAgIHRoaXMuRE9NX0RFTFRBX0xJTkUgPSAxO1xuICAgIHRoaXMuRE9NX0RFTFRBX1BBR0UgPSAyO1xuICB9XG59XG5GZWRlcmF0ZWRXaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTCA9IDA7XG5GZWRlcmF0ZWRXaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FID0gMTtcbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UgPSAyO1xuXG5leHBvcnQgeyBGZWRlcmF0ZWRXaGVlbEV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRXaGVlbEV2ZW50Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50LCB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgRXZlbnRzVGlja2VyIH0gZnJvbSAnLi9FdmVudFRpY2tlci5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkTW91c2VFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkTW91c2VFdmVudC5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRQb2ludGVyRXZlbnQubWpzJztcbmltcG9ydCB7IEZlZGVyYXRlZFdoZWVsRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFdoZWVsRXZlbnQubWpzJztcblxuY29uc3QgUFJPUEFHQVRJT05fTElNSVQgPSAyMDQ4O1xuY29uc3QgdGVtcEhpdExvY2F0aW9uID0gbmV3IFBvaW50KCk7XG5jb25zdCB0ZW1wTG9jYWxNYXBwaW5nID0gbmV3IFBvaW50KCk7XG5jbGFzcyBFdmVudEJvdW5kYXJ5IHtcbiAgY29uc3RydWN0b3Iocm9vdFRhcmdldCkge1xuICAgIHRoaXMuZGlzcGF0Y2ggPSBuZXcgdXRpbHMuRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5tb3ZlT25BbGwgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPSB0cnVlO1xuICAgIHRoaXMubWFwcGluZ1N0YXRlID0ge1xuICAgICAgdHJhY2tpbmdEYXRhOiB7fVxuICAgIH07XG4gICAgdGhpcy5ldmVudFBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9oaXRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX2lzUG9pbnRlck1vdmVFdmVudCA9IGZhbHNlO1xuICAgIHRoaXMucm9vdFRhcmdldCA9IHJvb3RUYXJnZXQ7XG4gICAgdGhpcy5oaXRQcnVuZUZuID0gdGhpcy5oaXRQcnVuZUZuLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oaXRUZXN0Rm4gPSB0aGlzLmhpdFRlc3RGbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwUG9pbnRlckRvd24gPSB0aGlzLm1hcFBvaW50ZXJEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyTW92ZSA9IHRoaXMubWFwUG9pbnRlck1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJPdXQgPSB0aGlzLm1hcFBvaW50ZXJPdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJPdmVyID0gdGhpcy5tYXBQb2ludGVyT3Zlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwUG9pbnRlclVwID0gdGhpcy5tYXBQb2ludGVyVXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJVcE91dHNpZGUgPSB0aGlzLm1hcFBvaW50ZXJVcE91dHNpZGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFdoZWVsID0gdGhpcy5tYXBXaGVlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwcGluZ1RhYmxlID0ge307XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVyZG93blwiLCB0aGlzLm1hcFBvaW50ZXJEb3duKTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJtb3ZlXCIsIHRoaXMubWFwUG9pbnRlck1vdmUpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcm91dFwiLCB0aGlzLm1hcFBvaW50ZXJPdXQpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMubWFwUG9pbnRlck91dCk7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVyb3ZlclwiLCB0aGlzLm1hcFBvaW50ZXJPdmVyKTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJ1cFwiLCB0aGlzLm1hcFBvaW50ZXJVcCk7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVydXBvdXRzaWRlXCIsIHRoaXMubWFwUG9pbnRlclVwT3V0c2lkZSk7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJ3aGVlbFwiLCB0aGlzLm1hcFdoZWVsKTtcbiAgfVxuICBhZGRFdmVudE1hcHBpbmcodHlwZSwgZm4pIHtcbiAgICBpZiAoIXRoaXMubWFwcGluZ1RhYmxlW3R5cGVdKSB7XG4gICAgICB0aGlzLm1hcHBpbmdUYWJsZVt0eXBlXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLm1hcHBpbmdUYWJsZVt0eXBlXS5wdXNoKHtcbiAgICAgIGZuLFxuICAgICAgcHJpb3JpdHk6IDBcbiAgICB9KTtcbiAgICB0aGlzLm1hcHBpbmdUYWJsZVt0eXBlXS5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gIH1cbiAgZGlzcGF0Y2hFdmVudChlLCB0eXBlKSB7XG4gICAgZS5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wYWdhdGUoZSwgdHlwZSk7XG4gICAgdGhpcy5kaXNwYXRjaC5lbWl0KHR5cGUgfHwgZS50eXBlLCBlKTtcbiAgfVxuICBtYXBFdmVudChlKSB7XG4gICAgaWYgKCF0aGlzLnJvb3RUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFwcGVycyA9IHRoaXMubWFwcGluZ1RhYmxlW2UudHlwZV07XG4gICAgaWYgKG1hcHBlcnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gbWFwcGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgbWFwcGVyc1tpXS5mbihlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBbRXZlbnRCb3VuZGFyeV06IEV2ZW50IG1hcHBpbmcgbm90IGRlZmluZWQgZm9yICR7ZS50eXBlfWApO1xuICAgIH1cbiAgfVxuICBoaXRUZXN0KHgsIHkpIHtcbiAgICBFdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSB0cnVlO1xuICAgIGNvbnN0IHVzZU1vdmUgPSB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgJiYgdGhpcy5lbmFibGVHbG9iYWxNb3ZlRXZlbnRzO1xuICAgIGNvbnN0IGZuID0gdXNlTW92ZSA/IFwiaGl0VGVzdE1vdmVSZWN1cnNpdmVcIiA6IFwiaGl0VGVzdFJlY3Vyc2l2ZVwiO1xuICAgIGNvbnN0IGludmVydGVkUGF0aCA9IHRoaXNbZm5dKHRoaXMucm9vdFRhcmdldCwgdGhpcy5yb290VGFyZ2V0LmV2ZW50TW9kZSwgdGVtcEhpdExvY2F0aW9uLnNldCh4LCB5KSwgdGhpcy5oaXRUZXN0Rm4sIHRoaXMuaGl0UHJ1bmVGbik7XG4gICAgcmV0dXJuIGludmVydGVkUGF0aCAmJiBpbnZlcnRlZFBhdGhbMF07XG4gIH1cbiAgcHJvcGFnYXRlKGUsIHR5cGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGUuY29tcG9zZWRQYXRoKCk7XG4gICAgZS5ldmVudFBoYXNlID0gZS5DQVBUVVJJTkdfUEhBU0U7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBjb21wb3NlZFBhdGgubGVuZ3RoIC0gMTsgaSA8IGo7IGkrKykge1xuICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY29tcG9zZWRQYXRoW2ldO1xuICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgdHlwZSk7XG4gICAgICBpZiAoZS5wcm9wYWdhdGlvblN0b3BwZWQgfHwgZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLmV2ZW50UGhhc2UgPSBlLkFUX1RBUkdFVDtcbiAgICBlLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKTtcbiAgICBpZiAoZS5wcm9wYWdhdGlvblN0b3BwZWQgfHwgZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZClcbiAgICAgIHJldHVybjtcbiAgICBlLmV2ZW50UGhhc2UgPSBlLkJVQkJMSU5HX1BIQVNFO1xuICAgIGZvciAobGV0IGkgPSBjb21wb3NlZFBhdGgubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGUuY3VycmVudFRhcmdldCA9IGNvbXBvc2VkUGF0aFtpXTtcbiAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIHR5cGUpO1xuICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgYWxsKGUsIHR5cGUsIHRhcmdldHMgPSB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGUuZXZlbnRQaGFzZSA9IGUuQlVCQkxJTkdfUEhBU0U7XG4gICAgY29uc3QgZXZlbnRzID0gQXJyYXkuaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcHJvcGFnYXRpb25QYXRoKHRhcmdldCkge1xuICAgIGNvbnN0IHByb3BhZ2F0aW9uUGF0aCA9IFt0YXJnZXRdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJPUEFHQVRJT05fTElNSVQgJiYgdGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQ7IGkrKykge1xuICAgICAgaWYgKCF0YXJnZXQucGFyZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHByb3BhZ2F0aW9uIHBhdGggdG8gZGlzY29ubmVjdGVkIHRhcmdldFwiKTtcbiAgICAgIH1cbiAgICAgIHByb3BhZ2F0aW9uUGF0aC5wdXNoKHRhcmdldC5wYXJlbnQpO1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcbiAgICB9XG4gICAgcHJvcGFnYXRpb25QYXRoLnJldmVyc2UoKTtcbiAgICByZXR1cm4gcHJvcGFnYXRpb25QYXRoO1xuICB9XG4gIGhpdFRlc3RNb3ZlUmVjdXJzaXZlKGN1cnJlbnRUYXJnZXQsIGV2ZW50TW9kZSwgbG9jYXRpb24sIHRlc3RGbiwgcHJ1bmVGbiwgaWdub3JlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5faW50ZXJhY3RpdmVQcnVuZShjdXJyZW50VGFyZ2V0KSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChjdXJyZW50VGFyZ2V0LmV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCIgfHwgZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgRXZlbnRzVGlja2VyLnBhdXNlVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VGFyZ2V0LmludGVyYWN0aXZlQ2hpbGRyZW4gJiYgY3VycmVudFRhcmdldC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuO1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IG5lc3RlZEhpdCA9IHRoaXMuaGl0VGVzdE1vdmVSZWN1cnNpdmUoY2hpbGQsIHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKSA/IGV2ZW50TW9kZSA6IGNoaWxkLmV2ZW50TW9kZSwgbG9jYXRpb24sIHRlc3RGbiwgcHJ1bmVGbiwgcHJ1bmVGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikpO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICBpZiAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgfHwgaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGlzSW50ZXJhY3RpdmUpXG4gICAgICAgICAgICAgIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMucHVzaChjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIG5lc3RlZEhpdC5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhpcy5faGl0RWxlbWVudHMgPSBuZXN0ZWRIaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZU1vZGUgPSB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSk7XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZVRhcmdldCA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgIGlmIChpc0ludGVyYWN0aXZlVGFyZ2V0ICYmIGlzSW50ZXJhY3RpdmVUYXJnZXQpXG4gICAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLnB1c2goY3VycmVudFRhcmdldCk7XG4gICAgaWYgKGlnbm9yZSB8fCB0aGlzLl9oaXRFbGVtZW50cy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlzSW50ZXJhY3RpdmVNb2RlICYmICghcHJ1bmVGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikgJiYgdGVzdEZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSkpIHtcbiAgICAgIHJldHVybiBpc0ludGVyYWN0aXZlVGFyZ2V0ID8gW2N1cnJlbnRUYXJnZXRdIDogW107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhpdFRlc3RSZWN1cnNpdmUoY3VycmVudFRhcmdldCwgZXZlbnRNb2RlLCBsb2NhdGlvbiwgdGVzdEZuLCBwcnVuZUZuKSB7XG4gICAgaWYgKHRoaXMuX2ludGVyYWN0aXZlUHJ1bmUoY3VycmVudFRhcmdldCkgfHwgcHJ1bmVGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRhcmdldC5ldmVudE1vZGUgPT09IFwiZHluYW1pY1wiIHx8IGV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgIEV2ZW50c1RpY2tlci5wYXVzZVVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRhcmdldC5pbnRlcmFjdGl2ZUNoaWxkcmVuICYmIGN1cnJlbnRUYXJnZXQuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY3VycmVudFRhcmdldC5jaGlsZHJlbjtcbiAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBjb25zdCBuZXN0ZWRIaXQgPSB0aGlzLmhpdFRlc3RSZWN1cnNpdmUoY2hpbGQsIHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKSA/IGV2ZW50TW9kZSA6IGNoaWxkLmV2ZW50TW9kZSwgbG9jYXRpb24sIHRlc3RGbiwgcHJ1bmVGbik7XG4gICAgICAgIGlmIChuZXN0ZWRIaXQpIHtcbiAgICAgICAgICBpZiAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgJiYgIW5lc3RlZEhpdFtuZXN0ZWRIaXQubGVuZ3RoIC0gMV0ucGFyZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNJbnRlcmFjdGl2ZSA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgICAgICAgIGlmIChuZXN0ZWRIaXQubGVuZ3RoID4gMCB8fCBpc0ludGVyYWN0aXZlKVxuICAgICAgICAgICAgbmVzdGVkSGl0LnB1c2goY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIG5lc3RlZEhpdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc0ludGVyYWN0aXZlTW9kZSA9IHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKTtcbiAgICBjb25zdCBpc0ludGVyYWN0aXZlVGFyZ2V0ID0gY3VycmVudFRhcmdldC5pc0ludGVyYWN0aXZlKCk7XG4gICAgaWYgKGlzSW50ZXJhY3RpdmVNb2RlICYmIHRlc3RGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikpIHtcbiAgICAgIHJldHVybiBpc0ludGVyYWN0aXZlVGFyZ2V0ID8gW2N1cnJlbnRUYXJnZXRdIDogW107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9pc0ludGVyYWN0aXZlKGludCkge1xuICAgIHJldHVybiBpbnQgPT09IFwic3RhdGljXCIgfHwgaW50ID09PSBcImR5bmFtaWNcIjtcbiAgfVxuICBfaW50ZXJhY3RpdmVQcnVuZShkaXNwbGF5T2JqZWN0KSB7XG4gICAgaWYgKCFkaXNwbGF5T2JqZWN0IHx8IGRpc3BsYXlPYmplY3QuaXNNYXNrIHx8ICFkaXNwbGF5T2JqZWN0LnZpc2libGUgfHwgIWRpc3BsYXlPYmplY3QucmVuZGVyYWJsZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5T2JqZWN0LmV2ZW50TW9kZSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5ldmVudE1vZGUgPT09IFwicGFzc2l2ZVwiICYmICFkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5pc01hc2spIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGl0UHJ1bmVGbihkaXNwbGF5T2JqZWN0LCBsb2NhdGlvbikge1xuICAgIGlmIChkaXNwbGF5T2JqZWN0LmhpdEFyZWEpIHtcbiAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKGxvY2F0aW9uLCB0ZW1wTG9jYWxNYXBwaW5nKTtcbiAgICAgIGlmICghZGlzcGxheU9iamVjdC5oaXRBcmVhLmNvbnRhaW5zKHRlbXBMb2NhbE1hcHBpbmcueCwgdGVtcExvY2FsTWFwcGluZy55KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2tPYmplY3QgPSBkaXNwbGF5T2JqZWN0Ll9tYXNrLmlzTWFza0RhdGEgPyBkaXNwbGF5T2JqZWN0Ll9tYXNrLm1hc2tPYmplY3QgOiBkaXNwbGF5T2JqZWN0Ll9tYXNrO1xuICAgICAgaWYgKG1hc2tPYmplY3QgJiYgIW1hc2tPYmplY3QuY29udGFpbnNQb2ludD8uKGxvY2F0aW9uKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhpdFRlc3RGbihkaXNwbGF5T2JqZWN0LCBsb2NhdGlvbikge1xuICAgIGlmIChkaXNwbGF5T2JqZWN0LmV2ZW50TW9kZSA9PT0gXCJwYXNzaXZlXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuaGl0QXJlYSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQpIHtcbiAgICAgIHJldHVybiBkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQobG9jYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbm90aWZ5VGFyZ2V0KGUsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSA/PyBlLnR5cGU7XG4gICAgY29uc3QgaGFuZGxlcktleSA9IGBvbiR7dHlwZX1gO1xuICAgIGUuY3VycmVudFRhcmdldFtoYW5kbGVyS2V5XT8uKGUpO1xuICAgIGNvbnN0IGtleSA9IGUuZXZlbnRQaGFzZSA9PT0gZS5DQVBUVVJJTkdfUEhBU0UgfHwgZS5ldmVudFBoYXNlID09PSBlLkFUX1RBUkdFVCA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlO1xuICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGUsIGtleSk7XG4gICAgaWYgKGUuZXZlbnRQaGFzZSA9PT0gZS5BVF9UQVJHRVQpIHtcbiAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpO1xuICAgIH1cbiAgfVxuICBtYXBQb2ludGVyRG93bihmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInBvaW50ZXJkb3duXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInRvdWNoc3RhcnRcIik7XG4gICAgfSBlbHNlIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIikge1xuICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0ZG93blwiIDogXCJtb3VzZWRvd25cIik7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dID0gZS5jb21wb3NlZFBhdGgoKTtcbiAgICB0aGlzLmZyZWVFdmVudChlKTtcbiAgfVxuICBtYXBQb2ludGVyTW92ZShmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gdHJ1ZTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gZmFsc2U7XG4gICAgY29uc3QgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBvdXRUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cz8ubGVuZ3RoID4gMCAmJiBvdXRUYXJnZXQgIT09IGUudGFyZ2V0KSB7XG4gICAgICBjb25zdCBvdXRUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW91dFwiIDogXCJwb2ludGVyb3V0XCI7XG4gICAgICBjb25zdCBvdXRFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIG91dFR5cGUsIG91dFRhcmdldCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwicG9pbnRlcm91dFwiKTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwibW91c2VvdXRcIik7XG4gICAgICBpZiAoIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMob3V0VGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBsZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVybGVhdmVcIiwgb3V0VGFyZ2V0KTtcbiAgICAgICAgbGVhdmVFdmVudC5ldmVudFBoYXNlID0gbGVhdmVFdmVudC5BVF9UQVJHRVQ7XG4gICAgICAgIHdoaWxlIChsZWF2ZUV2ZW50LnRhcmdldCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhsZWF2ZUV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBsZWF2ZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50KTtcbiAgICAgICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgICBsZWF2ZUV2ZW50LnRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVFdmVudChsZWF2ZUV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG91dEV2ZW50KTtcbiAgICB9XG4gICAgaWYgKG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgIGNvbnN0IG92ZXJUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW92ZXJcIiA6IFwicG9pbnRlcm92ZXJcIjtcbiAgICAgIGNvbnN0IG92ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgb3ZlclR5cGUpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG92ZXJFdmVudCwgXCJwb2ludGVyb3ZlclwiKTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3ZlckV2ZW50LCBcIm1vdXNlb3ZlclwiKTtcbiAgICAgIGxldCBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdXRUYXJnZXQ/LnBhcmVudDtcbiAgICAgIHdoaWxlIChvdmVyVGFyZ2V0QW5jZXN0b3IgJiYgb3ZlclRhcmdldEFuY2VzdG9yICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICAgIGlmIChvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IGUudGFyZ2V0KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdmVyVGFyZ2V0QW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgZGlkUG9pbnRlckVudGVyID0gIW92ZXJUYXJnZXRBbmNlc3RvciB8fCBvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQ7XG4gICAgICBpZiAoZGlkUG9pbnRlckVudGVyKSB7XG4gICAgICAgIGNvbnN0IGVudGVyRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIFwicG9pbnRlcmVudGVyXCIpO1xuICAgICAgICBlbnRlckV2ZW50LmV2ZW50UGhhc2UgPSBlbnRlckV2ZW50LkFUX1RBUkdFVDtcbiAgICAgICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSBvdXRUYXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQpIHtcbiAgICAgICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50KTtcbiAgICAgICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQsIFwibW91c2VlbnRlclwiKTtcbiAgICAgICAgICBlbnRlckV2ZW50LnRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVFdmVudChlbnRlckV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG92ZXJFdmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGFsbE1ldGhvZHMgPSBbXTtcbiAgICBjb25zdCBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgPSB0aGlzLmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPz8gdHJ1ZTtcbiAgICB0aGlzLm1vdmVPbkFsbCA/IGFsbE1ldGhvZHMucHVzaChcInBvaW50ZXJtb3ZlXCIpIDogdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcm1vdmVcIik7XG4gICAgYWxsb3dHbG9iYWxQb2ludGVyRXZlbnRzICYmIGFsbE1ldGhvZHMucHVzaChcImdsb2JhbHBvaW50ZXJtb3ZlXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHRoaXMubW92ZU9uQWxsID8gYWxsTWV0aG9kcy5zcGxpY2UoMSwgMCwgXCJ0b3VjaG1vdmVcIikgOiB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJ0b3VjaG1vdmVcIik7XG4gICAgICBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgJiYgYWxsTWV0aG9kcy5wdXNoKFwiZ2xvYmFsdG91Y2htb3ZlXCIpO1xuICAgIH1cbiAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgdGhpcy5tb3ZlT25BbGwgPyBhbGxNZXRob2RzLnNwbGljZSgxLCAwLCBcIm1vdXNlbW92ZVwiKSA6IHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcIm1vdXNlbW92ZVwiKTtcbiAgICAgIGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyAmJiBhbGxNZXRob2RzLnB1c2goXCJnbG9iYWxtb3VzZW1vdmVcIik7XG4gICAgICB0aGlzLmN1cnNvciA9IGUudGFyZ2V0Py5jdXJzb3I7XG4gICAgfVxuICAgIGlmIChhbGxNZXRob2RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWxsKGUsIGFsbE1ldGhvZHMpO1xuICAgIH1cbiAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIG1hcFBvaW50ZXJPdmVyKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pO1xuICAgIGNvbnN0IGlzTW91c2UgPSBlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIjtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJwb2ludGVyb3ZlclwiKTtcbiAgICBpZiAoaXNNb3VzZSlcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcIm1vdXNlb3ZlclwiKTtcbiAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKVxuICAgICAgdGhpcy5jdXJzb3IgPSBlLnRhcmdldD8uY3Vyc29yO1xuICAgIGNvbnN0IGVudGVyRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIFwicG9pbnRlcmVudGVyXCIpO1xuICAgIGVudGVyRXZlbnQuZXZlbnRQaGFzZSA9IGVudGVyRXZlbnQuQVRfVEFSR0VUO1xuICAgIHdoaWxlIChlbnRlckV2ZW50LnRhcmdldCAmJiBlbnRlckV2ZW50LnRhcmdldCAhPT0gdGhpcy5yb290VGFyZ2V0LnBhcmVudCkge1xuICAgICAgZW50ZXJFdmVudC5jdXJyZW50VGFyZ2V0ID0gZW50ZXJFdmVudC50YXJnZXQ7XG4gICAgICB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50KTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50LCBcIm1vdXNlZW50ZXJcIik7XG4gICAgICBlbnRlckV2ZW50LnRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICB9XG4gICAgdHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzID0gZS5jb21wb3NlZFBhdGgoKTtcbiAgICB0aGlzLmZyZWVFdmVudChlKTtcbiAgICB0aGlzLmZyZWVFdmVudChlbnRlckV2ZW50KTtcbiAgfVxuICBtYXBQb2ludGVyT3V0KGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cykge1xuICAgICAgY29uc3QgaXNNb3VzZSA9IGZyb20ucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBmcm9tLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgICAgY29uc3Qgb3V0VGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEub3ZlclRhcmdldHMpO1xuICAgICAgY29uc3Qgb3V0RXZlbnQgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCBcInBvaW50ZXJvdXRcIiwgb3V0VGFyZ2V0KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChvdXRFdmVudCk7XG4gICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG91dEV2ZW50LCBcIm1vdXNlb3V0XCIpO1xuICAgICAgY29uc3QgbGVhdmVFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIFwicG9pbnRlcmxlYXZlXCIsIG91dFRhcmdldCk7XG4gICAgICBsZWF2ZUV2ZW50LmV2ZW50UGhhc2UgPSBsZWF2ZUV2ZW50LkFUX1RBUkdFVDtcbiAgICAgIHdoaWxlIChsZWF2ZUV2ZW50LnRhcmdldCAmJiBsZWF2ZUV2ZW50LnRhcmdldCAhPT0gdGhpcy5yb290VGFyZ2V0LnBhcmVudCkge1xuICAgICAgICBsZWF2ZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCk7XG4gICAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgbGVhdmVFdmVudC50YXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBudWxsO1xuICAgICAgdGhpcy5mcmVlRXZlbnQob3V0RXZlbnQpO1xuICAgICAgdGhpcy5mcmVlRXZlbnQobGVhdmVFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgfVxuICBtYXBQb2ludGVyVXAoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJwb2ludGVydXBcIik7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2hlbmRcIik7XG4gICAgfSBlbHNlIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIikge1xuICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0dXBcIiA6IFwibW91c2V1cFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIGNvbnN0IHByZXNzVGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dKTtcbiAgICBsZXQgY2xpY2tUYXJnZXQgPSBwcmVzc1RhcmdldDtcbiAgICBpZiAocHJlc3NUYXJnZXQgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMocHJlc3NUYXJnZXQpKSB7XG4gICAgICBsZXQgY3VycmVudFRhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgICAgd2hpbGUgKGN1cnJlbnRUYXJnZXQgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoY3VycmVudFRhcmdldCkpIHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJwb2ludGVydXBvdXRzaWRlXCIpO1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJ0b3VjaGVuZG91dHNpZGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHR1cG91dHNpZGVcIiA6IFwibW91c2V1cG91dHNpZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQucGFyZW50O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl07XG4gICAgICBjbGlja1RhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChjbGlja1RhcmdldCkge1xuICAgICAgY29uc3QgY2xpY2tFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJjbGlja1wiKTtcbiAgICAgIGNsaWNrRXZlbnQudGFyZ2V0ID0gY2xpY2tUYXJnZXQ7XG4gICAgICBjbGlja0V2ZW50LnBhdGggPSBudWxsO1xuICAgICAgaWYgKCF0cmFja2luZ0RhdGEuY2xpY2tzQnlCdXR0b25bZnJvbS5idXR0b25dKSB7XG4gICAgICAgIHRyYWNraW5nRGF0YS5jbGlja3NCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gPSB7XG4gICAgICAgICAgY2xpY2tDb3VudDogMCxcbiAgICAgICAgICB0YXJnZXQ6IGNsaWNrRXZlbnQudGFyZ2V0LFxuICAgICAgICAgIHRpbWVTdGFtcDogbm93XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjbGlja0hpc3RvcnkgPSB0cmFja2luZ0RhdGEuY2xpY2tzQnlCdXR0b25bZnJvbS5idXR0b25dO1xuICAgICAgaWYgKGNsaWNrSGlzdG9yeS50YXJnZXQgPT09IGNsaWNrRXZlbnQudGFyZ2V0ICYmIG5vdyAtIGNsaWNrSGlzdG9yeS50aW1lU3RhbXAgPCAyMDApIHtcbiAgICAgICAgKytjbGlja0hpc3RvcnkuY2xpY2tDb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWNrSGlzdG9yeS5jbGlja0NvdW50ID0gMTtcbiAgICAgIH1cbiAgICAgIGNsaWNrSGlzdG9yeS50YXJnZXQgPSBjbGlja0V2ZW50LnRhcmdldDtcbiAgICAgIGNsaWNrSGlzdG9yeS50aW1lU3RhbXAgPSBub3c7XG4gICAgICBjbGlja0V2ZW50LmRldGFpbCA9IGNsaWNrSGlzdG9yeS5jbGlja0NvdW50O1xuICAgICAgaWYgKGNsaWNrRXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIikge1xuICAgICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gY2xpY2tFdmVudC5idXR0b24gPT09IDI7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50LCBpc1JpZ2h0QnV0dG9uID8gXCJyaWdodGNsaWNrXCIgOiBcImNsaWNrXCIpO1xuICAgICAgfSBlbHNlIGlmIChjbGlja0V2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsIFwidGFwXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsIFwicG9pbnRlcnRhcFwiKTtcbiAgICAgIHRoaXMuZnJlZUV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmZyZWVFdmVudChlKTtcbiAgfVxuICBtYXBQb2ludGVyVXBPdXRzaWRlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgY29uc3QgcHJlc3NUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0pO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICBpZiAocHJlc3NUYXJnZXQpIHtcbiAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgICB3aGlsZSAoY3VycmVudFRhcmdldCkge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBcInBvaW50ZXJ1cG91dHNpZGVcIik7XG4gICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBcInRvdWNoZW5kb3V0c2lkZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIGUuYnV0dG9uID09PSAyID8gXCJyaWdodHVwb3V0c2lkZVwiIDogXCJtb3VzZXVwb3V0c2lkZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBkZWxldGUgdHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXTtcbiAgICB9XG4gICAgdGhpcy5mcmVlRXZlbnQoZSk7XG4gIH1cbiAgbWFwV2hlZWwoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRXaGVlbEV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXdoZWVsIGV2ZW50IGFzIGEgd2hlZWwgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSB0aGlzLmNyZWF0ZVdoZWVsRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHdoZWVsRXZlbnQpO1xuICAgIHRoaXMuZnJlZUV2ZW50KHdoZWVsRXZlbnQpO1xuICB9XG4gIGZpbmRNb3VudGVkVGFyZ2V0KHByb3BhZ2F0aW9uUGF0aCkge1xuICAgIGlmICghcHJvcGFnYXRpb25QYXRoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRUYXJnZXQgPSBwcm9wYWdhdGlvblBhdGhbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wYWdhdGlvblBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcm9wYWdhdGlvblBhdGhbaV0ucGFyZW50ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBwcm9wYWdhdGlvblBhdGhbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQ7XG4gIH1cbiAgY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIHR5cGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgdGhpcy5jb3B5UG9pbnRlckRhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tO1xuICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldCA/PyB0aGlzLmhpdFRlc3QoZXZlbnQuZ2xvYmFsLngsIGV2ZW50Lmdsb2JhbC55KSA/PyB0aGlzLl9oaXRFbGVtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgY3JlYXRlV2hlZWxFdmVudChmcm9tKSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmFsbG9jYXRlRXZlbnQoRmVkZXJhdGVkV2hlZWxFdmVudCk7XG4gICAgdGhpcy5jb3B5V2hlZWxEYXRhKGZyb20sIGV2ZW50KTtcbiAgICB0aGlzLmNvcHlNb3VzZURhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weURhdGEoZnJvbSwgZXZlbnQpO1xuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudDtcbiAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gZnJvbTtcbiAgICBldmVudC50YXJnZXQgPSB0aGlzLmhpdFRlc3QoZXZlbnQuZ2xvYmFsLngsIGV2ZW50Lmdsb2JhbC55KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgY2xvbmVQb2ludGVyRXZlbnQoZnJvbSwgdHlwZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tLm9yaWdpbmFsRXZlbnQ7XG4gICAgdGhpcy5jb3B5UG9pbnRlckRhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQudGFyZ2V0ID0gZnJvbS50YXJnZXQ7XG4gICAgZXZlbnQucGF0aCA9IGZyb20uY29tcG9zZWRQYXRoKCkuc2xpY2UoKTtcbiAgICBldmVudC50eXBlID0gdHlwZSA/PyBldmVudC50eXBlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBjb3B5V2hlZWxEYXRhKGZyb20sIHRvKSB7XG4gICAgdG8uZGVsdGFNb2RlID0gZnJvbS5kZWx0YU1vZGU7XG4gICAgdG8uZGVsdGFYID0gZnJvbS5kZWx0YVg7XG4gICAgdG8uZGVsdGFZID0gZnJvbS5kZWx0YVk7XG4gICAgdG8uZGVsdGFaID0gZnJvbS5kZWx0YVo7XG4gIH1cbiAgY29weVBvaW50ZXJEYXRhKGZyb20sIHRvKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCAmJiB0byBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCkpXG4gICAgICByZXR1cm47XG4gICAgdG8ucG9pbnRlcklkID0gZnJvbS5wb2ludGVySWQ7XG4gICAgdG8ud2lkdGggPSBmcm9tLndpZHRoO1xuICAgIHRvLmhlaWdodCA9IGZyb20uaGVpZ2h0O1xuICAgIHRvLmlzUHJpbWFyeSA9IGZyb20uaXNQcmltYXJ5O1xuICAgIHRvLnBvaW50ZXJUeXBlID0gZnJvbS5wb2ludGVyVHlwZTtcbiAgICB0by5wcmVzc3VyZSA9IGZyb20ucHJlc3N1cmU7XG4gICAgdG8udGFuZ2VudGlhbFByZXNzdXJlID0gZnJvbS50YW5nZW50aWFsUHJlc3N1cmU7XG4gICAgdG8udGlsdFggPSBmcm9tLnRpbHRYO1xuICAgIHRvLnRpbHRZID0gZnJvbS50aWx0WTtcbiAgICB0by50d2lzdCA9IGZyb20udHdpc3Q7XG4gIH1cbiAgY29weU1vdXNlRGF0YShmcm9tLCB0bykge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRNb3VzZUV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkTW91c2VFdmVudCkpXG4gICAgICByZXR1cm47XG4gICAgdG8uYWx0S2V5ID0gZnJvbS5hbHRLZXk7XG4gICAgdG8uYnV0dG9uID0gZnJvbS5idXR0b247XG4gICAgdG8uYnV0dG9ucyA9IGZyb20uYnV0dG9ucztcbiAgICB0by5jbGllbnQuY29weUZyb20oZnJvbS5jbGllbnQpO1xuICAgIHRvLmN0cmxLZXkgPSBmcm9tLmN0cmxLZXk7XG4gICAgdG8ubWV0YUtleSA9IGZyb20ubWV0YUtleTtcbiAgICB0by5tb3ZlbWVudC5jb3B5RnJvbShmcm9tLm1vdmVtZW50KTtcbiAgICB0by5zY3JlZW4uY29weUZyb20oZnJvbS5zY3JlZW4pO1xuICAgIHRvLnNoaWZ0S2V5ID0gZnJvbS5zaGlmdEtleTtcbiAgICB0by5nbG9iYWwuY29weUZyb20oZnJvbS5nbG9iYWwpO1xuICB9XG4gIGNvcHlEYXRhKGZyb20sIHRvKSB7XG4gICAgdG8uaXNUcnVzdGVkID0gZnJvbS5pc1RydXN0ZWQ7XG4gICAgdG8uc3JjRWxlbWVudCA9IGZyb20uc3JjRWxlbWVudDtcbiAgICB0by50aW1lU3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0by50eXBlID0gZnJvbS50eXBlO1xuICAgIHRvLmRldGFpbCA9IGZyb20uZGV0YWlsO1xuICAgIHRvLnZpZXcgPSBmcm9tLnZpZXc7XG4gICAgdG8ud2hpY2ggPSBmcm9tLndoaWNoO1xuICAgIHRvLmxheWVyLmNvcHlGcm9tKGZyb20ubGF5ZXIpO1xuICAgIHRvLnBhZ2UuY29weUZyb20oZnJvbS5wYWdlKTtcbiAgfVxuICB0cmFja2luZ0RhdGEoaWQpIHtcbiAgICBpZiAoIXRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF0pIHtcbiAgICAgIHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF0gPSB7XG4gICAgICAgIHByZXNzVGFyZ2V0c0J5QnV0dG9uOiB7fSxcbiAgICAgICAgY2xpY2tzQnlCdXR0b246IHt9LFxuICAgICAgICBvdmVyVGFyZ2V0OiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXBwaW5nU3RhdGUudHJhY2tpbmdEYXRhW2lkXTtcbiAgfVxuICBhbGxvY2F0ZUV2ZW50KGNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50UG9vbC5oYXMoY29uc3RydWN0b3IpKSB7XG4gICAgICB0aGlzLmV2ZW50UG9vbC5zZXQoY29uc3RydWN0b3IsIFtdKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmV2ZW50UG9vbC5nZXQoY29uc3RydWN0b3IpLnBvcCgpIHx8IG5ldyBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICBldmVudC5ldmVudFBoYXNlID0gZXZlbnQuTk9ORTtcbiAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICBldmVudC5wYXRoID0gbnVsbDtcbiAgICBldmVudC50YXJnZXQgPSBudWxsO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBmcmVlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQubWFuYWdlciAhPT0gdGhpcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGlzIGlsbGVnYWwgdG8gZnJlZSBhbiBldmVudCBub3QgbWFuYWdlZCBieSB0aGlzIEV2ZW50Qm91bmRhcnkhXCIpO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZXZlbnQuY29uc3RydWN0b3I7XG4gICAgaWYgKCF0aGlzLmV2ZW50UG9vbC5oYXMoY29uc3RydWN0b3IpKSB7XG4gICAgICB0aGlzLmV2ZW50UG9vbC5zZXQoY29uc3RydWN0b3IsIFtdKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudFBvb2wuZ2V0KGNvbnN0cnVjdG9yKS5wdXNoKGV2ZW50KTtcbiAgfVxuICBub3RpZnlMaXN0ZW5lcnMoZSwgdHlwZSkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGUuY3VycmVudFRhcmdldC5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoXCJmblwiIGluIGxpc3RlbmVycykge1xuICAgICAgaWYgKGxpc3RlbmVycy5vbmNlKVxuICAgICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzLmZuLCB2b2lkIDAsIHRydWUpO1xuICAgICAgbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBqICYmICFlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKVxuICAgICAgICAgIGUuY3VycmVudFRhcmdldC5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0uZm4sIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgRXZlbnRCb3VuZGFyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRCb3VuZGFyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBFdmVudEJvdW5kYXJ5IH0gZnJvbSAnLi9FdmVudEJvdW5kYXJ5Lm1qcyc7XG5pbXBvcnQgeyBFdmVudHNUaWNrZXIgfSBmcm9tICcuL0V2ZW50VGlja2VyLm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkV2hlZWxFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuXG5jb25zdCBNT1VTRV9QT0lOVEVSX0lEID0gMTtcbmNvbnN0IFRPVUNIX1RPX1BPSU5URVIgPSB7XG4gIHRvdWNoc3RhcnQ6IFwicG9pbnRlcmRvd25cIixcbiAgdG91Y2hlbmQ6IFwicG9pbnRlcnVwXCIsXG4gIHRvdWNoZW5kb3V0c2lkZTogXCJwb2ludGVydXBvdXRzaWRlXCIsXG4gIHRvdWNobW92ZTogXCJwb2ludGVybW92ZVwiLFxuICB0b3VjaGNhbmNlbDogXCJwb2ludGVyY2FuY2VsXCJcbn07XG5jb25zdCBfRXZlbnRTeXN0ZW0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBnbG9iYWxUaGlzO1xuICAgIHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzID0gISFnbG9iYWxUaGlzLlBvaW50ZXJFdmVudDtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5ID0gbmV3IEV2ZW50Qm91bmRhcnkobnVsbCk7XG4gICAgRXZlbnRzVGlja2VyLmluaXQodGhpcyk7XG4gICAgdGhpcy5hdXRvUHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIHRoaXMuZXZlbnRzQWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJvb3RQb2ludGVyRXZlbnQgPSBuZXcgRmVkZXJhdGVkUG9pbnRlckV2ZW50KG51bGwpO1xuICAgIHRoaXMucm9vdFdoZWVsRXZlbnQgPSBuZXcgRmVkZXJhdGVkV2hlZWxFdmVudChudWxsKTtcbiAgICB0aGlzLmN1cnNvclN0eWxlcyA9IHtcbiAgICAgIGRlZmF1bHQ6IFwiaW5oZXJpdFwiLFxuICAgICAgcG9pbnRlcjogXCJwb2ludGVyXCJcbiAgICB9O1xuICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgUHJveHkoeyAuLi5fRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50RmVhdHVyZXMgfSwge1xuICAgICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiZ2xvYmFsTW92ZVwiKSB7XG4gICAgICAgICAgdGhpcy5yb290Qm91bmRhcnkuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub25Qb2ludGVyRG93biA9IHRoaXMub25Qb2ludGVyRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IHRoaXMub25Qb2ludGVyTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Qb2ludGVyVXAgPSB0aGlzLm9uUG9pbnRlclVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblBvaW50ZXJPdmVyT3V0ID0gdGhpcy5vblBvaW50ZXJPdmVyT3V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbldoZWVsID0gdGhpcy5vbldoZWVsLmJpbmQodGhpcyk7XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0RXZlbnRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0RXZlbnRNb2RlO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgdmlldywgcmVzb2x1dGlvbiB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICB0aGlzLnNldFRhcmdldEVsZW1lbnQodmlldyk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBfRXZlbnRTeXN0ZW0uX2RlZmF1bHRFdmVudE1vZGUgPSBvcHRpb25zLmV2ZW50TW9kZSA/PyBcImF1dG9cIjtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZmVhdHVyZXMsIG9wdGlvbnMuZXZlbnRGZWF0dXJlcyA/PyB7fSk7XG4gICAgdGhpcy5yb290Qm91bmRhcnkuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9IHRoaXMuZmVhdHVyZXMuZ2xvYmFsTW92ZTtcbiAgfVxuICByZXNvbHV0aW9uQ2hhbmdlKHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZXRUYXJnZXRFbGVtZW50KG51bGwpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG4gIHNldEN1cnNvcihtb2RlKSB7XG4gICAgbW9kZSA9IG1vZGUgfHwgXCJkZWZhdWx0XCI7XG4gICAgbGV0IGFwcGx5U3R5bGVzID0gdHJ1ZTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5PZmZzY3JlZW5DYW52YXMgJiYgdGhpcy5kb21FbGVtZW50IGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICBhcHBseVN0eWxlcyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50Q3Vyc29yID09PSBtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEN1cnNvciA9IG1vZGU7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmN1cnNvclN0eWxlc1ttb2RlXTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHN0eWxlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBpZiAoYXBwbHlTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBzdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHN0eWxlKG1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKGFwcGx5U3R5bGVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFwcGx5U3R5bGVzICYmIHR5cGVvZiBtb2RlID09PSBcInN0cmluZ1wiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJzb3JTdHlsZXMsIG1vZGUpKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gbW9kZTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBvaW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdFBvaW50ZXJFdmVudDtcbiAgfVxuICBvblBvaW50ZXJEb3duKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLmNsaWNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG5hdGl2ZUV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAodGhpcy5hdXRvUHJldmVudERlZmF1bHQgJiYgZXZlbnRzWzBdLmlzTm9ybWFsaXplZCkge1xuICAgICAgY29uc3QgY2FuY2VsYWJsZSA9IG5hdGl2ZUV2ZW50LmNhbmNlbGFibGUgfHwgIShcImNhbmNlbGFibGVcIiBpbiBuYXRpdmVFdmVudCk7XG4gICAgICBpZiAoY2FuY2VsYWJsZSkge1xuICAgICAgICBuYXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUV2ZW50MiA9IGV2ZW50c1tpXTtcbiAgICAgIGNvbnN0IGZlZGVyYXRlZEV2ZW50ID0gdGhpcy5ib290c3RyYXBFdmVudCh0aGlzLnJvb3RQb2ludGVyRXZlbnQsIG5hdGl2ZUV2ZW50Mik7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChmZWRlcmF0ZWRFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgb25Qb2ludGVyTW92ZShuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy5tb3ZlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG5hdGl2ZUV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpXG4gICAgICByZXR1cm47XG4gICAgRXZlbnRzVGlja2VyLnBvaW50ZXJNb3ZlZCgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9ybWFsaXplZEV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ib290c3RyYXBFdmVudCh0aGlzLnJvb3RQb2ludGVyRXZlbnQsIG5vcm1hbGl6ZWRFdmVudHNbaV0pO1xuICAgICAgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcih0aGlzLnJvb3RCb3VuZGFyeS5jdXJzb3IpO1xuICB9XG4gIG9uUG9pbnRlclVwKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLmNsaWNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG5hdGl2ZUV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldDtcbiAgICBpZiAobmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoICYmIG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRhcmdldCA9IG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgIH1cbiAgICBjb25zdCBvdXRzaWRlID0gdGFyZ2V0ICE9PSB0aGlzLmRvbUVsZW1lbnQgPyBcIm91dHNpZGVcIiA6IFwiXCI7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBub3JtYWxpemVkRXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmJvb3RzdHJhcEV2ZW50KHRoaXMucm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50c1tpXSk7XG4gICAgICBldmVudC50eXBlICs9IG91dHNpZGU7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgb25Qb2ludGVyT3Zlck91dChuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy5jbGljaylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBuYXRpdmVFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9ybWFsaXplZEV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ib290c3RyYXBFdmVudCh0aGlzLnJvb3RQb2ludGVyRXZlbnQsIG5vcm1hbGl6ZWRFdmVudHNbaV0pO1xuICAgICAgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcih0aGlzLnJvb3RCb3VuZGFyeS5jdXJzb3IpO1xuICB9XG4gIG9uV2hlZWwobmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMud2hlZWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgd2hlZWxFdmVudCA9IHRoaXMubm9ybWFsaXplV2hlZWxFdmVudChuYXRpdmVFdmVudCk7XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KHdoZWVsRXZlbnQpO1xuICB9XG4gIHNldFRhcmdldEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRzKCk7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZWxlbWVudDtcbiAgICBFdmVudHNUaWNrZXIuZG9tRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5hZGRFdmVudHMoKTtcbiAgfVxuICBhZGRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRzQWRkZWQgfHwgIXRoaXMuZG9tRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBFdmVudHNUaWNrZXIuYWRkVGlja2VyTGlzdGVuZXIoKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZG9tRWxlbWVudC5zdHlsZTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGlmIChnbG9iYWxUaGlzLm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgIHN0eWxlLm1zQ29udGVudFpvb21pbmcgPSBcIm5vbmVcIjtcbiAgICAgICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xuICAgICAgICBzdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMub25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLm9uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyb3ZlclwiLCB0aGlzLm9uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMub25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWxUaGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLm9uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cykge1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMub25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5ldmVudHNBZGRlZCA9IHRydWU7XG4gIH1cbiAgcmVtb3ZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5ldmVudHNBZGRlZCB8fCAhdGhpcy5kb21FbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEV2ZW50c1RpY2tlci5yZW1vdmVUaWNrZXJMaXN0ZW5lcigpO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5kb21FbGVtZW50LnN0eWxlO1xuICAgIGlmIChnbG9iYWxUaGlzLm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICBzdHlsZS5tc0NvbnRlbnRab29taW5nID0gXCJcIjtcbiAgICAgIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIlwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICBnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLm9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLm9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLm9uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLm9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLm9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMub25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCB0cnVlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZXZlbnRzQWRkZWQgPSBmYWxzZTtcbiAgfVxuICBtYXBQb3NpdGlvblRvUG9pbnQocG9pbnQsIHgsIHkpIHtcbiAgICBsZXQgcmVjdDtcbiAgICBpZiAoIXRoaXMuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICByZWN0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogdGhpcy5kb21FbGVtZW50LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuZG9tRWxlbWVudC5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdCA9IHRoaXMuZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHBvaW50LnggPSAoeCAtIHJlY3QubGVmdCkgKiAodGhpcy5kb21FbGVtZW50LndpZHRoIC8gcmVjdC53aWR0aCkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcbiAgICBwb2ludC55ID0gKHkgLSByZWN0LnRvcCkgKiAodGhpcy5kb21FbGVtZW50LmhlaWdodCAvIHJlY3QuaGVpZ2h0KSAqIHJlc29sdXRpb25NdWx0aXBsaWVyO1xuICB9XG4gIG5vcm1hbGl6ZVRvUG9pbnRlckRhdGEoZXZlbnQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gW107XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsaSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSA8IGxpOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b24gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2guYnV0dG9uID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b25zID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmJ1dHRvbnMgPSAxO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmlzUHJpbWFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRvdWNoLmlzUHJpbWFyeSA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxICYmIGV2ZW50LnR5cGUgPT09IFwidG91Y2hzdGFydFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gud2lkdGggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gud2lkdGggPSB0b3VjaC5yYWRpdXNYIHx8IDE7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2guaGVpZ2h0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmhlaWdodCA9IHRvdWNoLnJhZGl1c1kgfHwgMTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50aWx0WCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC50aWx0WCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gudGlsdFkgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJUeXBlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnBvaW50ZXJUeXBlID0gXCJ0b3VjaFwiO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJJZCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5wb2ludGVySWQgPSB0b3VjaC5pZGVudGlmaWVyIHx8IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gucHJlc3N1cmUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gucHJlc3N1cmUgPSB0b3VjaC5mb3JjZSB8fCAwLjU7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gudHdpc3QgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gudHdpc3QgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC50YW5nZW50aWFsUHJlc3N1cmUgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmxheWVyWCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5sYXllclggPSB0b3VjaC5vZmZzZXRYID0gdG91Y2guY2xpZW50WDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5sYXllclkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gubGF5ZXJZID0gdG91Y2gub2Zmc2V0WSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgIHRvdWNoLmlzTm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRvdWNoLnR5cGUgPSBldmVudC50eXBlO1xuICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2godG91Y2gpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdsb2JhbFRoaXMuTW91c2VFdmVudCB8fCBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgJiYgKCF0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyB8fCAhKGV2ZW50IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5Qb2ludGVyRXZlbnQpKSkge1xuICAgICAgY29uc3QgdGVtcEV2ZW50ID0gZXZlbnQ7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5pc1ByaW1hcnkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5pc1ByaW1hcnkgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQud2lkdGggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC53aWR0aCA9IDE7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5oZWlnaHQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5oZWlnaHQgPSAxO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQudGlsdFggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC50aWx0WCA9IDA7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC50aWx0WSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnRpbHRZID0gMDtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnBvaW50ZXJUeXBlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQucG9pbnRlclR5cGUgPSBcIm1vdXNlXCI7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5wb2ludGVySWQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5wb2ludGVySWQgPSBNT1VTRV9QT0lOVEVSX0lEO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQucHJlc3N1cmUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5wcmVzc3VyZSA9IDAuNTtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnR3aXN0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQudHdpc3QgPSAwO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcbiAgICAgIHRlbXBFdmVudC5pc05vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKHRlbXBFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaChldmVudCk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkRXZlbnRzO1xuICB9XG4gIG5vcm1hbGl6ZVdoZWVsRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMucm9vdFdoZWVsRXZlbnQ7XG4gICAgdGhpcy50cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpO1xuICAgIGV2ZW50LmRlbHRhWCA9IG5hdGl2ZUV2ZW50LmRlbHRhWDtcbiAgICBldmVudC5kZWx0YVkgPSBuYXRpdmVFdmVudC5kZWx0YVk7XG4gICAgZXZlbnQuZGVsdGFaID0gbmF0aXZlRXZlbnQuZGVsdGFaO1xuICAgIGV2ZW50LmRlbHRhTW9kZSA9IG5hdGl2ZUV2ZW50LmRlbHRhTW9kZTtcbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChldmVudC5zY3JlZW4sIG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpO1xuICAgIGV2ZW50Lmdsb2JhbC5jb3B5RnJvbShldmVudC5zY3JlZW4pO1xuICAgIGV2ZW50Lm9mZnNldC5jb3B5RnJvbShldmVudC5zY3JlZW4pO1xuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGU7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGJvb3RzdHJhcEV2ZW50KGV2ZW50LCBuYXRpdmVFdmVudCkge1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBudWxsO1xuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgZXZlbnQucG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgIGV2ZW50LndpZHRoID0gbmF0aXZlRXZlbnQud2lkdGg7XG4gICAgZXZlbnQuaGVpZ2h0ID0gbmF0aXZlRXZlbnQuaGVpZ2h0O1xuICAgIGV2ZW50LmlzUHJpbWFyeSA9IG5hdGl2ZUV2ZW50LmlzUHJpbWFyeTtcbiAgICBldmVudC5wb2ludGVyVHlwZSA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJUeXBlO1xuICAgIGV2ZW50LnByZXNzdXJlID0gbmF0aXZlRXZlbnQucHJlc3N1cmU7XG4gICAgZXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID0gbmF0aXZlRXZlbnQudGFuZ2VudGlhbFByZXNzdXJlO1xuICAgIGV2ZW50LnRpbHRYID0gbmF0aXZlRXZlbnQudGlsdFg7XG4gICAgZXZlbnQudGlsdFkgPSBuYXRpdmVFdmVudC50aWx0WTtcbiAgICBldmVudC50d2lzdCA9IG5hdGl2ZUV2ZW50LnR3aXN0O1xuICAgIHRoaXMudHJhbnNmZXJNb3VzZURhdGEoZXZlbnQsIG5hdGl2ZUV2ZW50KTtcbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChldmVudC5zY3JlZW4sIG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpO1xuICAgIGV2ZW50Lmdsb2JhbC5jb3B5RnJvbShldmVudC5zY3JlZW4pO1xuICAgIGV2ZW50Lm9mZnNldC5jb3B5RnJvbShldmVudC5zY3JlZW4pO1xuICAgIGV2ZW50LmlzVHJ1c3RlZCA9IG5hdGl2ZUV2ZW50LmlzVHJ1c3RlZDtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJwb2ludGVybGVhdmVcIikge1xuICAgICAgZXZlbnQudHlwZSA9IFwicG9pbnRlcm91dFwiO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZS5zdGFydHNXaXRoKFwibW91c2VcIikpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSBldmVudC50eXBlLnJlcGxhY2UoXCJtb3VzZVwiLCBcInBvaW50ZXJcIik7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKSkge1xuICAgICAgZXZlbnQudHlwZSA9IFRPVUNIX1RPX1BPSU5URVJbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIHRyYW5zZmVyTW91c2VEYXRhKGV2ZW50LCBuYXRpdmVFdmVudCkge1xuICAgIGV2ZW50LmlzVHJ1c3RlZCA9IG5hdGl2ZUV2ZW50LmlzVHJ1c3RlZDtcbiAgICBldmVudC5zcmNFbGVtZW50ID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudDtcbiAgICBldmVudC50aW1lU3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBldmVudC50eXBlID0gbmF0aXZlRXZlbnQudHlwZTtcbiAgICBldmVudC5hbHRLZXkgPSBuYXRpdmVFdmVudC5hbHRLZXk7XG4gICAgZXZlbnQuYnV0dG9uID0gbmF0aXZlRXZlbnQuYnV0dG9uO1xuICAgIGV2ZW50LmJ1dHRvbnMgPSBuYXRpdmVFdmVudC5idXR0b25zO1xuICAgIGV2ZW50LmNsaWVudC54ID0gbmF0aXZlRXZlbnQuY2xpZW50WDtcbiAgICBldmVudC5jbGllbnQueSA9IG5hdGl2ZUV2ZW50LmNsaWVudFk7XG4gICAgZXZlbnQuY3RybEtleSA9IG5hdGl2ZUV2ZW50LmN0cmxLZXk7XG4gICAgZXZlbnQubWV0YUtleSA9IG5hdGl2ZUV2ZW50Lm1ldGFLZXk7XG4gICAgZXZlbnQubW92ZW1lbnQueCA9IG5hdGl2ZUV2ZW50Lm1vdmVtZW50WDtcbiAgICBldmVudC5tb3ZlbWVudC55ID0gbmF0aXZlRXZlbnQubW92ZW1lbnRZO1xuICAgIGV2ZW50LnBhZ2UueCA9IG5hdGl2ZUV2ZW50LnBhZ2VYO1xuICAgIGV2ZW50LnBhZ2UueSA9IG5hdGl2ZUV2ZW50LnBhZ2VZO1xuICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgIGV2ZW50LnNoaWZ0S2V5ID0gbmF0aXZlRXZlbnQuc2hpZnRLZXk7XG4gIH1cbn07XG5sZXQgRXZlbnRTeXN0ZW0gPSBfRXZlbnRTeXN0ZW07XG5FdmVudFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiZXZlbnRzXCIsXG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXVxufTtcbkV2ZW50U3lzdGVtLmRlZmF1bHRFdmVudEZlYXR1cmVzID0ge1xuICBtb3ZlOiB0cnVlLFxuICBnbG9iYWxNb3ZlOiB0cnVlLFxuICBjbGljazogdHJ1ZSxcbiAgd2hlZWw6IHRydWVcbn07XG5leHRlbnNpb25zLmFkZChFdmVudFN5c3RlbSk7XG5cbmV4cG9ydCB7IEV2ZW50U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBEaXNwbGF5T2JqZWN0IH0gZnJvbSAnQHBpeGkvZGlzcGxheSc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gJ0BwaXhpL3V0aWxzJztcbmltcG9ydCB7IEV2ZW50U3lzdGVtIH0gZnJvbSAnLi9FdmVudFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZEV2ZW50Lm1qcyc7XG5cbmZ1bmN0aW9uIGNvbnZlcnRFdmVudE1vZGVUb0ludGVyYWN0aXZlTW9kZShtb2RlKSB7XG4gIHJldHVybiBtb2RlID09PSBcImR5bmFtaWNcIiB8fCBtb2RlID09PSBcInN0YXRpY1wiO1xufVxuY29uc3QgRmVkZXJhdGVkRGlzcGxheU9iamVjdCA9IHtcbiAgb25jbGljazogbnVsbCxcbiAgb25tb3VzZWRvd246IG51bGwsXG4gIG9ubW91c2VlbnRlcjogbnVsbCxcbiAgb25tb3VzZWxlYXZlOiBudWxsLFxuICBvbm1vdXNlbW92ZTogbnVsbCxcbiAgb25nbG9iYWxtb3VzZW1vdmU6IG51bGwsXG4gIG9ubW91c2VvdXQ6IG51bGwsXG4gIG9ubW91c2VvdmVyOiBudWxsLFxuICBvbm1vdXNldXA6IG51bGwsXG4gIG9ubW91c2V1cG91dHNpZGU6IG51bGwsXG4gIG9ucG9pbnRlcmNhbmNlbDogbnVsbCxcbiAgb25wb2ludGVyZG93bjogbnVsbCxcbiAgb25wb2ludGVyZW50ZXI6IG51bGwsXG4gIG9ucG9pbnRlcmxlYXZlOiBudWxsLFxuICBvbnBvaW50ZXJtb3ZlOiBudWxsLFxuICBvbmdsb2JhbHBvaW50ZXJtb3ZlOiBudWxsLFxuICBvbnBvaW50ZXJvdXQ6IG51bGwsXG4gIG9ucG9pbnRlcm92ZXI6IG51bGwsXG4gIG9ucG9pbnRlcnRhcDogbnVsbCxcbiAgb25wb2ludGVydXA6IG51bGwsXG4gIG9ucG9pbnRlcnVwb3V0c2lkZTogbnVsbCxcbiAgb25yaWdodGNsaWNrOiBudWxsLFxuICBvbnJpZ2h0ZG93bjogbnVsbCxcbiAgb25yaWdodHVwOiBudWxsLFxuICBvbnJpZ2h0dXBvdXRzaWRlOiBudWxsLFxuICBvbnRhcDogbnVsbCxcbiAgb250b3VjaGNhbmNlbDogbnVsbCxcbiAgb250b3VjaGVuZDogbnVsbCxcbiAgb250b3VjaGVuZG91dHNpZGU6IG51bGwsXG4gIG9udG91Y2htb3ZlOiBudWxsLFxuICBvbmdsb2JhbHRvdWNobW92ZTogbnVsbCxcbiAgb250b3VjaHN0YXJ0OiBudWxsLFxuICBvbndoZWVsOiBudWxsLFxuICBfaW50ZXJuYWxJbnRlcmFjdGl2ZTogdm9pZCAwLFxuICBnZXQgaW50ZXJhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsSW50ZXJhY3RpdmUgPz8gY29udmVydEV2ZW50TW9kZVRvSW50ZXJhY3RpdmVNb2RlKEV2ZW50U3lzdGVtLmRlZmF1bHRFdmVudE1vZGUpO1xuICB9LFxuICBzZXQgaW50ZXJhY3RpdmUodmFsdWUpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMi4wXCIsIGBTZXR0aW5nIGludGVyYWN0aXZlIGlzIGRlcHJlY2F0ZWQsIHVzZSBldmVudE1vZGUgPSAnbm9uZScvJ3Bhc3NpdmUnLydhdXRvJy8nc3RhdGljJy8nZHluYW1pYycgaW5zdGVhZC5gKTtcbiAgICB0aGlzLl9pbnRlcm5hbEludGVyYWN0aXZlID0gdmFsdWU7XG4gICAgdGhpcy5ldmVudE1vZGUgPSB2YWx1ZSA/IFwic3RhdGljXCIgOiBcImF1dG9cIjtcbiAgfSxcbiAgX2ludGVybmFsRXZlbnRNb2RlOiB2b2lkIDAsXG4gIGdldCBldmVudE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsRXZlbnRNb2RlID8/IEV2ZW50U3lzdGVtLmRlZmF1bHRFdmVudE1vZGU7XG4gIH0sXG4gIHNldCBldmVudE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9pbnRlcm5hbEludGVyYWN0aXZlID0gY29udmVydEV2ZW50TW9kZVRvSW50ZXJhY3RpdmVNb2RlKHZhbHVlKTtcbiAgICB0aGlzLl9pbnRlcm5hbEV2ZW50TW9kZSA9IHZhbHVlO1xuICB9LFxuICBpc0ludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50TW9kZSA9PT0gXCJzdGF0aWNcIiB8fCB0aGlzLmV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCI7XG4gIH0sXG4gIGludGVyYWN0aXZlQ2hpbGRyZW46IHRydWUsXG4gIGhpdEFyZWE6IG51bGwsXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXB0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiICYmIG9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5jYXB0dXJlO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IHZvaWQgMCA6IGxpc3RlbmVyO1xuICAgIHR5cGUgPSBjYXB0dXJlID8gYCR7dHlwZX1jYXB0dXJlYCA6IHR5cGU7XG4gICAgbGlzdGVuZXIgPSB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IGxpc3RlbmVyIDogbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XG4gICAgdGhpcy5vbih0eXBlLCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXB0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiICYmIG9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5jYXB0dXJlO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IHZvaWQgMCA6IGxpc3RlbmVyO1xuICAgIHR5cGUgPSBjYXB0dXJlID8gYCR7dHlwZX1jYXB0dXJlYCA6IHR5cGU7XG4gICAgbGlzdGVuZXIgPSB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IGxpc3RlbmVyIDogbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XG4gICAgdGhpcy5vZmYodHlwZSwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9LFxuICBkaXNwYXRjaEV2ZW50KGUpIHtcbiAgICBpZiAoIShlIGluc3RhbmNlb2YgRmVkZXJhdGVkRXZlbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNwbGF5T2JqZWN0IGNhbm5vdCBwcm9wYWdhdGUgZXZlbnRzIG91dHNpZGUgb2YgdGhlIEZlZGVyYXRlZCBFdmVudHMgQVBJXCIpO1xuICAgIH1cbiAgICBlLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICBlLnBhdGggPSBudWxsO1xuICAgIGUudGFyZ2V0ID0gdGhpcztcbiAgICBlLm1hbmFnZXIuZGlzcGF0Y2hFdmVudChlKTtcbiAgICByZXR1cm4gIWUuZGVmYXVsdFByZXZlbnRlZDtcbiAgfVxufTtcbkRpc3BsYXlPYmplY3QubWl4aW4oRmVkZXJhdGVkRGlzcGxheU9iamVjdCk7XG5cbmV4cG9ydCB7IEZlZGVyYXRlZERpc3BsYXlPYmplY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZEV2ZW50VGFyZ2V0Lm1qcy5tYXBcbiIsImV4cG9ydCB7IEV2ZW50Qm91bmRhcnkgfSBmcm9tICcuL0V2ZW50Qm91bmRhcnkubWpzJztcbmV4cG9ydCB7IEV2ZW50U3lzdGVtIH0gZnJvbSAnLi9FdmVudFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZEV2ZW50Lm1qcyc7XG5pbXBvcnQgJy4vRmVkZXJhdGVkRXZlbnRNYXAubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZERpc3BsYXlPYmplY3QgfSBmcm9tICcuL0ZlZGVyYXRlZEV2ZW50VGFyZ2V0Lm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMnO1xuZXhwb3J0IHsgRmVkZXJhdGVkV2hlZWxFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiY29uc3QgYWNjZXNzaWJsZVRhcmdldCA9IHtcbiAgYWNjZXNzaWJsZTogZmFsc2UsXG4gIGFjY2Vzc2libGVUaXRsZTogbnVsbCxcbiAgYWNjZXNzaWJsZUhpbnQ6IG51bGwsXG4gIHRhYkluZGV4OiAwLFxuICBfYWNjZXNzaWJsZUFjdGl2ZTogZmFsc2UsXG4gIF9hY2Nlc3NpYmxlRGl2OiBudWxsLFxuICBhY2Nlc3NpYmxlVHlwZTogXCJidXR0b25cIixcbiAgYWNjZXNzaWJsZVBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuICBhY2Nlc3NpYmxlQ2hpbGRyZW46IHRydWUsXG4gIHJlbmRlcklkOiAtMVxufTtcblxuZXhwb3J0IHsgYWNjZXNzaWJsZVRhcmdldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzaWJsZVRhcmdldC5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscywgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgRGlzcGxheU9iamVjdCB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICdAcGl4aS9ldmVudHMnO1xuaW1wb3J0IHsgYWNjZXNzaWJsZVRhcmdldCB9IGZyb20gJy4vYWNjZXNzaWJsZVRhcmdldC5tanMnO1xuXG5EaXNwbGF5T2JqZWN0Lm1peGluKGFjY2Vzc2libGVUYXJnZXQpO1xuY29uc3QgS0VZX0NPREVfVEFCID0gOTtcbmNvbnN0IERJVl9UT1VDSF9TSVpFID0gMTAwO1xuY29uc3QgRElWX1RPVUNIX1BPU19YID0gMDtcbmNvbnN0IERJVl9UT1VDSF9QT1NfWSA9IDA7XG5jb25zdCBESVZfVE9VQ0hfWklOREVYID0gMjtcbmNvbnN0IERJVl9IT09LX1NJWkUgPSAxO1xuY29uc3QgRElWX0hPT0tfUE9TX1ggPSAtMWUzO1xuY29uc3QgRElWX0hPT0tfUE9TX1kgPSAtMWUzO1xuY29uc3QgRElWX0hPT0tfWklOREVYID0gMjtcbmNsYXNzIEFjY2Vzc2liaWxpdHlNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLmRlYnVnID0gZmFsc2U7XG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9pc01vYmlsZUFjY2Vzc2liaWxpdHkgPSBmYWxzZTtcbiAgICB0aGlzLnBvb2wgPSBbXTtcbiAgICB0aGlzLnJlbmRlcklkID0gMDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5hbmRyb2lkVXBkYXRlQ291bnQgPSAwO1xuICAgIHRoaXMuYW5kcm9pZFVwZGF0ZUZyZXF1ZW5jeSA9IDUwMDtcbiAgICB0aGlzLl9ob29rRGl2ID0gbnVsbDtcbiAgICBpZiAodXRpbHMuaXNNb2JpbGUudGFibGV0IHx8IHV0aWxzLmlzTW9iaWxlLnBob25lKSB7XG4gICAgICB0aGlzLmNyZWF0ZVRvdWNoSG9vaygpO1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke0RJVl9UT1VDSF9TSVpFfXB4YDtcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7RElWX1RPVUNIX1NJWkV9cHhgO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gYCR7RElWX1RPVUNIX1BPU19YfXB4YDtcbiAgICBkaXYuc3R5bGUubGVmdCA9IGAke0RJVl9UT1VDSF9QT1NfWX1weGA7XG4gICAgZGl2LnN0eWxlLnpJbmRleCA9IERJVl9UT1VDSF9aSU5ERVgudG9TdHJpbmcoKTtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG4gIH1cbiAgZ2V0IGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0FjdGl2ZTtcbiAgfVxuICBnZXQgaXNNb2JpbGVBY2Nlc3NpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9pc01vYmlsZUFjY2Vzc2liaWxpdHk7XG4gIH1cbiAgY3JlYXRlVG91Y2hIb29rKCkge1xuICAgIGNvbnN0IGhvb2tEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGhvb2tEaXYuc3R5bGUud2lkdGggPSBgJHtESVZfSE9PS19TSVpFfXB4YDtcbiAgICBob29rRGl2LnN0eWxlLmhlaWdodCA9IGAke0RJVl9IT09LX1NJWkV9cHhgO1xuICAgIGhvb2tEaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgaG9va0Rpdi5zdHlsZS50b3AgPSBgJHtESVZfSE9PS19QT1NfWH1weGA7XG4gICAgaG9va0Rpdi5zdHlsZS5sZWZ0ID0gYCR7RElWX0hPT0tfUE9TX1l9cHhgO1xuICAgIGhvb2tEaXYuc3R5bGUuekluZGV4ID0gRElWX0hPT0tfWklOREVYLnRvU3RyaW5nKCk7XG4gICAgaG9va0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNGRjAwMDBcIjtcbiAgICBob29rRGl2LnRpdGxlID0gXCJzZWxlY3QgdG8gZW5hYmxlIGFjY2Vzc2liaWxpdHkgZm9yIHRoaXMgY29udGVudFwiO1xuICAgIGhvb2tEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2lzTW9iaWxlQWNjZXNzaWJpbGl0eSA9IHRydWU7XG4gICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICB0aGlzLmRlc3Ryb3lUb3VjaEhvb2soKTtcbiAgICB9KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhvb2tEaXYpO1xuICAgIHRoaXMuX2hvb2tEaXYgPSBob29rRGl2O1xuICB9XG4gIGRlc3Ryb3lUb3VjaEhvb2soKSB7XG4gICAgaWYgKCF0aGlzLl9ob29rRGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5faG9va0Rpdik7XG4gICAgdGhpcy5faG9va0RpdiA9IG51bGw7XG4gIH1cbiAgYWN0aXZhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZTtcbiAgICBnbG9iYWxUaGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xuICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG4gICAgdGhpcy5yZW5kZXJlci5vbihcInBvc3RyZW5kZXJcIiwgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIHRoaXMucmVuZGVyZXIudmlldy5wYXJlbnROb2RlPy5hcHBlbmRDaGlsZCh0aGlzLmRpdik7XG4gIH1cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQWN0aXZlIHx8IHRoaXMuX2lzTW9iaWxlQWNjZXNzaWJpbGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICB0aGlzLnJlbmRlcmVyLm9mZihcInBvc3RyZW5kZXJcIiwgdGhpcy51cGRhdGUpO1xuICAgIHRoaXMuZGl2LnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMuZGl2KTtcbiAgfVxuICB1cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyhkaXNwbGF5T2JqZWN0KSB7XG4gICAgaWYgKCFkaXNwbGF5T2JqZWN0LnZpc2libGUgfHwgIWRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGUgJiYgZGlzcGxheU9iamVjdC5pc0ludGVyYWN0aXZlKCkpIHtcbiAgICAgIGlmICghZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZUFjdGl2ZSkge1xuICAgICAgICB0aGlzLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xuICAgICAgfVxuICAgICAgZGlzcGxheU9iamVjdC5yZW5kZXJJZCA9IHRoaXMucmVuZGVySWQ7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyhjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAodXRpbHMuaXNNb2JpbGUuYW5kcm9pZC5kZXZpY2UgJiYgbm93IDwgdGhpcy5hbmRyb2lkVXBkYXRlQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hbmRyb2lkVXBkYXRlQ291bnQgPSBub3cgKyB0aGlzLmFuZHJvaWRVcGRhdGVGcmVxdWVuY3k7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCkge1xuICAgICAgdGhpcy51cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyh0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCk7XG4gICAgfVxuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5yZW5kZXJlci52aWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHsgd2lkdGg6IHZpZXdXaWR0aCwgaGVpZ2h0OiB2aWV3SGVpZ2h0LCByZXNvbHV0aW9uIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IHN4ID0gd2lkdGggLyB2aWV3V2lkdGggKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IHN5ID0gaGVpZ2h0IC8gdmlld0hlaWdodCAqIHJlc29sdXRpb247XG4gICAgbGV0IGRpdiA9IHRoaXMuZGl2O1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gICAgZGl2LnN0eWxlLnRvcCA9IGAke3l9cHhgO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke3ZpZXdXaWR0aH1weGA7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke3ZpZXdIZWlnaHR9cHhgO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnJlbmRlcklkICE9PSB0aGlzLnJlbmRlcklkKSB7XG4gICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGksIDEpO1xuICAgICAgICB0aGlzLmRpdi5yZW1vdmVDaGlsZChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgIHRoaXMucG9vbC5wdXNoKGNoaWxkLl9hY2Nlc3NpYmxlRGl2KTtcbiAgICAgICAgY2hpbGQuX2FjY2Vzc2libGVEaXYgPSBudWxsO1xuICAgICAgICBpLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYgPSBjaGlsZC5fYWNjZXNzaWJsZURpdjtcbiAgICAgICAgbGV0IGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xuICAgICAgICBjb25zdCB3dCA9IGNoaWxkLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICBpZiAoY2hpbGQuaGl0QXJlYSkge1xuICAgICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gYCR7KHd0LnR4ICsgaGl0QXJlYS54ICogd3QuYSkgKiBzeH1weGA7XG4gICAgICAgICAgZGl2LnN0eWxlLnRvcCA9IGAkeyh3dC50eSArIGhpdEFyZWEueSAqIHd0LmQpICogc3l9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke2hpdEFyZWEud2lkdGggKiB3dC5hICogc3h9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtoaXRBcmVhLmhlaWdodCAqIHd0LmQgKiBzeX1weGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGl0QXJlYSA9IGNoaWxkLmdldEJvdW5kcygpO1xuICAgICAgICAgIHRoaXMuY2FwSGl0QXJlYShoaXRBcmVhKTtcbiAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9IGAke2hpdEFyZWEueCAqIHN4fXB4YDtcbiAgICAgICAgICBkaXYuc3R5bGUudG9wID0gYCR7aGl0QXJlYS55ICogc3l9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke2hpdEFyZWEud2lkdGggKiBzeH1weGA7XG4gICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke2hpdEFyZWEuaGVpZ2h0ICogc3l9cHhgO1xuICAgICAgICAgIGlmIChkaXYudGl0bGUgIT09IGNoaWxkLmFjY2Vzc2libGVUaXRsZSAmJiBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpdi50aXRsZSA9IGNoaWxkLmFjY2Vzc2libGVUaXRsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpdi5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpICE9PSBjaGlsZC5hY2Nlc3NpYmxlSGludCAmJiBjaGlsZC5hY2Nlc3NpYmxlSGludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgY2hpbGQuYWNjZXNzaWJsZUhpbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQuYWNjZXNzaWJsZVRpdGxlICE9PSBkaXYudGl0bGUgfHwgY2hpbGQudGFiSW5kZXggIT09IGRpdi50YWJJbmRleCkge1xuICAgICAgICAgIGRpdi50aXRsZSA9IGNoaWxkLmFjY2Vzc2libGVUaXRsZTtcbiAgICAgICAgICBkaXYudGFiSW5kZXggPSBjaGlsZC50YWJJbmRleDtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGVidWdIVE1MKGRpdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJJZCsrO1xuICB9XG4gIHVwZGF0ZURlYnVnSFRNTChkaXYpIHtcbiAgICBkaXYuaW5uZXJIVE1MID0gYHR5cGU6ICR7ZGl2LnR5cGV9PC9icj4gdGl0bGUgOiAke2Rpdi50aXRsZX08L2JyPiB0YWJJbmRleDogJHtkaXYudGFiSW5kZXh9YDtcbiAgfVxuICBjYXBIaXRBcmVhKGhpdEFyZWEpIHtcbiAgICBpZiAoaGl0QXJlYS54IDwgMCkge1xuICAgICAgaGl0QXJlYS53aWR0aCArPSBoaXRBcmVhLng7XG4gICAgICBoaXRBcmVhLnggPSAwO1xuICAgIH1cbiAgICBpZiAoaGl0QXJlYS55IDwgMCkge1xuICAgICAgaGl0QXJlYS5oZWlnaHQgKz0gaGl0QXJlYS55O1xuICAgICAgaGl0QXJlYS55ID0gMDtcbiAgICB9XG4gICAgY29uc3QgeyB3aWR0aDogdmlld1dpZHRoLCBoZWlnaHQ6IHZpZXdIZWlnaHQgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgaWYgKGhpdEFyZWEueCArIGhpdEFyZWEud2lkdGggPiB2aWV3V2lkdGgpIHtcbiAgICAgIGhpdEFyZWEud2lkdGggPSB2aWV3V2lkdGggLSBoaXRBcmVhLng7XG4gICAgfVxuICAgIGlmIChoaXRBcmVhLnkgKyBoaXRBcmVhLmhlaWdodCA+IHZpZXdIZWlnaHQpIHtcbiAgICAgIGhpdEFyZWEuaGVpZ2h0ID0gdmlld0hlaWdodCAtIGhpdEFyZWEueTtcbiAgICB9XG4gIH1cbiAgYWRkQ2hpbGQoZGlzcGxheU9iamVjdCkge1xuICAgIGxldCBkaXYgPSB0aGlzLnBvb2wucG9wKCk7XG4gICAgaWYgKCFkaXYpIHtcbiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtESVZfVE9VQ0hfU0laRX1weGA7XG4gICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7RElWX1RPVUNIX1NJWkV9cHhgO1xuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGVidWcgPyBcInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiIDogXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IERJVl9UT1VDSF9aSU5ERVgudG9TdHJpbmcoKTtcbiAgICAgIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9IFwibm9uZVwiO1xuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImNocm9tZVwiKSkge1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwib2ZmXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9ydjouKkdlY2tvXFwvLykpIHtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtcmVsZXZhbnRcIiwgXCJhZGRpdGlvbnNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1yZWxldmFudFwiLCBcInRleHRcIik7XG4gICAgICB9XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX29uRm9jdXNPdXQuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlUG9pbnRlckV2ZW50cztcbiAgICBkaXYudHlwZSA9IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVR5cGU7XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICYmIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsKSB7XG4gICAgICBkaXYudGl0bGUgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZTtcbiAgICB9IGVsc2UgaWYgKCFkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50IHx8IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgPT09IG51bGwpIHtcbiAgICAgIGRpdi50aXRsZSA9IGBkaXNwbGF5T2JqZWN0ICR7ZGlzcGxheU9iamVjdC50YWJJbmRleH1gO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCAmJiBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ICE9PSBudWxsKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICB0aGlzLnVwZGF0ZURlYnVnSFRNTChkaXYpO1xuICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUgPSB0cnVlO1xuICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYgPSBkaXY7XG4gICAgZGl2LmRpc3BsYXlPYmplY3QgPSBkaXNwbGF5T2JqZWN0O1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChkaXNwbGF5T2JqZWN0KTtcbiAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2KTtcbiAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2LnRhYkluZGV4ID0gZGlzcGxheU9iamVjdC50YWJJbmRleDtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudChlLCB0eXBlKSB7XG4gICAgY29uc3QgeyBkaXNwbGF5T2JqZWN0OiB0YXJnZXQgfSA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IGJvdW5kcnkgPSB0aGlzLnJlbmRlcmVyLmV2ZW50cy5yb290Qm91bmRhcnk7XG4gICAgY29uc3QgZXZlbnQgPSBPYmplY3QuYXNzaWduKG5ldyBGZWRlcmF0ZWRFdmVudChib3VuZHJ5KSwgeyB0YXJnZXQgfSk7XG4gICAgYm91bmRyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgdHlwZS5mb3JFYWNoKCh0eXBlMikgPT4gYm91bmRyeS5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0eXBlMikpO1xuICB9XG4gIF9vbkNsaWNrKGUpIHtcbiAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGUsIFtcImNsaWNrXCIsIFwicG9pbnRlcnRhcFwiLCBcInRhcFwiXSk7XG4gIH1cbiAgX29uRm9jdXMoZSkge1xuICAgIGlmICghZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIpKSB7XG4gICAgICBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJhc3NlcnRpdmVcIik7XG4gICAgfVxuICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoZSwgW1wibW91c2VvdmVyXCJdKTtcbiAgfVxuICBfb25Gb2N1c091dChlKSB7XG4gICAgaWYgKCFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIikpIHtcbiAgICAgIGUudGFyZ2V0LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudChlLCBbXCJtb3VzZW91dFwiXSk7XG4gIH1cbiAgX29uS2V5RG93bihlKSB7XG4gICAgaWYgKGUua2V5Q29kZSAhPT0gS0VZX0NPREVfVEFCKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgfVxuICBfb25Nb3VzZU1vdmUoZSkge1xuICAgIGlmIChlLm1vdmVtZW50WCA9PT0gMCAmJiBlLm1vdmVtZW50WSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveVRvdWNoSG9vaygpO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICBnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xuICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duKTtcbiAgICB0aGlzLnBvb2wgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiYWNjZXNzaWJpbGl0eVwiLFxuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpbixcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyUGx1Z2luXG4gIF1cbn07XG5leHRlbnNpb25zLmFkZChBY2Nlc3NpYmlsaXR5TWFuYWdlcik7XG5cbmV4cG9ydCB7IEFjY2Vzc2liaWxpdHlNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2Nlc3NpYmlsaXR5TWFuYWdlci5tanMubWFwXG4iLCJleHBvcnQgeyBBY2Nlc3NpYmlsaXR5TWFuYWdlciB9IGZyb20gJy4vQWNjZXNzaWJpbGl0eU1hbmFnZXIubWpzJztcbmV4cG9ydCB7IGFjY2Vzc2libGVUYXJnZXQgfSBmcm9tICcuL2FjY2Vzc2libGVUYXJnZXQubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciwgZXh0ZW5zaW9ucywgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnQHBpeGkvZGlzcGxheSc7XG5cbmNvbnN0IF9BcHBsaWNhdGlvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuc3RhZ2UgPSBuZXcgQ29udGFpbmVyKCk7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZm9yY2VDYW52YXM6IGZhbHNlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5yZW5kZXJlciA9IGF1dG9EZXRlY3RSZW5kZXJlcihvcHRpb25zKTtcbiAgICBfQXBwbGljYXRpb24uX3BsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICBwbHVnaW4uaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnN0YWdlKTtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci52aWV3O1xuICB9XG4gIGdldCBzY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuc2NyZWVuO1xuICB9XG4gIGRlc3Ryb3kocmVtb3ZlVmlldywgc3RhZ2VPcHRpb25zKSB7XG4gICAgY29uc3QgcGx1Z2lucyA9IF9BcHBsaWNhdGlvbi5fcGx1Z2lucy5zbGljZSgwKTtcbiAgICBwbHVnaW5zLnJldmVyc2UoKTtcbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgcGx1Z2luLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YWdlLmRlc3Ryb3koc3RhZ2VPcHRpb25zKTtcbiAgICB0aGlzLnN0YWdlID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3kocmVtb3ZlVmlldyk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG5sZXQgQXBwbGljYXRpb24gPSBfQXBwbGljYXRpb247XG5BcHBsaWNhdGlvbi5fcGx1Z2lucyA9IFtdO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeUxpc3QoRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbiwgQXBwbGljYXRpb24uX3BsdWdpbnMpO1xuXG5leHBvcnQgeyBBcHBsaWNhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwbGljYXRpb24ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICBzdGF0aWMgaW5pdChvcHRpb25zKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzaXplVG9cIiwge1xuICAgICAgc2V0KGRvbSkge1xuICAgICAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5xdWV1ZVJlc2l6ZSk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gZG9tO1xuICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNpemVUbztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNhbmNlbFJlc2l6ZSgpO1xuICAgICAgdGhpcy5fcmVzaXplSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5yZXNpemUoKSk7XG4gICAgfTtcbiAgICB0aGlzLmNhbmNlbFJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZXNpemVJZCk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUlkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNhbmNlbFJlc2l6ZSgpO1xuICAgICAgbGV0IHdpZHRoO1xuICAgICAgbGV0IGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpIHtcbiAgICAgICAgd2lkdGggPSBnbG9iYWxUaGlzLmlubmVyV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGdsb2JhbFRoaXMuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB3aWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBvcHRpb25zLnJlc2l6ZVRvIHx8IG51bGw7XG4gIH1cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgdGhpcy5jYW5jZWxSZXNpemUgPSBudWxsO1xuICAgIHRoaXMucXVldWVSZXNpemUgPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplID0gbnVsbDtcbiAgfVxufVxuUmVzaXplUGx1Z2luLmV4dGVuc2lvbiA9IEV4dGVuc2lvblR5cGUuQXBwbGljYXRpb247XG5leHRlbnNpb25zLmFkZChSZXNpemVQbHVnaW4pO1xuXG5leHBvcnQgeyBSZXNpemVQbHVnaW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc2l6ZVBsdWdpbi5tanMubWFwXG4iLCJleHBvcnQgeyBBcHBsaWNhdGlvbiB9IGZyb20gJy4vQXBwbGljYXRpb24ubWpzJztcbmV4cG9ydCB7IFJlc2l6ZVBsdWdpbiB9IGZyb20gJy4vUmVzaXplUGx1Z2luLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGFzc2V0S2V5TWFwID0ge1xuICBsb2FkZXI6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgcmVzb2x2ZXI6IEV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlcixcbiAgY2FjaGU6IEV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsXG4gIGRldGVjdGlvbjogRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXJcbn07XG5leHRlbnNpb25zLmhhbmRsZShFeHRlbnNpb25UeXBlLkFzc2V0LCAoZXh0ZW5zaW9uKSA9PiB7XG4gIGNvbnN0IHJlZiA9IGV4dGVuc2lvbi5yZWY7XG4gIE9iamVjdC5lbnRyaWVzKGFzc2V0S2V5TWFwKS5maWx0ZXIoKFtrZXldKSA9PiAhIXJlZltrZXldKS5mb3JFYWNoKChba2V5LCB0eXBlXSkgPT4gZXh0ZW5zaW9ucy5hZGQoT2JqZWN0LmFzc2lnbihyZWZba2V5XSwgeyBleHRlbnNpb246IHJlZltrZXldLmV4dGVuc2lvbiA/PyB0eXBlIH0pKSk7XG59LCAoZXh0ZW5zaW9uKSA9PiB7XG4gIGNvbnN0IHJlZiA9IGV4dGVuc2lvbi5yZWY7XG4gIE9iamVjdC5rZXlzKGFzc2V0S2V5TWFwKS5maWx0ZXIoKGtleSkgPT4gISFyZWZba2V5XSkuZm9yRWFjaCgoa2V5KSA9PiBleHRlbnNpb25zLnJlbW92ZShyZWZba2V5XSkpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3NldEV4dGVuc2lvbi5tanMubWFwXG4iLCJjbGFzcyBCYWNrZ3JvdW5kTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobG9hZGVyLCB2ZXJib3NlID0gZmFsc2UpIHtcbiAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XG4gICAgdGhpcy5fYXNzZXRMaXN0ID0gW107XG4gICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbWF4Q29uY3VycmVudCA9IDE7XG4gICAgdGhpcy52ZXJib3NlID0gdmVyYm9zZTtcbiAgfVxuICBhZGQoYXNzZXRVcmxzKSB7XG4gICAgYXNzZXRVcmxzLmZvckVhY2goKGEpID0+IHtcbiAgICAgIHRoaXMuX2Fzc2V0TGlzdC5wdXNoKGEpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnZlcmJvc2UpXG4gICAgICBjb25zb2xlLmxvZyhcIltCYWNrZ3JvdW5kTG9hZGVyXSBhc3NldHM6IFwiLCB0aGlzLl9hc3NldExpc3QpO1xuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSAmJiAhdGhpcy5faXNMb2FkaW5nKSB7XG4gICAgICB0aGlzLl9uZXh0KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIGlmICh0aGlzLl9hc3NldExpc3QubGVuZ3RoICYmIHRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICB0aGlzLl9pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgdG9Mb2FkID0gW107XG4gICAgICBjb25zdCB0b0xvYWRBbW91bnQgPSBNYXRoLm1pbih0aGlzLl9hc3NldExpc3QubGVuZ3RoLCB0aGlzLl9tYXhDb25jdXJyZW50KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9Mb2FkQW1vdW50OyBpKyspIHtcbiAgICAgICAgdG9Mb2FkLnB1c2godGhpcy5fYXNzZXRMaXN0LnBvcCgpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX2xvYWRlci5sb2FkKHRvTG9hZCk7XG4gICAgICB0aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25leHQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNBY3RpdmU7XG4gIH1cbiAgc2V0IGFjdGl2ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSA9PT0gdmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNBY3RpdmUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgJiYgIXRoaXMuX2lzTG9hZGluZykge1xuICAgICAgdGhpcy5fbmV4dCgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBCYWNrZ3JvdW5kTG9hZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYWNrZ3JvdW5kTG9hZGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmZ1bmN0aW9uIGNoZWNrRXh0ZW5zaW9uKHVybCwgZXh0ZW5zaW9uKSB7XG4gIGNvbnN0IHRlbXBVUkwgPSB1cmwuc3BsaXQoXCI/XCIpWzBdO1xuICBjb25zdCBleHQgPSB1dGlscy5wYXRoLmV4dG5hbWUodGVtcFVSTCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXh0ZW5zaW9uKSkge1xuICAgIHJldHVybiBleHRlbnNpb24uaW5jbHVkZXMoZXh0KTtcbiAgfVxuICByZXR1cm4gZXh0ID09PSBleHRlbnNpb247XG59XG5cbmV4cG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja0V4dGVuc2lvbi5tanMubWFwXG4iLCJleHBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tICcuL2NoZWNrRGF0YVVybC5tanMnO1xuZXhwb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5leHBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi9jb252ZXJ0VG9MaXN0Lm1qcyc7XG5leHBvcnQgeyBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9jb3B5U2VhcmNoUGFyYW1zLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zIH0gZnJvbSAnLi9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcyc7XG5leHBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tICcuL2lzU2luZ2xlSXRlbS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiY29uc3QgY29udmVydFRvTGlzdCA9IChpbnB1dCwgdHJhbnNmb3JtKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IFtpbnB1dF07XG4gIH1cbiAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4ge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pO1xufTtcblxuZXhwb3J0IHsgY29udmVydFRvTGlzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVydFRvTGlzdC5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBCYXNlVGV4dHVyZSB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0ICcuLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4uL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzJztcblxuY2xhc3MgQ2FjaGVDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnNlcnMgPSBbXTtcbiAgICB0aGlzLl9jYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY2FjaGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX2NhY2hlTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLmhhcyhrZXkpO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgY29uc29sZS53YXJuKGBbQXNzZXRzXSBBc3NldCBpZCAke2tleX0gd2FzIG5vdCBmb3VuZCBpbiB0aGUgQ2FjaGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBjb252ZXJ0VG9MaXN0KGtleSk7XG4gICAgbGV0IGNhY2hlYWJsZUFzc2V0cztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXJzW2ldO1xuICAgICAgaWYgKHBhcnNlci50ZXN0KHZhbHVlKSkge1xuICAgICAgICBjYWNoZWFibGVBc3NldHMgPSBwYXJzZXIuZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2FjaGVhYmxlQXNzZXRzKSB7XG4gICAgICBjYWNoZWFibGVBc3NldHMgPSB7fTtcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgICBjYWNoZWFibGVBc3NldHNba2V5Ml0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZWFibGVBc3NldHMpO1xuICAgIGNvbnN0IGNhY2hlZEFzc2V0cyA9IHtcbiAgICAgIGNhY2hlS2V5cyxcbiAgICAgIGtleXNcbiAgICB9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgdGhpcy5fY2FjaGVNYXAuc2V0KGtleTIsIGNhY2hlZEFzc2V0cyk7XG4gICAgfSk7XG4gICAgY2FjaGVLZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoa2V5MikgJiYgdGhpcy5fY2FjaGUuZ2V0KGtleTIpICE9PSB2YWx1ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbQ2FjaGVdIGFscmVhZHkgaGFzIGtleTpcIiwga2V5Mik7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZS5zZXQoa2V5MiwgY2FjaGVhYmxlQXNzZXRzW2tleTJdKTtcbiAgICB9KTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdmFsdWU7XG4gICAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgICAgaWYgKHRleHR1cmUuYmFzZVRleHR1cmUgIT09IFRleHR1cmUuRU1QVFkuYmFzZVRleHR1cmUpIHtcbiAgICAgICAgICBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUuYmFzZVRleHR1cmUsIGtleTIpO1xuICAgICAgICB9XG4gICAgICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBrZXkyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgdGhpcy5fY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCF0aGlzLl9jYWNoZU1hcC5oYXMoa2V5KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbQXNzZXRzXSBBc3NldCBpZCAke2tleX0gd2FzIG5vdCBmb3VuZCBpbiB0aGUgQ2FjaGVgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVNYXAgPSB0aGlzLl9jYWNoZU1hcC5nZXQoa2V5KTtcbiAgICBjb25zdCBjYWNoZUtleXMgPSBjYWNoZU1hcC5jYWNoZUtleXM7XG4gICAgY2FjaGVLZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShrZXkyKTtcbiAgICB9KTtcbiAgICBjYWNoZU1hcC5rZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlTWFwLmRlbGV0ZShrZXkyKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgcGFyc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VycztcbiAgfVxufVxuY29uc3QgQ2FjaGUgPSBuZXcgQ2FjaGVDbGFzcygpO1xuXG5leHBvcnQgeyBDYWNoZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGUubWpzLm1hcFxuIiwiY29uc3QgaXNTaW5nbGVJdGVtID0gKGl0ZW0pID0+ICFBcnJheS5pc0FycmF5KGl0ZW0pO1xuXG5leHBvcnQgeyBpc1NpbmdsZUl0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2luZ2xlSXRlbS5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0ICcuLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSAnLi4vdXRpbHMvaXNTaW5nbGVJdGVtLm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi4vdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuXG5jbGFzcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXJzZXJzID0gW107XG4gICAgdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFyc2VycyA9IG5ldyBQcm94eSh0aGlzLl9wYXJzZXJzLCB7XG4gICAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb21pc2VDYWNoZSA9IHt9O1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByb21pc2VDYWNoZSA9IHt9O1xuICB9XG4gIF9nZXRMb2FkUHJvbWlzZUFuZFBhcnNlcih1cmwsIGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwcm9taXNlOiBudWxsLFxuICAgICAgcGFyc2VyOiBudWxsXG4gICAgfTtcbiAgICByZXN1bHQucHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYXNzZXQgPSBudWxsO1xuICAgICAgbGV0IHBhcnNlciA9IG51bGw7XG4gICAgICBpZiAoZGF0YS5sb2FkUGFyc2VyKSB7XG4gICAgICAgIHBhcnNlciA9IHRoaXMuX3BhcnNlckhhc2hbZGF0YS5sb2FkUGFyc2VyXTtcbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFtBc3NldHNdIHNwZWNpZmllZCBsb2FkIHBhcnNlciBcIiR7ZGF0YS5sb2FkUGFyc2VyfVwiIG5vdCBmb3VuZCB3aGlsZSBsb2FkaW5nICR7dXJsfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcnNlclggPSB0aGlzLnBhcnNlcnNbaV07XG4gICAgICAgICAgaWYgKHBhcnNlclgubG9hZCAmJiBwYXJzZXJYLnRlc3Q/Lih1cmwsIGRhdGEsIHRoaXMpKSB7XG4gICAgICAgICAgICBwYXJzZXIgPSBwYXJzZXJYO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBbQXNzZXRzXSAke3VybH0gY291bGQgbm90IGJlIGxvYWRlZCBhcyB3ZSBkb24ndCBrbm93IGhvdyB0byBwYXJzZSBpdCwgZW5zdXJlIHRoZSBjb3JyZWN0IHBhcnNlciBoYXMgYmVlbiBhZGRlZGApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3NldCA9IGF3YWl0IHBhcnNlci5sb2FkKHVybCwgZGF0YSwgdGhpcyk7XG4gICAgICByZXN1bHQucGFyc2VyID0gcGFyc2VyO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyc2VyMiA9IHRoaXMucGFyc2Vyc1tpXTtcbiAgICAgICAgaWYgKHBhcnNlcjIucGFyc2UpIHtcbiAgICAgICAgICBpZiAocGFyc2VyMi5wYXJzZSAmJiBhd2FpdCBwYXJzZXIyLnRlc3RQYXJzZT8uKGFzc2V0LCBkYXRhLCB0aGlzKSkge1xuICAgICAgICAgICAgYXNzZXQgPSBhd2FpdCBwYXJzZXIyLnBhcnNlKGFzc2V0LCBkYXRhLCB0aGlzKSB8fCBhc3NldDtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJzZXIgPSBwYXJzZXIyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFzc2V0O1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBsb2FkKGFzc2V0c1RvTG9hZEluLCBvblByb2dyZXNzKSB7XG4gICAgaWYgKCF0aGlzLl9wYXJzZXJzVmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZVBhcnNlcnMoKTtcbiAgICB9XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBhc3NldHMgPSB7fTtcbiAgICBjb25zdCBzaW5nbGVBc3NldCA9IGlzU2luZ2xlSXRlbShhc3NldHNUb0xvYWRJbik7XG4gICAgY29uc3QgYXNzZXRzVG9Mb2FkID0gY29udmVydFRvTGlzdChhc3NldHNUb0xvYWRJbiwgKGl0ZW0pID0+ICh7XG4gICAgICBzcmM6IGl0ZW1cbiAgICB9KSk7XG4gICAgY29uc3QgdG90YWwgPSBhc3NldHNUb0xvYWQubGVuZ3RoO1xuICAgIGNvbnN0IHByb21pc2VzID0gYXNzZXRzVG9Mb2FkLm1hcChhc3luYyAoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IHV0aWxzLnBhdGgudG9BYnNvbHV0ZShhc3NldC5zcmMpO1xuICAgICAgaWYgKCFhc3NldHNbYXNzZXQuc3JjXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghdGhpcy5wcm9taXNlQ2FjaGVbdXJsXSkge1xuICAgICAgICAgICAgdGhpcy5wcm9taXNlQ2FjaGVbdXJsXSA9IHRoaXMuX2dldExvYWRQcm9taXNlQW5kUGFyc2VyKHVybCwgYXNzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NldHNbYXNzZXQuc3JjXSA9IGF3YWl0IHRoaXMucHJvbWlzZUNhY2hlW3VybF0ucHJvbWlzZTtcbiAgICAgICAgICBpZiAob25Qcm9ncmVzcylcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MoKytjb3VudCAvIHRvdGFsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2VDYWNoZVt1cmxdO1xuICAgICAgICAgIGRlbGV0ZSBhc3NldHNbYXNzZXQuc3JjXTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtMb2FkZXIubG9hZF0gRmFpbGVkIHRvIGxvYWQgJHt1cmx9LlxuJHtlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IGFzc2V0c1thc3NldHNUb0xvYWRbMF0uc3JjXSA6IGFzc2V0cztcbiAgfVxuICBhc3luYyB1bmxvYWQoYXNzZXRzVG9VbmxvYWRJbikge1xuICAgIGNvbnN0IGFzc2V0c1RvVW5sb2FkID0gY29udmVydFRvTGlzdChhc3NldHNUb1VubG9hZEluLCAoaXRlbSkgPT4gKHtcbiAgICAgIHNyYzogaXRlbVxuICAgIH0pKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IGFzc2V0c1RvVW5sb2FkLm1hcChhc3luYyAoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IHV0aWxzLnBhdGgudG9BYnNvbHV0ZShhc3NldC5zcmMpO1xuICAgICAgY29uc3QgbG9hZFByb21pc2UgPSB0aGlzLnByb21pc2VDYWNoZVt1cmxdO1xuICAgICAgaWYgKGxvYWRQcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IGxvYWRlZEFzc2V0ID0gYXdhaXQgbG9hZFByb21pc2UucHJvbWlzZTtcbiAgICAgICAgbG9hZFByb21pc2UucGFyc2VyPy51bmxvYWQ/Lihsb2FkZWRBc3NldCwgYXNzZXQsIHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5wcm9taXNlQ2FjaGVbdXJsXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cbiAgX3ZhbGlkYXRlUGFyc2VycygpIHtcbiAgICB0aGlzLl9wYXJzZXJzVmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9wYXJzZXJIYXNoID0gdGhpcy5fcGFyc2Vycy5maWx0ZXIoKHBhcnNlcikgPT4gcGFyc2VyLm5hbWUpLnJlZHVjZSgoaGFzaCwgcGFyc2VyKSA9PiB7XG4gICAgICBpZiAoaGFzaFtwYXJzZXIubmFtZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbQXNzZXRzXSBsb2FkUGFyc2VyIG5hbWUgY29uZmxpY3QgXCIke3BhcnNlci5uYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5oYXNoLCBbcGFyc2VyLm5hbWVdOiBwYXJzZXIgfTtcbiAgICB9LCB7fSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgTG9hZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2FkZXIubWpzLm1hcFxuIiwidmFyIExvYWRlclBhcnNlclByaW9yaXR5ID0gLyogQF9fUFVSRV9fICovICgoTG9hZGVyUGFyc2VyUHJpb3JpdHkyKSA9PiB7XG4gIExvYWRlclBhcnNlclByaW9yaXR5MltMb2FkZXJQYXJzZXJQcmlvcml0eTJbXCJMb3dcIl0gPSAwXSA9IFwiTG93XCI7XG4gIExvYWRlclBhcnNlclByaW9yaXR5MltMb2FkZXJQYXJzZXJQcmlvcml0eTJbXCJOb3JtYWxcIl0gPSAxXSA9IFwiTm9ybWFsXCI7XG4gIExvYWRlclBhcnNlclByaW9yaXR5MltMb2FkZXJQYXJzZXJQcmlvcml0eTJbXCJIaWdoXCJdID0gMl0gPSBcIkhpZ2hcIjtcbiAgcmV0dXJuIExvYWRlclBhcnNlclByaW9yaXR5Mjtcbn0pKExvYWRlclBhcnNlclByaW9yaXR5IHx8IHt9KTtcblxuZXhwb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlclBhcnNlci5tanMubWFwXG4iLCJmdW5jdGlvbiBjaGVja0RhdGFVcmwodXJsLCBtaW1lcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtaW1lcykpIHtcbiAgICBmb3IgKGNvbnN0IG1pbWUgb2YgbWltZXMpIHtcbiAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChgZGF0YToke21pbWV9YCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybC5zdGFydHNXaXRoKGBkYXRhOiR7bWltZXN9YCk7XG59XG5cbmV4cG9ydCB7IGNoZWNrRGF0YVVybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tEYXRhVXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tICcuLi8uLi91dGlscy9jaGVja0RhdGFVcmwubWpzJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24ubWpzJztcbmltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSAnLi9Mb2FkZXJQYXJzZXIubWpzJztcblxuY29uc3QgdmFsaWRKU09ORXh0ZW5zaW9uID0gXCIuanNvblwiO1xuY29uc3QgdmFsaWRKU09OTUlNRSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuY29uc3QgbG9hZEpzb24gPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyUHJpb3JpdHkuTG93XG4gIH0sXG4gIG5hbWU6IFwibG9hZEpzb25cIixcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRKU09OTUlNRSkgfHwgY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZEpTT05FeHRlbnNpb24pO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn07XG5leHRlbnNpb25zLmFkZChsb2FkSnNvbik7XG5cbmV4cG9ydCB7IGxvYWRKc29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkSnNvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLm1qcyc7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5pbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4vTG9hZGVyUGFyc2VyLm1qcyc7XG5cbmNvbnN0IHZhbGlkVFhURXh0ZW5zaW9uID0gXCIudHh0XCI7XG5jb25zdCB2YWxpZFRYVE1JTUUgPSBcInRleHQvcGxhaW5cIjtcbmNvbnN0IGxvYWRUeHQgPSB7XG4gIG5hbWU6IFwibG9hZFR4dFwiLFxuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lkxvd1xuICB9LFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwodXJsLCB2YWxpZFRYVE1JTUUpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRUWFRFeHRlbnNpb24pO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpO1xuICAgIGNvbnN0IHR4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICByZXR1cm4gdHh0O1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZFR4dCk7XG5cbmV4cG9ydCB7IGxvYWRUeHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRUeHQubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMsIEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tICcuLi8uLi91dGlscy9jaGVja0RhdGFVcmwubWpzJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24ubWpzJztcbmltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSAnLi9Mb2FkZXJQYXJzZXIubWpzJztcblxuY29uc3QgdmFsaWRXZWlnaHRzID0gW1xuICBcIm5vcm1hbFwiLFxuICBcImJvbGRcIixcbiAgXCIxMDBcIixcbiAgXCIyMDBcIixcbiAgXCIzMDBcIixcbiAgXCI0MDBcIixcbiAgXCI1MDBcIixcbiAgXCI2MDBcIixcbiAgXCI3MDBcIixcbiAgXCI4MDBcIixcbiAgXCI5MDBcIlxuXTtcbmNvbnN0IHZhbGlkRm9udEV4dGVuc2lvbnMgPSBbXCIudHRmXCIsIFwiLm90ZlwiLCBcIi53b2ZmXCIsIFwiLndvZmYyXCJdO1xuY29uc3QgdmFsaWRGb250TUlNRXMgPSBbXG4gIFwiZm9udC90dGZcIixcbiAgXCJmb250L290ZlwiLFxuICBcImZvbnQvd29mZlwiLFxuICBcImZvbnQvd29mZjJcIlxuXTtcbmZ1bmN0aW9uIGdldEZvbnRGYW1pbHlOYW1lKHVybCkge1xuICBjb25zdCBleHQgPSB1dGlscy5wYXRoLmV4dG5hbWUodXJsKTtcbiAgY29uc3QgbmFtZSA9IHV0aWxzLnBhdGguYmFzZW5hbWUodXJsLCBleHQpO1xuICBjb25zdCBuYW1lV2l0aFNwYWNlcyA9IG5hbWUucmVwbGFjZSgvKC18XykvZywgXCIgXCIpO1xuICBjb25zdCBuYW1lVGl0bGVDYXNlID0gbmFtZVdpdGhTcGFjZXMudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIikubWFwKCh3b3JkKSA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSkuam9pbihcIiBcIik7XG4gIHJldHVybiBuYW1lVGl0bGVDYXNlO1xufVxuY29uc3QgbG9hZFdlYkZvbnQgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyUHJpb3JpdHkuTG93XG4gIH0sXG4gIG5hbWU6IFwibG9hZFdlYkZvbnRcIixcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRGb250TUlNRXMpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRGb250RXh0ZW5zaW9ucyk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9udHMgPSBzZXR0aW5ncy5BREFQVEVSLmdldEZvbnRGYWNlU2V0KCk7XG4gICAgaWYgKGZvbnRzKSB7XG4gICAgICBjb25zdCBmb250RmFjZXMgPSBbXTtcbiAgICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zLmRhdGE/LmZhbWlseSA/PyBnZXRGb250RmFtaWx5TmFtZSh1cmwpO1xuICAgICAgY29uc3Qgd2VpZ2h0cyA9IG9wdGlvbnMuZGF0YT8ud2VpZ2h0cz8uZmlsdGVyKCh3ZWlnaHQpID0+IHZhbGlkV2VpZ2h0cy5pbmNsdWRlcyh3ZWlnaHQpKSA/PyBbXCJub3JtYWxcIl07XG4gICAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhID8/IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IHdlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2UobmFtZSwgYHVybCgke2VuY29kZVVSSSh1cmwpfSlgLCB7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICB3ZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGZvbnQubG9hZCgpO1xuICAgICAgICBmb250cy5hZGQoZm9udCk7XG4gICAgICAgIGZvbnRGYWNlcy5wdXNoKGZvbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvbnRGYWNlcy5sZW5ndGggPT09IDEgPyBmb250RmFjZXNbMF0gOiBmb250RmFjZXM7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihcIltsb2FkV2ViRm9udF0gRm9udEZhY2UgQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIFNraXBwaW5nIGxvYWRpbmcgZm9udFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgdW5sb2FkKGZvbnQpIHtcbiAgICAoQXJyYXkuaXNBcnJheShmb250KSA/IGZvbnQgOiBbZm9udF0pLmZvckVhY2goKHQpID0+IHNldHRpbmdzLkFEQVBURVIuZ2V0Rm9udEZhY2VTZXQoKS5kZWxldGUodCkpO1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZFdlYkZvbnQpO1xuXG5leHBvcnQgeyBnZXRGb250RmFtaWx5TmFtZSwgbG9hZFdlYkZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRXZWJGb250Lm1qcy5tYXBcbiIsImxldCBVVUlEID0gMDtcbmxldCBNQVhfV09SS0VSUztcbmNvbnN0IFdISVRFX1BORyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FRQUFBQzFIQXdDQUFBQUMwbEVRVlI0Mm1QOC94OEFBd01DQU8raXAxc0FBQUFBU1VWT1JLNUNZSUk9XCI7XG5jb25zdCBjaGVja0ltYWdlQml0bWFwQ29kZSA9IHtcbiAgaWQ6IFwiY2hlY2tJbWFnZUJpdG1hcFwiLFxuICBjb2RlOiBgXG4gICAgYXN5bmMgZnVuY3Rpb24gY2hlY2tJbWFnZUJpdG1hcCgpXG4gICAge1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcke1dISVRFX1BOR30nKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlQmxvYiA9ICBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUJpdG1hcC53aWR0aCA9PT0gMSAmJiBpbWFnZUJpdG1hcC5oZWlnaHQgPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0ltYWdlQml0bWFwKCkudGhlbigocmVzdWx0KSA9PiB7IHNlbGYucG9zdE1lc3NhZ2UocmVzdWx0KTsgfSk7XG4gICAgYFxufTtcbmNvbnN0IHdvcmtlckNvZGUgPSB7XG4gIGlkOiBcImxvYWRJbWFnZUJpdG1hcFwiLFxuICBjb2RlOiBgXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZEltYWdlQml0bWFwKHVybClcbiAgICB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxgW1dvcmtlck1hbmFnZXIubG9hZEltYWdlQml0bWFwXSBGYWlsZWQgdG8gZmV0Y2ggXFwke3VybH06IFxcYFxuICAgICAgICAgICAgICAgICsgXFxgXFwke3Jlc3BvbnNlLnN0YXR1c30gXFwke3Jlc3BvbnNlLnN0YXR1c1RleHR9XFxgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGltYWdlQmxvYiA9ICBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2VCbG9iKTtcblxuICAgICAgICByZXR1cm4gaW1hZ2VCaXRtYXA7XG4gICAgfVxuICAgIHNlbGYub25tZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PlxuICAgIHtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgbG9hZEltYWdlQml0bWFwKGV2ZW50LmRhdGEuZGF0YVswXSk7XG5cbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGltYWdlQml0bWFwLFxuICAgICAgICAgICAgICAgIHV1aWQ6IGV2ZW50LmRhdGEudXVpZCxcbiAgICAgICAgICAgICAgICBpZDogZXZlbnQuZGF0YS5pZCxcbiAgICAgICAgICAgIH0sIFtpbWFnZUJpdG1hcF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIHV1aWQ6IGV2ZW50LmRhdGEudXVpZCxcbiAgICAgICAgICAgICAgICBpZDogZXZlbnQuZGF0YS5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtgXG59O1xubGV0IHdvcmtlclVSTDtcbmNsYXNzIFdvcmtlck1hbmFnZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fY3JlYXRlZFdvcmtlcnMgPSAwO1xuICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLnJlc29sdmVIYXNoID0ge307XG4gIH1cbiAgaXNJbWFnZUJpdG1hcFN1cHBvcnRlZCgpIHtcbiAgICBpZiAodGhpcy5faXNJbWFnZUJpdG1hcFN1cHBvcnRlZCAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQ7XG4gICAgdGhpcy5faXNJbWFnZUJpdG1hcFN1cHBvcnRlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCB3b3JrZXJVUkwyID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbY2hlY2tJbWFnZUJpdG1hcENvZGUuY29kZV0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfSkpO1xuICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVUkwyKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTDIpO1xuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQ7XG4gIH1cbiAgbG9hZEltYWdlQml0bWFwKHNyYykge1xuICAgIHJldHVybiB0aGlzLl9ydW4oXCJsb2FkSW1hZ2VCaXRtYXBcIiwgW3NyY10pO1xuICB9XG4gIGFzeW5jIF9pbml0V29ya2VycygpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIGdldFdvcmtlcigpIHtcbiAgICBpZiAoTUFYX1dPUktFUlMgPT09IHZvaWQgMCkge1xuICAgICAgTUFYX1dPUktFUlMgPSBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCA0O1xuICAgIH1cbiAgICBsZXQgd29ya2VyID0gdGhpcy53b3JrZXJQb29sLnBvcCgpO1xuICAgIGlmICghd29ya2VyICYmIHRoaXMuX2NyZWF0ZWRXb3JrZXJzIDwgTUFYX1dPUktFUlMpIHtcbiAgICAgIGlmICghd29ya2VyVVJMKSB7XG4gICAgICAgIHdvcmtlclVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dvcmtlckNvZGUuY29kZV0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3JlYXRlZFdvcmtlcnMrKztcbiAgICAgIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShldmVudC5kYXRhKTtcbiAgICAgICAgdGhpcy5yZXR1cm5Xb3JrZXIoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlcjtcbiAgfVxuICByZXR1cm5Xb3JrZXIod29ya2VyKSB7XG4gICAgdGhpcy53b3JrZXJQb29sLnB1c2god29ya2VyKTtcbiAgfVxuICBjb21wbGV0ZShkYXRhKSB7XG4gICAgaWYgKGRhdGEuZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZXNvbHZlSGFzaFtkYXRhLnV1aWRdLnJlamVjdChkYXRhLmVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNvbHZlSGFzaFtkYXRhLnV1aWRdLnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICB9XG4gICAgdGhpcy5yZXNvbHZlSGFzaFtkYXRhLnV1aWRdID0gbnVsbDtcbiAgfVxuICBhc3luYyBfcnVuKGlkLCBhcmdzKSB7XG4gICAgYXdhaXQgdGhpcy5faW5pdFdvcmtlcnMoKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgaWQsIGFyZ3VtZW50czogYXJncywgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3b3JrZXIgPSB0aGlzLmdldFdvcmtlcigpO1xuICAgIGlmICghd29ya2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRvRG8gPSB0aGlzLnF1ZXVlLnBvcCgpO1xuICAgIGNvbnN0IGlkID0gdG9Eby5pZDtcbiAgICB0aGlzLnJlc29sdmVIYXNoW1VVSURdID0geyByZXNvbHZlOiB0b0RvLnJlc29sdmUsIHJlamVjdDogdG9Eby5yZWplY3QgfTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgZGF0YTogdG9Eby5hcmd1bWVudHMsXG4gICAgICB1dWlkOiBVVUlEKyssXG4gICAgICBpZFxuICAgIH0pO1xuICB9XG59XG5jb25zdCBXb3JrZXJNYW5hZ2VyID0gbmV3IFdvcmtlck1hbmFnZXJDbGFzcygpO1xuXG5leHBvcnQgeyBXb3JrZXJNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Xb3JrZXJNYW5hZ2VyLm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIHVybCkge1xuICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoYmFzZSk7XG4gIHRleHR1cmUuYmFzZVRleHR1cmUub24oXCJkaXNwb3NlXCIsICgpID0+IHtcbiAgICBkZWxldGUgbG9hZGVyLnByb21pc2VDYWNoZVt1cmxdO1xuICB9KTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVRleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MsIEV4dGVuc2lvblR5cGUsIEJhc2VUZXh0dXJlLCB1dGlscywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLm1qcyc7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5pbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4uL0xvYWRlclBhcnNlci5tanMnO1xuaW1wb3J0IHsgV29ya2VyTWFuYWdlciB9IGZyb20gJy4uL1dvcmtlck1hbmFnZXIubWpzJztcbmltcG9ydCB7IGNyZWF0ZVRleHR1cmUgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzJztcblxuY29uc3QgdmFsaWRJbWFnZUV4dGVuc2lvbnMgPSBbXCIuanBlZ1wiLCBcIi5qcGdcIiwgXCIucG5nXCIsIFwiLndlYnBcIiwgXCIuYXZpZlwiXTtcbmNvbnN0IHZhbGlkSW1hZ2VNSU1FcyA9IFtcbiAgXCJpbWFnZS9qcGVnXCIsXG4gIFwiaW1hZ2UvcG5nXCIsXG4gIFwiaW1hZ2Uvd2VicFwiLFxuICBcImltYWdlL2F2aWZcIlxuXTtcbmFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZUJpdG1hcCh1cmwpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCk7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtsb2FkSW1hZ2VCaXRtYXBdIEZhaWxlZCB0byBmZXRjaCAke3VybH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gIH1cbiAgY29uc3QgaW1hZ2VCbG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XG4gIHJldHVybiBpbWFnZUJpdG1hcDtcbn1cbmNvbnN0IGxvYWRUZXh0dXJlcyA9IHtcbiAgbmFtZTogXCJsb2FkVGV4dHVyZXNcIixcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIGNvbmZpZzoge1xuICAgIHByZWZlcldvcmtlcnM6IHRydWUsXG4gICAgcHJlZmVyQ3JlYXRlSW1hZ2VCaXRtYXA6IHRydWUsXG4gICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCJcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRJbWFnZU1JTUVzKSB8fCBjaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkSW1hZ2VFeHRlbnNpb25zKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIGFzc2V0LCBsb2FkZXIpIHtcbiAgICBsZXQgc3JjID0gbnVsbDtcbiAgICBpZiAoZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcCAmJiB0aGlzLmNvbmZpZy5wcmVmZXJDcmVhdGVJbWFnZUJpdG1hcCkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnByZWZlcldvcmtlcnMgJiYgYXdhaXQgV29ya2VyTWFuYWdlci5pc0ltYWdlQml0bWFwU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgc3JjID0gYXdhaXQgV29ya2VyTWFuYWdlci5sb2FkSW1hZ2VCaXRtYXAodXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYyA9IGF3YWl0IGxvYWRJbWFnZUJpdG1hcCh1cmwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzcmMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzcmMgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgc3JjLmNyb3NzT3JpZ2luID0gdGhpcy5jb25maWcuY3Jvc3NPcmlnaW47XG4gICAgICAgIHNyYy5zcmMgPSB1cmw7XG4gICAgICAgIGlmIChzcmMuY29tcGxldGUpIHtcbiAgICAgICAgICByZXNvbHZlKHNyYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3JjLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoc3JjKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYmFzZSA9IG5ldyBCYXNlVGV4dHVyZShzcmMsIHtcbiAgICAgIHJlc29sdXRpb246IHV0aWxzLmdldFJlc29sdXRpb25PZlVybCh1cmwpLFxuICAgICAgLi4uYXNzZXQuZGF0YVxuICAgIH0pO1xuICAgIGJhc2UucmVzb3VyY2Uuc3JjID0gdXJsO1xuICAgIHJldHVybiBjcmVhdGVUZXh0dXJlKGJhc2UsIGxvYWRlciwgdXJsKTtcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICB0ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gIH1cbn07XG5leHRlbnNpb25zLmFkZChsb2FkVGV4dHVyZXMpO1xuXG5leHBvcnQgeyBsb2FkSW1hZ2VCaXRtYXAsIGxvYWRUZXh0dXJlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFRleHR1cmVzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIFNWR1Jlc291cmNlLCBCYXNlVGV4dHVyZSwgdXRpbHMsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaGVja0RhdGFVcmwubWpzJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24ubWpzJztcbmltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSAnLi4vTG9hZGVyUGFyc2VyLm1qcyc7XG5pbXBvcnQgeyBsb2FkVGV4dHVyZXMgfSBmcm9tICcuL2xvYWRUZXh0dXJlcy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dHVyZSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlVGV4dHVyZS5tanMnO1xuXG5jb25zdCB2YWxpZFNWR0V4dGVuc2lvbiA9IFwiLnN2Z1wiO1xuY29uc3QgdmFsaWRTVkdNSU1FID0gXCJpbWFnZS9zdmcreG1sXCI7XG5jb25zdCBsb2FkU1ZHID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5LkhpZ2hcbiAgfSxcbiAgbmFtZTogXCJsb2FkU1ZHXCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybCh1cmwsIHZhbGlkU1ZHTUlNRSkgfHwgY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZFNWR0V4dGVuc2lvbik7XG4gIH0sXG4gIGFzeW5jIHRlc3RQYXJzZShkYXRhKSB7XG4gICAgcmV0dXJuIFNWR1Jlc291cmNlLnRlc3QoZGF0YSk7XG4gIH0sXG4gIGFzeW5jIHBhcnNlKGFzc2V0LCBkYXRhLCBsb2FkZXIpIHtcbiAgICBjb25zdCBzcmMgPSBuZXcgU1ZHUmVzb3VyY2UoYXNzZXQsIGRhdGE/LmRhdGE/LnJlc291cmNlT3B0aW9ucyk7XG4gICAgY29uc3QgYmFzZSA9IG5ldyBCYXNlVGV4dHVyZShzcmMsIHtcbiAgICAgIHJlc29sdXRpb246IHV0aWxzLmdldFJlc29sdXRpb25PZlVybChhc3NldCksXG4gICAgICAuLi5kYXRhPy5kYXRhXG4gICAgfSk7XG4gICAgYmFzZS5yZXNvdXJjZS5zcmMgPSBhc3NldDtcbiAgICBjb25zdCB0ZXh0dXJlID0gY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIGFzc2V0KTtcbiAgICBpZiAoIWRhdGE/LmRhdGE/LnJlc291cmNlT3B0aW9ucz8uYXV0b0xvYWQpIHtcbiAgICAgIGF3YWl0IHNyYy5sb2FkKCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgX29wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKTtcbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9LFxuICB1bmxvYWQ6IGxvYWRUZXh0dXJlcy51bmxvYWRcbn07XG5leHRlbnNpb25zLmFkZChsb2FkU1ZHKTtcblxuZXhwb3J0IHsgbG9hZFNWRyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFNWRy5tanMubWFwXG4iLCJleHBvcnQgeyBjcmVhdGVUZXh0dXJlIH0gZnJvbSAnLi9jcmVhdGVUZXh0dXJlLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJleHBvcnQgeyBsb2FkU1ZHIH0gZnJvbSAnLi9sb2FkU1ZHLm1qcyc7XG5leHBvcnQgeyBsb2FkSW1hZ2VCaXRtYXAsIGxvYWRUZXh0dXJlcyB9IGZyb20gJy4vbG9hZFRleHR1cmVzLm1qcyc7XG5pbXBvcnQgJy4vdXRpbHMvaW5kZXgubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImV4cG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSAnLi9Mb2FkZXJQYXJzZXIubWpzJztcbmV4cG9ydCB7IGxvYWRKc29uIH0gZnJvbSAnLi9sb2FkSnNvbi5tanMnO1xuZXhwb3J0IHsgbG9hZFR4dCB9IGZyb20gJy4vbG9hZFR4dC5tanMnO1xuZXhwb3J0IHsgZ2V0Rm9udEZhbWlseU5hbWUsIGxvYWRXZWJGb250IH0gZnJvbSAnLi9sb2FkV2ViRm9udC5tanMnO1xuaW1wb3J0ICcuL3RleHR1cmVzL2luZGV4Lm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJmdW5jdGlvbiBwcm9jZXNzWChiYXNlLCBpZHMsIGRlcHRoLCByZXN1bHQsIHRhZ3MpIHtcbiAgY29uc3QgaWQgPSBpZHNbZGVwdGhdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBpZFtpXTtcbiAgICBpZiAoZGVwdGggPCBpZHMubGVuZ3RoIC0gMSkge1xuICAgICAgcHJvY2Vzc1goYmFzZS5yZXBsYWNlKHJlc3VsdFtkZXB0aF0sIHZhbHVlKSwgaWRzLCBkZXB0aCArIDEsIHJlc3VsdCwgdGFncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ3MucHVzaChiYXNlLnJlcGxhY2UocmVzdWx0W2RlcHRoXSwgdmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMoc3RyaW5nKSB7XG4gIGNvbnN0IHJlZ2V4ID0gL1xceyguKj8pXFx9L2c7XG4gIGNvbnN0IHJlc3VsdCA9IHN0cmluZy5tYXRjaChyZWdleCk7XG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgIHJlc3VsdC5mb3JFYWNoKCh2YXJzKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IHZhcnMuc3Vic3RyaW5nKDEsIHZhcnMubGVuZ3RoIC0gMSkuc3BsaXQoXCIsXCIpO1xuICAgICAgaWRzLnB1c2goc3BsaXQpO1xuICAgIH0pO1xuICAgIHByb2Nlc3NYKHN0cmluZywgaWRzLCAwLCByZXN1bHQsIHRhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRhZ3MucHVzaChzdHJpbmcpO1xuICB9XG4gIHJldHVybiB0YWdzO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi4vdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyB9IGZyb20gJy4uL3V0aWxzL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMubWpzJztcbmltcG9ydCB7IGlzU2luZ2xlSXRlbSB9IGZyb20gJy4uL3V0aWxzL2lzU2luZ2xlSXRlbS5tanMnO1xuXG5jbGFzcyBSZXNvbHZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucyA9IHtcbiAgICAgIGNvbm5lY3RvcjogXCItXCIsXG4gICAgICBjcmVhdGVCdW5kbGVBc3NldElkOiAoYnVuZGxlSWQsIGFzc2V0SWQpID0+IGAke2J1bmRsZUlkfSR7dGhpcy5fYnVuZGxlSWRDb25uZWN0b3J9JHthc3NldElkfWAsXG4gICAgICBleHRyYWN0QXNzZXRJZEZyb21CdW5kbGU6IChidW5kbGVJZCwgYXNzZXRCdW5kbGVJZCkgPT4gYXNzZXRCdW5kbGVJZC5yZXBsYWNlKGAke2J1bmRsZUlkfSR7dGhpcy5fYnVuZGxlSWRDb25uZWN0b3J9YCwgXCJcIilcbiAgICB9O1xuICAgIHRoaXMuX2J1bmRsZUlkQ29ubmVjdG9yID0gdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zLmNvbm5lY3RvcjtcbiAgICB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkID0gdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zLmNyZWF0ZUJ1bmRsZUFzc2V0SWQ7XG4gICAgdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlID0gdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zLmV4dHJhY3RBc3NldElkRnJvbUJ1bmRsZTtcbiAgICB0aGlzLl9hc3NldE1hcCA9IHt9O1xuICAgIHRoaXMuX3ByZWZlcnJlZE9yZGVyID0gW107XG4gICAgdGhpcy5fcGFyc2VycyA9IFtdO1xuICAgIHRoaXMuX3Jlc29sdmVySGFzaCA9IHt9O1xuICAgIHRoaXMuX2J1bmRsZXMgPSB7fTtcbiAgfVxuICBzZXRCdW5kbGVJZGVudGlmaWVyKGJ1bmRsZUlkZW50aWZpZXIpIHtcbiAgICB0aGlzLl9idW5kbGVJZENvbm5lY3RvciA9IGJ1bmRsZUlkZW50aWZpZXIuY29ubmVjdG9yID8/IHRoaXMuX2J1bmRsZUlkQ29ubmVjdG9yO1xuICAgIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQgPSBidW5kbGVJZGVudGlmaWVyLmNyZWF0ZUJ1bmRsZUFzc2V0SWQgPz8gdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZDtcbiAgICB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPSBidW5kbGVJZGVudGlmaWVyLmV4dHJhY3RBc3NldElkRnJvbUJ1bmRsZSA/PyB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGU7XG4gICAgaWYgKHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZShcImZvb1wiLCB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKFwiZm9vXCIsIFwiYmFyXCIpKSAhPT0gXCJiYXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1Jlc29sdmVyXSBHZW5lcmF0ZUJ1bmRsZUFzc2V0SWQgYXJlIG5vdCB3b3JraW5nIGNvcnJlY3RseVwiKTtcbiAgICB9XG4gIH1cbiAgcHJlZmVyKC4uLnByZWZlck9yZGVycykge1xuICAgIHByZWZlck9yZGVycy5mb3JFYWNoKChwcmVmZXIpID0+IHtcbiAgICAgIHRoaXMuX3ByZWZlcnJlZE9yZGVyLnB1c2gocHJlZmVyKTtcbiAgICAgIGlmICghcHJlZmVyLnByaW9yaXR5KSB7XG4gICAgICAgIHByZWZlci5wcmlvcml0eSA9IE9iamVjdC5rZXlzKHByZWZlci5wYXJhbXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3Jlc29sdmVySGFzaCA9IHt9O1xuICB9XG4gIHNldCBiYXNlUGF0aChiYXNlUGF0aCkge1xuICAgIHRoaXMuX2Jhc2VQYXRoID0gYmFzZVBhdGg7XG4gIH1cbiAgZ2V0IGJhc2VQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlUGF0aDtcbiAgfVxuICBzZXQgcm9vdFBhdGgocm9vdFBhdGgpIHtcbiAgICB0aGlzLl9yb290UGF0aCA9IHJvb3RQYXRoO1xuICB9XG4gIGdldCByb290UGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdFBhdGg7XG4gIH1cbiAgZ2V0IHBhcnNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlcnM7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zZXRCdW5kbGVJZGVudGlmaWVyKHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucyk7XG4gICAgdGhpcy5fYXNzZXRNYXAgPSB7fTtcbiAgICB0aGlzLl9wcmVmZXJyZWRPcmRlciA9IFtdO1xuICAgIHRoaXMuX3Jlc29sdmVySGFzaCA9IHt9O1xuICAgIHRoaXMuX3Jvb3RQYXRoID0gbnVsbDtcbiAgICB0aGlzLl9iYXNlUGF0aCA9IG51bGw7XG4gICAgdGhpcy5fbWFuaWZlc3QgPSBudWxsO1xuICAgIHRoaXMuX2J1bmRsZXMgPSB7fTtcbiAgICB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gbnVsbDtcbiAgfVxuICBzZXREZWZhdWx0U2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcykge1xuICAgIGlmICh0eXBlb2Ygc2VhcmNoUGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gc2VhcmNoUGFyYW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBxdWVyeVZhbHVlcyA9IHNlYXJjaFBhcmFtcztcbiAgICAgIHRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMgPSBPYmplY3Qua2V5cyhxdWVyeVZhbHVlcykubWFwKChrZXkpID0+IGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeVZhbHVlc1trZXldKX1gKS5qb2luKFwiJlwiKTtcbiAgICB9XG4gIH1cbiAgYWRkTWFuaWZlc3QobWFuaWZlc3QpIHtcbiAgICBpZiAodGhpcy5fbWFuaWZlc3QpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltSZXNvbHZlcl0gTWFuaWZlc3QgYWxyZWFkeSBleGlzdHMsIHRoaXMgd2lsbCBiZSBvdmVyd3JpdHRlblwiKTtcbiAgICB9XG4gICAgdGhpcy5fbWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICBtYW5pZmVzdC5idW5kbGVzLmZvckVhY2goKGJ1bmRsZSkgPT4ge1xuICAgICAgdGhpcy5hZGRCdW5kbGUoYnVuZGxlLm5hbWUsIGJ1bmRsZS5hc3NldHMpO1xuICAgIH0pO1xuICB9XG4gIGFkZEJ1bmRsZShidW5kbGVJZCwgYXNzZXRzKSB7XG4gICAgY29uc3QgYXNzZXROYW1lcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzc2V0cykpIHtcbiAgICAgIGFzc2V0cy5mb3JFYWNoKChhc3NldCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGFzc2V0Lm5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBidW5kbGVBc3NldElkID0gdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChidW5kbGVJZCwgYXNzZXQubmFtZSk7XG4gICAgICAgICAgYXNzZXROYW1lcy5wdXNoKGJ1bmRsZUFzc2V0SWQpO1xuICAgICAgICAgIHRoaXMuYWRkKFthc3NldC5uYW1lLCBidW5kbGVBc3NldElkXSwgYXNzZXQuc3JjcywgYXNzZXQuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYnVuZGxlSWRzID0gYXNzZXQubmFtZS5tYXAoKG5hbWUpID0+IHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIG5hbWUpKTtcbiAgICAgICAgICBidW5kbGVJZHMuZm9yRWFjaCgoYnVuZGxlSWQyKSA9PiB7XG4gICAgICAgICAgICBhc3NldE5hbWVzLnB1c2goYnVuZGxlSWQyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFkZChbLi4uYXNzZXQubmFtZSwgLi4uYnVuZGxlSWRzXSwgYXNzZXQuc3Jjcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3Qua2V5cyhhc3NldHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBhc3NldE5hbWVzLnB1c2godGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChidW5kbGVJZCwga2V5KSk7XG4gICAgICAgIHRoaXMuYWRkKFtrZXksIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIGtleSldLCBhc3NldHNba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fYnVuZGxlc1tidW5kbGVJZF0gPSBhc3NldE5hbWVzO1xuICB9XG4gIGFkZChrZXlzSW4sIGFzc2V0c0luLCBkYXRhKSB7XG4gICAgY29uc3Qga2V5cyA9IGNvbnZlcnRUb0xpc3Qoa2V5c0luKTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzS2V5KGtleSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbUmVzb2x2ZXJdIGFscmVhZHkgaGFzIGtleTogJHtrZXl9IG92ZXJ3cml0aW5nYCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFzc2V0c0luKSkge1xuICAgICAgaWYgKHR5cGVvZiBhc3NldHNJbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhc3NldHNJbiA9IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMoYXNzZXRzSW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXRzSW4gPSBbYXNzZXRzSW5dO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhc3NldE1hcCA9IGFzc2V0c0luLm1hcCgoYXNzZXQpID0+IHtcbiAgICAgIGxldCBmb3JtYXR0ZWRBc3NldCA9IGFzc2V0O1xuICAgICAgaWYgKHR5cGVvZiBhc3NldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMuX3BhcnNlcnNbaV07XG4gICAgICAgICAgaWYgKHBhcnNlci50ZXN0KGFzc2V0KSkge1xuICAgICAgICAgICAgZm9ybWF0dGVkQXNzZXQgPSBwYXJzZXIucGFyc2UoYXNzZXQpO1xuICAgICAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgIGZvcm1hdHRlZEFzc2V0ID0ge1xuICAgICAgICAgICAgc3JjOiBhc3NldFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm9ybWF0dGVkQXNzZXQuZm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdHRlZEFzc2V0LmZvcm1hdCA9IGZvcm1hdHRlZEFzc2V0LnNyYy5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAoIWZvcm1hdHRlZEFzc2V0LmFsaWFzKSB7XG4gICAgICAgIGZvcm1hdHRlZEFzc2V0LmFsaWFzID0ga2V5cztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9iYXNlUGF0aCB8fCB0aGlzLl9yb290UGF0aCkge1xuICAgICAgICBmb3JtYXR0ZWRBc3NldC5zcmMgPSB1dGlscy5wYXRoLnRvQWJzb2x1dGUoZm9ybWF0dGVkQXNzZXQuc3JjLCB0aGlzLl9iYXNlUGF0aCwgdGhpcy5fcm9vdFBhdGgpO1xuICAgICAgfVxuICAgICAgZm9ybWF0dGVkQXNzZXQuc3JjID0gdGhpcy5fYXBwZW5kRGVmYXVsdFNlYXJjaFBhcmFtcyhmb3JtYXR0ZWRBc3NldC5zcmMpO1xuICAgICAgZm9ybWF0dGVkQXNzZXQuZGF0YSA9IGZvcm1hdHRlZEFzc2V0LmRhdGEgPz8gZGF0YTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZWRBc3NldDtcbiAgICB9KTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5fYXNzZXRNYXBba2V5XSA9IGFzc2V0TWFwO1xuICAgIH0pO1xuICB9XG4gIHJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKSB7XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0oYnVuZGxlSWRzKTtcbiAgICBidW5kbGVJZHMgPSBjb252ZXJ0VG9MaXN0KGJ1bmRsZUlkcyk7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgYnVuZGxlSWRzLmZvckVhY2goKGJ1bmRsZUlkKSA9PiB7XG4gICAgICBjb25zdCBhc3NldE5hbWVzID0gdGhpcy5fYnVuZGxlc1tidW5kbGVJZF07XG4gICAgICBpZiAoYXNzZXROYW1lcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5yZXNvbHZlKGFzc2V0TmFtZXMpO1xuICAgICAgICBjb25zdCBhc3NldHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgICAgIGNvbnN0IGFzc2V0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICAgIGFzc2V0c1t0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUoYnVuZGxlSWQsIGtleSldID0gYXNzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgb3V0W2J1bmRsZUlkXSA9IGFzc2V0cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2luZ2xlQXNzZXQgPyBvdXRbYnVuZGxlSWRzWzBdXSA6IG91dDtcbiAgfVxuICByZXNvbHZlVXJsKGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzb2x2ZShrZXkpO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBvdXQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgaSBpbiByZXN1bHQpIHtcbiAgICAgICAgb3V0W2ldID0gcmVzdWx0W2ldLnNyYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc3JjO1xuICB9XG4gIHJlc29sdmUoa2V5cykge1xuICAgIGNvbnN0IHNpbmdsZUFzc2V0ID0gaXNTaW5nbGVJdGVtKGtleXMpO1xuICAgIGtleXMgPSBjb252ZXJ0VG9MaXN0KGtleXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc29sdmVySGFzaFtrZXldKSB7XG4gICAgICAgIGlmICh0aGlzLl9hc3NldE1hcFtrZXldKSB7XG4gICAgICAgICAgbGV0IGFzc2V0cyA9IHRoaXMuX2Fzc2V0TWFwW2tleV07XG4gICAgICAgICAgY29uc3QgcHJlZmVycmVkT3JkZXIgPSB0aGlzLl9nZXRQcmVmZXJyZWRPcmRlcihhc3NldHMpO1xuICAgICAgICAgIGNvbnN0IGJlc3RBc3NldCA9IGFzc2V0c1swXTtcbiAgICAgICAgICBwcmVmZXJyZWRPcmRlcj8ucHJpb3JpdHkuZm9yRWFjaCgocHJpb3JpdHlLZXkpID0+IHtcbiAgICAgICAgICAgIHByZWZlcnJlZE9yZGVyLnBhcmFtc1twcmlvcml0eUtleV0uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRBc3NldHMgPSBhc3NldHMuZmlsdGVyKChhc3NldCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhc3NldFtwcmlvcml0eUtleV0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhc3NldFtwcmlvcml0eUtleV0gPT09IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRBc3NldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXNzZXRzID0gZmlsdGVyZWRBc3NldHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVySGFzaFtrZXldID0gYXNzZXRzWzBdID8/IGJlc3RBc3NldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgc3JjID0ga2V5O1xuICAgICAgICAgIGlmICh0aGlzLl9iYXNlUGF0aCB8fCB0aGlzLl9yb290UGF0aCkge1xuICAgICAgICAgICAgc3JjID0gdXRpbHMucGF0aC50b0Fic29sdXRlKHNyYywgdGhpcy5fYmFzZVBhdGgsIHRoaXMuX3Jvb3RQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3JjID0gdGhpcy5fYXBwZW5kRGVmYXVsdFNlYXJjaFBhcmFtcyhzcmMpO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVySGFzaFtrZXldID0ge1xuICAgICAgICAgICAgc3JjXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLl9yZXNvbHZlckhhc2hba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2luZ2xlQXNzZXQgPyByZXN1bHRba2V5c1swXV0gOiByZXN1bHQ7XG4gIH1cbiAgaGFzS2V5KGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuX2Fzc2V0TWFwW2tleV07XG4gIH1cbiAgaGFzQnVuZGxlKGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuX2J1bmRsZXNba2V5XTtcbiAgfVxuICBfZ2V0UHJlZmVycmVkT3JkZXIoYXNzZXRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRzWzBdO1xuICAgICAgY29uc3QgcHJlZmVycmVkID0gdGhpcy5fcHJlZmVycmVkT3JkZXIuZmluZCgocHJlZmVyZW5jZSkgPT4gcHJlZmVyZW5jZS5wYXJhbXMuZm9ybWF0LmluY2x1ZGVzKGFzc2V0LmZvcm1hdCkpO1xuICAgICAgaWYgKHByZWZlcnJlZCkge1xuICAgICAgICByZXR1cm4gcHJlZmVycmVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJlZmVycmVkT3JkZXJbMF07XG4gIH1cbiAgX2FwcGVuZERlZmF1bHRTZWFyY2hQYXJhbXModXJsKSB7XG4gICAgaWYgKCF0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zKVxuICAgICAgcmV0dXJuIHVybDtcbiAgICBjb25zdCBwYXJhbUNvbm5lY3RvciA9IC9cXD8vLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCI7XG4gICAgcmV0dXJuIGAke3VybH0ke3BhcmFtQ29ubmVjdG9yfSR7dGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtc31gO1xuICB9XG59XG5cbmV4cG9ydCB7IFJlc29sdmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNvbHZlci5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zLCBFeHRlbnNpb25UeXBlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gJ0BwaXhpL3V0aWxzJztcbmltcG9ydCB7IEJhY2tncm91bmRMb2FkZXIgfSBmcm9tICcuL0JhY2tncm91bmRMb2FkZXIubWpzJztcbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXIvTG9hZGVyLm1qcyc7XG5pbXBvcnQgJy4vbG9hZGVyL3BhcnNlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IFJlc29sdmVyIH0gZnJvbSAnLi9yZXNvbHZlci9SZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4vdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuaW1wb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSAnLi91dGlscy9pc1NpbmdsZUl0ZW0ubWpzJztcbmltcG9ydCB7IGxvYWRUZXh0dXJlcyB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qcyc7XG5cbmNsYXNzIEFzc2V0c0NsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGV0ZWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5yZXNvbHZlciA9IG5ldyBSZXNvbHZlcigpO1xuICAgIHRoaXMubG9hZGVyID0gbmV3IExvYWRlcigpO1xuICAgIHRoaXMuY2FjaGUgPSBDYWNoZTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyID0gbmV3IEJhY2tncm91bmRMb2FkZXIodGhpcy5sb2FkZXIpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgYXN5bmMgaW5pdChvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltBc3NldHNdQXNzZXRNYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGl6ZWQsIGRpZCB5b3UgbG9hZCBiZWZvcmUgY2FsbGluZyB0aGlzIEFzc2V0LmluaXQoKT9cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgICB0aGlzLnJlc29sdmVyLnNldERlZmF1bHRTZWFyY2hQYXJhbXMob3B0aW9ucy5kZWZhdWx0U2VhcmNoUGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmFzZVBhdGgpIHtcbiAgICAgIHRoaXMucmVzb2x2ZXIuYmFzZVBhdGggPSBvcHRpb25zLmJhc2VQYXRoO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5idW5kbGVJZGVudGlmaWVyKSB7XG4gICAgICB0aGlzLnJlc29sdmVyLnNldEJ1bmRsZUlkZW50aWZpZXIob3B0aW9ucy5idW5kbGVJZGVudGlmaWVyKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWFuaWZlc3QpIHtcbiAgICAgIGxldCBtYW5pZmVzdCA9IG9wdGlvbnMubWFuaWZlc3Q7XG4gICAgICBpZiAodHlwZW9mIG1hbmlmZXN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1hbmlmZXN0ID0gYXdhaXQgdGhpcy5sb2FkKG1hbmlmZXN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzb2x2ZXIuYWRkTWFuaWZlc3QobWFuaWZlc3QpO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uUHJlZiA9IG9wdGlvbnMudGV4dHVyZVByZWZlcmVuY2U/LnJlc29sdXRpb24gPz8gMTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdHlwZW9mIHJlc29sdXRpb25QcmVmID09PSBcIm51bWJlclwiID8gW3Jlc29sdXRpb25QcmVmXSA6IHJlc29sdXRpb25QcmVmO1xuICAgIGxldCBmb3JtYXRzID0gW107XG4gICAgaWYgKG9wdGlvbnMudGV4dHVyZVByZWZlcmVuY2U/LmZvcm1hdCkge1xuICAgICAgY29uc3QgZm9ybWF0UHJlZiA9IG9wdGlvbnMudGV4dHVyZVByZWZlcmVuY2U/LmZvcm1hdDtcbiAgICAgIGZvcm1hdHMgPSB0eXBlb2YgZm9ybWF0UHJlZiA9PT0gXCJzdHJpbmdcIiA/IFtmb3JtYXRQcmVmXSA6IGZvcm1hdFByZWY7XG4gICAgICBmb3IgKGNvbnN0IGRldGVjdGlvbiBvZiB0aGlzLl9kZXRlY3Rpb25zKSB7XG4gICAgICAgIGlmICghYXdhaXQgZGV0ZWN0aW9uLnRlc3QoKSkge1xuICAgICAgICAgIGZvcm1hdHMgPSBhd2FpdCBkZXRlY3Rpb24ucmVtb3ZlKGZvcm1hdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgZGV0ZWN0aW9uIG9mIHRoaXMuX2RldGVjdGlvbnMpIHtcbiAgICAgICAgaWYgKGF3YWl0IGRldGVjdGlvbi50ZXN0KCkpIHtcbiAgICAgICAgICBmb3JtYXRzID0gYXdhaXQgZGV0ZWN0aW9uLmFkZChmb3JtYXRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlc29sdmVyLnByZWZlcih7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgZm9ybWF0OiBmb3JtYXRzLFxuICAgICAgICByZXNvbHV0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMucHJlZmVyZW5jZXMpIHtcbiAgICAgIHRoaXMuc2V0UHJlZmVyZW5jZXMob3B0aW9ucy5wcmVmZXJlbmNlcyk7XG4gICAgfVxuICB9XG4gIGFkZChrZXlzSW4sIGFzc2V0c0luLCBkYXRhKSB7XG4gICAgdGhpcy5yZXNvbHZlci5hZGQoa2V5c0luLCBhc3NldHNJbiwgZGF0YSk7XG4gIH1cbiAgYXN5bmMgbG9hZCh1cmxzLCBvblByb2dyZXNzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGNvbnN0IHNpbmdsZUFzc2V0ID0gaXNTaW5nbGVJdGVtKHVybHMpO1xuICAgIGNvbnN0IHVybEFycmF5ID0gY29udmVydFRvTGlzdCh1cmxzKS5tYXAoKHVybCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5hZGQodXJsLnNyYywgdXJsKTtcbiAgICAgICAgcmV0dXJuIHVybC5zcmM7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVzb2x2ZXIuaGFzS2V5KHVybCkpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5hZGQodXJsLCB1cmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9KTtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxBcnJheSk7XG4gICAgY29uc3Qgb3V0ID0gYXdhaXQgdGhpcy5fbWFwTG9hZFRvUmVzb2x2ZShyZXNvbHZlUmVzdWx0cywgb25Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gb3V0W3VybEFycmF5WzBdXSA6IG91dDtcbiAgfVxuICBhZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cykge1xuICAgIHRoaXMucmVzb2x2ZXIuYWRkQnVuZGxlKGJ1bmRsZUlkLCBhc3NldHMpO1xuICB9XG4gIGFzeW5jIGxvYWRCdW5kbGUoYnVuZGxlSWRzLCBvblByb2dyZXNzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGxldCBzaW5nbGVBc3NldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYnVuZGxlSWRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzaW5nbGVBc3NldCA9IHRydWU7XG4gICAgICBidW5kbGVJZHMgPSBbYnVuZGxlSWRzXTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZVJlc3VsdHMpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBjb25zdCBfb25Qcm9ncmVzcyA9ICgpID0+IHtcbiAgICAgIG9uUHJvZ3Jlc3M/LigrK2NvdW50IC8gdG90YWwpO1xuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZXMgPSBrZXlzLm1hcCgoYnVuZGxlSWQpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVSZXN1bHQgPSByZXNvbHZlUmVzdWx0c1tidW5kbGVJZF07XG4gICAgICB0b3RhbCArPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0KS5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwTG9hZFRvUmVzb2x2ZShyZXNvbHZlUmVzdWx0LCBfb25Qcm9ncmVzcykudGhlbigocmVzb2x2ZVJlc3VsdDIpID0+IHtcbiAgICAgICAgb3V0W2J1bmRsZUlkXSA9IHJlc29sdmVSZXN1bHQyO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IG91dFtidW5kbGVJZHNbMF1dIDogb3V0O1xuICB9XG4gIGFzeW5jIGJhY2tncm91bmRMb2FkKHVybHMpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB1cmxzID0gW3VybHNdO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxzKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFkZChPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKSk7XG4gIH1cbiAgYXN5bmMgYmFja2dyb3VuZExvYWRCdW5kbGUoYnVuZGxlSWRzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYnVuZGxlSWRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBidW5kbGVJZHMgPSBbYnVuZGxlSWRzXTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKTtcbiAgICBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0KSA9PiB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFkZChPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJlc29sdmVyLnJlc2V0KCk7XG4gICAgdGhpcy5sb2FkZXIucmVzZXQoKTtcbiAgICB0aGlzLmNhY2hlLnJlc2V0KCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQoa2V5cykge1xuICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIENhY2hlLmdldChrZXlzKTtcbiAgICB9XG4gICAgY29uc3QgYXNzZXRzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhc3NldHNbaV0gPSBDYWNoZS5nZXQoa2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBhc3NldHM7XG4gIH1cbiAgYXN5bmMgX21hcExvYWRUb1Jlc29sdmUocmVzb2x2ZVJlc3VsdHMsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKTtcbiAgICBjb25zdCByZXNvbHZlS2V5cyA9IE9iamVjdC5rZXlzKHJlc29sdmVSZXN1bHRzKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFjdGl2ZSA9IGZhbHNlO1xuICAgIGNvbnN0IGxvYWRlZEFzc2V0cyA9IGF3YWl0IHRoaXMubG9hZGVyLmxvYWQocmVzb2x2ZUFycmF5LCBvblByb2dyZXNzKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFjdGl2ZSA9IHRydWU7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgcmVzb2x2ZUFycmF5LmZvckVhY2goKHJlc29sdmVSZXN1bHQsIGkpID0+IHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gbG9hZGVkQXNzZXRzW3Jlc29sdmVSZXN1bHQuc3JjXTtcbiAgICAgIGNvbnN0IGtleXMgPSBbcmVzb2x2ZVJlc3VsdC5zcmNdO1xuICAgICAgaWYgKHJlc29sdmVSZXN1bHQuYWxpYXMpIHtcbiAgICAgICAga2V5cy5wdXNoKC4uLnJlc29sdmVSZXN1bHQuYWxpYXMpO1xuICAgICAgfVxuICAgICAgb3V0W3Jlc29sdmVLZXlzW2ldXSA9IGFzc2V0O1xuICAgICAgQ2FjaGUuc2V0KGtleXMsIGFzc2V0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGFzeW5jIHVubG9hZCh1cmxzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGNvbnN0IHVybEFycmF5ID0gY29udmVydFRvTGlzdCh1cmxzKS5tYXAoKHVybCkgPT4gdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiA/IHVybC5zcmMgOiB1cmwpO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlKHVybEFycmF5KTtcbiAgICBhd2FpdCB0aGlzLl91bmxvYWRGcm9tUmVzb2x2ZWQocmVzb2x2ZVJlc3VsdHMpO1xuICB9XG4gIGFzeW5jIHVubG9hZEJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgYnVuZGxlSWRzID0gY29udmVydFRvTGlzdChidW5kbGVJZHMpO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQnVuZGxlKGJ1bmRsZUlkcyk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0cykubWFwKChidW5kbGVJZCkgPT4gdGhpcy5fdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHRzW2J1bmRsZUlkXSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICBhc3luYyBfdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHQpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHQpO1xuICAgIHJlc29sdmVBcnJheS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0MikgPT4ge1xuICAgICAgQ2FjaGUucmVtb3ZlKHJlc29sdmVSZXN1bHQyLnNyYyk7XG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5sb2FkZXIudW5sb2FkKHJlc29sdmVBcnJheSk7XG4gIH1cbiAgZ2V0IGRldGVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RldGVjdGlvbnM7XG4gIH1cbiAgZ2V0IHByZWZlcldvcmtlcnMoKSB7XG4gICAgcmV0dXJuIGxvYWRUZXh0dXJlcy5jb25maWcucHJlZmVyV29ya2VycztcbiAgfVxuICBzZXQgcHJlZmVyV29ya2Vycyh2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJBc3NldHMucHJlZmVyc1dvcmtlcnMgaXMgZGVwcmVjYXRlZCwgdXNlIEFzc2V0cy5zZXRQcmVmZXJlbmNlcyh7IHByZWZlcldvcmtlcnM6IHRydWUgfSkgaW5zdGVhZC5cIik7XG4gICAgdGhpcy5zZXRQcmVmZXJlbmNlcyh7IHByZWZlcldvcmtlcnM6IHZhbHVlIH0pO1xuICB9XG4gIHNldFByZWZlcmVuY2VzKHByZWZlcmVuY2VzKSB7XG4gICAgdGhpcy5sb2FkZXIucGFyc2Vycy5mb3JFYWNoKChwYXJzZXIpID0+IHtcbiAgICAgIGlmICghcGFyc2VyLmNvbmZpZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgT2JqZWN0LmtleXMocGFyc2VyLmNvbmZpZykuZmlsdGVyKChrZXkpID0+IGtleSBpbiBwcmVmZXJlbmNlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHBhcnNlci5jb25maWdba2V5XSA9IHByZWZlcmVuY2VzW2tleV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQXNzZXRzID0gbmV3IEFzc2V0c0NsYXNzKCk7XG5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsIEFzc2V0cy5sb2FkZXIucGFyc2VycykuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlciwgQXNzZXRzLnJlc29sdmVyLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLkNhY2hlUGFyc2VyLCBBc3NldHMuY2FjaGUucGFyc2VycykuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLCBBc3NldHMuZGV0ZWN0aW9ucyk7XG5cbmV4cG9ydCB7IEFzc2V0cywgQXNzZXRzQ2xhc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0cy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBUZXh0dXJlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGNhY2hlVGV4dHVyZUFycmF5ID0ge1xuICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsXG4gIHRlc3Q6IChhc3NldCkgPT4gQXJyYXkuaXNBcnJheShhc3NldCkgJiYgYXNzZXQuZXZlcnkoKHQpID0+IHQgaW5zdGFuY2VvZiBUZXh0dXJlKSxcbiAgZ2V0Q2FjaGVhYmxlQXNzZXRzOiAoa2V5cywgYXNzZXQpID0+IHtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgYXNzZXQuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBvdXRba2V5ICsgKGkgPT09IDAgPyBcIlwiIDogaSArIDEpXSA9IGl0ZW07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQoY2FjaGVUZXh0dXJlQXJyYXkpO1xuXG5leHBvcnQgeyBjYWNoZVRleHR1cmVBcnJheSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGVUZXh0dXJlQXJyYXkubWpzLm1hcFxuIiwiZXhwb3J0IHsgY2FjaGVUZXh0dXJlQXJyYXkgfSBmcm9tICcuL2NhY2hlVGV4dHVyZUFycmF5Lm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJleHBvcnQgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUubWpzJztcbmltcG9ydCAnLi9DYWNoZVBhcnNlci5tanMnO1xuaW1wb3J0ICcuL3BhcnNlcnMvaW5kZXgubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGRldGVjdEF2aWYgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAxXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYXZpZkRhdGEgPSBcImRhdGE6aW1hZ2UvYXZpZjtiYXNlNjQsQUFBQUlHWjBlWEJoZG1sbUFBQUFBR0YyYVdadGFXWXhiV2xoWmsxQk1VSUFBQUR5YldWMFlRQUFBQUFBQUFBb2FHUnNjZ0FBQUFBQUFBQUFjR2xqZEFBQUFBQUFBQUFBQUFBQUFHeHBZbUYyYVdZQUFBQUFEbkJwZEcwQUFBQUFBQUVBQUFBZWFXeHZZd0FBQUFCRUFBQUJBQUVBQUFBQkFBQUJHZ0FBQUIwQUFBQW9hV2x1WmdBQUFBQUFBUUFBQUJwcGJtWmxBZ0FBQUFBQkFBQmhkakF4UTI5c2IzSUFBQUFBYW1sd2NuQUFBQUJMYVhCamJ3QUFBQlJwYzNCbEFBQUFBQUFBQUFJQUFBQUNBQUFBRUhCcGVHa0FBQUFBQXdnSUNBQUFBQXhoZGpGRGdRME1BQUFBQUJOamIyeHlibU5zZUFBQ0FBSUFBWUFBQUFBWGFYQnRZUUFBQUFBQUFBQUJBQUVFQVFLREJBQUFBQ1Z0WkdGMEVnQUtDQmdBTm9nUUVBd2dNZzhmOEQvLy84V2Zod0I4K0VySzQyQT1cIjtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaChhdmlmRGF0YSkudGhlbigocikgPT4gci5ibG9iKCkpO1xuICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChibG9iKS50aGVuKCgpID0+IHRydWUsICgpID0+IGZhbHNlKTtcbiAgfSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIFwiYXZpZlwiXSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gZm9ybWF0cy5maWx0ZXIoKGYpID0+IGYgIT09IFwiYXZpZlwiKVxufTtcbmV4dGVuc2lvbnMuYWRkKGRldGVjdEF2aWYpO1xuXG5leHBvcnQgeyBkZXRlY3RBdmlmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RBdmlmLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGRldGVjdFdlYnAgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAwXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgd2VicERhdGEgPSBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JoNEFBQUJYUlVKUVZsQTRUQkVBQUFBdkFBQUFBQWZRLy83M3YvK0JpT2gvQUFBPVwiO1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHdlYnBEYXRhKS50aGVuKChyKSA9PiByLmJsb2IoKSk7XG4gICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpLnRoZW4oKCkgPT4gdHJ1ZSwgKCkgPT4gZmFsc2UpO1xuICB9LFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiBbLi4uZm9ybWF0cywgXCJ3ZWJwXCJdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gZiAhPT0gXCJ3ZWJwXCIpXG59O1xuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0V2VicCk7XG5cbmV4cG9ydCB7IGRldGVjdFdlYnAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdFdlYnAubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jb25zdCBpbWFnZUZvcm1hdHMgPSBbXCJwbmdcIiwgXCJqcGdcIiwgXCJqcGVnXCJdO1xuY29uc3QgZGV0ZWN0RGVmYXVsdHMgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAtMVxuICB9LFxuICB0ZXN0OiAoKSA9PiBQcm9taXNlLnJlc29sdmUodHJ1ZSksXG4gIGFkZDogYXN5bmMgKGZvcm1hdHMpID0+IFsuLi5mb3JtYXRzLCAuLi5pbWFnZUZvcm1hdHNdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gIWltYWdlRm9ybWF0cy5pbmNsdWRlcyhmKSlcbn07XG5leHRlbnNpb25zLmFkZChkZXRlY3REZWZhdWx0cyk7XG5cbmV4cG9ydCB7IGRldGVjdERlZmF1bHRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3REZWZhdWx0cy5tanMubWFwXG4iLCJleHBvcnQgeyBkZXRlY3RBdmlmIH0gZnJvbSAnLi9kZXRlY3RBdmlmLm1qcyc7XG5leHBvcnQgeyBkZXRlY3RXZWJwIH0gZnJvbSAnLi9kZXRlY3RXZWJwLm1qcyc7XG5leHBvcnQgeyBkZXRlY3REZWZhdWx0cyB9IGZyb20gJy4vZGV0ZWN0RGVmYXVsdHMubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCAnLi9wYXJzZXJzL2luZGV4Lm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgJy4vcGFyc2Vycy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3R5cGVzLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0ICcuLi8uLi9sb2FkZXIvaW5kZXgubWpzJztcbmltcG9ydCB7IGxvYWRUZXh0dXJlcyB9IGZyb20gJy4uLy4uL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRUZXh0dXJlcy5tanMnO1xuXG5jb25zdCByZXNvbHZlVGV4dHVyZVVybCA9IHtcbiAgZXh0ZW5zaW9uOiBFeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gIHRlc3Q6IGxvYWRUZXh0dXJlcy50ZXN0LFxuICBwYXJzZTogKHZhbHVlKSA9PiAoe1xuICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoc2V0dGluZ3MuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICBmb3JtYXQ6IHZhbHVlLnNwbGl0KFwiLlwiKS5wb3AoKSxcbiAgICBzcmM6IHZhbHVlXG4gIH0pXG59O1xuZXh0ZW5zaW9ucy5hZGQocmVzb2x2ZVRleHR1cmVVcmwpO1xuXG5leHBvcnQgeyByZXNvbHZlVGV4dHVyZVVybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZVRleHR1cmVVcmwubWpzLm1hcFxuIiwiZXhwb3J0IHsgcmVzb2x2ZVRleHR1cmVVcmwgfSBmcm9tICcuL3Jlc29sdmVUZXh0dXJlVXJsLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgJy4vcGFyc2Vycy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3R5cGVzLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjb25zdCBjb3B5U2VhcmNoUGFyYW1zID0gKHRhcmdldFVybCwgc291cmNlVXJsKSA9PiB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHNvdXJjZVVybC5zcGxpdChcIj9cIilbMV07XG4gIGlmIChzZWFyY2hQYXJhbXMpIHtcbiAgICB0YXJnZXRVcmwgKz0gYD8ke3NlYXJjaFBhcmFtc31gO1xuICB9XG4gIHJldHVybiB0YXJnZXRVcmw7XG59O1xuXG5leHBvcnQgeyBjb3B5U2VhcmNoUGFyYW1zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5U2VhcmNoUGFyYW1zLm1qcy5tYXBcbiIsImltcG9ydCAnLi9Bc3NldEV4dGVuc2lvbi5tanMnO1xuZXhwb3J0IHsgQXNzZXRzLCBBc3NldHNDbGFzcyB9IGZyb20gJy4vQXNzZXRzLm1qcyc7XG5pbXBvcnQgJy4vY2FjaGUvaW5kZXgubWpzJztcbmltcG9ydCAnLi9kZXRlY3Rpb25zL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vbG9hZGVyL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vcmVzb2x2ZXIvaW5kZXgubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuZXhwb3J0IHsgQ2FjaGUgfSBmcm9tICcuL2NhY2hlL0NhY2hlLm1qcyc7XG5leHBvcnQgeyBjYWNoZVRleHR1cmVBcnJheSB9IGZyb20gJy4vY2FjaGUvcGFyc2Vycy9jYWNoZVRleHR1cmVBcnJheS5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0QXZpZiB9IGZyb20gJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdEF2aWYubWpzJztcbmV4cG9ydCB7IGRldGVjdFdlYnAgfSBmcm9tICcuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qcyc7XG5leHBvcnQgeyBkZXRlY3REZWZhdWx0cyB9IGZyb20gJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdERlZmF1bHRzLm1qcyc7XG5leHBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvTG9hZGVyUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBsb2FkSnNvbiB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvbG9hZEpzb24ubWpzJztcbmV4cG9ydCB7IGxvYWRUeHQgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL2xvYWRUeHQubWpzJztcbmV4cG9ydCB7IGdldEZvbnRGYW1pbHlOYW1lLCBsb2FkV2ViRm9udCB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvbG9hZFdlYkZvbnQubWpzJztcbmV4cG9ydCB7IGxvYWRTVkcgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRTVkcubWpzJztcbmV4cG9ydCB7IGxvYWRJbWFnZUJpdG1hcCwgbG9hZFRleHR1cmVzIH0gZnJvbSAnLi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkVGV4dHVyZXMubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVRleHR1cmUgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzJztcbmV4cG9ydCB7IHJlc29sdmVUZXh0dXJlVXJsIH0gZnJvbSAnLi9yZXNvbHZlci9wYXJzZXJzL3Jlc29sdmVUZXh0dXJlVXJsLm1qcyc7XG5leHBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tICcuL3V0aWxzL2NoZWNrRGF0YVVybC5tanMnO1xuZXhwb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5leHBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi91dGlscy9jb252ZXJ0VG9MaXN0Lm1qcyc7XG5leHBvcnQgeyBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSAnLi91dGlscy9jb3B5U2VhcmNoUGFyYW1zLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zIH0gZnJvbSAnLi91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcyc7XG5leHBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tICcuL3V0aWxzL2lzU2luZ2xlSXRlbS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIElOVEVSTkFMX0ZPUk1BVFMgPSAvKiBAX19QVVJFX18gKi8gKChJTlRFUk5BTF9GT1JNQVRTMikgPT4ge1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIl0gPSAzMzc3Nl0gPSBcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVFwiXSA9IDMzNzc3XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVFwiXSA9IDMzNzc4XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFwiXSA9IDMzNzc5XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVFwiXSA9IDM1OTE3XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVFwiXSA9IDM1OTE4XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFwiXSA9IDM1OTE5XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVFwiXSA9IDM1OTE2XSA9IFwiQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1IxMV9FQUNcIl0gPSAzNzQ4OF0gPSBcIkNPTVBSRVNTRURfUjExX0VBQ1wiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUNcIl0gPSAzNzQ4OV0gPSBcIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUNcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHMTFfRUFDXCJdID0gMzc0OTBdID0gXCJDT01QUkVTU0VEX1JHMTFfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUNcIl0gPSAzNzQ5MV0gPSBcIkNPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0I4X0VUQzJcIl0gPSAzNzQ5Ml0gPSBcIkNPTVBSRVNTRURfUkdCOF9FVEMyXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ1wiXSA9IDM3NDk2XSA9IFwiQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ1wiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU1JHQjhfRVRDMlwiXSA9IDM3NDkzXSA9IFwiQ09NUFJFU1NFRF9TUkdCOF9FVEMyXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUNcIl0gPSAzNzQ5N10gPSBcIkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiXSA9IDM3NDk0XSA9IFwiQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU1JHQjhfUFVOQ0hUSFJPVUdIX0FMUEhBMV9FVEMyXCJdID0gMzc0OTVdID0gXCJDT01QUkVTU0VEX1NSR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUdcIl0gPSAzNTg0MF0gPSBcIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUdcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNR1wiXSA9IDM1ODQyXSA9IFwiQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUdcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HXCJdID0gMzU4NDFdID0gXCJDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUdcIl0gPSAzNTg0M10gPSBcIkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTFwiXSA9IDM2MTk2XSA9IFwiQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX0FUQ19XRUJHTFwiXSA9IDM1OTg2XSA9IFwiQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTFwiXSA9IDM1OTg2XSA9IFwiQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMXCJdID0gMzQ3OThdID0gXCJDT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFJcIl0gPSAzNzgwOF0gPSBcIkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFJcIjtcbiAgcmV0dXJuIElOVEVSTkFMX0ZPUk1BVFMyO1xufSkoSU5URVJOQUxfRk9STUFUUyB8fCB7fSk7XG5jb25zdCBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMID0ge1xuICBbMzM3NzYgLyogQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCAqL106IDAuNSxcbiAgWzMzNzc3IC8qIENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUICovXTogMC41LFxuICBbMzM3NzggLyogQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQgKi9dOiAxLFxuICBbMzM3NzkgLyogQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQgKi9dOiAxLFxuICBbMzU5MTYgLyogQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQgKi9dOiAwLjUsXG4gIFszNTkxNyAvKiBDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVCAqL106IDAuNSxcbiAgWzM1OTE4IC8qIENPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUICovXTogMSxcbiAgWzM1OTE5IC8qIENPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUICovXTogMSxcbiAgWzM3NDg4IC8qIENPTVBSRVNTRURfUjExX0VBQyAqL106IDAuNSxcbiAgWzM3NDg5IC8qIENPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUMgKi9dOiAwLjUsXG4gIFszNzQ5MCAvKiBDT01QUkVTU0VEX1JHMTFfRUFDICovXTogMSxcbiAgWzM3NDkxIC8qIENPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDICovXTogMSxcbiAgWzM3NDkyIC8qIENPTVBSRVNTRURfUkdCOF9FVEMyICovXTogMC41LFxuICBbMzc0OTYgLyogQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQyAqL106IDEsXG4gIFszNzQ5MyAvKiBDT01QUkVTU0VEX1NSR0I4X0VUQzIgKi9dOiAwLjUsXG4gIFszNzQ5NyAvKiBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyAqL106IDEsXG4gIFszNzQ5NCAvKiBDT01QUkVTU0VEX1JHQjhfUFVOQ0hUSFJPVUdIX0FMUEhBMV9FVEMyICovXTogMC41LFxuICBbMzc0OTUgLyogQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzIgKi9dOiAwLjUsXG4gIFszNTg0MCAvKiBDT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HICovXTogMC41LFxuICBbMzU4NDIgLyogQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUcgKi9dOiAwLjUsXG4gIFszNTg0MSAvKiBDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HICovXTogMC4yNSxcbiAgWzM1ODQzIC8qIENPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HICovXTogMC4yNSxcbiAgWzM2MTk2IC8qIENPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wgKi9dOiAwLjUsXG4gIFszNTk4NiAvKiBDT01QUkVTU0VEX1JHQl9BVENfV0VCR0wgKi9dOiAwLjUsXG4gIFszNTk4NiAvKiBDT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMICovXTogMSxcbiAgWzM0Nzk4IC8qIENPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMICovXTogMSxcbiAgWzM3ODA4IC8qIENPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFIgKi9dOiAxXG59O1xuXG5leHBvcnQgeyBJTlRFUk5BTF9GT1JNQVRTLCBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyBhcyBleHRlbnNpb25zJDEgfSBmcm9tICdAcGl4aS9jb3JlJztcblxubGV0IHN0b3JlZEdsO1xubGV0IGV4dGVuc2lvbnM7XG5mdW5jdGlvbiBnZXRDb21wcmVzc2VkVGV4dHVyZUV4dGVuc2lvbnMoKSB7XG4gIGV4dGVuc2lvbnMgPSB7XG4gICAgczN0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIiksXG4gICAgczN0Y19zUkdCOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXCIpLFxuICAgIGV0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Y1wiKSxcbiAgICBldGMxOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMVwiKSxcbiAgICBwdnJ0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpIHx8IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIiksXG4gICAgYXRjOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXCIpLFxuICAgIGFzdGM6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjXCIpXG4gIH07XG59XG5jb25zdCBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAyXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXZWJHTCBub3QgYXZhaWxhYmxlIGZvciBjb21wcmVzc2VkIHRleHR1cmVzLlwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RvcmVkR2wgPSBnbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4ge1xuICAgIGlmICghZXh0ZW5zaW9ucylcbiAgICAgIGdldENvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucygpO1xuICAgIGNvbnN0IHRleHR1cmVGb3JtYXRzID0gW107XG4gICAgZm9yIChjb25zdCBleHRlbnNpb25OYW1lIGluIGV4dGVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV07XG4gICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRleHR1cmVGb3JtYXRzLnB1c2goZXh0ZW5zaW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGV4dHVyZUZvcm1hdHMsIC4uLmZvcm1hdHNdO1xuICB9LFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiB7XG4gICAgaWYgKCFleHRlbnNpb25zKVxuICAgICAgZ2V0Q29tcHJlc3NlZFRleHR1cmVFeHRlbnNpb25zKCk7XG4gICAgcmV0dXJuIGZvcm1hdHMuZmlsdGVyKChmKSA9PiAhKGYgaW4gZXh0ZW5zaW9ucykpO1xuICB9XG59O1xuZXh0ZW5zaW9ucyQxLmFkZChkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMpO1xuXG5leHBvcnQgeyBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdENvbXByZXNzZWRUZXh0dXJlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBCdWZmZXJSZXNvdXJjZSwgVmlld2FibGVCdWZmZXIgfSBmcm9tICdAcGl4aS9jb3JlJztcblxuY2xhc3MgQmxvYlJlc291cmNlIGV4dGVuZHMgQnVmZmVyUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEsIGF1dG9Mb2FkOiB0cnVlIH0pIHtcbiAgICBsZXQgb3JpZ2luO1xuICAgIGxldCBkYXRhO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvcmlnaW4gPSBzb3VyY2U7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luID0gbnVsbDtcbiAgICAgIGRhdGEgPSBzb3VyY2U7XG4gICAgfVxuICAgIHN1cGVyKGRhdGEsIG9wdGlvbnMpO1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIHRoaXMuYnVmZmVyID0gZGF0YSA/IG5ldyBWaWV3YWJsZUJ1ZmZlcihkYXRhKSA6IG51bGw7XG4gICAgaWYgKHRoaXMub3JpZ2luICYmIG9wdGlvbnMuYXV0b0xvYWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG4gICAgaWYgKGRhdGE/Lmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgdGhpcy5vbkJsb2JMb2FkZWQodGhpcy5idWZmZXIucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICB9XG4gIG9uQmxvYkxvYWRlZChfZGF0YSkge1xuICB9XG4gIGFzeW5jIGxvYWQoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLm9yaWdpbik7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IFZpZXdhYmxlQnVmZmVyKGFycmF5QnVmZmVyKTtcbiAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgdGhpcy5vbkJsb2JMb2FkZWQoYXJyYXlCdWZmZXIpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmxvYlJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbG9iUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTCB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBCbG9iUmVzb3VyY2UgfSBmcm9tICcuL0Jsb2JSZXNvdXJjZS5tanMnO1xuXG5jbGFzcyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIGV4dGVuZHMgQmxvYlJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCBvcHRpb25zKTtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgIHRoaXMubGV2ZWxzID0gb3B0aW9ucy5sZXZlbHMgfHwgMTtcbiAgICB0aGlzLl93aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgdGhpcy5fZXh0ZW5zaW9uID0gQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5fZm9ybWF0VG9FeHRlbnNpb24odGhpcy5mb3JtYXQpO1xuICAgIGlmIChvcHRpb25zLmxldmVsQnVmZmVycyB8fCB0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5fbGV2ZWxCdWZmZXJzID0gb3B0aW9ucy5sZXZlbEJ1ZmZlcnMgfHwgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5fY3JlYXRlTGV2ZWxCdWZmZXJzKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBzb3VyY2UgOiB0aGlzLmJ1ZmZlci51aW50OFZpZXcsIHRoaXMuZm9ybWF0LCB0aGlzLmxldmVscywgNCwgNCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICB1cGxvYWQocmVuZGVyZXIsIF90ZXh0dXJlLCBfZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBjb25zdCBleHRlbnNpb24gPSByZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnNbdGhpcy5fZXh0ZW5zaW9uXTtcbiAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX2V4dGVuc2lvbn0gdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgbWFjaGluZWApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2xldmVsQnVmZmVycykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMubGV2ZWxzOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCB7IGxldmVsSUQsIGxldmVsV2lkdGgsIGxldmVsSGVpZ2h0LCBsZXZlbEJ1ZmZlciB9ID0gdGhpcy5fbGV2ZWxCdWZmZXJzW2ldO1xuICAgICAgZ2wuY29tcHJlc3NlZFRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbGV2ZWxJRCwgdGhpcy5mb3JtYXQsIGxldmVsV2lkdGgsIGxldmVsSGVpZ2h0LCAwLCBsZXZlbEJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uQmxvYkxvYWRlZCgpIHtcbiAgICB0aGlzLl9sZXZlbEJ1ZmZlcnMgPSBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLl9jcmVhdGVMZXZlbEJ1ZmZlcnModGhpcy5idWZmZXIudWludDhWaWV3LCB0aGlzLmZvcm1hdCwgdGhpcy5sZXZlbHMsIDQsIDQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBzdGF0aWMgX2Zvcm1hdFRvRXh0ZW5zaW9uKGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPj0gMzM3NzYgJiYgZm9ybWF0IDw9IDMzNzc5KSB7XG4gICAgICByZXR1cm4gXCJzM3RjXCI7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPj0gMzc0ODggJiYgZm9ybWF0IDw9IDM3NDk3KSB7XG4gICAgICByZXR1cm4gXCJldGNcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA+PSAzNTg0MCAmJiBmb3JtYXQgPD0gMzU4NDMpIHtcbiAgICAgIHJldHVybiBcInB2cnRjXCI7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPj0gMzYxOTYpIHtcbiAgICAgIHJldHVybiBcImV0YzFcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA+PSAzNTk4NiAmJiBmb3JtYXQgPD0gMzQ3OTgpIHtcbiAgICAgIHJldHVybiBcImF0Y1wiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIChjb21wcmVzc2VkKSB0ZXh0dXJlIGZvcm1hdCBnaXZlbiFcIik7XG4gIH1cbiAgc3RhdGljIF9jcmVhdGVMZXZlbEJ1ZmZlcnMoYnVmZmVyLCBmb3JtYXQsIGxldmVscywgYmxvY2tXaWR0aCwgYmxvY2tIZWlnaHQsIGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0KSB7XG4gICAgY29uc3QgYnVmZmVycyA9IG5ldyBBcnJheShsZXZlbHMpO1xuICAgIGxldCBvZmZzZXQgPSBidWZmZXIuYnl0ZU9mZnNldDtcbiAgICBsZXQgbGV2ZWxXaWR0aCA9IGltYWdlV2lkdGg7XG4gICAgbGV0IGxldmVsSGVpZ2h0ID0gaW1hZ2VIZWlnaHQ7XG4gICAgbGV0IGFsaWduZWRMZXZlbFdpZHRoID0gbGV2ZWxXaWR0aCArIGJsb2NrV2lkdGggLSAxICYgfihibG9ja1dpZHRoIC0gMSk7XG4gICAgbGV0IGFsaWduZWRMZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ICsgYmxvY2tIZWlnaHQgLSAxICYgfihibG9ja0hlaWdodCAtIDEpO1xuICAgIGxldCBsZXZlbFNpemUgPSBhbGlnbmVkTGV2ZWxXaWR0aCAqIGFsaWduZWRMZXZlbEhlaWdodCAqIElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbZm9ybWF0XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVsczsgaSsrKSB7XG4gICAgICBidWZmZXJzW2ldID0ge1xuICAgICAgICBsZXZlbElEOiBpLFxuICAgICAgICBsZXZlbFdpZHRoOiBsZXZlbHMgPiAxID8gbGV2ZWxXaWR0aCA6IGFsaWduZWRMZXZlbFdpZHRoLFxuICAgICAgICBsZXZlbEhlaWdodDogbGV2ZWxzID4gMSA/IGxldmVsSGVpZ2h0IDogYWxpZ25lZExldmVsSGVpZ2h0LFxuICAgICAgICBsZXZlbEJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlciwgb2Zmc2V0LCBsZXZlbFNpemUpXG4gICAgICB9O1xuICAgICAgb2Zmc2V0ICs9IGxldmVsU2l6ZTtcbiAgICAgIGxldmVsV2lkdGggPSBsZXZlbFdpZHRoID4+IDEgfHwgMTtcbiAgICAgIGxldmVsSGVpZ2h0ID0gbGV2ZWxIZWlnaHQgPj4gMSB8fCAxO1xuICAgICAgYWxpZ25lZExldmVsV2lkdGggPSBsZXZlbFdpZHRoICsgYmxvY2tXaWR0aCAtIDEgJiB+KGJsb2NrV2lkdGggLSAxKTtcbiAgICAgIGFsaWduZWRMZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ICsgYmxvY2tIZWlnaHQgLSAxICYgfihibG9ja0hlaWdodCAtIDEpO1xuICAgICAgbGV2ZWxTaXplID0gYWxpZ25lZExldmVsV2lkdGggKiBhbGlnbmVkTGV2ZWxIZWlnaHQgKiBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMW2Zvcm1hdF07XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJzO1xuICB9XG59XG5cbmV4cG9ydCB7IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzLm1hcFxuIiwiZXhwb3J0IHsgQmxvYlJlc291cmNlIH0gZnJvbSAnLi9CbG9iUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuL0NvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IElOVEVSTkFMX0ZPUk1BVFMsIElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUwgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuaW1wb3J0ICcuLi9yZXNvdXJjZXMvaW5kZXgubWpzJztcbmltcG9ydCB7IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZXMvQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMnO1xuXG5jb25zdCBERFNfTUFHSUNfU0laRSA9IDQ7XG5jb25zdCBERFNfSEVBREVSX1NJWkUgPSAxMjQ7XG5jb25zdCBERFNfSEVBREVSX1BGX1NJWkUgPSAzMjtcbmNvbnN0IEREU19IRUFERVJfRFgxMF9TSVpFID0gMjA7XG5jb25zdCBERFNfTUFHSUMgPSA1NDIzMjc4NzY7XG5jb25zdCBERFNfRklFTERTID0ge1xuICBTSVpFOiAxLFxuICBGTEFHUzogMixcbiAgSEVJR0hUOiAzLFxuICBXSURUSDogNCxcbiAgTUlQTUFQX0NPVU5UOiA3LFxuICBQSVhFTF9GT1JNQVQ6IDE5XG59O1xuY29uc3QgRERTX1BGX0ZJRUxEUyA9IHtcbiAgU0laRTogMCxcbiAgRkxBR1M6IDEsXG4gIEZPVVJDQzogMixcbiAgUkdCX0JJVENPVU5UOiAzLFxuICBSX0JJVF9NQVNLOiA0LFxuICBHX0JJVF9NQVNLOiA1LFxuICBCX0JJVF9NQVNLOiA2LFxuICBBX0JJVF9NQVNLOiA3XG59O1xuY29uc3QgRERTX0RYMTBfRklFTERTID0ge1xuICBEWEdJX0ZPUk1BVDogMCxcbiAgUkVTT1VSQ0VfRElNRU5TSU9OOiAxLFxuICBNSVNDX0ZMQUc6IDIsXG4gIEFSUkFZX1NJWkU6IDMsXG4gIE1JU0NfRkxBR1MyOiA0XG59O1xudmFyIERYR0lfRk9STUFUID0gLyogQF9fUFVSRV9fICovICgoRFhHSV9GT1JNQVQyKSA9PiB7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9VTktOT1dOXCJdID0gMF0gPSBcIkRYR0lfRk9STUFUX1VOS05PV05cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9UWVBFTEVTU1wiXSA9IDFdID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJBMzJfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVFwiXSA9IDJdID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJBMzJfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9VSU5UXCJdID0gM10gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9VSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJBMzJfU0lOVFwiXSA9IDRdID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJBMzJfU0lOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1RZUEVMRVNTXCJdID0gNV0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX0ZMT0FUXCJdID0gNl0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMl9GTE9BVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1VJTlRcIl0gPSA3XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMkIzMl9TSU5UXCJdID0gOF0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfVFlQRUxFU1NcIl0gPSA5XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfRkxPQVRcIl0gPSAxMF0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9GTE9BVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X1VOT1JNXCJdID0gMTFdID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9VSU5UXCJdID0gMTJdID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X1NOT1JNXCJdID0gMTNdID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfU05PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9TSU5UXCJdID0gMTRdID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfU0lOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyX1RZUEVMRVNTXCJdID0gMTVdID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMl9GTE9BVFwiXSA9IDE2XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyX0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJfVUlOVFwiXSA9IDE3XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyX1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMl9TSU5UXCJdID0gMThdID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJfU0lOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzhYMjRfVFlQRUxFU1NcIl0gPSAxOV0gPSBcIkRYR0lfRk9STUFUX1IzMkc4WDI0X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9EMzJfRkxPQVRfUzhYMjRfVUlOVFwiXSA9IDIwXSA9IFwiRFhHSV9GT1JNQVRfRDMyX0ZMT0FUX1M4WDI0X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMl9GTE9BVF9YOFgyNF9UWVBFTEVTU1wiXSA9IDIxXSA9IFwiRFhHSV9GT1JNQVRfUjMyX0ZMT0FUX1g4WDI0X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9YMzJfVFlQRUxFU1NfRzhYMjRfVUlOVFwiXSA9IDIyXSA9IFwiRFhHSV9GT1JNQVRfWDMyX1RZUEVMRVNTX0c4WDI0X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxMEcxMEIxMEEyX1RZUEVMRVNTXCJdID0gMjNdID0gXCJEWEdJX0ZPUk1BVF9SMTBHMTBCMTBBMl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjEwRzEwQjEwQTJfVU5PUk1cIl0gPSAyNF0gPSBcIkRYR0lfRk9STUFUX1IxMEcxMEIxMEEyX1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTBHMTBCMTBBMl9VSU5UXCJdID0gMjVdID0gXCJEWEdJX0ZPUk1BVF9SMTBHMTBCMTBBMl9VSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTFHMTFCMTBfRkxPQVRcIl0gPSAyNl0gPSBcIkRYR0lfRk9STUFUX1IxMUcxMUIxMF9GTE9BVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOEI4QThfVFlQRUxFU1NcIl0gPSAyN10gPSBcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9VTk9STVwiXSA9IDI4XSA9IFwiRFhHSV9GT1JNQVRfUjhHOEI4QThfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1VOT1JNX1NSR0JcIl0gPSAyOV0gPSBcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1VOT1JNX1NSR0JcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1VJTlRcIl0gPSAzMF0gPSBcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1NOT1JNXCJdID0gMzFdID0gXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOEI4QThfU0lOVFwiXSA9IDMyXSA9IFwiRFhHSV9GT1JNQVRfUjhHOEI4QThfU0lOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2X1RZUEVMRVNTXCJdID0gMzNdID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNl9GTE9BVFwiXSA9IDM0XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZfVU5PUk1cIl0gPSAzNV0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2X1VJTlRcIl0gPSAzNl0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNl9VSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZfU05PUk1cIl0gPSAzN10gPSBcIkRYR0lfRk9STUFUX1IxNkcxNl9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2X1NJTlRcIl0gPSAzOF0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJfVFlQRUxFU1NcIl0gPSAzOV0gPSBcIkRYR0lfRk9STUFUX1IzMl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfRDMyX0ZMT0FUXCJdID0gNDBdID0gXCJEWEdJX0ZPUk1BVF9EMzJfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMl9GTE9BVFwiXSA9IDQxXSA9IFwiRFhHSV9GT1JNQVRfUjMyX0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJfVUlOVFwiXSA9IDQyXSA9IFwiRFhHSV9GT1JNQVRfUjMyX1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMl9TSU5UXCJdID0gNDNdID0gXCJEWEdJX0ZPUk1BVF9SMzJfU0lOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjI0RzhfVFlQRUxFU1NcIl0gPSA0NF0gPSBcIkRYR0lfRk9STUFUX1IyNEc4X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9EMjRfVU5PUk1fUzhfVUlOVFwiXSA9IDQ1XSA9IFwiRFhHSV9GT1JNQVRfRDI0X1VOT1JNX1M4X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IyNF9VTk9STV9YOF9UWVBFTEVTU1wiXSA9IDQ2XSA9IFwiRFhHSV9GT1JNQVRfUjI0X1VOT1JNX1g4X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9YMjRfVFlQRUxFU1NfRzhfVUlOVFwiXSA9IDQ3XSA9IFwiRFhHSV9GT1JNQVRfWDI0X1RZUEVMRVNTX0c4X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfVFlQRUxFU1NcIl0gPSA0OF0gPSBcIkRYR0lfRk9STUFUX1I4RzhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfVU5PUk1cIl0gPSA0OV0gPSBcIkRYR0lfRk9STUFUX1I4RzhfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfVUlOVFwiXSA9IDUwXSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9VSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOEc4X1NOT1JNXCJdID0gNTFdID0gXCJEWEdJX0ZPUk1BVF9SOEc4X1NOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOEc4X1NJTlRcIl0gPSA1Ml0gPSBcIkRYR0lfRk9STUFUX1I4RzhfU0lOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X1RZUEVMRVNTXCJdID0gNTNdID0gXCJEWEdJX0ZPUk1BVF9SMTZfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNl9GTE9BVFwiXSA9IDU0XSA9IFwiRFhHSV9GT1JNQVRfUjE2X0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9EMTZfVU5PUk1cIl0gPSA1NV0gPSBcIkRYR0lfRk9STUFUX0QxNl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X1VOT1JNXCJdID0gNTZdID0gXCJEWEdJX0ZPUk1BVF9SMTZfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNl9VSU5UXCJdID0gNTddID0gXCJEWEdJX0ZPUk1BVF9SMTZfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X1NOT1JNXCJdID0gNThdID0gXCJEWEdJX0ZPUk1BVF9SMTZfU05PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNl9TSU5UXCJdID0gNTldID0gXCJEWEdJX0ZPUk1BVF9SMTZfU0lOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhfVFlQRUxFU1NcIl0gPSA2MF0gPSBcIkRYR0lfRk9STUFUX1I4X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOF9VTk9STVwiXSA9IDYxXSA9IFwiRFhHSV9GT1JNQVRfUjhfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4X1VJTlRcIl0gPSA2Ml0gPSBcIkRYR0lfRk9STUFUX1I4X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4X1NOT1JNXCJdID0gNjNdID0gXCJEWEdJX0ZPUk1BVF9SOF9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhfU0lOVFwiXSA9IDY0XSA9IFwiRFhHSV9GT1JNQVRfUjhfU0lOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQThfVU5PUk1cIl0gPSA2NV0gPSBcIkRYR0lfRk9STUFUX0E4X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMV9VTk9STVwiXSA9IDY2XSA9IFwiRFhHSV9GT1JNQVRfUjFfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I5RzlCOUU1X1NIQVJFREVYUFwiXSA9IDY3XSA9IFwiRFhHSV9GT1JNQVRfUjlHOUI5RTVfU0hBUkVERVhQXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOEc4X0I4RzhfVU5PUk1cIl0gPSA2OF0gPSBcIkRYR0lfRk9STUFUX1I4RzhfQjhHOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfRzhSOF9HOEI4X1VOT1JNXCJdID0gNjldID0gXCJEWEdJX0ZPUk1BVF9HOFI4X0c4QjhfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDMV9UWVBFTEVTU1wiXSA9IDcwXSA9IFwiRFhHSV9GT1JNQVRfQkMxX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzFfVU5PUk1cIl0gPSA3MV0gPSBcIkRYR0lfRk9STUFUX0JDMV9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMxX1VOT1JNX1NSR0JcIl0gPSA3Ml0gPSBcIkRYR0lfRk9STUFUX0JDMV9VTk9STV9TUkdCXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzJfVFlQRUxFU1NcIl0gPSA3M10gPSBcIkRYR0lfRk9STUFUX0JDMl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMyX1VOT1JNXCJdID0gNzRdID0gXCJEWEdJX0ZPUk1BVF9CQzJfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDMl9VTk9STV9TUkdCXCJdID0gNzVdID0gXCJEWEdJX0ZPUk1BVF9CQzJfVU5PUk1fU1JHQlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMzX1RZUEVMRVNTXCJdID0gNzZdID0gXCJEWEdJX0ZPUk1BVF9CQzNfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDM19VTk9STVwiXSA9IDc3XSA9IFwiRFhHSV9GT1JNQVRfQkMzX1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzNfVU5PUk1fU1JHQlwiXSA9IDc4XSA9IFwiRFhHSV9GT1JNQVRfQkMzX1VOT1JNX1NSR0JcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNF9UWVBFTEVTU1wiXSA9IDc5XSA9IFwiRFhHSV9GT1JNQVRfQkM0X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzRfVU5PUk1cIl0gPSA4MF0gPSBcIkRYR0lfRk9STUFUX0JDNF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM0X1NOT1JNXCJdID0gODFdID0gXCJEWEdJX0ZPUk1BVF9CQzRfU05PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNV9UWVBFTEVTU1wiXSA9IDgyXSA9IFwiRFhHSV9GT1JNQVRfQkM1X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzVfVU5PUk1cIl0gPSA4M10gPSBcIkRYR0lfRk9STUFUX0JDNV9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM1X1NOT1JNXCJdID0gODRdID0gXCJEWEdJX0ZPUk1BVF9CQzVfU05PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0I1RzZSNV9VTk9STVwiXSA9IDg1XSA9IFwiRFhHSV9GT1JNQVRfQjVHNlI1X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CNUc1UjVBMV9VTk9STVwiXSA9IDg2XSA9IFwiRFhHSV9GT1JNQVRfQjVHNVI1QTFfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0I4RzhSOEE4X1VOT1JNXCJdID0gODddID0gXCJEWEdJX0ZPUk1BVF9COEc4UjhBOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjhHOFI4WDhfVU5PUk1cIl0gPSA4OF0gPSBcIkRYR0lfRk9STUFUX0I4RzhSOFg4X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTBHMTBCMTBfWFJfQklBU19BMl9VTk9STVwiXSA9IDg5XSA9IFwiRFhHSV9GT1JNQVRfUjEwRzEwQjEwX1hSX0JJQVNfQTJfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0I4RzhSOEE4X1RZUEVMRVNTXCJdID0gOTBdID0gXCJEWEdJX0ZPUk1BVF9COEc4UjhBOF9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjhHOFI4QThfVU5PUk1fU1JHQlwiXSA9IDkxXSA9IFwiRFhHSV9GT1JNQVRfQjhHOFI4QThfVU5PUk1fU1JHQlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjhHOFI4WDhfVFlQRUxFU1NcIl0gPSA5Ml0gPSBcIkRYR0lfRk9STUFUX0I4RzhSOFg4X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9COEc4UjhYOF9VTk9STV9TUkdCXCJdID0gOTNdID0gXCJEWEdJX0ZPUk1BVF9COEc4UjhYOF9VTk9STV9TUkdCXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzZIX1RZUEVMRVNTXCJdID0gOTRdID0gXCJEWEdJX0ZPUk1BVF9CQzZIX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzZIX1VGMTZcIl0gPSA5NV0gPSBcIkRYR0lfRk9STUFUX0JDNkhfVUYxNlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM2SF9TRjE2XCJdID0gOTZdID0gXCJEWEdJX0ZPUk1BVF9CQzZIX1NGMTZcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDN19UWVBFTEVTU1wiXSA9IDk3XSA9IFwiRFhHSV9GT1JNQVRfQkM3X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzdfVU5PUk1cIl0gPSA5OF0gPSBcIkRYR0lfRk9STUFUX0JDN19VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM3X1VOT1JNX1NSR0JcIl0gPSA5OV0gPSBcIkRYR0lfRk9STUFUX0JDN19VTk9STV9TUkdCXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9BWVVWXCJdID0gMTAwXSA9IFwiRFhHSV9GT1JNQVRfQVlVVlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfWTQxMFwiXSA9IDEwMV0gPSBcIkRYR0lfRk9STUFUX1k0MTBcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1k0MTZcIl0gPSAxMDJdID0gXCJEWEdJX0ZPUk1BVF9ZNDE2XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9OVjEyXCJdID0gMTAzXSA9IFwiRFhHSV9GT1JNQVRfTlYxMlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUDAxMFwiXSA9IDEwNF0gPSBcIkRYR0lfRk9STUFUX1AwMTBcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1AwMTZcIl0gPSAxMDVdID0gXCJEWEdJX0ZPUk1BVF9QMDE2XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF80MjBfT1BBUVVFXCJdID0gMTA2XSA9IFwiRFhHSV9GT1JNQVRfNDIwX09QQVFVRVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfWVVZMlwiXSA9IDEwN10gPSBcIkRYR0lfRk9STUFUX1lVWTJcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1kyMTBcIl0gPSAxMDhdID0gXCJEWEdJX0ZPUk1BVF9ZMjEwXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9ZMjE2XCJdID0gMTA5XSA9IFwiRFhHSV9GT1JNQVRfWTIxNlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfTlYxMVwiXSA9IDExMF0gPSBcIkRYR0lfRk9STUFUX05WMTFcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0FJNDRcIl0gPSAxMTFdID0gXCJEWEdJX0ZPUk1BVF9BSTQ0XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9JQTQ0XCJdID0gMTEyXSA9IFwiRFhHSV9GT1JNQVRfSUE0NFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUDhcIl0gPSAxMTNdID0gXCJEWEdJX0ZPUk1BVF9QOFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQThQOFwiXSA9IDExNF0gPSBcIkRYR0lfRk9STUFUX0E4UDhcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0I0RzRSNEE0X1VOT1JNXCJdID0gMTE1XSA9IFwiRFhHSV9GT1JNQVRfQjRHNFI0QTRfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1AyMDhcIl0gPSAxMTZdID0gXCJEWEdJX0ZPUk1BVF9QMjA4XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9WMjA4XCJdID0gMTE3XSA9IFwiRFhHSV9GT1JNQVRfVjIwOFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfVjQwOFwiXSA9IDExOF0gPSBcIkRYR0lfRk9STUFUX1Y0MDhcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1NBTVBMRVJfRkVFREJBQ0tfTUlOX01JUF9PUEFRVUVcIl0gPSAxMTldID0gXCJEWEdJX0ZPUk1BVF9TQU1QTEVSX0ZFRURCQUNLX01JTl9NSVBfT1BBUVVFXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9TQU1QTEVSX0ZFRURCQUNLX01JUF9SRUdJT05fVVNFRF9PUEFRVUVcIl0gPSAxMjBdID0gXCJEWEdJX0ZPUk1BVF9TQU1QTEVSX0ZFRURCQUNLX01JUF9SRUdJT05fVVNFRF9PUEFRVUVcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0ZPUkNFX1VJTlRcIl0gPSAxMjFdID0gXCJEWEdJX0ZPUk1BVF9GT1JDRV9VSU5UXCI7XG4gIHJldHVybiBEWEdJX0ZPUk1BVDI7XG59KShEWEdJX0ZPUk1BVCB8fCB7fSk7XG52YXIgRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OID0gLyogQF9fUFVSRV9fICovICgoRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OMikgPT4ge1xuICBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04yW0QzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbXCJERFNfRElNRU5TSU9OX1RFWFRVUkUxRFwiXSA9IDJdID0gXCJERFNfRElNRU5TSU9OX1RFWFRVUkUxRFwiO1xuICBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04yW0QzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbXCJERFNfRElNRU5TSU9OX1RFWFRVUkUyRFwiXSA9IDNdID0gXCJERFNfRElNRU5TSU9OX1RFWFRVUkUyRFwiO1xuICBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04yW0QzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbXCJERFNfRElNRU5TSU9OX1RFWFRVUkUzRFwiXSA9IDZdID0gXCJERFNfRElNRU5TSU9OX1RFWFRVUkUzRFwiO1xuICByZXR1cm4gRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OMjtcbn0pKEQzRDEwX1JFU09VUkNFX0RJTUVOU0lPTiB8fCB7fSk7XG5jb25zdCBQRl9GTEFHUyA9IDE7XG5jb25zdCBERFBGX0FMUEhBID0gMjtcbmNvbnN0IEREUEZfRk9VUkNDID0gNDtcbmNvbnN0IEREUEZfUkdCID0gNjQ7XG5jb25zdCBERFBGX1lVViA9IDUxMjtcbmNvbnN0IEREUEZfTFVNSU5BTkNFID0gMTMxMDcyO1xuY29uc3QgRk9VUkNDX0RYVDEgPSA4Mjc2MTEyMDQ7XG5jb25zdCBGT1VSQ0NfRFhUMyA9IDg2MTE2NTYzNjtcbmNvbnN0IEZPVVJDQ19EWFQ1ID0gODk0NzIwMDY4O1xuY29uc3QgRk9VUkNDX0RYMTAgPSA4MDg1NDAyMjg7XG5jb25zdCBERFNfUkVTT1VSQ0VfTUlTQ19URVhUVVJFQ1VCRSA9IDQ7XG5jb25zdCBGT1VSQ0NfVE9fRk9STUFUID0ge1xuICBbRk9VUkNDX0RYVDFdOiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICBbRk9VUkNDX0RYVDNdOiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhULFxuICBbRk9VUkNDX0RYVDVdOiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXG59O1xuY29uc3QgRFhHSV9UT19GT1JNQVQgPSB7XG4gIFs3MCAvKiBEWEdJX0ZPUk1BVF9CQzFfVFlQRUxFU1MgKi9dOiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICBbNzEgLyogRFhHSV9GT1JNQVRfQkMxX1VOT1JNICovXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCxcbiAgWzczIC8qIERYR0lfRk9STUFUX0JDMl9UWVBFTEVTUyAqL106IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gIFs3NCAvKiBEWEdJX0ZPUk1BVF9CQzJfVU5PUk0gKi9dOiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhULFxuICBbNzYgLyogRFhHSV9GT1JNQVRfQkMzX1RZUEVMRVNTICovXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCxcbiAgWzc3IC8qIERYR0lfRk9STUFUX0JDM19VTk9STSAqL106IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQsXG4gIFs3MiAvKiBEWEdJX0ZPUk1BVF9CQzFfVU5PUk1fU1JHQiAqL106IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFQsXG4gIFs3NSAvKiBEWEdJX0ZPUk1BVF9CQzJfVU5PUk1fU1JHQiAqL106IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFQsXG4gIFs3OCAvKiBEWEdJX0ZPUk1BVF9CQzNfVU5PUk1fU1JHQiAqL106IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFRcbn07XG5mdW5jdGlvbiBwYXJzZUREUyhhcnJheUJ1ZmZlcikge1xuICBjb25zdCBkYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKTtcbiAgY29uc3QgbWFnaWNXb3JkID0gZGF0YVswXTtcbiAgaWYgKG1hZ2ljV29yZCAhPT0gRERTX01BR0lDKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBERFMgZmlsZSBtYWdpYyB3b3JkXCIpO1xuICB9XG4gIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlciwgMCwgRERTX0hFQURFUl9TSVpFIC8gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xuICBjb25zdCBoZWlnaHQgPSBoZWFkZXJbRERTX0ZJRUxEUy5IRUlHSFRdO1xuICBjb25zdCB3aWR0aCA9IGhlYWRlcltERFNfRklFTERTLldJRFRIXTtcbiAgY29uc3QgbWlwbWFwQ291bnQgPSBoZWFkZXJbRERTX0ZJRUxEUy5NSVBNQVBfQ09VTlRdO1xuICBjb25zdCBwaXhlbEZvcm1hdCA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlciwgRERTX0ZJRUxEUy5QSVhFTF9GT1JNQVQgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgRERTX0hFQURFUl9QRl9TSVpFIC8gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xuICBjb25zdCBmb3JtYXRGbGFncyA9IHBpeGVsRm9ybWF0W1BGX0ZMQUdTXTtcbiAgaWYgKGZvcm1hdEZsYWdzICYgRERQRl9GT1VSQ0MpIHtcbiAgICBjb25zdCBmb3VyQ0MgPSBwaXhlbEZvcm1hdFtERFNfUEZfRklFTERTLkZPVVJDQ107XG4gICAgaWYgKGZvdXJDQyAhPT0gRk9VUkNDX0RYMTApIHtcbiAgICAgIGNvbnN0IGludGVybmFsRm9ybWF0MiA9IEZPVVJDQ19UT19GT1JNQVRbZm91ckNDXTtcbiAgICAgIGNvbnN0IGRhdGFPZmZzZXQyID0gRERTX01BR0lDX1NJWkUgKyBERFNfSEVBREVSX1NJWkU7XG4gICAgICBjb25zdCB0ZXhEYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQyKTtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UodGV4RGF0YSwge1xuICAgICAgICBmb3JtYXQ6IGludGVybmFsRm9ybWF0MixcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgbGV2ZWxzOiBtaXBtYXBDb3VudFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc291cmNlXTtcbiAgICB9XG4gICAgY29uc3QgZHgxME9mZnNldCA9IEREU19NQUdJQ19TSVpFICsgRERTX0hFQURFUl9TSVpFO1xuICAgIGNvbnN0IGR4MTBIZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIsIGR4MTBPZmZzZXQsIEREU19IRUFERVJfRFgxMF9TSVpFIC8gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgIGNvbnN0IGR4Z2lGb3JtYXQgPSBkeDEwSGVhZGVyW0REU19EWDEwX0ZJRUxEUy5EWEdJX0ZPUk1BVF07XG4gICAgY29uc3QgcmVzb3VyY2VEaW1lbnNpb24gPSBkeDEwSGVhZGVyW0REU19EWDEwX0ZJRUxEUy5SRVNPVVJDRV9ESU1FTlNJT05dO1xuICAgIGNvbnN0IG1pc2NGbGFnID0gZHgxMEhlYWRlcltERFNfRFgxMF9GSUVMRFMuTUlTQ19GTEFHXTtcbiAgICBjb25zdCBhcnJheVNpemUgPSBkeDEwSGVhZGVyW0REU19EWDEwX0ZJRUxEUy5BUlJBWV9TSVpFXTtcbiAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IERYR0lfVE9fRk9STUFUW2R4Z2lGb3JtYXRdO1xuICAgIGlmIChpbnRlcm5hbEZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEREU1BhcnNlciBjYW5ub3QgcGFyc2UgdGV4dHVyZSBkYXRhIHdpdGggRFhHSSBmb3JtYXQgJHtkeGdpRm9ybWF0fWApO1xuICAgIH1cbiAgICBpZiAobWlzY0ZsYWcgPT09IEREU19SRVNPVVJDRV9NSVNDX1RFWFRVUkVDVUJFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCBjdWJlbWFwIHRleHR1cmVzXCIpO1xuICAgIH1cbiAgICBpZiAocmVzb3VyY2VEaW1lbnNpb24gPT09IDYgLyogRERTX0RJTUVOU0lPTl9URVhUVVJFM0QgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkREU1BhcnNlciBkb2VzIG5vdCBzdXBwb3J0ZWQgM0QgdGV4dHVyZSBkYXRhXCIpO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZUJ1ZmZlcnMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBkYXRhT2Zmc2V0ID0gRERTX01BR0lDX1NJWkUgKyBERFNfSEVBREVSX1NJWkUgKyBERFNfSEVBREVSX0RYMTBfU0laRTtcbiAgICBpZiAoYXJyYXlTaXplID09PSAxKSB7XG4gICAgICBpbWFnZUJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwaXhlbFNpemUgPSBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMW2ludGVybmFsRm9ybWF0XTtcbiAgICAgIGxldCBpbWFnZVNpemUgPSAwO1xuICAgICAgbGV0IGxldmVsV2lkdGggPSB3aWR0aDtcbiAgICAgIGxldCBsZXZlbEhlaWdodCA9IGhlaWdodDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWlwbWFwQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBhbGlnbmVkTGV2ZWxXaWR0aCA9IE1hdGgubWF4KDEsIGxldmVsV2lkdGggKyAzICYgfjMpO1xuICAgICAgICBjb25zdCBhbGlnbmVkTGV2ZWxIZWlnaHQgPSBNYXRoLm1heCgxLCBsZXZlbEhlaWdodCArIDMgJiB+Myk7XG4gICAgICAgIGNvbnN0IGxldmVsU2l6ZSA9IGFsaWduZWRMZXZlbFdpZHRoICogYWxpZ25lZExldmVsSGVpZ2h0ICogcGl4ZWxTaXplO1xuICAgICAgICBpbWFnZVNpemUgKz0gbGV2ZWxTaXplO1xuICAgICAgICBsZXZlbFdpZHRoID0gbGV2ZWxXaWR0aCA+Pj4gMTtcbiAgICAgICAgbGV2ZWxIZWlnaHQgPSBsZXZlbEhlaWdodCA+Pj4gMTtcbiAgICAgIH1cbiAgICAgIGxldCBpbWFnZU9mZnNldCA9IGRhdGFPZmZzZXQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5U2l6ZTsgaSsrKSB7XG4gICAgICAgIGltYWdlQnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBpbWFnZU9mZnNldCwgaW1hZ2VTaXplKSk7XG4gICAgICAgIGltYWdlT2Zmc2V0ICs9IGltYWdlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlQnVmZmVycy5tYXAoKGJ1ZmZlcikgPT4gbmV3IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UoYnVmZmVyLCB7XG4gICAgICBmb3JtYXQ6IGludGVybmFsRm9ybWF0LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsZXZlbHM6IG1pcG1hcENvdW50XG4gICAgfSkpO1xuICB9XG4gIGlmIChmb3JtYXRGbGFncyAmIEREUEZfUkdCKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgdW5jb21wcmVzc2VkIHRleHR1cmUgZGF0YS5cIik7XG4gIH1cbiAgaWYgKGZvcm1hdEZsYWdzICYgRERQRl9ZVVYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydGVkIFlVViB1bmNvbXByZXNzZWQgdGV4dHVyZSBkYXRhLlwiKTtcbiAgfVxuICBpZiAoZm9ybWF0RmxhZ3MgJiBERFBGX0xVTUlOQU5DRSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkREU1BhcnNlciBkb2VzIG5vdCBzdXBwb3J0IHNpbmdsZS1jaGFubmVsIChsdW1uaW5hbmNlKSB0ZXh0dXJlIGRhdGEhXCIpO1xuICB9XG4gIGlmIChmb3JtYXRGbGFncyAmIEREUEZfQUxQSEEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCBzaW5nbGUtY2hhbm5lbCAoYWxwaGEpIHRleHR1cmUgZGF0YSFcIik7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGZhaWxlZCB0byBsb2FkIGEgdGV4dHVyZSBmaWxlIGR1ZSB0byBhbiB1bmtub3duIHJlYXNvbiFcIik7XG59XG5cbmV4cG9ydCB7IHBhcnNlRERTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUREUy5tanMubWFwXG4iLCJpbXBvcnQgeyBUWVBFUywgRk9STUFUUywgQnVmZmVyUmVzb3VyY2UgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUwgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuaW1wb3J0ICcuLi9yZXNvdXJjZXMvaW5kZXgubWpzJztcbmltcG9ydCB7IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZXMvQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMnO1xuXG5jb25zdCBGSUxFX0lERU5USUZJRVIgPSBbMTcxLCA3NSwgODQsIDg4LCAzMiwgNDksIDQ5LCAxODcsIDEzLCAxMCwgMjYsIDEwXTtcbmNvbnN0IEVORElBTk5FU1MgPSA2NzMwNTk4NTtcbmNvbnN0IEtUWF9GSUVMRFMgPSB7XG4gIEZJTEVfSURFTlRJRklFUjogMCxcbiAgRU5ESUFOTkVTUzogMTIsXG4gIEdMX1RZUEU6IDE2LFxuICBHTF9UWVBFX1NJWkU6IDIwLFxuICBHTF9GT1JNQVQ6IDI0LFxuICBHTF9JTlRFUk5BTF9GT1JNQVQ6IDI4LFxuICBHTF9CQVNFX0lOVEVSTkFMX0ZPUk1BVDogMzIsXG4gIFBJWEVMX1dJRFRIOiAzNixcbiAgUElYRUxfSEVJR0hUOiA0MCxcbiAgUElYRUxfREVQVEg6IDQ0LFxuICBOVU1CRVJfT0ZfQVJSQVlfRUxFTUVOVFM6IDQ4LFxuICBOVU1CRVJfT0ZfRkFDRVM6IDUyLFxuICBOVU1CRVJfT0ZfTUlQTUFQX0xFVkVMUzogNTYsXG4gIEJZVEVTX09GX0tFWV9WQUxVRV9EQVRBOiA2MFxufTtcbmNvbnN0IEZJTEVfSEVBREVSX1NJWkUgPSA2NDtcbmNvbnN0IFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQgPSB7XG4gIFtUWVBFUy5VTlNJR05FRF9CWVRFXTogMSxcbiAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXTogMixcbiAgW1RZUEVTLklOVF06IDQsXG4gIFtUWVBFUy5VTlNJR05FRF9JTlRdOiA0LFxuICBbVFlQRVMuRkxPQVRdOiA0LFxuICBbVFlQRVMuSEFMRl9GTE9BVF06IDhcbn07XG5jb25zdCBGT1JNQVRTX1RPX0NPTVBPTkVOVFMgPSB7XG4gIFtGT1JNQVRTLlJHQkFdOiA0LFxuICBbRk9STUFUUy5SR0JdOiAzLFxuICBbRk9STUFUUy5SR106IDIsXG4gIFtGT1JNQVRTLlJFRF06IDEsXG4gIFtGT1JNQVRTLkxVTUlOQU5DRV06IDEsXG4gIFtGT1JNQVRTLkxVTUlOQU5DRV9BTFBIQV06IDIsXG4gIFtGT1JNQVRTLkFMUEhBXTogMVxufTtcbmNvbnN0IFRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTCA9IHtcbiAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzRfNF80XzRdOiAyLFxuICBbVFlQRVMuVU5TSUdORURfU0hPUlRfNV81XzVfMV06IDIsXG4gIFtUWVBFUy5VTlNJR05FRF9TSE9SVF81XzZfNV06IDJcbn07XG5mdW5jdGlvbiBwYXJzZUtUWCh1cmwsIGFycmF5QnVmZmVyLCBsb2FkS2V5VmFsdWVEYXRhID0gZmFsc2UpIHtcbiAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICBpZiAoIXZhbGlkYXRlKHVybCwgZGF0YVZpZXcpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbGl0dGxlRW5kaWFuID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuRU5ESUFOTkVTUywgdHJ1ZSkgPT09IEVORElBTk5FU1M7XG4gIGNvbnN0IGdsVHlwZSA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLkdMX1RZUEUsIGxpdHRsZUVuZGlhbik7XG4gIGNvbnN0IGdsRm9ybWF0ID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuR0xfRk9STUFULCBsaXR0bGVFbmRpYW4pO1xuICBjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuR0xfSU5URVJOQUxfRk9STUFULCBsaXR0bGVFbmRpYW4pO1xuICBjb25zdCBwaXhlbFdpZHRoID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuUElYRUxfV0lEVEgsIGxpdHRsZUVuZGlhbik7XG4gIGNvbnN0IHBpeGVsSGVpZ2h0ID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuUElYRUxfSEVJR0hULCBsaXR0bGVFbmRpYW4pIHx8IDE7XG4gIGNvbnN0IHBpeGVsRGVwdGggPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5QSVhFTF9ERVBUSCwgbGl0dGxlRW5kaWFuKSB8fCAxO1xuICBjb25zdCBudW1iZXJPZkFycmF5RWxlbWVudHMgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5OVU1CRVJfT0ZfQVJSQVlfRUxFTUVOVFMsIGxpdHRsZUVuZGlhbikgfHwgMTtcbiAgY29uc3QgbnVtYmVyT2ZGYWNlcyA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLk5VTUJFUl9PRl9GQUNFUywgbGl0dGxlRW5kaWFuKTtcbiAgY29uc3QgbnVtYmVyT2ZNaXBtYXBMZXZlbHMgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5OVU1CRVJfT0ZfTUlQTUFQX0xFVkVMUywgbGl0dGxlRW5kaWFuKTtcbiAgY29uc3QgYnl0ZXNPZktleVZhbHVlRGF0YSA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLkJZVEVTX09GX0tFWV9WQUxVRV9EQVRBLCBsaXR0bGVFbmRpYW4pO1xuICBpZiAocGl4ZWxIZWlnaHQgPT09IDAgfHwgcGl4ZWxEZXB0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgMkQgdGV4dHVyZXMgYXJlIHN1cHBvcnRlZFwiKTtcbiAgfVxuICBpZiAobnVtYmVyT2ZGYWNlcyAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkN1YmVUZXh0dXJlcyBhcmUgbm90IHN1cHBvcnRlZCBieSBLVFhMb2FkZXIgeWV0IVwiKTtcbiAgfVxuICBpZiAobnVtYmVyT2ZBcnJheUVsZW1lbnRzICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgZG9lcyBub3Qgc3VwcG9ydCBhcnJheSB0ZXh0dXJlc1wiKTtcbiAgfVxuICBjb25zdCBibG9ja1dpZHRoID0gNDtcbiAgY29uc3QgYmxvY2tIZWlnaHQgPSA0O1xuICBjb25zdCBhbGlnbmVkV2lkdGggPSBwaXhlbFdpZHRoICsgMyAmIH4zO1xuICBjb25zdCBhbGlnbmVkSGVpZ2h0ID0gcGl4ZWxIZWlnaHQgKyAzICYgfjM7XG4gIGNvbnN0IGltYWdlQnVmZmVycyA9IG5ldyBBcnJheShudW1iZXJPZkFycmF5RWxlbWVudHMpO1xuICBsZXQgaW1hZ2VQaXhlbHMgPSBwaXhlbFdpZHRoICogcGl4ZWxIZWlnaHQ7XG4gIGlmIChnbFR5cGUgPT09IDApIHtcbiAgICBpbWFnZVBpeGVscyA9IGFsaWduZWRXaWR0aCAqIGFsaWduZWRIZWlnaHQ7XG4gIH1cbiAgbGV0IGltYWdlUGl4ZWxCeXRlU2l6ZTtcbiAgaWYgKGdsVHlwZSAhPT0gMCkge1xuICAgIGlmIChUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UW2dsVHlwZV0pIHtcbiAgICAgIGltYWdlUGl4ZWxCeXRlU2l6ZSA9IFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlRbZ2xUeXBlXSAqIEZPUk1BVFNfVE9fQ09NUE9ORU5UU1tnbEZvcm1hdF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGltYWdlUGl4ZWxCeXRlU2l6ZSA9IFRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTFtnbFR5cGVdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbWFnZVBpeGVsQnl0ZVNpemUgPSBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMW2dsSW50ZXJuYWxGb3JtYXRdO1xuICB9XG4gIGlmIChpbWFnZVBpeGVsQnl0ZVNpemUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIHRoZSBwaXhlbCBmb3JtYXQgc3RvcmVkIGluIHRoZSAqLmt0eCBmaWxlIVwiKTtcbiAgfVxuICBjb25zdCBrdkRhdGEgPSBsb2FkS2V5VmFsdWVEYXRhID8gcGFyc2VLdkRhdGEoZGF0YVZpZXcsIGJ5dGVzT2ZLZXlWYWx1ZURhdGEsIGxpdHRsZUVuZGlhbikgOiBudWxsO1xuICBjb25zdCBpbWFnZUJ5dGVTaXplID0gaW1hZ2VQaXhlbHMgKiBpbWFnZVBpeGVsQnl0ZVNpemU7XG4gIGxldCBtaXBCeXRlU2l6ZSA9IGltYWdlQnl0ZVNpemU7XG4gIGxldCBtaXBXaWR0aCA9IHBpeGVsV2lkdGg7XG4gIGxldCBtaXBIZWlnaHQgPSBwaXhlbEhlaWdodDtcbiAgbGV0IGFsaWduZWRNaXBXaWR0aCA9IGFsaWduZWRXaWR0aDtcbiAgbGV0IGFsaWduZWRNaXBIZWlnaHQgPSBhbGlnbmVkSGVpZ2h0O1xuICBsZXQgaW1hZ2VPZmZzZXQgPSBGSUxFX0hFQURFUl9TSVpFICsgYnl0ZXNPZktleVZhbHVlRGF0YTtcbiAgZm9yIChsZXQgbWlwbWFwTGV2ZWwgPSAwOyBtaXBtYXBMZXZlbCA8IG51bWJlck9mTWlwbWFwTGV2ZWxzOyBtaXBtYXBMZXZlbCsrKSB7XG4gICAgY29uc3QgaW1hZ2VTaXplID0gZGF0YVZpZXcuZ2V0VWludDMyKGltYWdlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBlbGVtZW50T2Zmc2V0ID0gaW1hZ2VPZmZzZXQgKyA0O1xuICAgIGZvciAobGV0IGFycmF5RWxlbWVudCA9IDA7IGFycmF5RWxlbWVudCA8IG51bWJlck9mQXJyYXlFbGVtZW50czsgYXJyYXlFbGVtZW50KyspIHtcbiAgICAgIGxldCBtaXBzID0gaW1hZ2VCdWZmZXJzW2FycmF5RWxlbWVudF07XG4gICAgICBpZiAoIW1pcHMpIHtcbiAgICAgICAgbWlwcyA9IGltYWdlQnVmZmVyc1thcnJheUVsZW1lbnRdID0gbmV3IEFycmF5KG51bWJlck9mTWlwbWFwTGV2ZWxzKTtcbiAgICAgIH1cbiAgICAgIG1pcHNbbWlwbWFwTGV2ZWxdID0ge1xuICAgICAgICBsZXZlbElEOiBtaXBtYXBMZXZlbCxcbiAgICAgICAgbGV2ZWxXaWR0aDogbnVtYmVyT2ZNaXBtYXBMZXZlbHMgPiAxIHx8IGdsVHlwZSAhPT0gMCA/IG1pcFdpZHRoIDogYWxpZ25lZE1pcFdpZHRoLFxuICAgICAgICBsZXZlbEhlaWdodDogbnVtYmVyT2ZNaXBtYXBMZXZlbHMgPiAxIHx8IGdsVHlwZSAhPT0gMCA/IG1pcEhlaWdodCA6IGFsaWduZWRNaXBIZWlnaHQsXG4gICAgICAgIGxldmVsQnVmZmVyOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZWxlbWVudE9mZnNldCwgbWlwQnl0ZVNpemUpXG4gICAgICB9O1xuICAgICAgZWxlbWVudE9mZnNldCArPSBtaXBCeXRlU2l6ZTtcbiAgICB9XG4gICAgaW1hZ2VPZmZzZXQgKz0gaW1hZ2VTaXplICsgNDtcbiAgICBpbWFnZU9mZnNldCA9IGltYWdlT2Zmc2V0ICUgNCAhPT0gMCA/IGltYWdlT2Zmc2V0ICsgNCAtIGltYWdlT2Zmc2V0ICUgNCA6IGltYWdlT2Zmc2V0O1xuICAgIG1pcFdpZHRoID0gbWlwV2lkdGggPj4gMSB8fCAxO1xuICAgIG1pcEhlaWdodCA9IG1pcEhlaWdodCA+PiAxIHx8IDE7XG4gICAgYWxpZ25lZE1pcFdpZHRoID0gbWlwV2lkdGggKyBibG9ja1dpZHRoIC0gMSAmIH4oYmxvY2tXaWR0aCAtIDEpO1xuICAgIGFsaWduZWRNaXBIZWlnaHQgPSBtaXBIZWlnaHQgKyBibG9ja0hlaWdodCAtIDEgJiB+KGJsb2NrSGVpZ2h0IC0gMSk7XG4gICAgbWlwQnl0ZVNpemUgPSBhbGlnbmVkTWlwV2lkdGggKiBhbGlnbmVkTWlwSGVpZ2h0ICogaW1hZ2VQaXhlbEJ5dGVTaXplO1xuICB9XG4gIGlmIChnbFR5cGUgIT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5jb21wcmVzc2VkOiBpbWFnZUJ1ZmZlcnMubWFwKChsZXZlbEJ1ZmZlcnMpID0+IHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvbnZlcnRUb0ludCA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2xUeXBlID09PSBUWVBFUy5GTE9BVCkge1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkobGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ1ZmZlciwgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVPZmZzZXQsIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlTGVuZ3RoIC8gNCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2xUeXBlID09PSBUWVBFUy5VTlNJR05FRF9JTlQpIHtcbiAgICAgICAgICBjb252ZXJ0VG9JbnQgPSB0cnVlO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnVmZmVyLCBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZU9mZnNldCwgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVMZW5ndGggLyA0KTtcbiAgICAgICAgfSBlbHNlIGlmIChnbFR5cGUgPT09IFRZUEVTLklOVCkge1xuICAgICAgICAgIGNvbnZlcnRUb0ludCA9IHRydWU7XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEludDMyQXJyYXkobGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ1ZmZlciwgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVPZmZzZXQsIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlTGVuZ3RoIC8gNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNvdXJjZTogbmV3IEJ1ZmZlclJlc291cmNlKGJ1ZmZlciwge1xuICAgICAgICAgICAgd2lkdGg6IGxldmVsQnVmZmVyc1swXS5sZXZlbFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxIZWlnaHRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0eXBlOiBnbFR5cGUsXG4gICAgICAgICAgZm9ybWF0OiBjb252ZXJ0VG9JbnQgPyBjb252ZXJ0Rm9ybWF0VG9JbnRlZ2VyKGdsRm9ybWF0KSA6IGdsRm9ybWF0XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIGt2RGF0YVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21wcmVzc2VkOiBpbWFnZUJ1ZmZlcnMubWFwKChsZXZlbEJ1ZmZlcnMpID0+IG5ldyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlKG51bGwsIHtcbiAgICAgIGZvcm1hdDogZ2xJbnRlcm5hbEZvcm1hdCxcbiAgICAgIHdpZHRoOiBwaXhlbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwaXhlbEhlaWdodCxcbiAgICAgIGxldmVsczogbnVtYmVyT2ZNaXBtYXBMZXZlbHMsXG4gICAgICBsZXZlbEJ1ZmZlcnNcbiAgICB9KSksXG4gICAga3ZEYXRhXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZSh1cmwsIGRhdGFWaWV3KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgRklMRV9JREVOVElGSUVSLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KGkpICE9PSBGSUxFX0lERU5USUZJRVJbaV0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYCR7dXJsfSBpcyBub3QgYSB2YWxpZCAqLmt0eCBmaWxlIWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRUb0ludGVnZXIoZm9ybWF0KSB7XG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSBGT1JNQVRTLlJHQkE6XG4gICAgICByZXR1cm4gRk9STUFUUy5SR0JBX0lOVEVHRVI7XG4gICAgY2FzZSBGT1JNQVRTLlJHQjpcbiAgICAgIHJldHVybiBGT1JNQVRTLlJHQl9JTlRFR0VSO1xuICAgIGNhc2UgRk9STUFUUy5SRzpcbiAgICAgIHJldHVybiBGT1JNQVRTLlJHX0lOVEVHRVI7XG4gICAgY2FzZSBGT1JNQVRTLlJFRDpcbiAgICAgIHJldHVybiBGT1JNQVRTLlJFRF9JTlRFR0VSO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUt2RGF0YShkYXRhVmlldywgYnl0ZXNPZktleVZhbHVlRGF0YSwgbGl0dGxlRW5kaWFuKSB7XG4gIGNvbnN0IGt2RGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBieXRlc0ludG9LZXlWYWx1ZURhdGEgPSAwO1xuICB3aGlsZSAoYnl0ZXNJbnRvS2V5VmFsdWVEYXRhIDwgYnl0ZXNPZktleVZhbHVlRGF0YSkge1xuICAgIGNvbnN0IGtleUFuZFZhbHVlQnl0ZVNpemUgPSBkYXRhVmlldy5nZXRVaW50MzIoRklMRV9IRUFERVJfU0laRSArIGJ5dGVzSW50b0tleVZhbHVlRGF0YSwgbGl0dGxlRW5kaWFuKTtcbiAgICBjb25zdCBrZXlBbmRWYWx1ZUJ5dGVPZmZzZXQgPSBGSUxFX0hFQURFUl9TSVpFICsgYnl0ZXNJbnRvS2V5VmFsdWVEYXRhICsgNDtcbiAgICBjb25zdCB2YWx1ZVBhZGRpbmcgPSAzIC0gKGtleUFuZFZhbHVlQnl0ZVNpemUgKyAzKSAlIDQ7XG4gICAgaWYgKGtleUFuZFZhbHVlQnl0ZVNpemUgPT09IDAgfHwga2V5QW5kVmFsdWVCeXRlU2l6ZSA+IGJ5dGVzT2ZLZXlWYWx1ZURhdGEgLSBieXRlc0ludG9LZXlWYWx1ZURhdGEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJLVFhMb2FkZXI6IGtleUFuZFZhbHVlQnl0ZVNpemUgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQga2V5TnVsQnl0ZSA9IDA7XG4gICAgZm9yICg7IGtleU51bEJ5dGUgPCBrZXlBbmRWYWx1ZUJ5dGVTaXplOyBrZXlOdWxCeXRlKyspIHtcbiAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChrZXlBbmRWYWx1ZUJ5dGVPZmZzZXQgKyBrZXlOdWxCeXRlKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleU51bEJ5dGUgPT09IC0xKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiS1RYTG9hZGVyOiBGYWlsZWQgdG8gZmluZCBudWxsIGJ5dGUgdGVybWluYXRpbmcga3ZEYXRhIGtleVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZGF0YVZpZXcuYnVmZmVyLCBrZXlBbmRWYWx1ZUJ5dGVPZmZzZXQsIGtleU51bEJ5dGUpKTtcbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBEYXRhVmlldyhkYXRhVmlldy5idWZmZXIsIGtleUFuZFZhbHVlQnl0ZU9mZnNldCArIGtleU51bEJ5dGUgKyAxLCBrZXlBbmRWYWx1ZUJ5dGVTaXplIC0ga2V5TnVsQnl0ZSAtIDEpO1xuICAgIGt2RGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgYnl0ZXNJbnRvS2V5VmFsdWVEYXRhICs9IDQgKyBrZXlBbmRWYWx1ZUJ5dGVTaXplICsgdmFsdWVQYWRkaW5nO1xuICB9XG4gIHJldHVybiBrdkRhdGE7XG59XG5cbmV4cG9ydCB7IEZPUk1BVFNfVE9fQ09NUE9ORU5UUywgVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCwgVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMLCBwYXJzZUtUWCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VLVFgubWpzLm1hcFxuIiwiZXhwb3J0IHsgcGFyc2VERFMgfSBmcm9tICcuL3BhcnNlRERTLm1qcyc7XG5leHBvcnQgeyBGT1JNQVRTX1RPX0NPTVBPTkVOVFMsIFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQsIFRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTCwgcGFyc2VLVFggfSBmcm9tICcuL3BhcnNlS1RYLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSwgY2hlY2tFeHRlbnNpb24sIGNyZWF0ZVRleHR1cmUgfSBmcm9tICdAcGl4aS9hc3NldHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgc2V0dGluZ3MsIEJhc2VUZXh0dXJlLCBNSVBNQVBfTU9ERVMsIEFMUEhBX01PREVTLCB1dGlscywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0ICcuLi9wYXJzZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBwYXJzZUREUyB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2VERFMubWpzJztcblxuY29uc3QgbG9hZEREUyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIG5hbWU6IFwibG9hZEREU1wiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0V4dGVuc2lvbih1cmwsIFwiLmRkc1wiKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIGFzc2V0LCBsb2FkZXIpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgcmVzb3VyY2VzID0gcGFyc2VERFMoYXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IHRleHR1cmVzID0gcmVzb3VyY2VzLm1hcCgocmVzb3VyY2UpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBuZXcgQmFzZVRleHR1cmUocmVzb3VyY2UsIHtcbiAgICAgICAgbWlwbWFwOiBNSVBNQVBfTU9ERVMuT0ZGLFxuICAgICAgICBhbHBoYU1vZGU6IEFMUEhBX01PREVTLk5PX1BSRU1VTFRJUExJRURfQUxQSEEsXG4gICAgICAgIHJlc29sdXRpb246IHV0aWxzLmdldFJlc29sdXRpb25PZlVybCh1cmwpLFxuICAgICAgICAuLi5hc3NldC5kYXRhXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlKGJhc2UsIGxvYWRlciwgdXJsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dHVyZXMubGVuZ3RoID09PSAxID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlcztcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0dXJlKSkge1xuICAgICAgdGV4dHVyZS5mb3JFYWNoKCh0KSA9PiB0LmRlc3Ryb3kodHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZEREUyk7XG5cbmV4cG9ydCB7IGxvYWRERFMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRERFMubWpzLm1hcFxuIiwiaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHksIGNoZWNrRXh0ZW5zaW9uLCBjcmVhdGVUZXh0dXJlIH0gZnJvbSAnQHBpeGkvYXNzZXRzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBNSVBNQVBfTU9ERVMsIEFMUEhBX01PREVTLCB1dGlscywgQmFzZVRleHR1cmUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCAnLi4vcGFyc2Vycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgcGFyc2VLVFggfSBmcm9tICcuLi9wYXJzZXJzL3BhcnNlS1RYLm1qcyc7XG5cbmNvbnN0IGxvYWRLVFggPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyUHJpb3JpdHkuSGlnaFxuICB9LFxuICBuYW1lOiBcImxvYWRLVFhcIixcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tFeHRlbnNpb24odXJsLCBcIi5rdHhcIik7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBhc3NldCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCk7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IHsgY29tcHJlc3NlZCwgdW5jb21wcmVzc2VkLCBrdkRhdGEgfSA9IHBhcnNlS1RYKHVybCwgYXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IHJlc291cmNlcyA9IGNvbXByZXNzZWQgPz8gdW5jb21wcmVzc2VkO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtaXBtYXA6IE1JUE1BUF9NT0RFUy5PRkYsXG4gICAgICBhbHBoYU1vZGU6IEFMUEhBX01PREVTLk5PX1BSRU1VTFRJUExJRURfQUxQSEEsXG4gICAgICByZXNvbHV0aW9uOiB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwodXJsKSxcbiAgICAgIC4uLmFzc2V0LmRhdGFcbiAgICB9O1xuICAgIGNvbnN0IHRleHR1cmVzID0gcmVzb3VyY2VzLm1hcCgocmVzb3VyY2UpID0+IHtcbiAgICAgIGlmIChyZXNvdXJjZXMgPT09IHVuY29tcHJlc3NlZCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICB0eXBlOiByZXNvdXJjZS50eXBlLFxuICAgICAgICAgIGZvcm1hdDogcmVzb3VyY2UuZm9ybWF0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFzZSA9IG5ldyBCYXNlVGV4dHVyZShyZXNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICBiYXNlLmt0eEtleVZhbHVlRGF0YSA9IGt2RGF0YTtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlKGJhc2UsIGxvYWRlciwgdXJsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dHVyZXMubGVuZ3RoID09PSAxID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlcztcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0dXJlKSkge1xuICAgICAgdGV4dHVyZS5mb3JFYWNoKCh0KSA9PiB0LmRlc3Ryb3kodHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZEtUWCk7XG5cbmV4cG9ydCB7IGxvYWRLVFggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRLVFgubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgc2V0dGluZ3MsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9jb3JlJztcblxuY29uc3QgcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsID0ge1xuICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlcixcbiAgdGVzdDogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdGVtcCA9IHZhbHVlLnNwbGl0KFwiP1wiKVswXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZW1wLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICByZXR1cm4gW1wiYmFzaXNcIiwgXCJrdHhcIiwgXCJkZHNcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uKTtcbiAgfSxcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHRlbXAgPSB2YWx1ZS5zcGxpdChcIj9cIilbMF07XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGVtcC5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgaWYgKGV4dGVuc2lvbiA9PT0gXCJrdHhcIikge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uczIgPSBbXG4gICAgICAgIFwiLnMzdGMua3R4XCIsXG4gICAgICAgIFwiLnMzdGNfc1JHQi5rdHhcIixcbiAgICAgICAgXCIuZXRjLmt0eFwiLFxuICAgICAgICBcIi5ldGMxLmt0eFwiLFxuICAgICAgICBcIi5wdnJ0Lmt0eFwiLFxuICAgICAgICBcIi5hdGMua3R4XCIsXG4gICAgICAgIFwiLmFzdGMua3R4XCJcbiAgICAgIF07XG4gICAgICBpZiAoZXh0ZW5zaW9uczIuc29tZSgoZXh0KSA9PiB2YWx1ZS5lbmRzV2l0aChleHQpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoc2V0dGluZ3MuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICAgICAgICBmb3JtYXQ6IGV4dGVuc2lvbnMyLmZpbmQoKGV4dCkgPT4gdmFsdWUuZW5kc1dpdGgoZXh0KSksXG4gICAgICAgICAgc3JjOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzb2x1dGlvbjogcGFyc2VGbG9hdChzZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gXCIxXCIpLFxuICAgICAgZm9ybWF0OiB2YWx1ZS5zcGxpdChcIi5cIikucG9wKCksXG4gICAgICBzcmM6IHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCk7XG5cbmV4cG9ydCB7IHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLm1qcy5tYXBcbiIsImltcG9ydCAnLi9jb21wcmVzc2VkVGV4dHVyZUV4dGVuc2lvbnMubWpzJztcbmV4cG9ydCB7IGRldGVjdENvbXByZXNzZWRUZXh0dXJlcyB9IGZyb20gJy4vZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzLm1qcyc7XG5leHBvcnQgeyBsb2FkRERTIH0gZnJvbSAnLi9sb2FkRERTLm1qcyc7XG5leHBvcnQgeyBsb2FkS1RYIH0gZnJvbSAnLi9sb2FkS1RYLm1qcyc7XG5leHBvcnQgeyByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwgfSBmcm9tICcuL3Jlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiZXhwb3J0IHsgSU5URVJOQUxfRk9STUFUUywgSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTCB9IGZyb20gJy4vY29uc3QubWpzJztcbmltcG9ydCAnLi9sb2FkZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vcGFyc2Vycy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3Jlc291cmNlcy9pbmRleC5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzIH0gZnJvbSAnLi9sb2FkZXJzL2RldGVjdENvbXByZXNzZWRUZXh0dXJlcy5tanMnO1xuZXhwb3J0IHsgbG9hZEREUyB9IGZyb20gJy4vbG9hZGVycy9sb2FkRERTLm1qcyc7XG5leHBvcnQgeyBsb2FkS1RYIH0gZnJvbSAnLi9sb2FkZXJzL2xvYWRLVFgubWpzJztcbmV4cG9ydCB7IHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCB9IGZyb20gJy4vbG9hZGVycy9yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwubWpzJztcbmV4cG9ydCB7IHBhcnNlRERTIH0gZnJvbSAnLi9wYXJzZXJzL3BhcnNlRERTLm1qcyc7XG5leHBvcnQgeyBGT1JNQVRTX1RPX0NPTVBPTkVOVFMsIFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQsIFRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTCwgcGFyc2VLVFggfSBmcm9tICcuL3BhcnNlcnMvcGFyc2VLVFgubWpzJztcbmV4cG9ydCB7IEJsb2JSZXNvdXJjZSB9IGZyb20gJy4vcmVzb3VyY2VzL0Jsb2JSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSB9IGZyb20gJy4vcmVzb3VyY2VzL0NvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSwgdXRpbHMsIFJlbmRlclRleHR1cmUsIE1TQUFfUVVBTElUWSwgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jb25zdCBURU1QX1JFQ1QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5jb25zdCBCWVRFU19QRVJfUElYRUwgPSA0O1xuY29uc3QgX0V4dHJhY3QgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGFzeW5jIGltYWdlKHRhcmdldCwgZm9ybWF0LCBxdWFsaXR5KSB7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSBhd2FpdCB0aGlzLmJhc2U2NCh0YXJnZXQsIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIGFzeW5jIGJhc2U2NCh0YXJnZXQsIGZvcm1hdCwgcXVhbGl0eSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzKHRhcmdldCk7XG4gICAgaWYgKGNhbnZhcy50b0RhdGFVUkwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoZm9ybWF0LCBxdWFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGNhbnZhcy5jb252ZXJ0VG9CbG9iICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBjYW52YXMuY29udmVydFRvQmxvYih7IHR5cGU6IGZvcm1hdCwgcXVhbGl0eSB9KTtcbiAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0cmFjdC5iYXNlNjQoKSByZXF1aXJlcyBJQ2FudmFzLnRvRGF0YVVSTCBvciBJQ2FudmFzLmNvbnZlcnRUb0Jsb2IgdG8gYmUgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgY2FudmFzKHRhcmdldCwgZnJhbWUpIHtcbiAgICBjb25zdCB7IHBpeGVscywgd2lkdGgsIGhlaWdodCwgZmxpcFkgfSA9IHRoaXMuX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKTtcbiAgICBsZXQgY2FudmFzQnVmZmVyID0gbmV3IHV0aWxzLkNhbnZhc1JlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCAxKTtcbiAgICBjb25zdCBjYW52YXNEYXRhID0gY2FudmFzQnVmZmVyLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIF9FeHRyYWN0LmFycmF5UG9zdERpdmlkZShwaXhlbHMsIGNhbnZhc0RhdGEuZGF0YSk7XG4gICAgY2FudmFzQnVmZmVyLmNvbnRleHQucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgIGlmIChmbGlwWSkge1xuICAgICAgY29uc3QgdGFyZ2V0MiA9IG5ldyB1dGlscy5DYW52YXNSZW5kZXJUYXJnZXQoY2FudmFzQnVmZmVyLndpZHRoLCBjYW52YXNCdWZmZXIuaGVpZ2h0LCAxKTtcbiAgICAgIHRhcmdldDIuY29udGV4dC5zY2FsZSgxLCAtMSk7XG4gICAgICB0YXJnZXQyLmNvbnRleHQuZHJhd0ltYWdlKGNhbnZhc0J1ZmZlci5jYW52YXMsIDAsIC1oZWlnaHQpO1xuICAgICAgY2FudmFzQnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIGNhbnZhc0J1ZmZlciA9IHRhcmdldDI7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNCdWZmZXIuY2FudmFzO1xuICB9XG4gIHBpeGVscyh0YXJnZXQsIGZyYW1lKSB7XG4gICAgY29uc3QgeyBwaXhlbHMgfSA9IHRoaXMuX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKTtcbiAgICBfRXh0cmFjdC5hcnJheVBvc3REaXZpZGUocGl4ZWxzLCBwaXhlbHMpO1xuICAgIHJldHVybiBwaXhlbHM7XG4gIH1cbiAgX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBFeHRyYWN0IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x1dGlvbjtcbiAgICBsZXQgZmxpcFkgPSBmYWxzZTtcbiAgICBsZXQgcmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG11bHRpc2FtcGxlID0gcmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPj0gMiA/IHJlbmRlcmVyLm11bHRpc2FtcGxlIDogTVNBQV9RVUFMSVRZLk5PTkU7XG4gICAgICAgIHJlbmRlclRleHR1cmUgPSByZW5kZXJlci5nZW5lcmF0ZVRleHR1cmUodGFyZ2V0LCB7IG11bHRpc2FtcGxlIH0pO1xuICAgICAgICBpZiAobXVsdGlzYW1wbGUgIT09IE1TQUFfUVVBTElUWS5OT05FKSB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRUZXh0dXJlID0gUmVuZGVyVGV4dHVyZS5jcmVhdGUoe1xuICAgICAgICAgICAgd2lkdGg6IHJlbmRlclRleHR1cmUud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHJlbmRlclRleHR1cmUuaGVpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZChyZW5kZXJUZXh0dXJlLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICByZW5kZXJlci5mcmFtZWJ1ZmZlci5ibGl0KHJlc29sdmVkVGV4dHVyZS5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgcmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZCgpO1xuICAgICAgICAgIHJlbmRlclRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICByZW5kZXJUZXh0dXJlID0gcmVzb2x2ZWRUZXh0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGdlbmVyYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICByZXNvbHV0aW9uID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgZnJhbWUgPSBmcmFtZSA/PyByZW5kZXJUZXh0dXJlLmZyYW1lO1xuICAgICAgZmxpcFkgPSBmYWxzZTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICBpZiAoIWZyYW1lKSB7XG4gICAgICAgIGZyYW1lID0gVEVNUF9SRUNUO1xuICAgICAgICBmcmFtZS53aWR0aCA9IHJlbmRlcmVyLndpZHRoO1xuICAgICAgICBmcmFtZS5oZWlnaHQgPSByZW5kZXJlci5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBmbGlwWSA9IHRydWU7XG4gICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lLndpZHRoICogcmVzb2x1dGlvbik7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheShCWVRFU19QRVJfUElYRUwgKiB3aWR0aCAqIGhlaWdodCk7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBnbC5yZWFkUGl4ZWxzKE1hdGgucm91bmQoZnJhbWUueCAqIHJlc29sdXRpb24pLCBNYXRoLnJvdW5kKGZyYW1lLnkgKiByZXNvbHV0aW9uKSwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICBpZiAoZ2VuZXJhdGVkKSB7XG4gICAgICByZW5kZXJUZXh0dXJlPy5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBwaXhlbHMsIHdpZHRoLCBoZWlnaHQsIGZsaXBZIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgYXJyYXlQb3N0RGl2aWRlKHBpeGVscywgb3V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IGFscGhhID0gb3V0W2kgKyAzXSA9IHBpeGVsc1tpICsgM107XG4gICAgICBpZiAoYWxwaGEgIT09IDApIHtcbiAgICAgICAgb3V0W2ldID0gTWF0aC5yb3VuZChNYXRoLm1pbihwaXhlbHNbaV0gKiAyNTUgLyBhbHBoYSwgMjU1KSk7XG4gICAgICAgIG91dFtpICsgMV0gPSBNYXRoLnJvdW5kKE1hdGgubWluKHBpeGVsc1tpICsgMV0gKiAyNTUgLyBhbHBoYSwgMjU1KSk7XG4gICAgICAgIG91dFtpICsgMl0gPSBNYXRoLnJvdW5kKE1hdGgubWluKHBpeGVsc1tpICsgMl0gKiAyNTUgLyBhbHBoYSwgMjU1KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbaV0gPSBwaXhlbHNbaV07XG4gICAgICAgIG91dFtpICsgMV0gPSBwaXhlbHNbaSArIDFdO1xuICAgICAgICBvdXRbaSArIDJdID0gcGl4ZWxzW2kgKyAyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5sZXQgRXh0cmFjdCA9IF9FeHRyYWN0O1xuRXh0cmFjdC5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiZXh0cmFjdFwiLFxuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtXG59O1xuZXh0ZW5zaW9ucy5hZGQoRXh0cmFjdCk7XG5cbmV4cG9ydCB7IEV4dHJhY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4dHJhY3QubWpzLm1hcFxuIiwiZXhwb3J0IHsgRXh0cmFjdCB9IGZyb20gJy4vRXh0cmFjdC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGJ1aWxkQ2lyY2xlID0ge1xuICBidWlsZChncmFwaGljc0RhdGEpIHtcbiAgICBjb25zdCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGxldCBkeDtcbiAgICBsZXQgZHk7XG4gICAgbGV0IHJ4O1xuICAgIGxldCByeTtcbiAgICBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IFNIQVBFUy5DSVJDKSB7XG4gICAgICBjb25zdCBjaXJjbGUgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICB4ID0gY2lyY2xlLng7XG4gICAgICB5ID0gY2lyY2xlLnk7XG4gICAgICByeCA9IHJ5ID0gY2lyY2xlLnJhZGl1cztcbiAgICAgIGR4ID0gZHkgPSAwO1xuICAgIH0gZWxzZSBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IFNIQVBFUy5FTElQKSB7XG4gICAgICBjb25zdCBlbGxpcHNlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgeCA9IGVsbGlwc2UueDtcbiAgICAgIHkgPSBlbGxpcHNlLnk7XG4gICAgICByeCA9IGVsbGlwc2Uud2lkdGg7XG4gICAgICByeSA9IGVsbGlwc2UuaGVpZ2h0O1xuICAgICAgZHggPSBkeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdW5kZWRSZWN0ID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgY29uc3QgaGFsZldpZHRoID0gcm91bmRlZFJlY3Qud2lkdGggLyAyO1xuICAgICAgY29uc3QgaGFsZkhlaWdodCA9IHJvdW5kZWRSZWN0LmhlaWdodCAvIDI7XG4gICAgICB4ID0gcm91bmRlZFJlY3QueCArIGhhbGZXaWR0aDtcbiAgICAgIHkgPSByb3VuZGVkUmVjdC55ICsgaGFsZkhlaWdodDtcbiAgICAgIHJ4ID0gcnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyb3VuZGVkUmVjdC5yYWRpdXMsIE1hdGgubWluKGhhbGZXaWR0aCwgaGFsZkhlaWdodCkpKTtcbiAgICAgIGR4ID0gaGFsZldpZHRoIC0gcng7XG4gICAgICBkeSA9IGhhbGZIZWlnaHQgLSByeTtcbiAgICB9XG4gICAgaWYgKCEocnggPj0gMCAmJiByeSA+PSAwICYmIGR4ID49IDAgJiYgZHkgPj0gMCkpIHtcbiAgICAgIHBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuID0gTWF0aC5jZWlsKDIuMyAqIE1hdGguc3FydChyeCArIHJ5KSk7XG4gICAgY29uc3QgbSA9IG4gKiA4ICsgKGR4ID8gNCA6IDApICsgKGR5ID8gNCA6IDApO1xuICAgIHBvaW50cy5sZW5ndGggPSBtO1xuICAgIGlmIChtID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBwb2ludHMubGVuZ3RoID0gODtcbiAgICAgIHBvaW50c1swXSA9IHBvaW50c1s2XSA9IHggKyBkeDtcbiAgICAgIHBvaW50c1sxXSA9IHBvaW50c1szXSA9IHkgKyBkeTtcbiAgICAgIHBvaW50c1syXSA9IHBvaW50c1s0XSA9IHggLSBkeDtcbiAgICAgIHBvaW50c1s1XSA9IHBvaW50c1s3XSA9IHkgLSBkeTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGoxID0gMDtcbiAgICBsZXQgajIgPSBuICogNCArIChkeCA/IDIgOiAwKSArIDI7XG4gICAgbGV0IGozID0gajI7XG4gICAgbGV0IGo0ID0gbTtcbiAgICB7XG4gICAgICBjb25zdCB4MCA9IGR4ICsgcng7XG4gICAgICBjb25zdCB5MCA9IGR5O1xuICAgICAgY29uc3QgeDEgPSB4ICsgeDA7XG4gICAgICBjb25zdCB4MiA9IHggLSB4MDtcbiAgICAgIGNvbnN0IHkxID0geSArIHkwO1xuICAgICAgcG9pbnRzW2oxKytdID0geDE7XG4gICAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICAgIHBvaW50c1stLWoyXSA9IHkxO1xuICAgICAgcG9pbnRzWy0tajJdID0geDI7XG4gICAgICBpZiAoZHkpIHtcbiAgICAgICAgY29uc3QgeTIgPSB5IC0geTA7XG4gICAgICAgIHBvaW50c1tqMysrXSA9IHgyO1xuICAgICAgICBwb2ludHNbajMrK10gPSB5MjtcbiAgICAgICAgcG9pbnRzWy0tajRdID0geTI7XG4gICAgICAgIHBvaW50c1stLWo0XSA9IHgxO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgY29uc3QgYSA9IE1hdGguUEkgLyAyICogKGkgLyBuKTtcbiAgICAgIGNvbnN0IHgwID0gZHggKyBNYXRoLmNvcyhhKSAqIHJ4O1xuICAgICAgY29uc3QgeTAgPSBkeSArIE1hdGguc2luKGEpICogcnk7XG4gICAgICBjb25zdCB4MSA9IHggKyB4MDtcbiAgICAgIGNvbnN0IHgyID0geCAtIHgwO1xuICAgICAgY29uc3QgeTEgPSB5ICsgeTA7XG4gICAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHgxO1xuICAgICAgcG9pbnRzW2oxKytdID0geTE7XG4gICAgICBwb2ludHNbLS1qMl0gPSB5MTtcbiAgICAgIHBvaW50c1stLWoyXSA9IHgyO1xuICAgICAgcG9pbnRzW2ozKytdID0geDI7XG4gICAgICBwb2ludHNbajMrK10gPSB5MjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHkyO1xuICAgICAgcG9pbnRzWy0tajRdID0geDE7XG4gICAgfVxuICAgIHtcbiAgICAgIGNvbnN0IHgwID0gZHg7XG4gICAgICBjb25zdCB5MCA9IGR5ICsgcnk7XG4gICAgICBjb25zdCB4MSA9IHggKyB4MDtcbiAgICAgIGNvbnN0IHgyID0geCAtIHgwO1xuICAgICAgY29uc3QgeTEgPSB5ICsgeTA7XG4gICAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHgxO1xuICAgICAgcG9pbnRzW2oxKytdID0geTE7XG4gICAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHgxO1xuICAgICAgaWYgKGR4KSB7XG4gICAgICAgIHBvaW50c1tqMSsrXSA9IHgyO1xuICAgICAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICAgICAgcG9pbnRzWy0tajRdID0geTI7XG4gICAgICAgIHBvaW50c1stLWo0XSA9IHgyO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgY29uc3QgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBjb25zdCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xuICAgIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGNlbnRlciA9IHZlcnRQb3M7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgaWYgKGdyYXBoaWNzRGF0YS50eXBlICE9PSBTSEFQRVMuUlJFQykge1xuICAgICAgY29uc3QgY2lyY2xlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgeCA9IGNpcmNsZS54O1xuICAgICAgeSA9IGNpcmNsZS55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb3VuZGVkUmVjdCA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICAgIHggPSByb3VuZGVkUmVjdC54ICsgcm91bmRlZFJlY3Qud2lkdGggLyAyO1xuICAgICAgeSA9IHJvdW5kZWRSZWN0LnkgKyByb3VuZGVkUmVjdC5oZWlnaHQgLyAyO1xuICAgIH1cbiAgICBjb25zdCBtYXRyaXggPSBncmFwaGljc0RhdGEubWF0cml4O1xuICAgIHZlcnRzLnB1c2goZ3JhcGhpY3NEYXRhLm1hdHJpeCA/IG1hdHJpeC5hICogeCArIG1hdHJpeC5jICogeSArIG1hdHJpeC50eCA6IHgsIGdyYXBoaWNzRGF0YS5tYXRyaXggPyBtYXRyaXguYiAqIHggKyBtYXRyaXguZCAqIHkgKyBtYXRyaXgudHkgOiB5KTtcbiAgICB2ZXJ0UG9zKys7XG4gICAgdmVydHMucHVzaChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZlcnRzLnB1c2gocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zKyssIGNlbnRlciwgdmVydFBvcyk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChjZW50ZXIgKyAxLCBjZW50ZXIsIHZlcnRQb3MpO1xuICB9XG59O1xuXG5leHBvcnQgeyBidWlsZENpcmNsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDaXJjbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMgfSBmcm9tICdAcGl4aS9jb3JlJztcblxuZnVuY3Rpb24gZml4T3JpZW50YXRpb24ocG9pbnRzLCBob2xlID0gZmFsc2UpIHtcbiAgY29uc3QgbSA9IHBvaW50cy5sZW5ndGg7XG4gIGlmIChtIDwgNikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCB4MSA9IHBvaW50c1ttIC0gMl0sIHkxID0gcG9pbnRzW20gLSAxXTsgaSA8IG07IGkgKz0gMikge1xuICAgIGNvbnN0IHgyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IHkyID0gcG9pbnRzW2kgKyAxXTtcbiAgICBhcmVhICs9ICh4MiAtIHgxKSAqICh5MiArIHkxKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgaWYgKCFob2xlICYmIGFyZWEgPiAwIHx8IGhvbGUgJiYgYXJlYSA8PSAwKSB7XG4gICAgY29uc3QgbiA9IG0gLyAyO1xuICAgIGZvciAobGV0IGkgPSBuICsgbiAlIDI7IGkgPCBtOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGkxID0gbSAtIGkgLSAyO1xuICAgICAgY29uc3QgaTIgPSBtIC0gaSAtIDE7XG4gICAgICBjb25zdCBpMyA9IGk7XG4gICAgICBjb25zdCBpNCA9IGkgKyAxO1xuICAgICAgW3BvaW50c1tpMV0sIHBvaW50c1tpM11dID0gW3BvaW50c1tpM10sIHBvaW50c1tpMV1dO1xuICAgICAgW3BvaW50c1tpMl0sIHBvaW50c1tpNF1dID0gW3BvaW50c1tpNF0sIHBvaW50c1tpMl1dO1xuICAgIH1cbiAgfVxufVxuY29uc3QgYnVpbGRQb2x5ID0ge1xuICBidWlsZChncmFwaGljc0RhdGEpIHtcbiAgICBncmFwaGljc0RhdGEucG9pbnRzID0gZ3JhcGhpY3NEYXRhLnNoYXBlLnBvaW50cy5zbGljZSgpO1xuICB9LFxuICB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBjb25zdCBob2xlcyA9IGdyYXBoaWNzRGF0YS5ob2xlcztcbiAgICBjb25zdCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xuICAgIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPj0gNikge1xuICAgICAgZml4T3JpZW50YXRpb24ocG9pbnRzLCBmYWxzZSk7XG4gICAgICBjb25zdCBob2xlQXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaG9sZSA9IGhvbGVzW2ldO1xuICAgICAgICBmaXhPcmllbnRhdGlvbihob2xlLnBvaW50cywgdHJ1ZSk7XG4gICAgICAgIGhvbGVBcnJheS5wdXNoKHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzLmNvbmNhdChob2xlLnBvaW50cyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmlhbmdsZXMgPSB1dGlscy5lYXJjdXQocG9pbnRzLCBob2xlQXJyYXksIDIpO1xuICAgICAgaWYgKCF0cmlhbmdsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDFdICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVydFBvcyk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgeyBidWlsZFBvbHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUG9seS5tanMubWFwXG4iLCJjb25zdCBidWlsZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgY29uc3QgcmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgY29uc3QgeCA9IHJlY3REYXRhLng7XG4gICAgY29uc3QgeSA9IHJlY3REYXRhLnk7XG4gICAgY29uc3Qgd2lkdGggPSByZWN0RGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBwb2ludHMubGVuZ3RoID0gMDtcbiAgICBpZiAoISh3aWR0aCA+PSAwICYmIGhlaWdodCA+PSAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwb2ludHMucHVzaCh4LCB5LCB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCk7XG4gIH0sXG4gIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgIGNvbnN0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgY29uc3QgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgICB2ZXJ0cy5wdXNoKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzZdLCBwb2ludHNbN10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICBncmFwaGljc0dlb21ldHJ5LmluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zICsgMSwgdmVydFBvcyArIDIsIHZlcnRQb3MgKyAxLCB2ZXJ0UG9zICsgMiwgdmVydFBvcyArIDMpO1xuICB9XG59O1xuXG5leHBvcnQgeyBidWlsZFJlY3RhbmdsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRSZWN0YW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tICcuL2J1aWxkQ2lyY2xlLm1qcyc7XG5cbmNvbnN0IGJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgYnVpbGRDaXJjbGUuYnVpbGQoZ3JhcGhpY3NEYXRhKTtcbiAgfSxcbiAgdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgYnVpbGRDaXJjbGUudHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZFJvdW5kZWRSZWN0YW5nbGUubWpzLm1hcFxuIiwidmFyIExJTkVfSk9JTiA9IC8qIEBfX1BVUkVfXyAqLyAoKExJTkVfSk9JTjIpID0+IHtcbiAgTElORV9KT0lOMltcIk1JVEVSXCJdID0gXCJtaXRlclwiO1xuICBMSU5FX0pPSU4yW1wiQkVWRUxcIl0gPSBcImJldmVsXCI7XG4gIExJTkVfSk9JTjJbXCJST1VORFwiXSA9IFwicm91bmRcIjtcbiAgcmV0dXJuIExJTkVfSk9JTjI7XG59KShMSU5FX0pPSU4gfHwge30pO1xudmFyIExJTkVfQ0FQID0gLyogQF9fUFVSRV9fICovICgoTElORV9DQVAyKSA9PiB7XG4gIExJTkVfQ0FQMltcIkJVVFRcIl0gPSBcImJ1dHRcIjtcbiAgTElORV9DQVAyW1wiUk9VTkRcIl0gPSBcInJvdW5kXCI7XG4gIExJTkVfQ0FQMltcIlNRVUFSRVwiXSA9IFwic3F1YXJlXCI7XG4gIHJldHVybiBMSU5FX0NBUDI7XG59KShMSU5FX0NBUCB8fCB7fSk7XG5jb25zdCBjdXJ2ZXMgPSB7XG4gIGFkYXB0aXZlOiB0cnVlLFxuICBtYXhMZW5ndGg6IDEwLFxuICBtaW5TZWdtZW50czogOCxcbiAgbWF4U2VnbWVudHM6IDIwNDgsXG4gIGVwc2lsb246IDFlLTQsXG4gIF9zZWdtZW50c0NvdW50KGxlbmd0aCwgZGVmYXVsdFNlZ21lbnRzID0gMjApIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRpdmUgfHwgIWxlbmd0aCB8fCBpc05hTihsZW5ndGgpKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFNlZ21lbnRzO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMubWF4TGVuZ3RoKTtcbiAgICBpZiAocmVzdWx0IDwgdGhpcy5taW5TZWdtZW50cykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5taW5TZWdtZW50cztcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCA+IHRoaXMubWF4U2VnbWVudHMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMubWF4U2VnbWVudHM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5jb25zdCBHUkFQSElDU19DVVJWRVMgPSBjdXJ2ZXM7XG5cbmV4cG9ydCB7IEdSQVBISUNTX0NVUlZFUywgTElORV9DQVAsIExJTkVfSk9JTiwgY3VydmVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJpbXBvcnQgeyBQSV8yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBjdXJ2ZXMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5jbGFzcyBBcmNVdGlscyB7XG4gIHN0YXRpYyBjdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMsIHBvaW50cykge1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgYTEgPSBmcm9tWSAtIHkxO1xuICAgIGNvbnN0IGIxID0gZnJvbVggLSB4MTtcbiAgICBjb25zdCBhMiA9IHkyIC0geTE7XG4gICAgY29uc3QgYjIgPSB4MiAtIHgxO1xuICAgIGNvbnN0IG1tID0gTWF0aC5hYnMoYTEgKiBiMiAtIGIxICogYTIpO1xuICAgIGlmIChtbSA8IDFlLTggfHwgcmFkaXVzID09PSAwKSB7XG4gICAgICBpZiAocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAhPT0geDEgfHwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAhPT0geTEpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goeDEsIHkxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZCA9IGExICogYTEgKyBiMSAqIGIxO1xuICAgIGNvbnN0IGNjID0gYTIgKiBhMiArIGIyICogYjI7XG4gICAgY29uc3QgdHQgPSBhMSAqIGEyICsgYjEgKiBiMjtcbiAgICBjb25zdCBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbTtcbiAgICBjb25zdCBrMiA9IHJhZGl1cyAqIE1hdGguc3FydChjYykgLyBtbTtcbiAgICBjb25zdCBqMSA9IGsxICogdHQgLyBkZDtcbiAgICBjb25zdCBqMiA9IGsyICogdHQgLyBjYztcbiAgICBjb25zdCBjeCA9IGsxICogYjIgKyBrMiAqIGIxO1xuICAgIGNvbnN0IGN5ID0gazEgKiBhMiArIGsyICogYTE7XG4gICAgY29uc3QgcHggPSBiMSAqIChrMiArIGoxKTtcbiAgICBjb25zdCBweSA9IGExICogKGsyICsgajEpO1xuICAgIGNvbnN0IHF4ID0gYjIgKiAoazEgKyBqMik7XG4gICAgY29uc3QgcXkgPSBhMiAqIChrMSArIGoyKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gTWF0aC5hdGFuMihweSAtIGN5LCBweCAtIGN4KTtcbiAgICBjb25zdCBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBjeCArIHgxLFxuICAgICAgY3k6IGN5ICsgeTEsXG4gICAgICByYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUsXG4gICAgICBhbnRpY2xvY2t3aXNlOiBiMSAqIGEyID4gYjIgKiBhMVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFyYyhfc3RhcnRYLCBfc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIF9hbnRpY2xvY2t3aXNlLCBwb2ludHMpIHtcbiAgICBjb25zdCBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBjb25zdCBuID0gY3VydmVzLl9zZWdtZW50c0NvdW50KE1hdGguYWJzKHN3ZWVwKSAqIHJhZGl1cywgTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIFBJXzIpICogNDApO1xuICAgIGNvbnN0IHRoZXRhID0gc3dlZXAgLyAobiAqIDIpO1xuICAgIGNvbnN0IHRoZXRhMiA9IHRoZXRhICogMjtcbiAgICBjb25zdCBjVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgY29uc3Qgc1RoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgIGNvbnN0IHNlZ01pbnVzID0gbiAtIDE7XG4gICAgY29uc3QgcmVtYWluZGVyID0gc2VnTWludXMgJSAxIC8gc2VnTWludXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2VnTWludXM7ICsraSkge1xuICAgICAgY29uc3QgcmVhbCA9IGkgKyByZW1haW5kZXIgKiBpO1xuICAgICAgY29uc3QgYW5nbGUgPSB0aGV0YSArIHN0YXJ0QW5nbGUgKyB0aGV0YTIgKiByZWFsO1xuICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIGNvbnN0IHMgPSAtTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgcG9pbnRzLnB1c2goKGNUaGV0YSAqIGMgKyBzVGhldGEgKiBzKSAqIHJhZGl1cyArIGN4LCAoY1RoZXRhICogLXMgKyBzVGhldGEgKiBjKSAqIHJhZGl1cyArIGN5KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQXJjVXRpbHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFyY1V0aWxzLm1qcy5tYXBcbiIsImltcG9ydCB7IGN1cnZlcyB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5cbmNsYXNzIEJlemllclV0aWxzIHtcbiAgc3RhdGljIGN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XG4gICAgY29uc3QgbiA9IDEwO1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGxldCB0ID0gMDtcbiAgICBsZXQgdDIgPSAwO1xuICAgIGxldCB0MyA9IDA7XG4gICAgbGV0IG50ID0gMDtcbiAgICBsZXQgbnQyID0gMDtcbiAgICBsZXQgbnQzID0gMDtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBkeCA9IDA7XG4gICAgbGV0IGR5ID0gMDtcbiAgICBsZXQgcHJldlggPSBmcm9tWDtcbiAgICBsZXQgcHJldlkgPSBmcm9tWTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBuOyArK2kpIHtcbiAgICAgIHQgPSBpIC8gbjtcbiAgICAgIHQyID0gdCAqIHQ7XG4gICAgICB0MyA9IHQyICogdDtcbiAgICAgIG50ID0gMSAtIHQ7XG4gICAgICBudDIgPSBudCAqIG50O1xuICAgICAgbnQzID0gbnQyICogbnQ7XG4gICAgICB4ID0gbnQzICogZnJvbVggKyAzICogbnQyICogdCAqIGNwWCArIDMgKiBudCAqIHQyICogY3BYMiArIHQzICogdG9YO1xuICAgICAgeSA9IG50MyAqIGZyb21ZICsgMyAqIG50MiAqIHQgKiBjcFkgKyAzICogbnQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWTtcbiAgICAgIGR4ID0gcHJldlggLSB4O1xuICAgICAgZHkgPSBwcmV2WSAtIHk7XG4gICAgICBwcmV2WCA9IHg7XG4gICAgICBwcmV2WSA9IHk7XG4gICAgICByZXN1bHQgKz0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHBvaW50cykge1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgcG9pbnRzLmxlbmd0aCAtPSAyO1xuICAgIGNvbnN0IG4gPSBjdXJ2ZXMuX3NlZ21lbnRzQ291bnQoQmV6aWVyVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpKTtcbiAgICBsZXQgZHQgPSAwO1xuICAgIGxldCBkdDIgPSAwO1xuICAgIGxldCBkdDMgPSAwO1xuICAgIGxldCB0MiA9IDA7XG4gICAgbGV0IHQzID0gMDtcbiAgICBwb2ludHMucHVzaChmcm9tWCwgZnJvbVkpO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGogPSBpIC8gbjtcbiAgICAgIGR0ID0gMSAtIGo7XG4gICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgZHQzID0gZHQyICogZHQ7XG4gICAgICB0MiA9IGogKiBqO1xuICAgICAgdDMgPSB0MiAqIGo7XG4gICAgICBwb2ludHMucHVzaChkdDMgKiBmcm9tWCArIDMgKiBkdDIgKiBqICogY3BYICsgMyAqIGR0ICogdDIgKiBjcFgyICsgdDMgKiB0b1gsIGR0MyAqIGZyb21ZICsgMyAqIGR0MiAqIGogKiBjcFkgKyAzICogZHQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEJlemllclV0aWxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CZXppZXJVdGlscy5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCwgU0hBUEVTIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBMSU5FX0NBUCwgTElORV9KT0lOLCBjdXJ2ZXMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5mdW5jdGlvbiBzcXVhcmUoeCwgeSwgbngsIG55LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIGNsb2Nrd2lzZSwgdmVydHMpIHtcbiAgY29uc3QgaXggPSB4IC0gbnggKiBpbm5lcldlaWdodDtcbiAgY29uc3QgaXkgPSB5IC0gbnkgKiBpbm5lcldlaWdodDtcbiAgY29uc3Qgb3ggPSB4ICsgbnggKiBvdXRlcldlaWdodDtcbiAgY29uc3Qgb3kgPSB5ICsgbnkgKiBvdXRlcldlaWdodDtcbiAgbGV0IGV4eDtcbiAgbGV0IGV5eTtcbiAgaWYgKGNsb2Nrd2lzZSkge1xuICAgIGV4eCA9IG55O1xuICAgIGV5eSA9IC1ueDtcbiAgfSBlbHNlIHtcbiAgICBleHggPSAtbnk7XG4gICAgZXl5ID0gbng7XG4gIH1cbiAgY29uc3QgZWl4ID0gaXggKyBleHg7XG4gIGNvbnN0IGVpeSA9IGl5ICsgZXl5O1xuICBjb25zdCBlb3ggPSBveCArIGV4eDtcbiAgY29uc3QgZW95ID0gb3kgKyBleXk7XG4gIHZlcnRzLnB1c2goZWl4LCBlaXksIGVveCwgZW95KTtcbiAgcmV0dXJuIDI7XG59XG5mdW5jdGlvbiByb3VuZChjeCwgY3ksIHN4LCBzeSwgZXgsIGV5LCB2ZXJ0cywgY2xvY2t3aXNlKSB7XG4gIGNvbnN0IGN4MnAweCA9IHN4IC0gY3g7XG4gIGNvbnN0IGN5MnAweSA9IHN5IC0gY3k7XG4gIGxldCBhbmdsZTAgPSBNYXRoLmF0YW4yKGN4MnAweCwgY3kycDB5KTtcbiAgbGV0IGFuZ2xlMSA9IE1hdGguYXRhbjIoZXggLSBjeCwgZXkgLSBjeSk7XG4gIGlmIChjbG9ja3dpc2UgJiYgYW5nbGUwIDwgYW5nbGUxKSB7XG4gICAgYW5nbGUwICs9IE1hdGguUEkgKiAyO1xuICB9IGVsc2UgaWYgKCFjbG9ja3dpc2UgJiYgYW5nbGUwID4gYW5nbGUxKSB7XG4gICAgYW5nbGUxICs9IE1hdGguUEkgKiAyO1xuICB9XG4gIGxldCBzdGFydEFuZ2xlID0gYW5nbGUwO1xuICBjb25zdCBhbmdsZURpZmYgPSBhbmdsZTEgLSBhbmdsZTA7XG4gIGNvbnN0IGFic0FuZ2xlRGlmZiA9IE1hdGguYWJzKGFuZ2xlRGlmZik7XG4gIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydChjeDJwMHggKiBjeDJwMHggKyBjeTJwMHkgKiBjeTJwMHkpO1xuICBjb25zdCBzZWdDb3VudCA9ICgxNSAqIGFic0FuZ2xlRGlmZiAqIE1hdGguc3FydChyYWRpdXMpIC8gTWF0aC5QSSA+PiAwKSArIDE7XG4gIGNvbnN0IGFuZ2xlSW5jID0gYW5nbGVEaWZmIC8gc2VnQ291bnQ7XG4gIHN0YXJ0QW5nbGUgKz0gYW5nbGVJbmM7XG4gIGlmIChjbG9ja3dpc2UpIHtcbiAgICB2ZXJ0cy5wdXNoKGN4LCBjeSwgc3gsIHN5KTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpIHtcbiAgICAgIHZlcnRzLnB1c2goY3gsIGN5LCBjeCArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cywgY3kgKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMpO1xuICAgIH1cbiAgICB2ZXJ0cy5wdXNoKGN4LCBjeSwgZXgsIGV5KTtcbiAgfSBlbHNlIHtcbiAgICB2ZXJ0cy5wdXNoKHN4LCBzeSwgY3gsIGN5KTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpIHtcbiAgICAgIHZlcnRzLnB1c2goY3ggKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsIGN5ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLCBjeCwgY3kpO1xuICAgIH1cbiAgICB2ZXJ0cy5wdXNoKGV4LCBleSwgY3gsIGN5KTtcbiAgfVxuICByZXR1cm4gc2VnQ291bnQgKiAyO1xufVxuZnVuY3Rpb24gYnVpbGROb25OYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBjb25zdCBzaGFwZSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgbGV0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMgfHwgc2hhcGUucG9pbnRzLnNsaWNlKCk7XG4gIGNvbnN0IGVwcyA9IGdyYXBoaWNzR2VvbWV0cnkuY2xvc2VQb2ludEVwcztcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSBncmFwaGljc0RhdGEubGluZVN0eWxlO1xuICBjb25zdCBmaXJzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgY29uc3QgbGFzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICBjb25zdCBjbG9zZWRTaGFwZSA9IHNoYXBlLnR5cGUgIT09IFNIQVBFUy5QT0xZIHx8IHNoYXBlLmNsb3NlU3Ryb2tlO1xuICBjb25zdCBjbG9zZWRQYXRoID0gTWF0aC5hYnMoZmlyc3RQb2ludC54IC0gbGFzdFBvaW50LngpIDwgZXBzICYmIE1hdGguYWJzKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSA8IGVwcztcbiAgaWYgKGNsb3NlZFNoYXBlKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XG4gICAgaWYgKGNsb3NlZFBhdGgpIHtcbiAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgIGxhc3RQb2ludC5zZXQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIGNvbnN0IG1pZFBvaW50WCA9IChmaXJzdFBvaW50LnggKyBsYXN0UG9pbnQueCkgKiAwLjU7XG4gICAgY29uc3QgbWlkUG9pbnRZID0gKGxhc3RQb2ludC55ICsgZmlyc3RQb2ludC55KSAqIDAuNTtcbiAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICB9XG4gIGNvbnN0IHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gIGNvbnN0IGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICBsZXQgaW5kZXhDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICBjb25zdCB3aWR0aCA9IHN0eWxlLndpZHRoIC8gMjtcbiAgY29uc3Qgd2lkdGhTcXVhcmVkID0gd2lkdGggKiB3aWR0aDtcbiAgY29uc3QgbWl0ZXJMaW1pdFNxdWFyZWQgPSBzdHlsZS5taXRlckxpbWl0ICogc3R5bGUubWl0ZXJMaW1pdDtcbiAgbGV0IHgwID0gcG9pbnRzWzBdO1xuICBsZXQgeTAgPSBwb2ludHNbMV07XG4gIGxldCB4MSA9IHBvaW50c1syXTtcbiAgbGV0IHkxID0gcG9pbnRzWzNdO1xuICBsZXQgeDIgPSAwO1xuICBsZXQgeTIgPSAwO1xuICBsZXQgcGVycHggPSAtKHkwIC0geTEpO1xuICBsZXQgcGVycHkgPSB4MCAtIHgxO1xuICBsZXQgcGVycDF4ID0gMDtcbiAgbGV0IHBlcnAxeSA9IDA7XG4gIGxldCBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4ICogcGVycHggKyBwZXJweSAqIHBlcnB5KTtcbiAgcGVycHggLz0gZGlzdDtcbiAgcGVycHkgLz0gZGlzdDtcbiAgcGVycHggKj0gd2lkdGg7XG4gIHBlcnB5ICo9IHdpZHRoO1xuICBjb25zdCByYXRpbyA9IHN0eWxlLmFsaWdubWVudDtcbiAgY29uc3QgaW5uZXJXZWlnaHQgPSAoMSAtIHJhdGlvKSAqIDI7XG4gIGNvbnN0IG91dGVyV2VpZ2h0ID0gcmF0aW8gKiAyO1xuICBpZiAoIWNsb3NlZFNoYXBlKSB7XG4gICAgaWYgKHN0eWxlLmNhcCA9PT0gTElORV9DQVAuUk9VTkQpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDAgLSBwZXJweCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeTAgLSBwZXJweSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeDAgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MCAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgwICsgcGVycHggKiBvdXRlcldlaWdodCwgeTAgKyBwZXJweSAqIG91dGVyV2VpZ2h0LCB2ZXJ0cywgdHJ1ZSkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBMSU5FX0NBUC5TUVVBUkUpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gc3F1YXJlKHgwLCB5MCwgcGVycHgsIHBlcnB5LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIHRydWUsIHZlcnRzKTtcbiAgICB9XG4gIH1cbiAgdmVydHMucHVzaCh4MCAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkwIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDAgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MCArIHBlcnB5ICogb3V0ZXJXZWlnaHQpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgIHgwID0gcG9pbnRzWyhpIC0gMSkgKiAyXTtcbiAgICB5MCA9IHBvaW50c1soaSAtIDEpICogMiArIDFdO1xuICAgIHgxID0gcG9pbnRzW2kgKiAyXTtcbiAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgIHgyID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIHBlcnB4ID0gLSh5MCAtIHkxKTtcbiAgICBwZXJweSA9IHgwIC0geDE7XG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gICAgcGVycHggLz0gZGlzdDtcbiAgICBwZXJweSAvPSBkaXN0O1xuICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgIHBlcnB5ICo9IHdpZHRoO1xuICAgIHBlcnAxeCA9IC0oeTEgLSB5Mik7XG4gICAgcGVycDF5ID0geDEgLSB4MjtcbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAxeCAqIHBlcnAxeCArIHBlcnAxeSAqIHBlcnAxeSk7XG4gICAgcGVycDF4IC89IGRpc3Q7XG4gICAgcGVycDF5IC89IGRpc3Q7XG4gICAgcGVycDF4ICo9IHdpZHRoO1xuICAgIHBlcnAxeSAqPSB3aWR0aDtcbiAgICBjb25zdCBkeDAgPSB4MSAtIHgwO1xuICAgIGNvbnN0IGR5MCA9IHkwIC0geTE7XG4gICAgY29uc3QgZHgxID0geDEgLSB4MjtcbiAgICBjb25zdCBkeTEgPSB5MiAtIHkxO1xuICAgIGNvbnN0IGRvdCA9IGR4MCAqIGR4MSArIGR5MCAqIGR5MTtcbiAgICBjb25zdCBjcm9zcyA9IGR5MCAqIGR4MSAtIGR5MSAqIGR4MDtcbiAgICBjb25zdCBjbG9ja3dpc2UgPSBjcm9zcyA8IDA7XG4gICAgaWYgKE1hdGguYWJzKGNyb3NzKSA8IDFlLTMgKiBNYXRoLmFicyhkb3QpKSB7XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycHggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LCB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCk7XG4gICAgICBpZiAoZG90ID49IDApIHtcbiAgICAgICAgaWYgKHN0eWxlLmpvaW4gPT09IExJTkVfSk9JTi5ST1VORCkge1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEsIHkxLCB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCwgdmVydHMsIGZhbHNlKSArIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgLSBwZXJwMXkgKiBvdXRlcldlaWdodCwgeDEgKyBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgKyBwZXJwMXkgKiBpbm5lcldlaWdodCk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYzEgPSAoLXBlcnB4ICsgeDApICogKC1wZXJweSArIHkxKSAtICgtcGVycHggKyB4MSkgKiAoLXBlcnB5ICsgeTApO1xuICAgIGNvbnN0IGMyID0gKC1wZXJwMXggKyB4MikgKiAoLXBlcnAxeSArIHkxKSAtICgtcGVycDF4ICsgeDEpICogKC1wZXJwMXkgKyB5Mik7XG4gICAgY29uc3QgcHggPSAoZHgwICogYzIgLSBkeDEgKiBjMSkgLyBjcm9zcztcbiAgICBjb25zdCBweSA9IChkeTEgKiBjMSAtIGR5MCAqIGMyKSAvIGNyb3NzO1xuICAgIGNvbnN0IHBkaXN0ID0gKHB4IC0geDEpICogKHB4IC0geDEpICsgKHB5IC0geTEpICogKHB5IC0geTEpO1xuICAgIGNvbnN0IGlteCA9IHgxICsgKHB4IC0geDEpICogaW5uZXJXZWlnaHQ7XG4gICAgY29uc3QgaW15ID0geTEgKyAocHkgLSB5MSkgKiBpbm5lcldlaWdodDtcbiAgICBjb25zdCBvbXggPSB4MSAtIChweCAtIHgxKSAqIG91dGVyV2VpZ2h0O1xuICAgIGNvbnN0IG9teSA9IHkxIC0gKHB5IC0geTEpICogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgc21hbGxlckluc2lkZVNlZ21lbnRTcSA9IE1hdGgubWluKGR4MCAqIGR4MCArIGR5MCAqIGR5MCwgZHgxICogZHgxICsgZHkxICogZHkxKTtcbiAgICBjb25zdCBpbnNpZGVXZWlnaHQgPSBjbG9ja3dpc2UgPyBpbm5lcldlaWdodCA6IG91dGVyV2VpZ2h0O1xuICAgIGNvbnN0IHNtYWxsZXJJbnNpZGVEaWFnb25hbFNxID0gc21hbGxlckluc2lkZVNlZ21lbnRTcSArIGluc2lkZVdlaWdodCAqIGluc2lkZVdlaWdodCAqIHdpZHRoU3F1YXJlZDtcbiAgICBjb25zdCBpbnNpZGVNaXRlck9rID0gcGRpc3QgPD0gc21hbGxlckluc2lkZURpYWdvbmFsU3E7XG4gICAgbGV0IGpvaW4gPSBzdHlsZS5qb2luO1xuICAgIGlmIChqb2luID09PSBMSU5FX0pPSU4uTUlURVIgJiYgcGRpc3QgLyB3aWR0aFNxdWFyZWQgPiBtaXRlckxpbWl0U3F1YXJlZCkge1xuICAgICAgam9pbiA9IExJTkVfSk9JTi5CRVZFTDtcbiAgICB9XG4gICAgaWYgKGluc2lkZU1pdGVyT2spIHtcbiAgICAgIHN3aXRjaCAoam9pbikge1xuICAgICAgICBjYXNlIExJTkVfSk9JTi5NSVRFUjoge1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIG9teCwgb215KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExJTkVfSk9JTi5CRVZFTDoge1xuICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LCBpbXgsIGlteSwgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIG9teCwgb215LCB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LCBvbXgsIG9teSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExJTkVfSk9JTi5ST1VORDoge1xuICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEsIHkxLCB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCwgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCwgdmVydHMsIHRydWUpICsgNDtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycHggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LCBvbXgsIG9teSk7XG4gICAgICAgICAgICBpbmRleENvdW50ICs9IHJvdW5kKHgxLCB5MSwgeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsIHZlcnRzLCBmYWxzZSkgKyA0O1xuICAgICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LCBvbXgsIG9teSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgIHN3aXRjaCAoam9pbikge1xuICAgICAgICBjYXNlIExJTkVfSk9JTi5NSVRFUjoge1xuICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXksIG9teCwgb215KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVydHMucHVzaChpbXgsIGlteSwgaW14LCBpbXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBMSU5FX0pPSU4uUk9VTkQ6IHtcbiAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICBpbmRleENvdW50ICs9IHJvdW5kKHgxLCB5MSwgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQsIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsIHZlcnRzLCB0cnVlKSArIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEsIHkxLCB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCwgdmVydHMsIGZhbHNlKSArIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgIH1cbiAgfVxuICB4MCA9IHBvaW50c1sobGVuZ3RoIC0gMikgKiAyXTtcbiAgeTAgPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMiArIDFdO1xuICB4MSA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyXTtcbiAgeTEgPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMiArIDFdO1xuICBwZXJweCA9IC0oeTAgLSB5MSk7XG4gIHBlcnB5ID0geDAgLSB4MTtcbiAgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gIHBlcnB4IC89IGRpc3Q7XG4gIHBlcnB5IC89IGRpc3Q7XG4gIHBlcnB4ICo9IHdpZHRoO1xuICBwZXJweSAqPSB3aWR0aDtcbiAgdmVydHMucHVzaCh4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQpO1xuICBpZiAoIWNsb3NlZFNoYXBlKSB7XG4gICAgaWYgKHN0eWxlLmNhcCA9PT0gTElORV9DQVAuUk9VTkQpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEgLSBwZXJweCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeTEgLSBwZXJweSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LCB2ZXJ0cywgZmFsc2UpICsgMjtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLmNhcCA9PT0gTElORV9DQVAuU1FVQVJFKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MSwgeTEsIHBlcnB4LCBwZXJweSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBmYWxzZSwgdmVydHMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICBjb25zdCBlcHMyID0gY3VydmVzLmVwc2lsb24gKiBjdXJ2ZXMuZXBzaWxvbjtcbiAgZm9yIChsZXQgaSA9IGluZGV4U3RhcnQ7IGkgPCBpbmRleENvdW50ICsgaW5kZXhTdGFydCAtIDI7ICsraSkge1xuICAgIHgwID0gdmVydHNbaSAqIDJdO1xuICAgIHkwID0gdmVydHNbaSAqIDIgKyAxXTtcbiAgICB4MSA9IHZlcnRzWyhpICsgMSkgKiAyXTtcbiAgICB5MSA9IHZlcnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgeDIgPSB2ZXJ0c1soaSArIDIpICogMl07XG4gICAgeTIgPSB2ZXJ0c1soaSArIDIpICogMiArIDFdO1xuICAgIGlmIChNYXRoLmFicyh4MCAqICh5MSAtIHkyKSArIHgxICogKHkyIC0geTApICsgeDIgKiAoeTAgLSB5MSkpIDwgZXBzMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChpLCBpICsgMSwgaSArIDIpO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3Qgc2hhcGUgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gIGNvbnN0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMgfHwgc2hhcGUucG9pbnRzO1xuICBjb25zdCBjbG9zZWRTaGFwZSA9IHNoYXBlLnR5cGUgIT09IFNIQVBFUy5QT0xZIHx8IHNoYXBlLmNsb3NlU3Ryb2tlO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gIGNvbnN0IGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICBjb25zdCBzdGFydEluZGV4ID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgbGV0IGN1cnJlbnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdKTtcbiAgICBpbmRpY2VzLnB1c2goY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggKyAxKTtcbiAgICBjdXJyZW50SW5kZXgrKztcbiAgfVxuICBpZiAoY2xvc2VkU2hhcGUpIHtcbiAgICBpbmRpY2VzLnB1c2goY3VycmVudEluZGV4LCBzdGFydEluZGV4KTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVTdHlsZS5uYXRpdmUpIHtcbiAgICBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBidWlsZE5vbk5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZExpbmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkTGluZS5tanMubWFwXG4iLCJpbXBvcnQgeyBjdXJ2ZXMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5jbGFzcyBRdWFkcmF0aWNVdGlscyB7XG4gIHN0YXRpYyBjdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgIGNvbnN0IGF4ID0gZnJvbVggLSAyICogY3BYICsgdG9YO1xuICAgIGNvbnN0IGF5ID0gZnJvbVkgLSAyICogY3BZICsgdG9ZO1xuICAgIGNvbnN0IGJ4ID0gMiAqIGNwWCAtIDIgKiBmcm9tWDtcbiAgICBjb25zdCBieSA9IDIgKiBjcFkgLSAyICogZnJvbVk7XG4gICAgY29uc3QgYSA9IDQgKiAoYXggKiBheCArIGF5ICogYXkpO1xuICAgIGNvbnN0IGIgPSA0ICogKGF4ICogYnggKyBheSAqIGJ5KTtcbiAgICBjb25zdCBjID0gYnggKiBieCArIGJ5ICogYnk7XG4gICAgY29uc3QgcyA9IDIgKiBNYXRoLnNxcnQoYSArIGIgKyBjKTtcbiAgICBjb25zdCBhMiA9IE1hdGguc3FydChhKTtcbiAgICBjb25zdCBhMzIgPSAyICogYSAqIGEyO1xuICAgIGNvbnN0IGMyID0gMiAqIE1hdGguc3FydChjKTtcbiAgICBjb25zdCBiYSA9IGIgLyBhMjtcbiAgICByZXR1cm4gKGEzMiAqIHMgKyBhMiAqIGIgKiAocyAtIGMyKSArICg0ICogYyAqIGEgLSBiICogYikgKiBNYXRoLmxvZygoMiAqIGEyICsgYmEgKyBzKSAvIChiYSArIGMyKSkpIC8gKDQgKiBhMzIpO1xuICB9XG4gIHN0YXRpYyBjdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSwgcG9pbnRzKSB7XG4gICAgY29uc3QgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBuID0gY3VydmVzLl9zZWdtZW50c0NvdW50KFF1YWRyYXRpY1V0aWxzLmN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKSk7XG4gICAgbGV0IHhhID0gMDtcbiAgICBsZXQgeWEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG47ICsraSkge1xuICAgICAgY29uc3QgaiA9IGkgLyBuO1xuICAgICAgeGEgPSBmcm9tWCArIChjcFggLSBmcm9tWCkgKiBqO1xuICAgICAgeWEgPSBmcm9tWSArIChjcFkgLSBmcm9tWSkgKiBqO1xuICAgICAgcG9pbnRzLnB1c2goeGEgKyAoY3BYICsgKHRvWCAtIGNwWCkgKiBqIC0geGEpICogaiwgeWEgKyAoY3BZICsgKHRvWSAtIGNwWSkgKiBqIC0geWEpICogaik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFF1YWRyYXRpY1V0aWxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkcmF0aWNVdGlscy5tanMubWFwXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IGJ1aWxkQ2lyY2xlIH0gZnJvbSAnLi9idWlsZENpcmNsZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tICcuL2J1aWxkQ2lyY2xlLm1qcyc7XG5pbXBvcnQgeyBidWlsZFBvbHkgfSBmcm9tICcuL2J1aWxkUG9seS5tanMnO1xuZXhwb3J0IHsgYnVpbGRQb2x5IH0gZnJvbSAnLi9idWlsZFBvbHkubWpzJztcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSAnLi9idWlsZFJlY3RhbmdsZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRSZWN0YW5nbGUgfSBmcm9tICcuL2J1aWxkUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBidWlsZFJvdW5kZWRSZWN0YW5nbGUgfSBmcm9tICcuL2J1aWxkUm91bmRlZFJlY3RhbmdsZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi9idWlsZFJvdW5kZWRSZWN0YW5nbGUubWpzJztcbmV4cG9ydCB7IEFyY1V0aWxzIH0gZnJvbSAnLi9BcmNVdGlscy5tanMnO1xuZXhwb3J0IHsgQmF0Y2hQYXJ0IH0gZnJvbSAnLi9CYXRjaFBhcnQubWpzJztcbmV4cG9ydCB7IEJlemllclV0aWxzIH0gZnJvbSAnLi9CZXppZXJVdGlscy5tanMnO1xuZXhwb3J0IHsgYnVpbGRMaW5lIH0gZnJvbSAnLi9idWlsZExpbmUubWpzJztcbmV4cG9ydCB7IFF1YWRyYXRpY1V0aWxzIH0gZnJvbSAnLi9RdWFkcmF0aWNVdGlscy5tanMnO1xuXG5jb25zdCBGSUxMX0NPTU1BTkRTID0ge1xuICBbU0hBUEVTLlBPTFldOiBidWlsZFBvbHksXG4gIFtTSEFQRVMuQ0lSQ106IGJ1aWxkQ2lyY2xlLFxuICBbU0hBUEVTLkVMSVBdOiBidWlsZENpcmNsZSxcbiAgW1NIQVBFUy5SRUNUXTogYnVpbGRSZWN0YW5nbGUsXG4gIFtTSEFQRVMuUlJFQ106IGJ1aWxkUm91bmRlZFJlY3RhbmdsZVxufTtcbmNvbnN0IEJBVENIX1BPT0wgPSBbXTtcbmNvbnN0IERSQVdfQ0FMTF9QT09MID0gW107XG5cbmV4cG9ydCB7IEJBVENIX1BPT0wsIERSQVdfQ0FMTF9QT09MLCBGSUxMX0NPTU1BTkRTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjbGFzcyBHcmFwaGljc0RhdGEge1xuICBjb25zdHJ1Y3RvcihzaGFwZSwgZmlsbFN0eWxlID0gbnVsbCwgbGluZVN0eWxlID0gbnVsbCwgbWF0cml4ID0gbnVsbCkge1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5ob2xlcyA9IFtdO1xuICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICB0aGlzLmxpbmVTdHlsZSA9IGxpbmVTdHlsZTtcbiAgICB0aGlzLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB0aGlzLnR5cGUgPSBzaGFwZS50eXBlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKHRoaXMuc2hhcGUsIHRoaXMuZmlsbFN0eWxlLCB0aGlzLmxpbmVTdHlsZSwgdGhpcy5tYXRyaXgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zaGFwZSA9IG51bGw7XG4gICAgdGhpcy5ob2xlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaG9sZXMgPSBudWxsO1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wb2ludHMgPSBudWxsO1xuICAgIHRoaXMubGluZVN0eWxlID0gbnVsbDtcbiAgICB0aGlzLmZpbGxTdHlsZSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgR3JhcGhpY3NEYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc0RhdGEubWpzLm1hcFxuIiwiY2xhc3MgQmF0Y2hQYXJ0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIGJlZ2luKHN0eWxlLCBzdGFydEluZGV4LCBhdHRyaWJTdGFydCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0SW5kZXg7XG4gICAgdGhpcy5hdHRyaWJTdGFydCA9IGF0dHJpYlN0YXJ0O1xuICB9XG4gIGVuZChlbmRJbmRleCwgZW5kQXR0cmliKSB7XG4gICAgdGhpcy5hdHRyaWJTaXplID0gZW5kQXR0cmliIC0gdGhpcy5hdHRyaWJTdGFydDtcbiAgICB0aGlzLnNpemUgPSBlbmRJbmRleCAtIHRoaXMuc3RhcnQ7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmF0dHJpYlN0YXJ0ID0gMDtcbiAgICB0aGlzLmF0dHJpYlNpemUgPSAwO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoUGFydCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hQYXJ0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50LCBCYXRjaEdlb21ldHJ5LCBXUkFQX01PREVTLCBCYXNlVGV4dHVyZSwgQmF0Y2hEcmF3Q2FsbCwgQmF0Y2hUZXh0dXJlQXJyYXksIERSQVdfTU9ERVMsIENvbG9yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICdAcGl4aS9kaXNwbGF5JztcbmltcG9ydCB7IEdyYXBoaWNzRGF0YSB9IGZyb20gJy4vR3JhcGhpY3NEYXRhLm1qcyc7XG5pbXBvcnQgeyBEUkFXX0NBTExfUE9PTCwgQkFUQ0hfUE9PTCwgRklMTF9DT01NQU5EUyB9IGZyb20gJy4vdXRpbHMvaW5kZXgubWpzJztcbmltcG9ydCB7IEJhdGNoUGFydCB9IGZyb20gJy4vdXRpbHMvQmF0Y2hQYXJ0Lm1qcyc7XG5pbXBvcnQgeyBidWlsZFBvbHkgfSBmcm9tICcuL3V0aWxzL2J1aWxkUG9seS5tanMnO1xuaW1wb3J0IHsgYnVpbGRMaW5lIH0gZnJvbSAnLi91dGlscy9idWlsZExpbmUubWpzJztcblxuY29uc3QgdG1wUG9pbnQgPSBuZXcgUG9pbnQoKTtcbmNvbnN0IF9HcmFwaGljc0dlb21ldHJ5ID0gY2xhc3MgZXh0ZW5kcyBCYXRjaEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNsb3NlUG9pbnRFcHMgPSAxZS00O1xuICAgIHRoaXMuYm91bmRzUGFkZGluZyA9IDA7XG4gICAgdGhpcy51dnNGbG9hdDMyID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXNVaW50MTYgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgIHRoaXMudXZzID0gW107XG4gICAgdGhpcy5pbmRpY2VzID0gW107XG4gICAgdGhpcy50ZXh0dXJlSWRzID0gW107XG4gICAgdGhpcy5ncmFwaGljc0RhdGEgPSBbXTtcbiAgICB0aGlzLmRyYXdDYWxscyA9IFtdO1xuICAgIHRoaXMuYmF0Y2hEaXJ0eSA9IC0xO1xuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgIHRoaXMuZGlydHkgPSAwO1xuICAgIHRoaXMuY2FjaGVEaXJ0eSA9IC0xO1xuICAgIHRoaXMuY2xlYXJEaXJ0eSA9IDA7XG4gICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xO1xuICB9XG4gIGdldCBib3VuZHMoKSB7XG4gICAgdGhpcy51cGRhdGVCYXRjaGVzKCk7XG4gICAgaWYgKHRoaXMuYm91bmRzRGlydHkgIT09IHRoaXMuZGlydHkpIHtcbiAgICAgIHRoaXMuYm91bmRzRGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuYm91bmRzRGlydHkgPSAtMTtcbiAgICB0aGlzLmRpcnR5Kys7XG4gICAgdGhpcy5iYXRjaERpcnR5Kys7XG4gICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29sb3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRleHR1cmVJZHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRyYXdDYWxsc1tpXS50ZXhBcnJheS5jbGVhcigpO1xuICAgICAgRFJBV19DQUxMX1BPT0wucHVzaCh0aGlzLmRyYXdDYWxsc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoUGFydCA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoUGFydC5yZXNldCgpO1xuICAgICAgQkFUQ0hfUE9PTC5wdXNoKGJhdGNoUGFydCk7XG4gICAgfVxuICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHRoaXMuY2xlYXJEaXJ0eSsrO1xuICAgICAgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZHJhd1NoYXBlKHNoYXBlLCBmaWxsU3R5bGUgPSBudWxsLCBsaW5lU3R5bGUgPSBudWxsLCBtYXRyaXggPSBudWxsKSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBHcmFwaGljc0RhdGEoc2hhcGUsIGZpbGxTdHlsZSwgbGluZVN0eWxlLCBtYXRyaXgpO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2goZGF0YSk7XG4gICAgdGhpcy5kaXJ0eSsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRyYXdIb2xlKHNoYXBlLCBtYXRyaXggPSBudWxsKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gbmV3IEdyYXBoaWNzRGF0YShzaGFwZSwgbnVsbCwgbnVsbCwgbWF0cml4KTtcbiAgICBjb25zdCBsYXN0U2hhcGUgPSB0aGlzLmdyYXBoaWNzRGF0YVt0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcbiAgICBkYXRhLmxpbmVTdHlsZSA9IGxhc3RTaGFwZS5saW5lU3R5bGU7XG4gICAgbGFzdFNoYXBlLmhvbGVzLnB1c2goZGF0YSk7XG4gICAgdGhpcy5kaXJ0eSsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnBvaW50cyA9IG51bGw7XG4gICAgdGhpcy5jb2xvcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNvbG9ycyA9IG51bGw7XG4gICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnV2cyA9IG51bGw7XG4gICAgdGhpcy5pbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPSAwO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gbnVsbDtcbiAgICB0aGlzLmRyYXdDYWxscy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZHJhd0NhbGxzID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmJhdGNoZXMgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIH1cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIGNvbnN0IGdyYXBoaWNzRGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBkYXRhID0gZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgaWYgKCFkYXRhLmZpbGxTdHlsZS52aXNpYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2hhcGUpIHtcbiAgICAgICAgaWYgKGRhdGEubWF0cml4KSB7XG4gICAgICAgICAgZGF0YS5tYXRyaXguYXBwbHlJbnZlcnNlKHBvaW50LCB0bXBQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wUG9pbnQuY29weUZyb20ocG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNoYXBlLmNvbnRhaW5zKHRtcFBvaW50LngsIHRtcFBvaW50LnkpKSB7XG4gICAgICAgICAgbGV0IGhpdEhvbGUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZGF0YS5ob2xlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGRhdGEuaG9sZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhvbGUgPSBkYXRhLmhvbGVzW2kyXTtcbiAgICAgICAgICAgICAgaWYgKGhvbGUuc2hhcGUuY29udGFpbnModG1wUG9pbnQueCwgdG1wUG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICBoaXRIb2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWhpdEhvbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlQmF0Y2hlcygpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5iYXRjaGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVCYXRjaGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2FjaGVEaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgY29uc3QgdXZzID0gdGhpcy51dnM7XG4gICAgY29uc3QgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XG4gICAgbGV0IGJhdGNoUGFydCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRTdHlsZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuYmF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBiYXRjaFBhcnQgPSB0aGlzLmJhdGNoZXNbdGhpcy5iYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgY3VycmVudFN0eWxlID0gYmF0Y2hQYXJ0LnN0eWxlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGhpcy5zaGFwZUluZGV4OyBpIDwgZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnNoYXBlSW5kZXgrKztcbiAgICAgIGNvbnN0IGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG4gICAgICBjb25zdCBmaWxsU3R5bGUgPSBkYXRhLmZpbGxTdHlsZTtcbiAgICAgIGNvbnN0IGxpbmVTdHlsZSA9IGRhdGEubGluZVN0eWxlO1xuICAgICAgY29uc3QgY29tbWFuZCA9IEZJTExfQ09NTUFORFNbZGF0YS50eXBlXTtcbiAgICAgIGNvbW1hbmQuYnVpbGQoZGF0YSk7XG4gICAgICBpZiAoZGF0YS5tYXRyaXgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludHMoZGF0YS5wb2ludHMsIGRhdGEubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3R5bGUudmlzaWJsZSB8fCBsaW5lU3R5bGUudmlzaWJsZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NIb2xlcyhkYXRhLmhvbGVzKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gaiA9PT0gMCA/IGZpbGxTdHlsZSA6IGxpbmVTdHlsZTtcbiAgICAgICAgaWYgKCFzdHlsZS52aXNpYmxlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXh0VGV4dHVyZSA9IHN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIGNvbnN0IGluZGV4MiA9IHRoaXMuaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGF0dHJpYkluZGV4ID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgbmV4dFRleHR1cmUud3JhcE1vZGUgPSBXUkFQX01PREVTLlJFUEVBVDtcbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NGaWxsKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc0xpbmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDIgLSBhdHRyaWJJbmRleDtcbiAgICAgICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChiYXRjaFBhcnQgJiYgIXRoaXMuX2NvbXBhcmVTdHlsZXMoY3VycmVudFN0eWxlLCBzdHlsZSkpIHtcbiAgICAgICAgICBiYXRjaFBhcnQuZW5kKGluZGV4MiwgYXR0cmliSW5kZXgpO1xuICAgICAgICAgIGJhdGNoUGFydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiYXRjaFBhcnQpIHtcbiAgICAgICAgICBiYXRjaFBhcnQgPSBCQVRDSF9QT09MLnBvcCgpIHx8IG5ldyBCYXRjaFBhcnQoKTtcbiAgICAgICAgICBiYXRjaFBhcnQuYmVnaW4oc3R5bGUsIGluZGV4MiwgYXR0cmliSW5kZXgpO1xuICAgICAgICAgIHRoaXMuYmF0Y2hlcy5wdXNoKGJhdGNoUGFydCk7XG4gICAgICAgICAgY3VycmVudFN0eWxlID0gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRVdnModGhpcy5wb2ludHMsIHV2cywgc3R5bGUudGV4dHVyZSwgYXR0cmliSW5kZXgsIHNpemUsIHN0eWxlLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBhdHRyaWIgPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xuICAgIGlmIChiYXRjaFBhcnQpIHtcbiAgICAgIGJhdGNoUGFydC5lbmQoaW5kZXgsIGF0dHJpYik7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmJhdGNoYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWQzMiA9IGF0dHJpYiA+IDY1NTM1O1xuICAgIGlmICh0aGlzLmluZGljZXNVaW50MTYgJiYgdGhpcy5pbmRpY2VzLmxlbmd0aCA9PT0gdGhpcy5pbmRpY2VzVWludDE2Lmxlbmd0aCAmJiBuZWVkMzIgPT09IHRoaXMuaW5kaWNlc1VpbnQxNi5CWVRFU19QRVJfRUxFTUVOVCA+IDIpIHtcbiAgICAgIHRoaXMuaW5kaWNlc1VpbnQxNi5zZXQodGhpcy5pbmRpY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbmRpY2VzVWludDE2ID0gbmVlZDMyID8gbmV3IFVpbnQzMkFycmF5KHRoaXMuaW5kaWNlcykgOiBuZXcgVWludDE2QXJyYXkodGhpcy5pbmRpY2VzKTtcbiAgICB9XG4gICAgdGhpcy5iYXRjaGFibGUgPSB0aGlzLmlzQmF0Y2hhYmxlKCk7XG4gICAgaWYgKHRoaXMuYmF0Y2hhYmxlKSB7XG4gICAgICB0aGlzLnBhY2tCYXRjaGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnVpbGREcmF3Q2FsbHMoKTtcbiAgICB9XG4gIH1cbiAgX2NvbXBhcmVTdHlsZXMoc3R5bGVBLCBzdHlsZUIpIHtcbiAgICBpZiAoIXN0eWxlQSB8fCAhc3R5bGVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHlsZUEudGV4dHVyZS5iYXNlVGV4dHVyZSAhPT0gc3R5bGVCLnRleHR1cmUuYmFzZVRleHR1cmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlQS5jb2xvciArIHN0eWxlQS5hbHBoYSAhPT0gc3R5bGVCLmNvbG9yICsgc3R5bGVCLmFscGhhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghIXN0eWxlQS5uYXRpdmUgIT09ICEhc3R5bGVCLm5hdGl2ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YWxpZGF0ZUJhdGNoaW5nKCkge1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSB0aGlzLmNhY2hlRGlydHkgfHwgIXRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgY29uc3QgZmlsbCA9IGRhdGEuZmlsbFN0eWxlO1xuICAgICAgY29uc3QgbGluZSA9IGRhdGEubGluZVN0eWxlO1xuICAgICAgaWYgKGZpbGwgJiYgIWZpbGwudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGxpbmUgJiYgIWxpbmUudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBwYWNrQmF0Y2hlcygpIHtcbiAgICB0aGlzLmJhdGNoRGlydHkrKztcbiAgICB0aGlzLnV2c0Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXZzKTtcbiAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5iYXRjaGVzO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYmF0Y2hlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmF0Y2guc2l6ZTsgaisrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYmF0Y2guc3RhcnQgKyBqO1xuICAgICAgICB0aGlzLmluZGljZXNVaW50MTZbaW5kZXhdID0gdGhpcy5pbmRpY2VzVWludDE2W2luZGV4XSAtIGJhdGNoLmF0dHJpYlN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0JhdGNoYWJsZSgpIHtcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID4gNjU1MzUgKiAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLmJhdGNoZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYmF0Y2hlc1tpXS5zdHlsZS5uYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb2ludHMubGVuZ3RoIDwgX0dyYXBoaWNzR2VvbWV0cnkuQkFUQ0hBQkxFX1NJWkUgKiAyO1xuICB9XG4gIGJ1aWxkRHJhd0NhbGxzKCkge1xuICAgIGxldCBUSUNLID0gKytCYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRyYXdDYWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5kcmF3Q2FsbHNbaV0udGV4QXJyYXkuY2xlYXIoKTtcbiAgICAgIERSQVdfQ0FMTF9QT09MLnB1c2godGhpcy5kcmF3Q2FsbHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLmRyYXdDYWxscy5sZW5ndGggPSAwO1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgIGNvbnN0IHRleHR1cmVJZHMgPSB0aGlzLnRleHR1cmVJZHM7XG4gICAgbGV0IGN1cnJlbnRHcm91cCA9IERSQVdfQ0FMTF9QT09MLnBvcCgpO1xuICAgIGlmICghY3VycmVudEdyb3VwKSB7XG4gICAgICBjdXJyZW50R3JvdXAgPSBuZXcgQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgY3VycmVudEdyb3VwLnRleEFycmF5ID0gbmV3IEJhdGNoVGV4dHVyZUFycmF5KCk7XG4gICAgfVxuICAgIGN1cnJlbnRHcm91cC50ZXhBcnJheS5jb3VudCA9IDA7XG4gICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gMDtcbiAgICBjdXJyZW50R3JvdXAuc2l6ZSA9IDA7XG4gICAgY3VycmVudEdyb3VwLnR5cGUgPSBEUkFXX01PREVTLlRSSUFOR0xFUztcbiAgICBsZXQgdGV4dHVyZUNvdW50ID0gMDtcbiAgICBsZXQgY3VycmVudFRleHR1cmUgPSBudWxsO1xuICAgIGxldCB0ZXh0dXJlSWQgPSAwO1xuICAgIGxldCBuYXRpdmUgPSBmYWxzZTtcbiAgICBsZXQgZHJhd01vZGUgPSBEUkFXX01PREVTLlRSSUFOR0xFUztcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgIGNvbnN0IG1heFRleHR1cmVzID0gODtcbiAgICAgIGNvbnN0IHN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICAgIGNvbnN0IG5leHRUZXh0dXJlID0gc3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgIGlmIChuYXRpdmUgIT09ICEhc3R5bGUubmF0aXZlKSB7XG4gICAgICAgIG5hdGl2ZSA9ICEhc3R5bGUubmF0aXZlO1xuICAgICAgICBkcmF3TW9kZSA9IG5hdGl2ZSA/IERSQVdfTU9ERVMuTElORVMgOiBEUkFXX01PREVTLlRSSUFOR0xFUztcbiAgICAgICAgY3VycmVudFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0ZXh0dXJlQ291bnQgPSBtYXhUZXh0dXJlcztcbiAgICAgICAgVElDSysrO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSkge1xuICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG5leHRUZXh0dXJlO1xuICAgICAgICBpZiAobmV4dFRleHR1cmUuX2JhdGNoRW5hYmxlZCAhPT0gVElDSykge1xuICAgICAgICAgIGlmICh0ZXh0dXJlQ291bnQgPT09IG1heFRleHR1cmVzKSB7XG4gICAgICAgICAgICBUSUNLKys7XG4gICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cC5zaXplID4gMCkge1xuICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBEUkFXX0NBTExfUE9PTC5wb3AoKTtcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBuZXcgQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXhBcnJheSA9IG5ldyBCYXRjaFRleHR1cmVBcnJheSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSAwO1xuICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleEFycmF5LmNvdW50ID0gMDtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC50eXBlID0gZHJhd01vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRUZXh0dXJlLnRvdWNoZWQgPSAxO1xuICAgICAgICAgIG5leHRUZXh0dXJlLl9iYXRjaEVuYWJsZWQgPSBUSUNLO1xuICAgICAgICAgIG5leHRUZXh0dXJlLl9iYXRjaExvY2F0aW9uID0gdGV4dHVyZUNvdW50O1xuICAgICAgICAgIG5leHRUZXh0dXJlLndyYXBNb2RlID0gV1JBUF9NT0RFUy5SRVBFQVQ7XG4gICAgICAgICAgY3VycmVudEdyb3VwLnRleEFycmF5LmVsZW1lbnRzW2N1cnJlbnRHcm91cC50ZXhBcnJheS5jb3VudCsrXSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgIHRleHR1cmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50R3JvdXAuc2l6ZSArPSBkYXRhLnNpemU7XG4gICAgICBpbmRleCArPSBkYXRhLnNpemU7XG4gICAgICB0ZXh0dXJlSWQgPSBuZXh0VGV4dHVyZS5fYmF0Y2hMb2NhdGlvbjtcbiAgICAgIHRoaXMuYWRkQ29sb3JzKGNvbG9ycywgc3R5bGUuY29sb3IsIHN0eWxlLmFscGhhLCBkYXRhLmF0dHJpYlNpemUsIGRhdGEuYXR0cmliU3RhcnQpO1xuICAgICAgdGhpcy5hZGRUZXh0dXJlSWRzKHRleHR1cmVJZHMsIHRleHR1cmVJZCwgZGF0YS5hdHRyaWJTaXplLCBkYXRhLmF0dHJpYlN0YXJ0KTtcbiAgICB9XG4gICAgQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gVElDSztcbiAgICB0aGlzLnBhY2tBdHRyaWJ1dGVzKCk7XG4gIH1cbiAgcGFja0F0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgdmVydHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCB1dnMgPSB0aGlzLnV2cztcbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICBjb25zdCB0ZXh0dXJlSWRzID0gdGhpcy50ZXh0dXJlSWRzO1xuICAgIGNvbnN0IGdsUG9pbnRzID0gbmV3IEFycmF5QnVmZmVyKHZlcnRzLmxlbmd0aCAqIDMgKiA0KTtcbiAgICBjb25zdCBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KGdsUG9pbnRzKTtcbiAgICBjb25zdCB1MzIgPSBuZXcgVWludDMyQXJyYXkoZ2xQb2ludHMpO1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgZjMyW3ArK10gPSB2ZXJ0c1tpICogMl07XG4gICAgICBmMzJbcCsrXSA9IHZlcnRzW2kgKiAyICsgMV07XG4gICAgICBmMzJbcCsrXSA9IHV2c1tpICogMl07XG4gICAgICBmMzJbcCsrXSA9IHV2c1tpICogMiArIDFdO1xuICAgICAgdTMyW3ArK10gPSBjb2xvcnNbaV07XG4gICAgICBmMzJbcCsrXSA9IHRleHR1cmVJZHNbaV07XG4gICAgfVxuICAgIHRoaXMuX2J1ZmZlci51cGRhdGUoZ2xQb2ludHMpO1xuICAgIHRoaXMuX2luZGV4QnVmZmVyLnVwZGF0ZSh0aGlzLmluZGljZXNVaW50MTYpO1xuICB9XG4gIHByb2Nlc3NGaWxsKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5ob2xlcy5sZW5ndGgpIHtcbiAgICAgIGJ1aWxkUG9seS50cmlhbmd1bGF0ZShkYXRhLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tbWFuZCA9IEZJTExfQ09NTUFORFNbZGF0YS50eXBlXTtcbiAgICAgIGNvbW1hbmQudHJpYW5ndWxhdGUoZGF0YSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NMaW5lKGRhdGEpIHtcbiAgICBidWlsZExpbmUoZGF0YSwgdGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWlsZExpbmUoZGF0YS5ob2xlc1tpXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NIb2xlcyhob2xlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGhvbGUgPSBob2xlc1tpXTtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBGSUxMX0NPTU1BTkRTW2hvbGUudHlwZV07XG4gICAgICBjb21tYW5kLmJ1aWxkKGhvbGUpO1xuICAgICAgaWYgKGhvbGUubWF0cml4KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUG9pbnRzKGhvbGUucG9pbnRzLCBob2xlLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCk7XG4gICAgYm91bmRzLmFkZFZlcnRleERhdGEodGhpcy5wb2ludHMsIDAsIHRoaXMucG9pbnRzLmxlbmd0aCk7XG4gICAgYm91bmRzLnBhZCh0aGlzLmJvdW5kc1BhZGRpbmcsIHRoaXMuYm91bmRzUGFkZGluZyk7XG4gIH1cbiAgdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgbWF0cml4KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIGNvbnN0IHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIHBvaW50c1tpICogMl0gPSBtYXRyaXguYSAqIHggKyBtYXRyaXguYyAqIHkgKyBtYXRyaXgudHg7XG4gICAgICBwb2ludHNbaSAqIDIgKyAxXSA9IG1hdHJpeC5iICogeCArIG1hdHJpeC5kICogeSArIG1hdHJpeC50eTtcbiAgICB9XG4gIH1cbiAgYWRkQ29sb3JzKGNvbG9ycywgY29sb3IsIGFscGhhLCBzaXplLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgYmdyID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbG9yKS50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShiZ3IpLnRvUHJlbXVsdGlwbGllZChhbHBoYSk7XG4gICAgY29sb3JzLmxlbmd0aCA9IE1hdGgubWF4KGNvbG9ycy5sZW5ndGgsIG9mZnNldCArIHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBjb2xvcnNbb2Zmc2V0ICsgaV0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG4gIGFkZFRleHR1cmVJZHModGV4dHVyZUlkcywgaWQsIHNpemUsIG9mZnNldCA9IDApIHtcbiAgICB0ZXh0dXJlSWRzLmxlbmd0aCA9IE1hdGgubWF4KHRleHR1cmVJZHMubGVuZ3RoLCBvZmZzZXQgKyBzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdGV4dHVyZUlkc1tvZmZzZXQgKyBpXSA9IGlkO1xuICAgIH1cbiAgfVxuICBhZGRVdnModmVydHMsIHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHV2c1N0YXJ0ID0gdXZzLmxlbmd0aDtcbiAgICBjb25zdCBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgICAgbGV0IHggPSB2ZXJ0c1soc3RhcnQgKyBpbmRleCkgKiAyXTtcbiAgICAgIGxldCB5ID0gdmVydHNbKHN0YXJ0ICsgaW5kZXgpICogMiArIDFdO1xuICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICBjb25zdCBueCA9IG1hdHJpeC5hICogeCArIG1hdHJpeC5jICogeSArIG1hdHJpeC50eDtcbiAgICAgICAgeSA9IG1hdHJpeC5iICogeCArIG1hdHJpeC5kICogeSArIG1hdHJpeC50eTtcbiAgICAgICAgeCA9IG54O1xuICAgICAgfVxuICAgICAgaW5kZXgrKztcbiAgICAgIHV2cy5wdXNoKHggLyBmcmFtZS53aWR0aCwgeSAvIGZyYW1lLmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBpZiAoZnJhbWUud2lkdGggPCBiYXNlVGV4dHVyZS53aWR0aCB8fCBmcmFtZS5oZWlnaHQgPCBiYXNlVGV4dHVyZS5oZWlnaHQpIHtcbiAgICAgIHRoaXMuYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgdXZzU3RhcnQsIHNpemUpO1xuICAgIH1cbiAgfVxuICBhZGp1c3RVdnModXZzLCB0ZXh0dXJlLCBzdGFydCwgc2l6ZSkge1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBjb25zdCBlcHMgPSAxZS02O1xuICAgIGNvbnN0IGZpbmlzaCA9IHN0YXJ0ICsgc2l6ZSAqIDI7XG4gICAgY29uc3QgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuICAgIGNvbnN0IHNjYWxlWCA9IGZyYW1lLndpZHRoIC8gYmFzZVRleHR1cmUud2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gZnJhbWUuaGVpZ2h0IC8gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgIGxldCBvZmZzZXRYID0gZnJhbWUueCAvIGZyYW1lLndpZHRoO1xuICAgIGxldCBvZmZzZXRZID0gZnJhbWUueSAvIGZyYW1lLmhlaWdodDtcbiAgICBsZXQgbWluWCA9IE1hdGguZmxvb3IodXZzW3N0YXJ0XSArIGVwcyk7XG4gICAgbGV0IG1pblkgPSBNYXRoLmZsb29yKHV2c1tzdGFydCArIDFdICsgZXBzKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAyOyBpIDwgZmluaXNoOyBpICs9IDIpIHtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBNYXRoLmZsb29yKHV2c1tpXSArIGVwcykpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIE1hdGguZmxvb3IodXZzW2kgKyAxXSArIGVwcykpO1xuICAgIH1cbiAgICBvZmZzZXRYIC09IG1pblg7XG4gICAgb2Zmc2V0WSAtPSBtaW5ZO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGZpbmlzaDsgaSArPSAyKSB7XG4gICAgICB1dnNbaV0gPSAodXZzW2ldICsgb2Zmc2V0WCkgKiBzY2FsZVg7XG4gICAgICB1dnNbaSArIDFdID0gKHV2c1tpICsgMV0gKyBvZmZzZXRZKSAqIHNjYWxlWTtcbiAgICB9XG4gIH1cbn07XG5sZXQgR3JhcGhpY3NHZW9tZXRyeSA9IF9HcmFwaGljc0dlb21ldHJ5O1xuR3JhcGhpY3NHZW9tZXRyeS5CQVRDSEFCTEVfU0laRSA9IDEwMDtcblxuZXhwb3J0IHsgR3JhcGhpY3NHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NHZW9tZXRyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNsYXNzIEZpbGxTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29sb3IgPSAxNjc3NzIxNTtcbiAgICB0aGlzLmFscGhhID0gMTtcbiAgICB0aGlzLnRleHR1cmUgPSBUZXh0dXJlLldISVRFO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgb2JqID0gbmV3IEZpbGxTdHlsZSgpO1xuICAgIG9iai5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgb2JqLmFscGhhID0gdGhpcy5hbHBoYTtcbiAgICBvYmoudGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICBvYmoubWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgb2JqLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmNvbG9yID0gMTY3NzcyMTU7XG4gICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgdGhpcy50ZXh0dXJlID0gVGV4dHVyZS5XSElURTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBGaWxsU3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGxTdHlsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBMSU5FX0NBUCwgTElORV9KT0lOIH0gZnJvbSAnLi4vY29uc3QubWpzJztcbmltcG9ydCB7IEZpbGxTdHlsZSB9IGZyb20gJy4vRmlsbFN0eWxlLm1qcyc7XG5cbmNsYXNzIExpbmVTdHlsZSBleHRlbmRzIEZpbGxTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5hbGlnbm1lbnQgPSAwLjU7XG4gICAgdGhpcy5uYXRpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNhcCA9IExJTkVfQ0FQLkJVVFQ7XG4gICAgdGhpcy5qb2luID0gTElORV9KT0lOLk1JVEVSO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IDEwO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG9iaiA9IG5ldyBMaW5lU3R5bGUoKTtcbiAgICBvYmouY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIG9iai5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgb2JqLnRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgb2JqLm1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgIG9iai52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgIG9iai53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgb2JqLmFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50O1xuICAgIG9iai5uYXRpdmUgPSB0aGlzLm5hdGl2ZTtcbiAgICBvYmouY2FwID0gdGhpcy5jYXA7XG4gICAgb2JqLmpvaW4gPSB0aGlzLmpvaW47XG4gICAgb2JqLm1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQ7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIHRoaXMuY29sb3IgPSAwO1xuICAgIHRoaXMuYWxpZ25tZW50ID0gMC41O1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMubmF0aXZlID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgTGluZVN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lU3R5bGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgU3RhdGUsIENvbG9yLCBCTEVORF9NT0RFUywgVGV4dHVyZSwgUG9seWdvbiwgUElfMiwgUmVjdGFuZ2xlLCBSb3VuZGVkUmVjdGFuZ2xlLCBDaXJjbGUsIEVsbGlwc2UsIFNIQVBFUywgTWF0cml4LCBVbmlmb3JtR3JvdXAsIFNoYWRlciwgUG9pbnQgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgTElORV9DQVAsIExJTkVfSk9JTiwgY3VydmVzIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NHZW9tZXRyeSB9IGZyb20gJy4vR3JhcGhpY3NHZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgRmlsbFN0eWxlIH0gZnJvbSAnLi9zdHlsZXMvRmlsbFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBMaW5lU3R5bGUgfSBmcm9tICcuL3N0eWxlcy9MaW5lU3R5bGUubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljVXRpbHMgfSBmcm9tICcuL3V0aWxzL1F1YWRyYXRpY1V0aWxzLm1qcyc7XG5pbXBvcnQgeyBCZXppZXJVdGlscyB9IGZyb20gJy4vdXRpbHMvQmV6aWVyVXRpbHMubWpzJztcbmltcG9ydCB7IEFyY1V0aWxzIH0gZnJvbSAnLi91dGlscy9BcmNVdGlscy5tanMnO1xuXG5jb25zdCBERUZBVUxUX1NIQURFUlMgPSB7fTtcbmNvbnN0IF9HcmFwaGljcyA9IGNsYXNzIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZ2VvbWV0cnkgPSBudWxsKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5wbHVnaW5OYW1lID0gXCJiYXRjaFwiO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgIHRoaXMuYmF0Y2hUaW50ID0gLTE7XG4gICAgdGhpcy5iYXRjaERpcnR5ID0gLTE7XG4gICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgICB0aGlzLl9maWxsU3R5bGUgPSBuZXcgRmlsbFN0eWxlKCk7XG4gICAgdGhpcy5fbGluZVN0eWxlID0gbmV3IExpbmVTdHlsZSgpO1xuICAgIHRoaXMuX21hdHJpeCA9IG51bGw7XG4gICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5IHx8IG5ldyBHcmFwaGljc0dlb21ldHJ5KCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkucmVmQ291bnQrKztcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBDb2xvcigxNjc3NzIxNSk7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUw7XG4gIH1cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICByZXR1cm4gbmV3IF9HcmFwaGljcyh0aGlzLl9nZW9tZXRyeSk7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIHRoaXMuX3RpbnRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IGZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxTdHlsZTtcbiAgfVxuICBnZXQgbGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZVN0eWxlO1xuICB9XG4gIGxpbmVTdHlsZShvcHRpb25zID0gbnVsbCwgY29sb3IgPSAwLCBhbHBoYSwgYWxpZ25tZW50ID0gMC41LCBuYXRpdmUgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgb3B0aW9ucyA9IHsgd2lkdGg6IG9wdGlvbnMsIGNvbG9yLCBhbHBoYSwgYWxpZ25tZW50LCBuYXRpdmUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGluZVRleHR1cmVTdHlsZShvcHRpb25zKTtcbiAgfVxuICBsaW5lVGV4dHVyZVN0eWxlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0TGluZVN0eWxlT3B0aW9ucyA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgdGV4dHVyZTogVGV4dHVyZS5XSElURSxcbiAgICAgIGNvbG9yOiBvcHRpb25zPy50ZXh0dXJlID8gMTY3NzcyMTUgOiAwLFxuICAgICAgbWF0cml4OiBudWxsLFxuICAgICAgYWxpZ25tZW50OiAwLjUsXG4gICAgICBuYXRpdmU6IGZhbHNlLFxuICAgICAgY2FwOiBMSU5FX0NBUC5CVVRULFxuICAgICAgam9pbjogTElORV9KT0lOLk1JVEVSLFxuICAgICAgbWl0ZXJMaW1pdDogMTBcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRMaW5lU3R5bGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLm5vcm1hbGl6ZUNvbG9yKG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9seSgpO1xuICAgIH1cbiAgICBjb25zdCB2aXNpYmxlID0gb3B0aW9ucy53aWR0aCA+IDAgJiYgb3B0aW9ucy5hbHBoYSA+IDA7XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICB0aGlzLl9saW5lU3R5bGUucmVzZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMubWF0cml4KSB7XG4gICAgICAgIG9wdGlvbnMubWF0cml4ID0gb3B0aW9ucy5tYXRyaXguY2xvbmUoKTtcbiAgICAgICAgb3B0aW9ucy5tYXRyaXguaW52ZXJ0KCk7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2xpbmVTdHlsZSwgeyB2aXNpYmxlIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGFydFBvbHkoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgICAgY29uc3QgbGVuID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUodGhpcy5jdXJyZW50UGF0aCk7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBuZXcgUG9seWdvbigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmNsb3NlU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBvbHlnb24oKTtcbiAgICAgIHRoaXMuY3VycmVudFBhdGguY2xvc2VTdHJva2UgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZmluaXNoUG9seSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUodGhpcy5jdXJyZW50UGF0aCk7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLnN0YXJ0UG9seSgpO1xuICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzWzBdID0geDtcbiAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50c1sxXSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgIHRoaXMubW92ZVRvKDAsIDApO1xuICAgIH1cbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgY29uc3QgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChmcm9tWCAhPT0geCB8fCBmcm9tWSAhPT0geSkge1xuICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0Q3VydmUoeCA9IDAsIHkgPSAwKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMgPSBbeCwgeV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuICBxdWFkcmF0aWNDdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgIHRoaXMuX2luaXRDdXJ2ZSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICB9XG4gICAgUXVhZHJhdGljVXRpbHMuY3VydmVUbyhjcFgsIGNwWSwgdG9YLCB0b1ksIHBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmV6aWVyQ3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcbiAgICB0aGlzLl9pbml0Q3VydmUoKTtcbiAgICBCZXppZXJVdGlscy5jdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICB0aGlzLl9pbml0Q3VydmUoeDEsIHkxKTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICBjb25zdCByZXN1bHQgPSBBcmNVdGlscy5jdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMsIHBvaW50cyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgY29uc3QgeyBjeCwgY3ksIHJhZGl1czogcmFkaXVzMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UgfSA9IHJlc3VsdDtcbiAgICAgIHRoaXMuYXJjKGN4LCBjeSwgcmFkaXVzMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhcmMoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gZmFsc2UpIHtcbiAgICBpZiAoc3RhcnRBbmdsZSA9PT0gZW5kQW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIWFudGljbG9ja3dpc2UgJiYgZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSkge1xuICAgICAgZW5kQW5nbGUgKz0gUElfMjtcbiAgICB9IGVsc2UgaWYgKGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSkge1xuICAgICAgc3RhcnRBbmdsZSArPSBQSV8yO1xuICAgIH1cbiAgICBjb25zdCBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBpZiAoc3dlZXAgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZXBzID0gdGhpcy5fZ2VvbWV0cnkuY2xvc2VQb2ludEVwcztcbiAgICBsZXQgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aCA/IHRoaXMuY3VycmVudFBhdGgucG9pbnRzIDogbnVsbDtcbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBjb25zdCB4RGlmZiA9IE1hdGguYWJzKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gLSBzdGFydFgpO1xuICAgICAgY29uc3QgeURpZmYgPSBNYXRoLmFicyhwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIC0gc3RhcnRZKTtcbiAgICAgIGlmICh4RGlmZiA8IGVwcyAmJiB5RGlmZiA8IGVwcykge1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICB9XG4gICAgQXJjVXRpbHMuYXJjKHN0YXJ0WCwgc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmVnaW5GaWxsKGNvbG9yID0gMCwgYWxwaGEpIHtcbiAgICByZXR1cm4gdGhpcy5iZWdpblRleHR1cmVGaWxsKHsgdGV4dHVyZTogVGV4dHVyZS5XSElURSwgY29sb3IsIGFscGhhIH0pO1xuICB9XG4gIG5vcm1hbGl6ZUNvbG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZW1wID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKG9wdGlvbnMuY29sb3IgPz8gMCk7XG4gICAgb3B0aW9ucy5jb2xvciA9IHRlbXAudG9OdW1iZXIoKTtcbiAgICBvcHRpb25zLmFscGhhID8/IChvcHRpb25zLmFscGhhID0gdGVtcC5hbHBoYSk7XG4gIH1cbiAgYmVnaW5UZXh0dXJlRmlsbChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB0ZXh0dXJlOiBUZXh0dXJlLldISVRFLFxuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgbWF0cml4OiBudWxsXG4gICAgfTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5ub3JtYWxpemVDb2xvcihvcHRpb25zKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgdGhpcy5zdGFydFBvbHkoKTtcbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZSA9IG9wdGlvbnMuYWxwaGEgPiAwO1xuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgdGhpcy5fZmlsbFN0eWxlLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLm1hdHJpeCkge1xuICAgICAgICBvcHRpb25zLm1hdHJpeCA9IG9wdGlvbnMubWF0cml4LmNsb25lKCk7XG4gICAgICAgIG9wdGlvbnMubWF0cml4LmludmVydCgpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9maWxsU3R5bGUsIHsgdmlzaWJsZSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kRmlsbCgpIHtcbiAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICB0aGlzLl9maWxsU3R5bGUucmVzZXQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIGRyYXdSb3VuZGVkUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IFJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSk7XG4gIH1cbiAgZHJhd0NpcmNsZSh4LCB5LCByYWRpdXMpIHtcbiAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IENpcmNsZSh4LCB5LCByYWRpdXMpKTtcbiAgfVxuICBkcmF3RWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgfVxuICBkcmF3UG9seWdvbiguLi5wYXRoKSB7XG4gICAgbGV0IHBvaW50cztcbiAgICBsZXQgY2xvc2VTdHJva2UgPSB0cnVlO1xuICAgIGNvbnN0IHBvbHkgPSBwYXRoWzBdO1xuICAgIGlmIChwb2x5LnBvaW50cykge1xuICAgICAgY2xvc2VTdHJva2UgPSBwb2x5LmNsb3NlU3Ryb2tlO1xuICAgICAgcG9pbnRzID0gcG9seS5wb2ludHM7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGhbMF0pKSB7XG4gICAgICBwb2ludHMgPSBwYXRoWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSBwYXRoO1xuICAgIH1cbiAgICBjb25zdCBzaGFwZSA9IG5ldyBQb2x5Z29uKHBvaW50cyk7XG4gICAgc2hhcGUuY2xvc2VTdHJva2UgPSBjbG9zZVN0cm9rZTtcbiAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZHJhd1NoYXBlKHNoYXBlKSB7XG4gICAgaWYgKCF0aGlzLl9ob2xlTW9kZSkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkuZHJhd1NoYXBlKHNoYXBlLCB0aGlzLl9maWxsU3R5bGUuY2xvbmUoKSwgdGhpcy5fbGluZVN0eWxlLmNsb25lKCksIHRoaXMuX21hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LmRyYXdIb2xlKHNoYXBlLCB0aGlzLl9tYXRyaXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9nZW9tZXRyeS5jbGVhcigpO1xuICAgIHRoaXMuX2xpbmVTdHlsZS5yZXNldCgpO1xuICAgIHRoaXMuX2ZpbGxTdHlsZS5yZXNldCgpO1xuICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgdGhpcy5fbWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLl9ob2xlTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlzRmFzdFJlY3QoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2dlb21ldHJ5LmdyYXBoaWNzRGF0YTtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXS5zaGFwZS50eXBlID09PSBTSEFQRVMuUkVDVCAmJiAhZGF0YVswXS5tYXRyaXggJiYgIWRhdGFbMF0uaG9sZXMubGVuZ3RoICYmICEoZGF0YVswXS5saW5lU3R5bGUudmlzaWJsZSAmJiBkYXRhWzBdLmxpbmVTdHlsZS53aWR0aCk7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIHRoaXMuZmluaXNoUG9seSgpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gICAgZ2VvbWV0cnkudXBkYXRlQmF0Y2hlcygpO1xuICAgIGlmIChnZW9tZXRyeS5iYXRjaGFibGUpIHtcbiAgICAgIGlmICh0aGlzLmJhdGNoRGlydHkgIT09IGdlb21ldHJ5LmJhdGNoRGlydHkpIHtcbiAgICAgICAgdGhpcy5fcG9wdWxhdGVCYXRjaGVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJCYXRjaGVkKHJlbmRlcmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgIHRoaXMuX3JlbmRlckRpcmVjdChyZW5kZXJlcik7XG4gICAgfVxuICB9XG4gIF9wb3B1bGF0ZUJhdGNoZXMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICBjb25zdCBibGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICBjb25zdCBsZW4gPSBnZW9tZXRyeS5iYXRjaGVzLmxlbmd0aDtcbiAgICB0aGlzLmJhdGNoVGludCA9IC0xO1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgdGhpcy5iYXRjaERpcnR5ID0gZ2VvbWV0cnkuYmF0Y2hEaXJ0eTtcbiAgICB0aGlzLmJhdGNoZXMubGVuZ3RoID0gbGVuO1xuICAgIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkucG9pbnRzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBnSSA9IGdlb21ldHJ5LmJhdGNoZXNbaV07XG4gICAgICBjb25zdCBjb2xvciA9IGdJLnN0eWxlLmNvbG9yO1xuICAgICAgY29uc3QgdmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0ZXhEYXRhLmJ1ZmZlciwgZ0kuYXR0cmliU3RhcnQgKiA0ICogMiwgZ0kuYXR0cmliU2l6ZSAqIDIpO1xuICAgICAgY29uc3QgdXZzID0gbmV3IEZsb2F0MzJBcnJheShnZW9tZXRyeS51dnNGbG9hdDMyLmJ1ZmZlciwgZ0kuYXR0cmliU3RhcnQgKiA0ICogMiwgZ0kuYXR0cmliU2l6ZSAqIDIpO1xuICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShnZW9tZXRyeS5pbmRpY2VzVWludDE2LmJ1ZmZlciwgZ0kuc3RhcnQgKiAyLCBnSS5zaXplKTtcbiAgICAgIGNvbnN0IGJhdGNoID0ge1xuICAgICAgICB2ZXJ0ZXhEYXRhLFxuICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgIGluZGljZXMsXG4gICAgICAgIHV2cyxcbiAgICAgICAgX2JhdGNoUkdCOiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvUmdiQXJyYXkoKSxcbiAgICAgICAgX3RpbnRSR0I6IGNvbG9yLFxuICAgICAgICBfdGV4dHVyZTogZ0kuc3R5bGUudGV4dHVyZSxcbiAgICAgICAgYWxwaGE6IGdJLnN0eWxlLmFscGhhLFxuICAgICAgICB3b3JsZEFscGhhOiAxXG4gICAgICB9O1xuICAgICAgdGhpcy5iYXRjaGVzW2ldID0gYmF0Y2g7XG4gICAgfVxuICB9XG4gIF9yZW5kZXJCYXRjaGVkKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLmJhdGNoZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXSk7XG4gICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgIHRoaXMuY2FsY3VsYXRlVGludHMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5iYXRjaGVzW2ldO1xuICAgICAgYmF0Y2gud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYSAqIGJhdGNoLmFscGhhO1xuICAgICAgcmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdLnJlbmRlcihiYXRjaCk7XG4gICAgfVxuICB9XG4gIF9yZW5kZXJEaXJlY3QocmVuZGVyZXIpIHtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLl9yZXNvbHZlRGlyZWN0U2hhZGVyKHJlbmRlcmVyKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICAgIGNvbnN0IHdvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBzaGFkZXIudW5pZm9ybXM7XG4gICAgY29uc3QgZHJhd0NhbGxzID0gZ2VvbWV0cnkuZHJhd0NhbGxzO1xuICAgIHVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikucHJlbXVsdGlwbHkod29ybGRBbHBoYSkudG9BcnJheSh1bmlmb3Jtcy50aW50KTtcbiAgICByZW5kZXJlci5zaGFkZXIuYmluZChzaGFkZXIpO1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoZ2VvbWV0cnksIHNoYWRlcik7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZHJhd0NhbGxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5fcmVuZGVyRHJhd0NhbGxEaXJlY3QocmVuZGVyZXIsIGdlb21ldHJ5LmRyYXdDYWxsc1tpXSk7XG4gICAgfVxuICB9XG4gIF9yZW5kZXJEcmF3Q2FsbERpcmVjdChyZW5kZXJlciwgZHJhd0NhbGwpIHtcbiAgICBjb25zdCB7IHRleEFycmF5LCB0eXBlLCBzaXplLCBzdGFydCB9ID0gZHJhd0NhbGw7XG4gICAgY29uc3QgZ3JvdXBUZXh0dXJlQ291bnQgPSB0ZXhBcnJheS5jb3VudDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyb3VwVGV4dHVyZUNvdW50OyBqKyspIHtcbiAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZCh0ZXhBcnJheS5lbGVtZW50c1tqXSwgaik7XG4gICAgfVxuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcodHlwZSwgc2l6ZSwgc3RhcnQpO1xuICB9XG4gIF9yZXNvbHZlRGlyZWN0U2hhZGVyKHJlbmRlcmVyKSB7XG4gICAgbGV0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIGNvbnN0IHBsdWdpbk5hbWUgPSB0aGlzLnBsdWdpbk5hbWU7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIGlmICghREVGQVVMVF9TSEFERVJTW3BsdWdpbk5hbWVdKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4VGV4dHVyZXMgfSA9IHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICAgIGNvbnN0IHNhbXBsZVZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KG1heFRleHR1cmVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XG4gICAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgICAgICB0aW50OiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksXG4gICAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IG5ldyBNYXRyaXgoKSxcbiAgICAgICAgICBkZWZhdWx0OiBVbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sIHRydWUpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSByZW5kZXJlci5wbHVnaW5zW3BsdWdpbk5hbWVdLl9zaGFkZXIucHJvZ3JhbTtcbiAgICAgICAgREVGQVVMVF9TSEFERVJTW3BsdWdpbk5hbWVdID0gbmV3IFNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gICAgICB9XG4gICAgICBzaGFkZXIgPSBERUZBVUxUX1NIQURFUlNbcGx1Z2luTmFtZV07XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXI7XG4gIH1cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICAgIGlmICghZ2VvbWV0cnkuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IG1pblgsIG1pblksIG1heFgsIG1heFkgfSA9IGdlb21ldHJ5LmJvdW5kcztcbiAgICB0aGlzLl9ib3VuZHMuYWRkRnJhbWUodGhpcy50cmFuc2Zvcm0sIG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgX0dyYXBoaWNzLl9URU1QX1BPSU5UKTtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnkuY29udGFpbnNQb2ludChfR3JhcGhpY3MuX1RFTVBfUE9JTlQpO1xuICB9XG4gIGNhbGN1bGF0ZVRpbnRzKCkge1xuICAgIGlmICh0aGlzLmJhdGNoVGludCAhPT0gdGhpcy50aW50KSB7XG4gICAgICB0aGlzLmJhdGNoVGludCA9IHRoaXMuX3RpbnRDb2xvci50b051bWJlcigpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XG4gICAgICAgIGJhdGNoLl90aW50UkdCID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikubXVsdGlwbHkoYmF0Y2guX2JhdGNoUkdCKS50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB3dElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB3dElEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gd3RJRDtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZ2VvbWV0cnkucG9pbnRzO1xuICAgIGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSBkYXRhW2ldO1xuICAgICAgY29uc3QgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgdmVydGV4RGF0YVtjb3VudCsrXSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgIHZlcnRleERhdGFbY291bnQrK10gPSBkICogeSArIGIgKiB4ICsgdHk7XG4gICAgfVxuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgaWYgKGN1cnJlbnRQYXRoKSB7XG4gICAgICBjdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IHRydWU7XG4gICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0TWF0cml4KG1hdHJpeCkge1xuICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWdpbkhvbGUoKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgdGhpcy5faG9sZU1vZGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuZEhvbGUoKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLl9nZW9tZXRyeS5yZWZDb3VudC0tO1xuICAgIGlmICh0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgIHRoaXMuX2xpbmVTdHlsZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fbGluZVN0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9maWxsU3R5bGUuZGVzdHJveSgpO1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGEgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuYmF0Y2hlcyA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbmxldCBHcmFwaGljcyA9IF9HcmFwaGljcztcbkdyYXBoaWNzLmN1cnZlcyA9IGN1cnZlcztcbkdyYXBoaWNzLl9URU1QX1BPSU5UID0gbmV3IFBvaW50KCk7XG5cbmV4cG9ydCB7IEdyYXBoaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljcy5tanMubWFwXG4iLCJpbXBvcnQgeyBGSUxMX0NPTU1BTkRTLCBCQVRDSF9QT09MLCBEUkFXX0NBTExfUE9PTCB9IGZyb20gJy4vdXRpbHMvaW5kZXgubWpzJztcbmV4cG9ydCB7IEdSQVBISUNTX0NVUlZFUywgTElORV9DQVAsIExJTkVfSk9JTiwgY3VydmVzIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuZXhwb3J0IHsgR3JhcGhpY3MgfSBmcm9tICcuL0dyYXBoaWNzLm1qcyc7XG5leHBvcnQgeyBHcmFwaGljc0RhdGEgfSBmcm9tICcuL0dyYXBoaWNzRGF0YS5tanMnO1xuZXhwb3J0IHsgR3JhcGhpY3NHZW9tZXRyeSB9IGZyb20gJy4vR3JhcGhpY3NHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgRmlsbFN0eWxlIH0gZnJvbSAnLi9zdHlsZXMvRmlsbFN0eWxlLm1qcyc7XG5leHBvcnQgeyBMaW5lU3R5bGUgfSBmcm9tICcuL3N0eWxlcy9MaW5lU3R5bGUubWpzJztcbmltcG9ydCB7IGJ1aWxkUG9seSB9IGZyb20gJy4vdXRpbHMvYnVpbGRQb2x5Lm1qcyc7XG5pbXBvcnQgeyBidWlsZENpcmNsZSB9IGZyb20gJy4vdXRpbHMvYnVpbGRDaXJjbGUubWpzJztcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSAnLi91dGlscy9idWlsZFJlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi91dGlscy9idWlsZFJvdW5kZWRSZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IGJ1aWxkTGluZSB9IGZyb20gJy4vdXRpbHMvYnVpbGRMaW5lLm1qcyc7XG5pbXBvcnQgeyBBcmNVdGlscyB9IGZyb20gJy4vdXRpbHMvQXJjVXRpbHMubWpzJztcbmltcG9ydCB7IEJlemllclV0aWxzIH0gZnJvbSAnLi91dGlscy9CZXppZXJVdGlscy5tanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljVXRpbHMgfSBmcm9tICcuL3V0aWxzL1F1YWRyYXRpY1V0aWxzLm1qcyc7XG5pbXBvcnQgeyBCYXRjaFBhcnQgfSBmcm9tICcuL3V0aWxzL0JhdGNoUGFydC5tanMnO1xuXG5jb25zdCBncmFwaGljc1V0aWxzID0ge1xuICBidWlsZFBvbHksXG4gIGJ1aWxkQ2lyY2xlLFxuICBidWlsZFJlY3RhbmdsZSxcbiAgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlLFxuICBidWlsZExpbmUsXG4gIEFyY1V0aWxzLFxuICBCZXppZXJVdGlscyxcbiAgUXVhZHJhdGljVXRpbHMsXG4gIEJhdGNoUGFydCxcbiAgRklMTF9DT01NQU5EUyxcbiAgQkFUQ0hfUE9PTCxcbiAgRFJBV19DQUxMX1BPT0xcbn07XG5cbmV4cG9ydCB7IGdyYXBoaWNzVXRpbHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNsYXNzIE1lc2hCYXRjaFV2cyB7XG4gIGNvbnN0cnVjdG9yKHV2QnVmZmVyLCB1dk1hdHJpeCkge1xuICAgIHRoaXMudXZCdWZmZXIgPSB1dkJ1ZmZlcjtcbiAgICB0aGlzLnV2TWF0cml4ID0gdXZNYXRyaXg7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJVcGRhdGVJZCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9IC0xO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgfVxuICB1cGRhdGUoZm9yY2VVcGRhdGUpIHtcbiAgICBpZiAoIWZvcmNlVXBkYXRlICYmIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID09PSB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRCAmJiB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPT09IHRoaXMudXZNYXRyaXguX3VwZGF0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID0gdGhpcy51dkJ1ZmZlci5fdXBkYXRlSUQ7XG4gICAgdGhpcy5fdGV4dHVyZVVwZGF0ZUlkID0gdGhpcy51dk1hdHJpeC5fdXBkYXRlSUQ7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMudXZCdWZmZXIuZGF0YTtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMudXZNYXRyaXgubXVsdGlwbHlVdnMoZGF0YSwgdGhpcy5kYXRhKTtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICB9XG59XG5cbmV4cG9ydCB7IE1lc2hCYXRjaFV2cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaEJhdGNoVXZzLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50LCBQb2x5Z29uLCBTdGF0ZSwgc2V0dGluZ3MsIERSQVdfTU9ERVMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgTWVzaEJhdGNoVXZzIH0gZnJvbSAnLi9NZXNoQmF0Y2hVdnMubWpzJztcblxuY29uc3QgdGVtcFBvaW50ID0gbmV3IFBvaW50KCk7XG5jb25zdCB0ZW1wUG9seWdvbiA9IG5ldyBQb2x5Z29uKCk7XG5jb25zdCBfTWVzaCA9IGNsYXNzIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZ2VvbWV0cnksIHNoYWRlciwgc3RhdGUsIGRyYXdNb2RlID0gRFJBV19NT0RFUy5UUklBTkdMRVMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwgU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLmRyYXdNb2RlID0gZHJhd01vZGU7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLnV2cyA9IG51bGw7XG4gICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICAgIHRoaXMudmVydGV4RGlydHkgPSAtMTtcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gc2V0dGluZ3MuUk9VTkRfUElYRUxTO1xuICAgIHRoaXMuYmF0Y2hVdnMgPSBudWxsO1xuICB9XG4gIGdldCBnZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG4gIH1cbiAgc2V0IGdlb21ldHJ5KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2dlb21ldHJ5ID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LnJlZkNvdW50LS07XG4gICAgICBpZiAodGhpcy5fZ2VvbWV0cnkucmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9nZW9tZXRyeSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLl9nZW9tZXRyeSkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkucmVmQ291bnQrKztcbiAgICB9XG4gICAgdGhpcy52ZXJ0ZXhEaXJ0eSA9IC0xO1xuICB9XG4gIGdldCB1dkJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzFdO1xuICB9XG4gIGdldCB2ZXJ0aWNlc0J1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzBdO1xuICB9XG4gIHNldCBtYXRlcmlhbCh2YWx1ZSkge1xuICAgIHRoaXMuc2hhZGVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlcjtcbiAgfVxuICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYmxlbmRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmJsZW5kTW9kZTtcbiAgfVxuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICBpZiAodGhpcy5fcm91bmRQaXhlbHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xuICB9XG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIFwidGludFwiIGluIHRoaXMuc2hhZGVyID8gdGhpcy5zaGFkZXIudGludCA6IG51bGw7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICB0aGlzLnNoYWRlci50aW50ID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHRpbnRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIudGludFZhbHVlO1xuICB9XG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiBcInRleHR1cmVcIiBpbiB0aGlzLnNoYWRlciA/IHRoaXMuc2hhZGVyLnRleHR1cmUgOiBudWxsO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5zaGFkZXIudGV4dHVyZSA9IHZhbHVlO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXS5kYXRhO1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIGlmIChzaGFkZXIuYmF0Y2hhYmxlICYmIHRoaXMuZHJhd01vZGUgPT09IERSQVdfTU9ERVMuVFJJQU5HTEVTICYmIHZlcnRpY2VzLmxlbmd0aCA8IF9NZXNoLkJBVENIQUJMRV9TSVpFICogMikge1xuICAgICAgdGhpcy5fcmVuZGVyVG9CYXRjaChyZW5kZXJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlckRlZmF1bHQocmVuZGVyZXIpO1xuICAgIH1cbiAgfVxuICBfcmVuZGVyRGVmYXVsdChyZW5kZXJlcikge1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIHNoYWRlci5hbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgICBpZiAoc2hhZGVyLnVwZGF0ZSkge1xuICAgICAgc2hhZGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgICByZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xuICAgIHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XG4gICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKTtcbiAgICByZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLmdlb21ldHJ5LCBzaGFkZXIpO1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcodGhpcy5kcmF3TW9kZSwgdGhpcy5zaXplLCB0aGlzLnN0YXJ0LCB0aGlzLmdlb21ldHJ5Lmluc3RhbmNlQ291bnQpO1xuICB9XG4gIF9yZW5kZXJUb0JhdGNoKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIGlmIChzaGFkZXIudXZNYXRyaXgpIHtcbiAgICAgIHNoYWRlci51dk1hdHJpeC51cGRhdGUoKTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlVXZzKCk7XG4gICAgfVxuICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICB0aGlzLmluZGljZXMgPSBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhO1xuICAgIHRoaXMuX3RpbnRSR0IgPSBzaGFkZXIuX3RpbnRSR0I7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHNoYWRlci50ZXh0dXJlO1xuICAgIGNvbnN0IHBsdWdpbk5hbWUgPSB0aGlzLm1hdGVyaWFsLnBsdWdpbk5hbWU7XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXSk7XG4gICAgcmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgY2FsY3VsYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IHZlcnRpY2VzQnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1swXTtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHZlcnRpY2VzQnVmZmVyLmRhdGE7XG4gICAgY29uc3QgdmVydGV4RGlydHlJZCA9IHZlcnRpY2VzQnVmZmVyLl91cGRhdGVJRDtcbiAgICBpZiAodmVydGV4RGlydHlJZCA9PT0gdGhpcy52ZXJ0ZXhEaXJ0eSAmJiB0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgICBpZiAodGhpcy52ZXJ0ZXhEYXRhLmxlbmd0aCAhPT0gdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgY29uc3QgYSA9IHd0LmE7XG4gICAgY29uc3QgYiA9IHd0LmI7XG4gICAgY29uc3QgYyA9IHd0LmM7XG4gICAgY29uc3QgZCA9IHd0LmQ7XG4gICAgY29uc3QgdHggPSB3dC50eDtcbiAgICBjb25zdCB0eSA9IHd0LnR5O1xuICAgIGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY29uc3QgeCA9IHZlcnRpY2VzW2kgKiAyXTtcbiAgICAgIGNvbnN0IHkgPSB2ZXJ0aWNlc1tpICogMiArIDFdO1xuICAgICAgdmVydGV4RGF0YVtpICogMl0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICB2ZXJ0ZXhEYXRhW2kgKiAyICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmVydGV4RGF0YVtpXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpXSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52ZXJ0ZXhEaXJ0eSA9IHZlcnRleERpcnR5SWQ7XG4gIH1cbiAgY2FsY3VsYXRlVXZzKCkge1xuICAgIGNvbnN0IGdlb21VdnMgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV07XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG4gICAgaWYgKCFzaGFkZXIudXZNYXRyaXguaXNTaW1wbGUpIHtcbiAgICAgIGlmICghdGhpcy5iYXRjaFV2cykge1xuICAgICAgICB0aGlzLmJhdGNoVXZzID0gbmV3IE1lc2hCYXRjaFV2cyhnZW9tVXZzLCBzaGFkZXIudXZNYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5iYXRjaFV2cy51cGRhdGUoKTtcbiAgICAgIHRoaXMudXZzID0gdGhpcy5iYXRjaFV2cy5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnV2cyA9IGdlb21VdnMuZGF0YTtcbiAgICB9XG4gIH1cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgdGhpcy5fYm91bmRzLmFkZFZlcnRleERhdGEodGhpcy52ZXJ0ZXhEYXRhLCAwLCB0aGlzLnZlcnRleERhdGEubGVuZ3RoKTtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgaWYgKCF0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0ZW1wUG9pbnQpO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YTtcbiAgICBjb25zdCBwb2ludHMgPSB0ZW1wUG9seWdvbi5wb2ludHM7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0SW5kZXgoKS5kYXRhO1xuICAgIGNvbnN0IGxlbiA9IGluZGljZXMubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmRyYXdNb2RlID09PSA0ID8gMyA6IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgKyAyIDwgbGVuOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IGluZDAgPSBpbmRpY2VzW2ldICogMjtcbiAgICAgIGNvbnN0IGluZDEgPSBpbmRpY2VzW2kgKyAxXSAqIDI7XG4gICAgICBjb25zdCBpbmQyID0gaW5kaWNlc1tpICsgMl0gKiAyO1xuICAgICAgcG9pbnRzWzBdID0gdmVydGljZXNbaW5kMF07XG4gICAgICBwb2ludHNbMV0gPSB2ZXJ0aWNlc1tpbmQwICsgMV07XG4gICAgICBwb2ludHNbMl0gPSB2ZXJ0aWNlc1tpbmQxXTtcbiAgICAgIHBvaW50c1szXSA9IHZlcnRpY2VzW2luZDEgKyAxXTtcbiAgICAgIHBvaW50c1s0XSA9IHZlcnRpY2VzW2luZDJdO1xuICAgICAgcG9pbnRzWzVdID0gdmVydGljZXNbaW5kMiArIDFdO1xuICAgICAgaWYgKHRlbXBQb2x5Z29uLmNvbnRhaW5zKHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLl9jYWNoZWRUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2NhY2hlZFRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy51dnMgPSBudWxsO1xuICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG4gICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgfVxufTtcbmxldCBNZXNoID0gX01lc2g7XG5NZXNoLkJBVENIQUJMRV9TSVpFID0gMTAwO1xuXG5leHBvcnQgeyBNZXNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoLm1qcy5tYXBcbiIsImltcG9ydCB7IEdlb21ldHJ5LCBCdWZmZXIsIFRZUEVTIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNsYXNzIE1lc2hHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IodmVydGljZXMsIHV2cywgaW5kZXgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHZlcnRpY2VzQnVmZmVyID0gbmV3IEJ1ZmZlcih2ZXJ0aWNlcyk7XG4gICAgY29uc3QgdXZzQnVmZmVyID0gbmV3IEJ1ZmZlcih1dnMsIHRydWUpO1xuICAgIGNvbnN0IGluZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcihpbmRleCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhVmVydGV4UG9zaXRpb25cIiwgdmVydGljZXNCdWZmZXIsIDIsIGZhbHNlLCBUWVBFUy5GTE9BVCkuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVDb29yZFwiLCB1dnNCdWZmZXIsIDIsIGZhbHNlLCBUWVBFUy5GTE9BVCkuYWRkSW5kZXgoaW5kZXhCdWZmZXIpO1xuICAgIHRoaXMuX3VwZGF0ZUlkID0gLTE7XG4gIH1cbiAgZ2V0IHZlcnRleERpcnR5SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyc1swXS5fdXBkYXRlSUQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgTWVzaEdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoR2VvbWV0cnkubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gubWpzLm1hcFxuIiwidmFyIHZlcnRleCA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1VGV4dHVyZU1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRleHR1cmVNYXRyaXggKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgdmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gyLm1qcy5tYXBcbiIsImltcG9ydCB7IFNoYWRlciwgTWF0cml4LCBQcm9ncmFtLCBUZXh0dXJlTWF0cml4LCBDb2xvciB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vc2hhZGVyL21lc2gubWpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi9zaGFkZXIvbWVzaDIubWpzJztcblxuY2xhc3MgTWVzaE1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyIHtcbiAgY29uc3RydWN0b3IodVNhbXBsZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHVTYW1wbGVyLFxuICAgICAgYWxwaGE6IDEsXG4gICAgICB1VGV4dHVyZU1hdHJpeDogTWF0cml4LklERU5USVRZLFxuICAgICAgdUNvbG9yOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSlcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHRpbnQ6IDE2Nzc3MjE1LFxuICAgICAgYWxwaGE6IDEsXG4gICAgICBwbHVnaW5OYW1lOiBcImJhdGNoXCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy51bmlmb3Jtcykge1xuICAgICAgT2JqZWN0LmFzc2lnbih1bmlmb3Jtcywgb3B0aW9ucy51bmlmb3Jtcyk7XG4gICAgfVxuICAgIHN1cGVyKG9wdGlvbnMucHJvZ3JhbSB8fCBQcm9ncmFtLmZyb20odmVydGV4LCBmcmFnbWVudCksIHVuaWZvcm1zKTtcbiAgICB0aGlzLl9jb2xvckRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy51dk1hdHJpeCA9IG5ldyBUZXh0dXJlTWF0cml4KHVTYW1wbGVyKTtcbiAgICB0aGlzLmJhdGNoYWJsZSA9IG9wdGlvbnMucHJvZ3JhbSA9PT0gdm9pZCAwO1xuICAgIHRoaXMucGx1Z2luTmFtZSA9IG9wdGlvbnMucGx1Z2luTmFtZTtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBuZXcgQ29sb3Iob3B0aW9ucy50aW50KTtcbiAgICB0aGlzLl90aW50UkdCID0gdGhpcy5fdGludENvbG9yLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCk7XG4gICAgdGhpcy5fY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5hbHBoYSA9IG9wdGlvbnMuYWxwaGE7XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNhbXBsZXI7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3Jtcy51U2FtcGxlciAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy51bmlmb3Jtcy51U2FtcGxlci5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgIT09ICF2YWx1ZS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUpIHtcbiAgICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyID0gdmFsdWU7XG4gICAgICB0aGlzLnV2TWF0cml4LnRleHR1cmUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLl9hbHBoYSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9hbHBoYSA9IHZhbHVlO1xuICAgIHRoaXMuX2NvbG9yRGlydHkgPSB0cnVlO1xuICB9XG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxwaGE7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMudGludClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90aW50Q29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgIHRoaXMuX3RpbnRSR0IgPSB0aGlzLl90aW50Q29sb3IudG9MaXR0bGVFbmRpYW5OdW1iZXIoKTtcbiAgICB0aGlzLl9jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIGdldCB0aW50VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci50b051bWJlcigpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY29sb3JEaXJ0eSkge1xuICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IGZhbHNlO1xuICAgICAgY29uc3QgYmFzZVRleHR1cmUgPSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICBjb25zdCBhcHBseVRvQ2hhbm5lbHMgPSBiYXNlVGV4dHVyZS5hbHBoYU1vZGU7XG4gICAgICBDb2xvci5zaGFyZWQuc2V0VmFsdWUodGhpcy5fdGludENvbG9yKS5wcmVtdWx0aXBseSh0aGlzLl9hbHBoYSwgYXBwbHlUb0NoYW5uZWxzKS50b0FycmF5KHRoaXMudW5pZm9ybXMudUNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXZNYXRyaXgudXBkYXRlKCkpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMudVRleHR1cmVNYXRyaXggPSB0aGlzLnV2TWF0cml4Lm1hcENvb3JkO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBNZXNoTWF0ZXJpYWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hNYXRlcmlhbC5tanMubWFwXG4iLCJleHBvcnQgeyBNZXNoIH0gZnJvbSAnLi9NZXNoLm1qcyc7XG5leHBvcnQgeyBNZXNoQmF0Y2hVdnMgfSBmcm9tICcuL01lc2hCYXRjaFV2cy5tanMnO1xuZXhwb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi9NZXNoR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IE1lc2hNYXRlcmlhbCB9IGZyb20gJy4vTWVzaE1hdGVyaWFsLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICdAcGl4aS9tZXNoJztcblxuY2xhc3MgUGxhbmVHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDAsIHNlZ1dpZHRoID0gMTAsIHNlZ0hlaWdodCA9IDEwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlZ1dpZHRoID0gc2VnV2lkdGg7XG4gICAgdGhpcy5zZWdIZWlnaHQgPSBzZWdIZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2VnV2lkdGggKiB0aGlzLnNlZ0hlaWdodDtcbiAgICBjb25zdCB2ZXJ0cyA9IFtdO1xuICAgIGNvbnN0IHV2cyA9IFtdO1xuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCBzZWdtZW50c1ggPSB0aGlzLnNlZ1dpZHRoIC0gMTtcbiAgICBjb25zdCBzZWdtZW50c1kgPSB0aGlzLnNlZ0hlaWdodCAtIDE7XG4gICAgY29uc3Qgc2l6ZVggPSB0aGlzLndpZHRoIC8gc2VnbWVudHNYO1xuICAgIGNvbnN0IHNpemVZID0gdGhpcy5oZWlnaHQgLyBzZWdtZW50c1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIHRoaXMuc2VnV2lkdGg7XG4gICAgICBjb25zdCB5ID0gaSAvIHRoaXMuc2VnV2lkdGggfCAwO1xuICAgICAgdmVydHMucHVzaCh4ICogc2l6ZVgsIHkgKiBzaXplWSk7XG4gICAgICB1dnMucHVzaCh4IC8gc2VnbWVudHNYLCB5IC8gc2VnbWVudHNZKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxTdWIgPSBzZWdtZW50c1ggKiBzZWdtZW50c1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFN1YjsgaSsrKSB7XG4gICAgICBjb25zdCB4cG9zID0gaSAlIHNlZ21lbnRzWDtcbiAgICAgIGNvbnN0IHlwb3MgPSBpIC8gc2VnbWVudHNYIHwgMDtcbiAgICAgIGNvbnN0IHZhbHVlID0geXBvcyAqIHRoaXMuc2VnV2lkdGggKyB4cG9zO1xuICAgICAgY29uc3QgdmFsdWUyID0geXBvcyAqIHRoaXMuc2VnV2lkdGggKyB4cG9zICsgMTtcbiAgICAgIGNvbnN0IHZhbHVlMyA9ICh5cG9zICsgMSkgKiB0aGlzLnNlZ1dpZHRoICsgeHBvcztcbiAgICAgIGNvbnN0IHZhbHVlNCA9ICh5cG9zICsgMSkgKiB0aGlzLnNlZ1dpZHRoICsgeHBvcyArIDE7XG4gICAgICBpbmRpY2VzLnB1c2godmFsdWUsIHZhbHVlMiwgdmFsdWUzLCB2YWx1ZTIsIHZhbHVlNCwgdmFsdWUzKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJzWzBdLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMV0uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodXZzKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XG4gICAgdGhpcy5idWZmZXJzWzBdLnVwZGF0ZSgpO1xuICAgIHRoaXMuYnVmZmVyc1sxXS51cGRhdGUoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLnVwZGF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCB7IFBsYW5lR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsYW5lR2VvbWV0cnkubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnQHBpeGkvbWVzaCc7XG5cbmNsYXNzIFJvcGVHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMjAwLCBwb2ludHMsIHRleHR1cmVTY2FsZSA9IDApIHtcbiAgICBzdXBlcihuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KSwgbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksIG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNikpO1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy50ZXh0dXJlU2NhbGUgPSB0ZXh0dXJlU2NhbGU7XG4gICAgdGhpcy5idWlsZCgpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgYnVpbGQoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYgKCFwb2ludHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIik7XG4gICAgY29uc3QgdXZCdWZmZXIgPSB0aGlzLmdldEJ1ZmZlcihcImFUZXh0dXJlQ29vcmRcIik7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLmdldEluZGV4KCk7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2ZXJ0ZXhCdWZmZXIuZGF0YS5sZW5ndGggLyA0ICE9PSBwb2ludHMubGVuZ3RoKSB7XG4gICAgICB2ZXJ0ZXhCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgdXZCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgaW5kZXhCdWZmZXIuZGF0YSA9IG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNik7XG4gICAgfVxuICAgIGNvbnN0IHV2cyA9IHV2QnVmZmVyLmRhdGE7XG4gICAgY29uc3QgaW5kaWNlcyA9IGluZGV4QnVmZmVyLmRhdGE7XG4gICAgdXZzWzBdID0gMDtcbiAgICB1dnNbMV0gPSAwO1xuICAgIHV2c1syXSA9IDA7XG4gICAgdXZzWzNdID0gMTtcbiAgICBsZXQgYW1vdW50ID0gMDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1swXTtcbiAgICBjb25zdCB0ZXh0dXJlV2lkdGggPSB0aGlzLl93aWR0aCAqIHRoaXMudGV4dHVyZVNjYWxlO1xuICAgIGNvbnN0IHRvdGFsID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQ7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlU2NhbGUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcHJldi54IC0gcG9pbnRzW2ldLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcHJldi55IC0gcG9pbnRzW2ldLnk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgcHJldiA9IHBvaW50c1tpXTtcbiAgICAgICAgYW1vdW50ICs9IGRpc3RhbmNlIC8gdGV4dHVyZVdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW1vdW50ID0gaSAvICh0b3RhbCAtIDEpO1xuICAgICAgfVxuICAgICAgdXZzW2luZGV4XSA9IGFtb3VudDtcbiAgICAgIHV2c1tpbmRleCArIDFdID0gMDtcbiAgICAgIHV2c1tpbmRleCArIDJdID0gYW1vdW50O1xuICAgICAgdXZzW2luZGV4ICsgM10gPSAxO1xuICAgIH1cbiAgICBsZXQgaW5kZXhDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBpICogMjtcbiAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4O1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAyO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAyO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAzO1xuICAgIH1cbiAgICB1dkJ1ZmZlci51cGRhdGUoKTtcbiAgICBpbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XG4gIH1cbiAgdXBkYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gICAgbGV0IG5leHRQb2ludDtcbiAgICBsZXQgcGVycFggPSAwO1xuICAgIGxldCBwZXJwWSA9IDA7XG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLmJ1ZmZlcnNbMF0uZGF0YTtcbiAgICBjb25zdCB0b3RhbCA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgaGFsZldpZHRoID0gdGhpcy50ZXh0dXJlU2NhbGUgPiAwID8gdGhpcy50ZXh0dXJlU2NhbGUgKiB0aGlzLl93aWR0aCAvIDIgOiB0aGlzLl93aWR0aCAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQ7XG4gICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludDtcbiAgICAgIH1cbiAgICAgIHBlcnBZID0gLShuZXh0UG9pbnQueCAtIGxhc3RQb2ludC54KTtcbiAgICAgIHBlcnBYID0gbmV4dFBvaW50LnkgLSBsYXN0UG9pbnQueTtcbiAgICAgIGxldCByYXRpbyA9ICgxIC0gaSAvICh0b3RhbCAtIDEpKSAqIDEwO1xuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICByYXRpbyA9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KHBlcnBYICogcGVycFggKyBwZXJwWSAqIHBlcnBZKTtcbiAgICAgIGlmIChwZXJwTGVuZ3RoIDwgMWUtNikge1xuICAgICAgICBwZXJwWCA9IDA7XG4gICAgICAgIHBlcnBZID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcnBYIC89IHBlcnBMZW5ndGg7XG4gICAgICAgIHBlcnBZIC89IHBlcnBMZW5ndGg7XG4gICAgICAgIHBlcnBYICo9IGhhbGZXaWR0aDtcbiAgICAgICAgcGVycFkgKj0gaGFsZldpZHRoO1xuICAgICAgfVxuICAgICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnBYO1xuICAgICAgdmVydGljZXNbaW5kZXggKyAxXSA9IHBvaW50LnkgKyBwZXJwWTtcbiAgICAgIHZlcnRpY2VzW2luZGV4ICsgMl0gPSBwb2ludC54IC0gcGVycFg7XG4gICAgICB2ZXJ0aWNlc1tpbmRleCArIDNdID0gcG9pbnQueSAtIHBlcnBZO1xuICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMudGV4dHVyZVNjYWxlID4gMCkge1xuICAgICAgdGhpcy5idWlsZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFJvcGVHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um9wZUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IE1lc2gsIE1lc2hNYXRlcmlhbCB9IGZyb20gJ0BwaXhpL21lc2gnO1xuaW1wb3J0IHsgUGxhbmVHZW9tZXRyeSB9IGZyb20gJy4vZ2VvbWV0cnkvUGxhbmVHZW9tZXRyeS5tanMnO1xuXG5jbGFzcyBTaW1wbGVQbGFuZSBleHRlbmRzIE1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCB2ZXJ0aWNlc1gsIHZlcnRpY2VzWSkge1xuICAgIGNvbnN0IHBsYW5lR2VvbWV0cnkgPSBuZXcgUGxhbmVHZW9tZXRyeSh0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCwgdmVydGljZXNYLCB2ZXJ0aWNlc1kpO1xuICAgIGNvbnN0IG1lc2hNYXRlcmlhbCA9IG5ldyBNZXNoTWF0ZXJpYWwoVGV4dHVyZS5XSElURSk7XG4gICAgc3VwZXIocGxhbmVHZW9tZXRyeSwgbWVzaE1hdGVyaWFsKTtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHRydWU7XG4gIH1cbiAgdGV4dHVyZVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5zaGFkZXIudGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zaGFkZXIudGV4dHVyZTtcbiAgICBpZiAodGhpcy5hdXRvUmVzaXplICYmIChnZW9tZXRyeS53aWR0aCAhPT0gd2lkdGggfHwgZ2VvbWV0cnkuaGVpZ2h0ICE9PSBoZWlnaHQpKSB7XG4gICAgICBnZW9tZXRyeS53aWR0aCA9IHRoaXMuc2hhZGVyLnRleHR1cmUud2lkdGg7XG4gICAgICBnZW9tZXRyeS5oZWlnaHQgPSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodDtcbiAgICAgIGdlb21ldHJ5LmJ1aWxkKCk7XG4gICAgfVxuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2hhZGVyLnRleHR1cmUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2hhZGVyLnRleHR1cmUgPSB2YWx1ZTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgIHRoaXMudGV4dHVyZVVwZGF0ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUub25jZShcInVwZGF0ZVwiLCB0aGlzLnRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyLnRleHR1cmU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLl90ZXh0dXJlSUQgIT09IHRoaXMuc2hhZGVyLnRleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICB0aGlzLnRleHR1cmVVcGRhdGVkKCk7XG4gICAgfVxuICAgIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHRoaXMuc2hhZGVyLnRleHR1cmUub2ZmKFwidXBkYXRlXCIsIHRoaXMudGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2ltcGxlUGxhbmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpbXBsZVBsYW5lLm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IFNpbXBsZVBsYW5lIH0gZnJvbSAnLi9TaW1wbGVQbGFuZS5tanMnO1xuXG5jb25zdCBERUZBVUxUX0JPUkRFUl9TSVpFID0gMTA7XG5jbGFzcyBOaW5lU2xpY2VQbGFuZSBleHRlbmRzIFNpbXBsZVBsYW5lIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgbGVmdFdpZHRoLCB0b3BIZWlnaHQsIHJpZ2h0V2lkdGgsIGJvdHRvbUhlaWdodCkge1xuICAgIHN1cGVyKFRleHR1cmUuV0hJVEUsIDQsIDQpO1xuICAgIHRoaXMuX29yaWdXaWR0aCA9IHRleHR1cmUub3JpZy53aWR0aDtcbiAgICB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX29yaWdXaWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9vcmlnSGVpZ2h0O1xuICAgIHRoaXMuX2xlZnRXaWR0aCA9IGxlZnRXaWR0aCA/PyB0ZXh0dXJlLmRlZmF1bHRCb3JkZXJzPy5sZWZ0ID8/IERFRkFVTFRfQk9SREVSX1NJWkU7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IHJpZ2h0V2lkdGggPz8gdGV4dHVyZS5kZWZhdWx0Qm9yZGVycz8ucmlnaHQgPz8gREVGQVVMVF9CT1JERVJfU0laRTtcbiAgICB0aGlzLl90b3BIZWlnaHQgPSB0b3BIZWlnaHQgPz8gdGV4dHVyZS5kZWZhdWx0Qm9yZGVycz8udG9wID8/IERFRkFVTFRfQk9SREVSX1NJWkU7XG4gICAgdGhpcy5fYm90dG9tSGVpZ2h0ID0gYm90dG9tSGVpZ2h0ID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LmJvdHRvbSA/PyBERUZBVUxUX0JPUkRFUl9TSVpFO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gIH1cbiAgdGV4dHVyZVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5zaGFkZXIudGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCB2ZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YTtcbiAgfVxuICBzZXQgdmVydGljZXModmFsdWUpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhID0gdmFsdWU7XG4gIH1cbiAgdXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2dldE1pblNjYWxlKCk7XG4gICAgdmVydGljZXNbOV0gPSB2ZXJ0aWNlc1sxMV0gPSB2ZXJ0aWNlc1sxM10gPSB2ZXJ0aWNlc1sxNV0gPSB0aGlzLl90b3BIZWlnaHQgKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1sxN10gPSB2ZXJ0aWNlc1sxOV0gPSB2ZXJ0aWNlc1syMV0gPSB2ZXJ0aWNlc1syM10gPSB0aGlzLl9oZWlnaHQgLSB0aGlzLl9ib3R0b21IZWlnaHQgKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1syNV0gPSB2ZXJ0aWNlc1syN10gPSB2ZXJ0aWNlc1syOV0gPSB2ZXJ0aWNlc1szMV0gPSB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgdXBkYXRlVmVydGljYWxWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9nZXRNaW5TY2FsZSgpO1xuICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbMTBdID0gdmVydGljZXNbMThdID0gdmVydGljZXNbMjZdID0gdGhpcy5fbGVmdFdpZHRoICogc2NhbGU7XG4gICAgdmVydGljZXNbNF0gPSB2ZXJ0aWNlc1sxMl0gPSB2ZXJ0aWNlc1syMF0gPSB2ZXJ0aWNlc1syOF0gPSB0aGlzLl93aWR0aCAtIHRoaXMuX3JpZ2h0V2lkdGggKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1s2XSA9IHZlcnRpY2VzWzE0XSA9IHZlcnRpY2VzWzIyXSA9IHZlcnRpY2VzWzMwXSA9IHRoaXMuX3dpZHRoO1xuICB9XG4gIF9nZXRNaW5TY2FsZSgpIHtcbiAgICBjb25zdCB3ID0gdGhpcy5fbGVmdFdpZHRoICsgdGhpcy5fcmlnaHRXaWR0aDtcbiAgICBjb25zdCBzY2FsZVcgPSB0aGlzLl93aWR0aCA+IHcgPyAxIDogdGhpcy5fd2lkdGggLyB3O1xuICAgIGNvbnN0IGggPSB0aGlzLl90b3BIZWlnaHQgKyB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVIID0gdGhpcy5faGVpZ2h0ID4gaCA/IDEgOiB0aGlzLl9oZWlnaHQgLyBoO1xuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oc2NhbGVXLCBzY2FsZUgpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCBsZWZ0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlZnRXaWR0aDtcbiAgfVxuICBzZXQgbGVmdFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fbGVmdFdpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCByaWdodFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9yaWdodFdpZHRoO1xuICB9XG4gIHNldCByaWdodFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgdG9wSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl90b3BIZWlnaHQ7XG4gIH1cbiAgc2V0IHRvcEhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX3RvcEhlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgYm90dG9tSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gIH1cbiAgc2V0IGJvdHRvbUhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2JvdHRvbUhlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIGNvbnN0IHV2cyA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXS5kYXRhO1xuICAgIHRoaXMuX29yaWdXaWR0aCA9IHRleHR1cmUub3JpZy53aWR0aDtcbiAgICB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICBjb25zdCBfdXZ3ID0gMSAvIHRoaXMuX29yaWdXaWR0aDtcbiAgICBjb25zdCBfdXZoID0gMSAvIHRoaXMuX29yaWdIZWlnaHQ7XG4gICAgdXZzWzBdID0gdXZzWzhdID0gdXZzWzE2XSA9IHV2c1syNF0gPSAwO1xuICAgIHV2c1sxXSA9IHV2c1szXSA9IHV2c1s1XSA9IHV2c1s3XSA9IDA7XG4gICAgdXZzWzZdID0gdXZzWzE0XSA9IHV2c1syMl0gPSB1dnNbMzBdID0gMTtcbiAgICB1dnNbMjVdID0gdXZzWzI3XSA9IHV2c1syOV0gPSB1dnNbMzFdID0gMTtcbiAgICB1dnNbMl0gPSB1dnNbMTBdID0gdXZzWzE4XSA9IHV2c1syNl0gPSBfdXZ3ICogdGhpcy5fbGVmdFdpZHRoO1xuICAgIHV2c1s0XSA9IHV2c1sxMl0gPSB1dnNbMjBdID0gdXZzWzI4XSA9IDEgLSBfdXZ3ICogdGhpcy5fcmlnaHRXaWR0aDtcbiAgICB1dnNbOV0gPSB1dnNbMTFdID0gdXZzWzEzXSA9IHV2c1sxNV0gPSBfdXZoICogdGhpcy5fdG9wSGVpZ2h0O1xuICAgIHV2c1sxN10gPSB1dnNbMTldID0gdXZzWzIxXSA9IHV2c1syM10gPSAxIC0gX3V2aCAqIHRoaXMuX2JvdHRvbUhlaWdodDtcbiAgICB0aGlzLnVwZGF0ZUhvcml6b250YWxWZXJ0aWNlcygpO1xuICAgIHRoaXMudXBkYXRlVmVydGljYWxWZXJ0aWNlcygpO1xuICAgIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgICB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV0udXBkYXRlKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgTmluZVNsaWNlUGxhbmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5pbmVTbGljZVBsYW5lLm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IE1lc2gsIE1lc2hHZW9tZXRyeSwgTWVzaE1hdGVyaWFsIH0gZnJvbSAnQHBpeGkvbWVzaCc7XG5cbmNsYXNzIFNpbXBsZU1lc2ggZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSA9IFRleHR1cmUuRU1QVFksIHZlcnRpY2VzLCB1dnMsIGluZGljZXMsIGRyYXdNb2RlKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgTWVzaEdlb21ldHJ5KHZlcnRpY2VzLCB1dnMsIGluZGljZXMpO1xuICAgIGdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5zdGF0aWMgPSBmYWxzZTtcbiAgICBjb25zdCBtZXNoTWF0ZXJpYWwgPSBuZXcgTWVzaE1hdGVyaWFsKHRleHR1cmUpO1xuICAgIHN1cGVyKGdlb21ldHJ5LCBtZXNoTWF0ZXJpYWwsIG51bGwsIGRyYXdNb2RlKTtcbiAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuICB9XG4gIGdldCB2ZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YTtcbiAgfVxuICBzZXQgdmVydGljZXModmFsdWUpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhID0gdmFsdWU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLmF1dG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgeyBTaW1wbGVNZXNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaW1wbGVNZXNoLm1qcy5tYXBcbiIsImltcG9ydCB7IFdSQVBfTU9ERVMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IE1lc2gsIE1lc2hNYXRlcmlhbCB9IGZyb20gJ0BwaXhpL21lc2gnO1xuaW1wb3J0IHsgUm9wZUdlb21ldHJ5IH0gZnJvbSAnLi9nZW9tZXRyeS9Sb3BlR2VvbWV0cnkubWpzJztcblxuY2xhc3MgU2ltcGxlUm9wZSBleHRlbmRzIE1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBwb2ludHMsIHRleHR1cmVTY2FsZSA9IDApIHtcbiAgICBjb25zdCByb3BlR2VvbWV0cnkgPSBuZXcgUm9wZUdlb21ldHJ5KHRleHR1cmUuaGVpZ2h0LCBwb2ludHMsIHRleHR1cmVTY2FsZSk7XG4gICAgY29uc3QgbWVzaE1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbCh0ZXh0dXJlKTtcbiAgICBpZiAodGV4dHVyZVNjYWxlID4gMCkge1xuICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS53cmFwTW9kZSA9IFdSQVBfTU9ERVMuUkVQRUFUO1xuICAgIH1cbiAgICBzdXBlcihyb3BlR2VvbWV0cnksIG1lc2hNYXRlcmlhbCk7XG4gICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGlmICh0aGlzLmF1dG9VcGRhdGUgfHwgZ2VvbWV0cnkuX3dpZHRoICE9PSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodCkge1xuICAgICAgZ2VvbWV0cnkuX3dpZHRoID0gdGhpcy5zaGFkZXIudGV4dHVyZS5oZWlnaHQ7XG4gICAgICBnZW9tZXRyeS51cGRhdGUoKTtcbiAgICB9XG4gICAgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2ltcGxlUm9wZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlUm9wZS5tanMubWFwXG4iLCJleHBvcnQgeyBQbGFuZUdlb21ldHJ5IH0gZnJvbSAnLi9nZW9tZXRyeS9QbGFuZUdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBSb3BlR2VvbWV0cnkgfSBmcm9tICcuL2dlb21ldHJ5L1JvcGVHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgTmluZVNsaWNlUGxhbmUgfSBmcm9tICcuL05pbmVTbGljZVBsYW5lLm1qcyc7XG5leHBvcnQgeyBTaW1wbGVNZXNoIH0gZnJvbSAnLi9TaW1wbGVNZXNoLm1qcyc7XG5leHBvcnQgeyBTaW1wbGVQbGFuZSB9IGZyb20gJy4vU2ltcGxlUGxhbmUubWpzJztcbmV4cG9ydCB7IFNpbXBsZVJvcGUgfSBmcm9tICcuL1NpbXBsZVJvcGUubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IEJMRU5EX01PREVTLCBDb2xvciB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnQHBpeGkvZGlzcGxheSc7XG5cbmNsYXNzIFBhcnRpY2xlQ29udGFpbmVyIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDE1MDAsIHByb3BlcnRpZXMsIGJhdGNoU2l6ZSA9IDE2Mzg0LCBhdXRvUmVzaXplID0gZmFsc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG1heEJhdGNoU2l6ZSA9IDE2Mzg0O1xuICAgIGlmIChiYXRjaFNpemUgPiBtYXhCYXRjaFNpemUpIHtcbiAgICAgIGJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZTtcbiAgICB9XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IFtmYWxzZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XG4gICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemU7XG4gICAgdGhpcy5fYmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcyA9IFtdO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IEJMRU5EX01PREVTLk5PUk1BTDtcbiAgICB0aGlzLmF1dG9SZXNpemUgPSBhdXRvUmVzaXplO1xuICAgIHRoaXMucm91bmRQaXhlbHMgPSB0cnVlO1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBuZXcgQ29sb3IoMCk7XG4gICAgdGhpcy50aW50UmdiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICB0aGlzLnRpbnQgPSAxNjc3NzIxNTtcbiAgfVxuICBzZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcHJvcGVydGllc1swXSA9IFwidmVydGljZXNcIiBpbiBwcm9wZXJ0aWVzIHx8IFwic2NhbGVcIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnZlcnRpY2VzIHx8ICEhcHJvcGVydGllcy5zY2FsZSA6IHRoaXMuX3Byb3BlcnRpZXNbMF07XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzWzFdID0gXCJwb3NpdGlvblwiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMucG9zaXRpb24gOiB0aGlzLl9wcm9wZXJ0aWVzWzFdO1xuICAgICAgdGhpcy5fcHJvcGVydGllc1syXSA9IFwicm90YXRpb25cIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnJvdGF0aW9uIDogdGhpcy5fcHJvcGVydGllc1syXTtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXNbM10gPSBcInV2c1wiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudXZzIDogdGhpcy5fcHJvcGVydGllc1szXTtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXNbNF0gPSBcInRpbnRcIiBpbiBwcm9wZXJ0aWVzIHx8IFwiYWxwaGFcIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnRpbnQgfHwgISFwcm9wZXJ0aWVzLmFscGhhIDogdGhpcy5fcHJvcGVydGllc1s0XTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIGdldCB0aW50KCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICB0aGlzLl90aW50Q29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgIHRoaXMuX3RpbnRDb2xvci50b1JnYkFycmF5KHRoaXMudGludFJnYik7XG4gIH1cbiAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmJhc2VUZXh0dXJlKSB7XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlID0gdGhpcy5jaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgIGlmICghdGhpcy5iYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9uY2UoXCJ1cGRhdGVcIiwgKCkgPT4gdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKDApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZSk7XG4gICAgcmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgb25DaGlsZHJlbkNoYW5nZShzbWFsbGVzdENoaWxkSW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJJbmRleCA9IE1hdGguZmxvb3Ioc21hbGxlc3RDaGlsZEluZGV4IC8gdGhpcy5fYmF0Y2hTaXplKTtcbiAgICB3aGlsZSAodGhpcy5fYnVmZmVyVXBkYXRlSURzLmxlbmd0aCA8IGJ1ZmZlckluZGV4KSB7XG4gICAgICB0aGlzLl9idWZmZXJVcGRhdGVJRHMucHVzaCgwKTtcbiAgICB9XG4gICAgdGhpcy5fYnVmZmVyVXBkYXRlSURzW2J1ZmZlckluZGV4XSA9ICsrdGhpcy5fdXBkYXRlSUQ7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVycykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG51bGw7XG4gICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5fYnVmZmVyVXBkYXRlSURzID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBQYXJ0aWNsZUNvbnRhaW5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVDb250YWluZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgR2VvbWV0cnksIFRZUEVTLCBCdWZmZXIsIHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNsYXNzIFBhcnRpY2xlQnVmZmVyIHtcbiAgY29uc3RydWN0b3IocHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIHNpemUpIHtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkgPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsXG4gICAgICAgIHNpemU6IHByb3BlcnR5LnNpemUsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbixcbiAgICAgICAgdHlwZTogcHJvcGVydHkudHlwZSB8fCBUWVBFUy5GTE9BVCxcbiAgICAgICAgb2Zmc2V0OiBwcm9wZXJ0eS5vZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoZHluYW1pY1Byb3BlcnR5RmxhZ3NbaV0pIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwO1xuICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG51bGw7XG4gICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLmluaXRCdWZmZXJzKCk7XG4gIH1cbiAgaW5pdEJ1ZmZlcnMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcih1dGlscy5jcmVhdGVJbmRpY2VzRm9yUXVhZHModGhpcy5zaXplKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VvbWV0cnkuYWRkSW5kZXgodGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5Lm9mZnNldCA9IGR5bmFtaWNPZmZzZXQ7XG4gICAgICBkeW5hbWljT2Zmc2V0ICs9IHByb3BlcnR5LnNpemU7XG4gICAgICB0aGlzLmR5bmFtaWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICB9XG4gICAgY29uc3QgZHluQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSAqIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQgKiA0KTtcbiAgICB0aGlzLmR5bmFtaWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheShkeW5CdWZmZXIpO1xuICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoZHluQnVmZmVyKTtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMuZHluYW1pY0RhdGEsIGZhbHNlLCBmYWxzZSk7XG4gICAgbGV0IHN0YXRpY09mZnNldCA9IDA7XG4gICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5Lm9mZnNldCA9IHN0YXRpY09mZnNldDtcbiAgICAgIHN0YXRpY09mZnNldCArPSBwcm9wZXJ0eS5zaXplO1xuICAgICAgdGhpcy5zdGF0aWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLnNpemUgKiB0aGlzLnN0YXRpY1N0cmlkZSAqIDQgKiA0KTtcbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXRCdWZmZXIpO1xuICAgIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShzdGF0QnVmZmVyKTtcbiAgICB0aGlzLnN0YXRpY0J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5zdGF0aWNEYXRhLCB0cnVlLCBmYWxzZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG4gICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUocHJvcGVydHkuYXR0cmlidXRlTmFtZSwgdGhpcy5keW5hbWljQnVmZmVyLCAwLCBwcm9wZXJ0eS50eXBlID09PSBUWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eS50eXBlLCB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0LCBwcm9wZXJ0eS5vZmZzZXQgKiA0KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsIHRoaXMuc3RhdGljQnVmZmVyLCAwLCBwcm9wZXJ0eS50eXBlID09PSBUWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eS50eXBlLCB0aGlzLnN0YXRpY1N0cmlkZSAqIDQsIHByb3BlcnR5Lm9mZnNldCAqIDQpO1xuICAgIH1cbiAgfVxuICB1cGxvYWREeW5hbWljKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIHByb3BlcnR5LnR5cGUgPT09IFRZUEVTLlVOU0lHTkVEX0JZVEUgPyB0aGlzLmR5bmFtaWNEYXRhVWludDMyIDogdGhpcy5keW5hbWljRGF0YSwgdGhpcy5keW5hbWljU3RyaWRlLCBwcm9wZXJ0eS5vZmZzZXQpO1xuICAgIH1cbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gIH1cbiAgdXBsb2FkU3RhdGljKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaV07XG4gICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBwcm9wZXJ0eS50eXBlID09PSBUWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5zdGF0aWNEYXRhVWludDMyIDogdGhpcy5zdGF0aWNEYXRhLCB0aGlzLnN0YXRpY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcbiAgICB9XG4gICAgdGhpcy5zdGF0aWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljUHJvcGVydGllcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljRGF0YSA9IG51bGw7XG4gICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICB0aGlzLmdlb21ldHJ5LmRlc3Ryb3koKTtcbiAgfVxufVxuXG5leHBvcnQgeyBQYXJ0aWNsZUJ1ZmZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVCdWZmZXIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKXtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGljbGVzLm1qcy5tYXBcbiIsInZhciB2ZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb25Db29yZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYVJvdGF0aW9uO1xcblxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgICBmbG9hdCB4ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIGNvcyhhUm90YXRpb24pIC0gKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIHNpbihhUm90YXRpb24pO1xcbiAgICBmbG9hdCB5ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIHNpbihhUm90YXRpb24pICsgKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIGNvcyhhUm90YXRpb24pO1xcblxcbiAgICB2ZWMyIHYgPSB2ZWMyKHgsIHkpO1xcbiAgICB2ID0gdiArIGFQb3NpdGlvbkNvb3JkO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyh2LCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdkNvbG9yID0gYUNvbG9yICogdUNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgdmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpY2xlczIubWpzLm1hcFxuIiwiaW1wb3J0IHsgT2JqZWN0UmVuZGVyZXIsIE1hdHJpeCwgVFlQRVMsIFNoYWRlciwgU3RhdGUsIHV0aWxzLCBDb2xvciwgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgUGFydGljbGVCdWZmZXIgfSBmcm9tICcuL1BhcnRpY2xlQnVmZmVyLm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9wYXJ0aWNsZXMubWpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi9wYXJ0aWNsZXMyLm1qcyc7XG5cbmNsYXNzIFBhcnRpY2xlUmVuZGVyZXIgZXh0ZW5kcyBPYmplY3RSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpO1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBudWxsO1xuICAgIHRoaXMudGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBbXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVZlcnRleFBvc2l0aW9uXCIsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFZlcnRpY2VzLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVBvc2l0aW9uQ29vcmRcIixcbiAgICAgICAgc2l6ZTogMixcbiAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkUG9zaXRpb24sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhUm90YXRpb25cIixcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkUm90YXRpb24sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhVGV4dHVyZUNvb3JkXCIsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFV2cyxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBcImFDb2xvclwiLFxuICAgICAgICBzaXplOiAxLFxuICAgICAgICB0eXBlOiBUWVBFUy5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRUaW50LFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICBdO1xuICAgIHRoaXMuc2hhZGVyID0gU2hhZGVyLmZyb20odmVydGV4LCBmcmFnbWVudCwge30pO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5mb3IyZCgpO1xuICB9XG4gIHJlbmRlcihjb250YWluZXIpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICBjb25zdCBtYXhTaXplID0gY29udGFpbmVyLl9tYXhTaXplO1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAodG90YWxDaGlsZHJlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodG90YWxDaGlsZHJlbiA+IG1heFNpemUgJiYgIWNvbnRhaW5lci5hdXRvUmVzaXplKSB7XG4gICAgICB0b3RhbENoaWxkcmVuID0gbWF4U2l6ZTtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlcnMgPSBjb250YWluZXIuX2J1ZmZlcnM7XG4gICAgaWYgKCFidWZmZXJzKSB7XG4gICAgICBidWZmZXJzID0gY29udGFpbmVyLl9idWZmZXJzID0gdGhpcy5nZW5lcmF0ZUJ1ZmZlcnMoY29udGFpbmVyKTtcbiAgICB9XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBjaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBjb25zdCBwcmVtdWx0aXBsaWVkID0gYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMDtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHV0aWxzLmNvcnJlY3RCbGVuZE1vZGUoY29udGFpbmVyLmJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZCk7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgY29uc3QgbSA9IGNvbnRhaW5lci53b3JsZFRyYW5zZm9ybS5jb3B5VG8odGhpcy50ZW1wTWF0cml4KTtcbiAgICBtLnByZXBlbmQocmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSBtLnRvQXJyYXkodHJ1ZSk7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudUNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbnRhaW5lci50aW50UmdiKS5wcmVtdWx0aXBseShjb250YWluZXIud29ybGRBbHBoYSwgcHJlbXVsdGlwbGllZCkudG9BcnJheSh0aGlzLnNoYWRlci51bmlmb3Jtcy51Q29sb3IpO1xuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gYmFzZVRleHR1cmU7XG4gICAgdGhpcy5yZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzLnNoYWRlcik7XG4gICAgbGV0IHVwZGF0ZVN0YXRpYyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsQ2hpbGRyZW47IGkgKz0gYmF0Y2hTaXplLCBqICs9IDEpIHtcbiAgICAgIGxldCBhbW91bnQgPSB0b3RhbENoaWxkcmVuIC0gaTtcbiAgICAgIGlmIChhbW91bnQgPiBiYXRjaFNpemUpIHtcbiAgICAgICAgYW1vdW50ID0gYmF0Y2hTaXplO1xuICAgICAgfVxuICAgICAgaWYgKGogPj0gYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKHRoaXMuX2dlbmVyYXRlT25lTW9yZUJ1ZmZlcihjb250YWluZXIpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG4gICAgICBidWZmZXIudXBsb2FkRHluYW1pYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcbiAgICAgIGNvbnN0IGJpZCA9IGNvbnRhaW5lci5fYnVmZmVyVXBkYXRlSURzW2pdIHx8IDA7XG4gICAgICB1cGRhdGVTdGF0aWMgPSB1cGRhdGVTdGF0aWMgfHwgYnVmZmVyLl91cGRhdGVJRCA8IGJpZDtcbiAgICAgIGlmICh1cGRhdGVTdGF0aWMpIHtcbiAgICAgICAgYnVmZmVyLl91cGRhdGVJRCA9IGNvbnRhaW5lci5fdXBkYXRlSUQ7XG4gICAgICAgIGJ1ZmZlci51cGxvYWRTdGF0aWMoY2hpbGRyZW4sIGksIGFtb3VudCk7XG4gICAgICB9XG4gICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKGJ1ZmZlci5nZW9tZXRyeSk7XG4gICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBhbW91bnQgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgfVxuICB9XG4gIGdlbmVyYXRlQnVmZmVycyhjb250YWluZXIpIHtcbiAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgY29uc3Qgc2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZTtcbiAgICBjb25zdCBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZTtcbiAgICBjb25zdCBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgICBidWZmZXJzLnB1c2gobmV3IFBhcnRpY2xlQnVmZmVyKHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVycztcbiAgfVxuICBfZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgIGNvbnN0IGR5bmFtaWNQcm9wZXJ0eUZsYWdzID0gY29udGFpbmVyLl9wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBuZXcgUGFydGljbGVCdWZmZXIodGhpcy5wcm9wZXJ0aWVzLCBkeW5hbWljUHJvcGVydHlGbGFncywgYmF0Y2hTaXplKTtcbiAgfVxuICB1cGxvYWRWZXJ0aWNlcyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBsZXQgdzAgPSAwO1xuICAgIGxldCB3MSA9IDA7XG4gICAgbGV0IGgwID0gMDtcbiAgICBsZXQgaDEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgICBjb25zdCBzeCA9IHNwcml0ZS5zY2FsZS54O1xuICAgICAgY29uc3Qgc3kgPSBzcHJpdGUuc2NhbGUueTtcbiAgICAgIGNvbnN0IHRyaW0gPSB0ZXh0dXJlLnRyaW07XG4gICAgICBjb25zdCBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgdzEgPSB0cmltLnggLSBzcHJpdGUuYW5jaG9yLnggKiBvcmlnLndpZHRoO1xuICAgICAgICB3MCA9IHcxICsgdHJpbS53aWR0aDtcbiAgICAgICAgaDEgPSB0cmltLnkgLSBzcHJpdGUuYW5jaG9yLnkgKiBvcmlnLmhlaWdodDtcbiAgICAgICAgaDAgPSBoMSArIHRyaW0uaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdzAgPSBvcmlnLndpZHRoICogKDEgLSBzcHJpdGUuYW5jaG9yLngpO1xuICAgICAgICB3MSA9IG9yaWcud2lkdGggKiAtc3ByaXRlLmFuY2hvci54O1xuICAgICAgICBoMCA9IG9yaWcuaGVpZ2h0ICogKDEgLSBzcHJpdGUuYW5jaG9yLnkpO1xuICAgICAgICBoMSA9IG9yaWcuaGVpZ2h0ICogLXNwcml0ZS5hbmNob3IueTtcbiAgICAgIH1cbiAgICAgIGFycmF5W29mZnNldF0gPSB3MSAqIHN4O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBoMSAqIHN5O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHcwICogc3g7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IGgxICogc3k7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHcwICogc3g7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBoMCAqIHN5O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSB3MSAqIHN4O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gaDAgKiBzeTtcbiAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbiAgfVxuICB1cGxvYWRQb3NpdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzcHJpdGVQb3NpdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5wb3NpdGlvbjtcbiAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVBvc2l0aW9uLng7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnk7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHNwcml0ZVBvc2l0aW9uLng7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcbiAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbiAgfVxuICB1cGxvYWRSb3RhdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzcHJpdGVSb3RhdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5yb3RhdGlvbjtcbiAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gc3ByaXRlUm90YXRpb247XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZVJvdGF0aW9uO1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxuICB9XG4gIHVwbG9hZFV2cyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlVXZzID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLl90ZXh0dXJlLl91dnM7XG4gICAgICBpZiAodGV4dHVyZVV2cykge1xuICAgICAgICBhcnJheVtvZmZzZXRdID0gdGV4dHVyZVV2cy54MDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0ZXh0dXJlVXZzLnkwO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdGV4dHVyZVV2cy54MTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSB0ZXh0dXJlVXZzLnkxO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHRleHR1cmVVdnMueDI7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IHRleHR1cmVVdnMueTI7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gdGV4dHVyZVV2cy54MztcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gdGV4dHVyZVV2cy55MztcbiAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVtvZmZzZXRdID0gMDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAwO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gMDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSAwO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IDA7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IDA7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gMDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gMDtcbiAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwbG9hZFRpbnQoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgY29uc3Qgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldO1xuICAgICAgY29uc3QgcmVzdWx0ID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHNwcml0ZS5fdGludFJHQikudG9QcmVtdWx0aXBsaWVkKHNwcml0ZS5hbHBoYSk7XG4gICAgICBhcnJheVtvZmZzZXRdID0gcmVzdWx0O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHJlc3VsdDtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gcmVzdWx0O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSByZXN1bHQ7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMudGVtcE1hdHJpeCA9IG51bGw7XG4gIH1cbn1cblBhcnRpY2xlUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcInBhcnRpY2xlXCIsXG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJQbHVnaW5cbn07XG5leHRlbnNpb25zLmFkZChQYXJ0aWNsZVJlbmRlcmVyKTtcblxuZXhwb3J0IHsgUGFydGljbGVSZW5kZXJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVSZW5kZXJlci5tanMubWFwXG4iLCJleHBvcnQgeyBQYXJ0aWNsZUNvbnRhaW5lciB9IGZyb20gJy4vUGFydGljbGVDb250YWluZXIubWpzJztcbmV4cG9ydCB7IFBhcnRpY2xlUmVuZGVyZXIgfSBmcm9tICcuL1BhcnRpY2xlUmVuZGVyZXIubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsInZhciBURVhUX0dSQURJRU5UID0gLyogQF9fUFVSRV9fICovICgoVEVYVF9HUkFESUVOVDIpID0+IHtcbiAgVEVYVF9HUkFESUVOVDJbVEVYVF9HUkFESUVOVDJbXCJMSU5FQVJfVkVSVElDQUxcIl0gPSAwXSA9IFwiTElORUFSX1ZFUlRJQ0FMXCI7XG4gIFRFWFRfR1JBRElFTlQyW1RFWFRfR1JBRElFTlQyW1wiTElORUFSX0hPUklaT05UQUxcIl0gPSAxXSA9IFwiTElORUFSX0hPUklaT05UQUxcIjtcbiAgcmV0dXJuIFRFWFRfR1JBRElFTlQyO1xufSkoVEVYVF9HUkFESUVOVCB8fCB7fSk7XG5cbmV4cG9ydCB7IFRFWFRfR1JBRElFTlQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGNvbnRleHRTZXR0aW5ncyA9IHtcbiAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG59O1xuY29uc3QgX1RleHRNZXRyaWNzID0gY2xhc3Mge1xuICBzdGF0aWMgZ2V0IGV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQoKSB7XG4gICAgbGV0IHJlc3VsdCA9IF9UZXh0TWV0cmljcy5fZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZDtcbiAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHByb3RvID0gc2V0dGluZ3MuQURBUFRFUi5nZXRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQoKS5wcm90b3R5cGU7XG4gICAgICByZXN1bHQgPSBfVGV4dE1ldHJpY3MuX2V4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQgPSBcImxldHRlclNwYWNpbmdcIiBpbiBwcm90byB8fCBcInRleHRMZXR0ZXJTcGFjaW5nXCIgaW4gcHJvdG87XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0LCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgdGhpcy5tYXhMaW5lV2lkdGggPSBtYXhMaW5lV2lkdGg7XG4gICAgdGhpcy5mb250UHJvcGVydGllcyA9IGZvbnRQcm9wZXJ0aWVzO1xuICB9XG4gIHN0YXRpYyBtZWFzdXJlVGV4dCh0ZXh0LCBzdHlsZSwgd29yZFdyYXAsIGNhbnZhcyA9IF9UZXh0TWV0cmljcy5fY2FudmFzKSB7XG4gICAgd29yZFdyYXAgPSB3b3JkV3JhcCA9PT0gdm9pZCAwIHx8IHdvcmRXcmFwID09PSBudWxsID8gc3R5bGUud29yZFdyYXAgOiB3b3JkV3JhcDtcbiAgICBjb25zdCBmb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBfVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XG4gICAgaWYgKGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplID09PSAwKSB7XG4gICAgICBmb250UHJvcGVydGllcy5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgICAgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gc3R5bGUuZm9udFNpemU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBvdXRwdXRUZXh0ID0gd29yZFdyYXAgPyBfVGV4dE1ldHJpY3Mud29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykgOiB0ZXh0O1xuICAgIGNvbnN0IGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG4gICAgY29uc3QgbGluZVdpZHRocyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IF9UZXh0TWV0cmljcy5fbWVhc3VyZVRleHQobGluZXNbaV0sIHN0eWxlLmxldHRlclNwYWNpbmcsIGNvbnRleHQpO1xuICAgICAgbGluZVdpZHRoc1tpXSA9IGxpbmVXaWR0aDtcbiAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICB9XG4gICAgbGV0IHdpZHRoID0gbWF4TGluZVdpZHRoICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICB3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAqIDIpICsgKGxpbmVzLmxlbmd0aCAtIDEpICogKGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nKTtcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgaGVpZ2h0ICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVGV4dE1ldHJpY3ModGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZywgbWF4TGluZVdpZHRoLCBmb250UHJvcGVydGllcyk7XG4gIH1cbiAgc3RhdGljIF9tZWFzdXJlVGV4dCh0ZXh0LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSB7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbiAgICBpZiAoX1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChfVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIGlmICh1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgIHdpZHRoIC09IGxldHRlclNwYWNpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCArPSAoX1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyKHRleHQpLmxlbmd0aCAtIDEpICogbGV0dGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG4gIHN0YXRpYyB3b3JkV3JhcCh0ZXh0LCBzdHlsZSwgY2FudmFzID0gX1RleHRNZXRyaWNzLl9jYW52YXMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpO1xuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGxpbmUgPSBcIlwiO1xuICAgIGxldCBsaW5lcyA9IFwiXCI7XG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCB7IGxldHRlclNwYWNpbmcsIHdoaXRlU3BhY2UgfSA9IHN0eWxlO1xuICAgIGNvbnN0IGNvbGxhcHNlU3BhY2VzID0gX1RleHRNZXRyaWNzLmNvbGxhcHNlU3BhY2VzKHdoaXRlU3BhY2UpO1xuICAgIGNvbnN0IGNvbGxhcHNlTmV3bGluZXMgPSBfVGV4dE1ldHJpY3MuY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKTtcbiAgICBsZXQgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcbiAgICBjb25zdCB3b3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgY29uc3QgdG9rZW5zID0gX1RleHRNZXRyaWNzLnRva2VuaXplKHRleHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBpZiAoX1RleHRNZXRyaWNzLmlzTmV3bGluZSh0b2tlbikpIHtcbiAgICAgICAgaWYgKCFjb2xsYXBzZU5ld2xpbmVzKSB7XG4gICAgICAgICAgbGluZXMgKz0gX1RleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSBcIiBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzZVNwYWNlcykge1xuICAgICAgICBjb25zdCBjdXJySXNCcmVha2luZ1NwYWNlID0gX1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbik7XG4gICAgICAgIGNvbnN0IGxhc3RJc0JyZWFraW5nU3BhY2UgPSBfVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGxpbmVbbGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChjdXJySXNCcmVha2luZ1NwYWNlICYmIGxhc3RJc0JyZWFraW5nU3BhY2UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5XaWR0aCA9IF9UZXh0TWV0cmljcy5nZXRGcm9tQ2FjaGUodG9rZW4sIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcbiAgICAgIGlmICh0b2tlbldpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICBpZiAobGluZSAhPT0gXCJcIikge1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX1RleHRNZXRyaWNzLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IF9UZXh0TWV0cmljcy53b3JkV3JhcFNwbGl0KHRva2VuKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYXJhY3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gY2hhcmFjdGVyc1tqXTtcbiAgICAgICAgICAgIGxldCBsYXN0Q2hhciA9IGNoYXI7XG4gICAgICAgICAgICBsZXQgayA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyc1tqICsga10pIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyYWN0ZXJzW2ogKyBrXTtcbiAgICAgICAgICAgICAgaWYgKCFfVGV4dE1ldHJpY3MuY2FuQnJlYWtDaGFycyhsYXN0Q2hhciwgbmV4dENoYXIsIHRva2VuLCBqLCBzdHlsZS5icmVha1dvcmRzKSkge1xuICAgICAgICAgICAgICAgIGNoYXIgKz0gbmV4dENoYXI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdENoYXIgPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaiArPSBrIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlcldpZHRoID0gX1RleHRNZXRyaWNzLmdldEZyb21DYWNoZShjaGFyLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY2hhcmFjdGVyV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgbGluZXMgKz0gX1RleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmUgKz0gY2hhcjtcbiAgICAgICAgICAgIHdpZHRoICs9IGNoYXJhY3RlcldpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsaW5lcyArPSBfVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKHRva2VuLCAhaXNMYXN0VG9rZW4pO1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwIHx8ICFfVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKHRva2VuKSB8fCBjYW5QcmVwZW5kU3BhY2VzKSB7XG4gICAgICAgICAgbGluZSArPSB0b2tlbjtcbiAgICAgICAgICB3aWR0aCArPSB0b2tlbldpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUsIGZhbHNlKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgc3RhdGljIGFkZExpbmUobGluZSwgbmV3TGluZSA9IHRydWUpIHtcbiAgICBsaW5lID0gX1RleHRNZXRyaWNzLnRyaW1SaWdodChsaW5lKTtcbiAgICBsaW5lID0gbmV3TGluZSA/IGAke2xpbmV9XG5gIDogbGluZTtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuICBzdGF0aWMgZ2V0RnJvbUNhY2hlKGtleSwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpIHtcbiAgICBsZXQgd2lkdGggPSBjYWNoZVtrZXldO1xuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHdpZHRoID0gX1RleHRNZXRyaWNzLl9tZWFzdXJlVGV4dChrZXksIGxldHRlclNwYWNpbmcsIGNvbnRleHQpICsgbGV0dGVyU3BhY2luZztcbiAgICAgIGNhY2hlW2tleV0gPSB3aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG4gIHN0YXRpYyBjb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09IFwibm9ybWFsXCIgfHwgd2hpdGVTcGFjZSA9PT0gXCJwcmUtbGluZVwiO1xuICB9XG4gIHN0YXRpYyBjb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpIHtcbiAgICByZXR1cm4gd2hpdGVTcGFjZSA9PT0gXCJub3JtYWxcIjtcbiAgfVxuICBzdGF0aWMgdHJpbVJpZ2h0KHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICBpZiAoIV9UZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhcikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc05ld2xpbmUoY2hhcikge1xuICAgIGlmICh0eXBlb2YgY2hhciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX1RleHRNZXRyaWNzLl9uZXdsaW5lcy5pbmNsdWRlcyhjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICB9XG4gIHN0YXRpYyBpc0JyZWFraW5nU3BhY2UoY2hhciwgX25leHRDaGFyKSB7XG4gICAgaWYgKHR5cGVvZiBjaGFyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzLmluY2x1ZGVzKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gIH1cbiAgc3RhdGljIHRva2VuaXplKHRleHQpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgdG9rZW4gPSBcIlwiO1xuICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gdGV4dFtpXTtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICBpZiAoX1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShjaGFyLCBuZXh0Q2hhcikgfHwgX1RleHRNZXRyaWNzLmlzTmV3bGluZShjaGFyKSkge1xuICAgICAgICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgdG9rZW4gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKGNoYXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRva2VuICs9IGNoYXI7XG4gICAgfVxuICAgIGlmICh0b2tlbiAhPT0gXCJcIikge1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG4gIHN0YXRpYyBjYW5CcmVha1dvcmRzKF90b2tlbiwgYnJlYWtXb3Jkcykge1xuICAgIHJldHVybiBicmVha1dvcmRzO1xuICB9XG4gIHN0YXRpYyBjYW5CcmVha0NoYXJzKF9jaGFyLCBfbmV4dENoYXIsIF90b2tlbiwgX2luZGV4LCBfYnJlYWtXb3Jkcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyB3b3JkV3JhcFNwbGl0KHRva2VuKSB7XG4gICAgcmV0dXJuIF9UZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0b2tlbik7XG4gIH1cbiAgc3RhdGljIG1lYXN1cmVGb250KGZvbnQpIHtcbiAgICBpZiAoX1RleHRNZXRyaWNzLl9mb250c1tmb250XSkge1xuICAgICAgcmV0dXJuIF9UZXh0TWV0cmljcy5fZm9udHNbZm9udF07XG4gICAgfVxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBhc2NlbnQ6IDAsXG4gICAgICBkZXNjZW50OiAwLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9O1xuICAgIGNvbnN0IGNhbnZhcyA9IF9UZXh0TWV0cmljcy5fY2FudmFzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBfVGV4dE1ldHJpY3MuX2NvbnRleHQ7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBtZXRyaWNzU3RyaW5nID0gX1RleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HICsgX1RleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTDtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KG1ldHJpY3NTdHJpbmcpLndpZHRoKTtcbiAgICBsZXQgYmFzZWxpbmUgPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChfVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MKS53aWR0aCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKF9UZXh0TWV0cmljcy5IRUlHSFRfTVVMVElQTElFUiAqIGJhc2VsaW5lKTtcbiAgICBiYXNlbGluZSA9IGJhc2VsaW5lICogX1RleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgfCAwO1xuICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgIF9UZXh0TWV0cmljcy5fZm9udHNbZm9udF0gPSBwcm9wZXJ0aWVzO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNmMDBcIjtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xuICAgIGNvbnRleHQuZmlsbFRleHQobWV0cmljc1N0cmluZywgMCwgYmFzZWxpbmUpO1xuICAgIGNvbnN0IGltYWdlZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgY29uc3QgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBsaW5lID0gd2lkdGggKiA0O1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlbGluZTsgKytpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmU7IGogKz0gNCkge1xuICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpIHtcbiAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzdG9wKSB7XG4gICAgICAgIGlkeCArPSBsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpO1xuICAgIGlkeCA9IHBpeGVscyAtIGxpbmU7XG4gICAgc3RvcCA9IGZhbHNlO1xuICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyAtLWkpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZTsgaiArPSA0KSB7XG4gICAgICAgIGlmIChpbWFnZWRhdGFbaWR4ICsgal0gIT09IDI1NSkge1xuICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgaWR4IC09IGxpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcGVydGllcy5kZXNjZW50ID0gaSAtIGJhc2VsaW5lO1xuICAgIHByb3BlcnRpZXMuZm9udFNpemUgPSBwcm9wZXJ0aWVzLmFzY2VudCArIHByb3BlcnRpZXMuZGVzY2VudDtcbiAgICBfVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdID0gcHJvcGVydGllcztcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBzdGF0aWMgY2xlYXJNZXRyaWNzKGZvbnQgPSBcIlwiKSB7XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIGRlbGV0ZSBfVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX2NhbnZhcygpIHtcbiAgICBpZiAoIV9UZXh0TWV0cmljcy5fX2NhbnZhcykge1xuICAgICAgbGV0IGNhbnZhcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKTtcbiAgICAgICAgaWYgKGNvbnRleHQ/Lm1lYXN1cmVUZXh0KSB7XG4gICAgICAgICAgX1RleHRNZXRyaWNzLl9fY2FudmFzID0gYztcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMgPSBzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY2FudmFzID0gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxMDtcbiAgICAgIF9UZXh0TWV0cmljcy5fX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgcmV0dXJuIF9UZXh0TWV0cmljcy5fX2NhbnZhcztcbiAgfVxuICBzdGF0aWMgZ2V0IF9jb250ZXh0KCkge1xuICAgIGlmICghX1RleHRNZXRyaWNzLl9fY29udGV4dCkge1xuICAgICAgX1RleHRNZXRyaWNzLl9fY29udGV4dCA9IF9UZXh0TWV0cmljcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gX1RleHRNZXRyaWNzLl9fY29udGV4dDtcbiAgfVxufTtcbmxldCBUZXh0TWV0cmljcyA9IF9UZXh0TWV0cmljcztcblRleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HID0gXCJ8XFx4QzlxXFx4QzVcIjtcblRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCA9IFwiTVwiO1xuVGV4dE1ldHJpY3MuQkFTRUxJTkVfTVVMVElQTElFUiA9IDEuNDtcblRleHRNZXRyaWNzLkhFSUdIVF9NVUxUSVBMSUVSID0gMjtcblRleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBJbnRsPy5TZWdtZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcigpO1xuICAgIHJldHVybiAocykgPT4gWy4uLnNlZ21lbnRlci5zZWdtZW50KHMpXS5tYXAoKHgpID0+IHguc2VnbWVudCk7XG4gIH1cbiAgcmV0dXJuIChzKSA9PiBbLi4uc107XG59KSgpO1xuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IGZhbHNlO1xuVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG5UZXh0TWV0cmljcy5fbmV3bGluZXMgPSBbXG4gIDEwLFxuICAxM1xuXTtcblRleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcyA9IFtcbiAgOSxcbiAgMzIsXG4gIDgxOTIsXG4gIDgxOTMsXG4gIDgxOTQsXG4gIDgxOTUsXG4gIDgxOTYsXG4gIDgxOTcsXG4gIDgxOTgsXG4gIDgyMDAsXG4gIDgyMDEsXG4gIDgyMDIsXG4gIDgyODcsXG4gIDEyMjg4XG5dO1xuXG5leHBvcnQgeyBUZXh0TWV0cmljcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dE1ldHJpY3MubWpzLm1hcFxuIiwiaW1wb3J0IHsgVEVYVF9HUkFESUVOVCB9IGZyb20gJy4vY29uc3QubWpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGdlbmVyaWNGb250RmFtaWxpZXMgPSBbXG4gIFwic2VyaWZcIixcbiAgXCJzYW5zLXNlcmlmXCIsXG4gIFwibW9ub3NwYWNlXCIsXG4gIFwiY3Vyc2l2ZVwiLFxuICBcImZhbnRhc3lcIixcbiAgXCJzeXN0ZW0tdWlcIlxuXTtcbmNvbnN0IF9UZXh0U3R5bGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZUlEID0gMDtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIHN0eWxlLCBzdHlsZSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmVkUHJvcGVydGllcyA9IHt9O1xuICAgIGRlZXBDb3B5UHJvcGVydGllcyhjbG9uZWRQcm9wZXJ0aWVzLCB0aGlzLCBfVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSk7XG4gICAgcmV0dXJuIG5ldyBfVGV4dFN0eWxlKGNsb25lZFByb3BlcnRpZXMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBfVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSwgX1RleHRTdHlsZS5kZWZhdWx0U3R5bGUpO1xuICB9XG4gIGdldCBhbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gIH1cbiAgc2V0IGFsaWduKGFsaWduKSB7XG4gICAgaWYgKHRoaXMuX2FsaWduICE9PSBhbGlnbikge1xuICAgICAgdGhpcy5fYWxpZ24gPSBhbGlnbjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgYnJlYWtXb3JkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWtXb3JkcztcbiAgfVxuICBzZXQgYnJlYWtXb3JkcyhicmVha1dvcmRzKSB7XG4gICAgaWYgKHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMpIHtcbiAgICAgIHRoaXMuX2JyZWFrV29yZHMgPSBicmVha1dvcmRzO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBkcm9wU2hhZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93O1xuICB9XG4gIHNldCBkcm9wU2hhZG93KGRyb3BTaGFkb3cpIHtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvdyAhPT0gZHJvcFNoYWRvdykge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvdyA9IGRyb3BTaGFkb3c7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dBbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FscGhhO1xuICB9XG4gIHNldCBkcm9wU2hhZG93QWxwaGEoZHJvcFNoYWRvd0FscGhhKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSAhPT0gZHJvcFNoYWRvd0FscGhhKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93QWxwaGEgPSBkcm9wU2hhZG93QWxwaGE7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xuICB9XG4gIHNldCBkcm9wU2hhZG93QW5nbGUoZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSAhPT0gZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93QW5nbGUgPSBkcm9wU2hhZG93QW5nbGU7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dCbHVyKCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Qmx1cjtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0JsdXIoZHJvcFNoYWRvd0JsdXIpIHtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0JsdXIgIT09IGRyb3BTaGFkb3dCbHVyKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBkcm9wU2hhZG93Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dDb2xvcjtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0NvbG9yKGRyb3BTaGFkb3dDb2xvcikge1xuICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0NvbG9yICE9PSBvdXRwdXRDb2xvcikge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvd0NvbG9yID0gb3V0cHV0Q29sb3I7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICB9XG4gIHNldCBkcm9wU2hhZG93RGlzdGFuY2UoZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSAhPT0gZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2UgPSBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGw7XG4gIH1cbiAgc2V0IGZpbGwoZmlsbCkge1xuICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZmlsbCk7XG4gICAgaWYgKHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICB0aGlzLl9maWxsID0gb3V0cHV0Q29sb3I7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZpbGxHcmFkaWVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGU7XG4gIH1cbiAgc2V0IGZpbGxHcmFkaWVudFR5cGUoZmlsbEdyYWRpZW50VHlwZSkge1xuICAgIGlmICh0aGlzLl9maWxsR3JhZGllbnRUeXBlICE9PSBmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICB0aGlzLl9maWxsR3JhZGllbnRUeXBlID0gZmlsbEdyYWRpZW50VHlwZTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZmlsbEdyYWRpZW50U3RvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRTdG9wcyhmaWxsR3JhZGllbnRTdG9wcykge1xuICAgIGlmICghYXJlQXJyYXlzRXF1YWwodGhpcy5fZmlsbEdyYWRpZW50U3RvcHMsIGZpbGxHcmFkaWVudFN0b3BzKSkge1xuICAgICAgdGhpcy5fZmlsbEdyYWRpZW50U3RvcHMgPSBmaWxsR3JhZGllbnRTdG9wcztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udEZhbWlseSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udEZhbWlseTtcbiAgfVxuICBzZXQgZm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gICAgaWYgKHRoaXMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgdGhpcy5fZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZvbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgfVxuICBzZXQgZm9udFNpemUoZm9udFNpemUpIHtcbiAgICBpZiAodGhpcy5fZm9udFNpemUgIT09IGZvbnRTaXplKSB7XG4gICAgICB0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBmb250U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZTtcbiAgfVxuICBzZXQgZm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICAgIGlmICh0aGlzLl9mb250U3R5bGUgIT09IGZvbnRTdHlsZSkge1xuICAgICAgdGhpcy5fZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBmb250VmFyaWFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFZhcmlhbnQ7XG4gIH1cbiAgc2V0IGZvbnRWYXJpYW50KGZvbnRWYXJpYW50KSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRWYXJpYW50ICE9PSBmb250VmFyaWFudCkge1xuICAgICAgdGhpcy5fZm9udFZhcmlhbnQgPSBmb250VmFyaWFudDtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgfVxuICBzZXQgZm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRXZWlnaHQgIT09IGZvbnRXZWlnaHQpIHtcbiAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICB9XG4gIHNldCBsZXR0ZXJTcGFjaW5nKGxldHRlclNwYWNpbmcpIHtcbiAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gbGV0dGVyU3BhY2luZykge1xuICAgICAgdGhpcy5fbGV0dGVyU3BhY2luZyA9IGxldHRlclNwYWNpbmc7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gIH1cbiAgc2V0IGxpbmVIZWlnaHQobGluZUhlaWdodCkge1xuICAgIGlmICh0aGlzLl9saW5lSGVpZ2h0ICE9PSBsaW5lSGVpZ2h0KSB7XG4gICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgbGVhZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZGluZztcbiAgfVxuICBzZXQgbGVhZGluZyhsZWFkaW5nKSB7XG4gICAgaWYgKHRoaXMuX2xlYWRpbmcgIT09IGxlYWRpbmcpIHtcbiAgICAgIHRoaXMuX2xlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBsaW5lSm9pbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZUpvaW47XG4gIH1cbiAgc2V0IGxpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgaWYgKHRoaXMuX2xpbmVKb2luICE9PSBsaW5lSm9pbikge1xuICAgICAgdGhpcy5fbGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl0ZXJMaW1pdDtcbiAgfVxuICBzZXQgbWl0ZXJMaW1pdChtaXRlckxpbWl0KSB7XG4gICAgaWYgKHRoaXMuX21pdGVyTGltaXQgIT09IG1pdGVyTGltaXQpIHtcbiAgICAgIHRoaXMuX21pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICB9XG4gIHNldCBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5fcGFkZGluZyAhPT0gcGFkZGluZykge1xuICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IHN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICB9XG4gIHNldCBzdHJva2Uoc3Ryb2tlKSB7XG4gICAgY29uc3Qgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihzdHJva2UpO1xuICAgIGlmICh0aGlzLl9zdHJva2UgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICB0aGlzLl9zdHJva2UgPSBvdXRwdXRDb2xvcjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgc3Ryb2tlVGhpY2tuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VUaGlja25lc3M7XG4gIH1cbiAgc2V0IHN0cm9rZVRoaWNrbmVzcyhzdHJva2VUaGlja25lc3MpIHtcbiAgICBpZiAodGhpcy5fc3Ryb2tlVGhpY2tuZXNzICE9PSBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgIHRoaXMuX3N0cm9rZVRoaWNrbmVzcyA9IHN0cm9rZVRoaWNrbmVzcztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgdGV4dEJhc2VsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0QmFzZWxpbmU7XG4gIH1cbiAgc2V0IHRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpIHtcbiAgICBpZiAodGhpcy5fdGV4dEJhc2VsaW5lICE9PSB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgIHRoaXMuX3RleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgdHJpbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJpbTtcbiAgfVxuICBzZXQgdHJpbSh0cmltKSB7XG4gICAgaWYgKHRoaXMuX3RyaW0gIT09IHRyaW0pIHtcbiAgICAgIHRoaXMuX3RyaW0gPSB0cmltO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCB3aGl0ZVNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICB9XG4gIHNldCB3aGl0ZVNwYWNlKHdoaXRlU3BhY2UpIHtcbiAgICBpZiAodGhpcy5fd2hpdGVTcGFjZSAhPT0gd2hpdGVTcGFjZSkge1xuICAgICAgdGhpcy5fd2hpdGVTcGFjZSA9IHdoaXRlU3BhY2U7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IHdvcmRXcmFwKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcbiAgfVxuICBzZXQgd29yZFdyYXAod29yZFdyYXApIHtcbiAgICBpZiAodGhpcy5fd29yZFdyYXAgIT09IHdvcmRXcmFwKSB7XG4gICAgICB0aGlzLl93b3JkV3JhcCA9IHdvcmRXcmFwO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCB3b3JkV3JhcFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcFdpZHRoO1xuICB9XG4gIHNldCB3b3JkV3JhcFdpZHRoKHdvcmRXcmFwV2lkdGgpIHtcbiAgICBpZiAodGhpcy5fd29yZFdyYXBXaWR0aCAhPT0gd29yZFdyYXBXaWR0aCkge1xuICAgICAgdGhpcy5fd29yZFdyYXBXaWR0aCA9IHdvcmRXcmFwV2lkdGg7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgdG9Gb250U3RyaW5nKCkge1xuICAgIGNvbnN0IGZvbnRTaXplU3RyaW5nID0gdHlwZW9mIHRoaXMuZm9udFNpemUgPT09IFwibnVtYmVyXCIgPyBgJHt0aGlzLmZvbnRTaXplfXB4YCA6IHRoaXMuZm9udFNpemU7XG4gICAgbGV0IGZvbnRGYW1pbGllcyA9IHRoaXMuZm9udEZhbWlseTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5mb250RmFtaWx5KSkge1xuICAgICAgZm9udEZhbWlsaWVzID0gdGhpcy5mb250RmFtaWx5LnNwbGl0KFwiLFwiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGZvbnRGYW1pbGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgICAgaWYgKCEvKFtcXFwiXFwnXSlbXlxcJ1xcXCJdK1xcMS8udGVzdChmb250RmFtaWx5KSAmJiAhZ2VuZXJpY0ZvbnRGYW1pbGllcy5pbmNsdWRlcyhmb250RmFtaWx5KSkge1xuICAgICAgICBmb250RmFtaWx5ID0gYFwiJHtmb250RmFtaWx5fVwiYDtcbiAgICAgIH1cbiAgICAgIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmZvbnRTdHlsZX0gJHt0aGlzLmZvbnRWYXJpYW50fSAke3RoaXMuZm9udFdlaWdodH0gJHtmb250U2l6ZVN0cmluZ30gJHtmb250RmFtaWxpZXMuam9pbihcIixcIil9YDtcbiAgfVxufTtcbmxldCBUZXh0U3R5bGUgPSBfVGV4dFN0eWxlO1xuVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSA9IHtcbiAgYWxpZ246IFwibGVmdFwiLFxuICBicmVha1dvcmRzOiBmYWxzZSxcbiAgZHJvcFNoYWRvdzogZmFsc2UsXG4gIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgZHJvcFNoYWRvd0FuZ2xlOiBNYXRoLlBJIC8gNixcbiAgZHJvcFNoYWRvd0JsdXI6IDAsXG4gIGRyb3BTaGFkb3dDb2xvcjogXCJibGFja1wiLFxuICBkcm9wU2hhZG93RGlzdGFuY2U6IDUsXG4gIGZpbGw6IFwiYmxhY2tcIixcbiAgZmlsbEdyYWRpZW50VHlwZTogVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXG4gIGZpbGxHcmFkaWVudFN0b3BzOiBbXSxcbiAgZm9udEZhbWlseTogXCJBcmlhbFwiLFxuICBmb250U2l6ZTogMjYsXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgZm9udFZhcmlhbnQ6IFwibm9ybWFsXCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIGxlYWRpbmc6IDAsXG4gIGxldHRlclNwYWNpbmc6IDAsXG4gIGxpbmVIZWlnaHQ6IDAsXG4gIGxpbmVKb2luOiBcIm1pdGVyXCIsXG4gIG1pdGVyTGltaXQ6IDEwLFxuICBwYWRkaW5nOiAwLFxuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgc3Ryb2tlVGhpY2tuZXNzOiAwLFxuICB0ZXh0QmFzZWxpbmU6IFwiYWxwaGFiZXRpY1wiLFxuICB0cmltOiBmYWxzZSxcbiAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgd29yZFdyYXA6IGZhbHNlLFxuICB3b3JkV3JhcFdpZHRoOiAxMDBcbn07XG5mdW5jdGlvbiBnZXRDb2xvcihjb2xvcikge1xuICBjb25zdCB0ZW1wID0gQ29sb3Iuc2hhcmVkO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIHRlbXAuc2V0VmFsdWUoY29sb3IpLnRvSGV4KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcCgoYykgPT4gdGVtcC5zZXRWYWx1ZShjKS50b0hleCgpKTtcbiAgfVxufVxuZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYXJyYXkxLCBhcnJheTIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5MSkgfHwgIUFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHlPYmopIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5T2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlW3Byb3BdKSkge1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgVGV4dFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0U3R5bGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MsIFRleHR1cmUsIFJlY3RhbmdsZSwgdXRpbHMsIENvbG9yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tICdAcGl4aS9zcHJpdGUnO1xuaW1wb3J0IHsgVEVYVF9HUkFESUVOVCB9IGZyb20gJy4vY29uc3QubWpzJztcbmltcG9ydCB7IFRleHRNZXRyaWNzIH0gZnJvbSAnLi9UZXh0TWV0cmljcy5tanMnO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi9UZXh0U3R5bGUubWpzJztcblxuY29uc3QgZGVmYXVsdERlc3Ryb3lPcHRpb25zID0ge1xuICB0ZXh0dXJlOiB0cnVlLFxuICBjaGlsZHJlbjogZmFsc2UsXG4gIGJhc2VUZXh0dXJlOiB0cnVlXG59O1xuY29uc3QgX1RleHQgPSBjbGFzcyBleHRlbmRzIFNwcml0ZSB7XG4gIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlLCBjYW52YXMpIHtcbiAgICBsZXQgb3duQ2FudmFzID0gZmFsc2U7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgICBvd25DYW52YXMgPSB0cnVlO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSAzO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAzO1xuICAgIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlLmZyb20oY2FudmFzKTtcbiAgICB0ZXh0dXJlLm9yaWcgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGV4dHVyZS50cmltID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHN1cGVyKHRleHR1cmUpO1xuICAgIHRoaXMuX293bkNhbnZhcyA9IG93bkNhbnZhcztcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSBfVGV4dC5kZWZhdWx0UmVzb2x1dGlvbiA/PyBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gX1RleHQuZGVmYXVsdEF1dG9SZXNvbHV0aW9uO1xuICAgIHRoaXMuX3RleHQgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9zdHlsZUxpc3RlbmVyID0gbnVsbDtcbiAgICB0aGlzLl9mb250ID0gXCJcIjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICB9XG4gIHN0YXRpYyBnZXQgZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZygpIHtcbiAgICByZXR1cm4gVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZztcbiAgfVxuICBzdGF0aWMgc2V0IGV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwiVGV4dC5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nIGlzIGRlcHJlY2F0ZWQsIHVzZSBUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nXCIpO1xuICAgIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSB2YWx1ZTtcbiAgfVxuICB1cGRhdGVUZXh0KHJlc3BlY3REaXJ0eSkge1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fc3R5bGU7XG4gICAgaWYgKHRoaXMubG9jYWxTdHlsZUlEICE9PSBzdHlsZS5zdHlsZUlEKSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gc3R5bGUuc3R5bGVJRDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9mb250ID0gdGhpcy5fc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBtZWFzdXJlZCA9IFRleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRoaXMuX3RleHQgfHwgXCIgXCIsIHRoaXMuX3N0eWxlLCB0aGlzLl9zdHlsZS53b3JkV3JhcCwgdGhpcy5jYW52YXMpO1xuICAgIGNvbnN0IHdpZHRoID0gbWVhc3VyZWQud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0O1xuICAgIGNvbnN0IGxpbmVzID0gbWVhc3VyZWQubGluZXM7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IG1lYXN1cmVkLmxpbmVIZWlnaHQ7XG4gICAgY29uc3QgbGluZVdpZHRocyA9IG1lYXN1cmVkLmxpbmVXaWR0aHM7XG4gICAgY29uc3QgbWF4TGluZVdpZHRoID0gbWVhc3VyZWQubWF4TGluZVdpZHRoO1xuICAgIGNvbnN0IGZvbnRQcm9wZXJ0aWVzID0gbWVhc3VyZWQuZm9udFByb3BlcnRpZXM7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIHdpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgIGNvbnRleHQuc2NhbGUodGhpcy5fcmVzb2x1dGlvbiwgdGhpcy5fcmVzb2x1dGlvbik7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgY29udGV4dC5mb250ID0gdGhpcy5fZm9udDtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gc3R5bGUubGluZUpvaW47XG4gICAgY29udGV4dC5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdDtcbiAgICBsZXQgbGluZVBvc2l0aW9uWDtcbiAgICBsZXQgbGluZVBvc2l0aW9uWTtcbiAgICBjb25zdCBwYXNzZXNDb3VudCA9IHN0eWxlLmRyb3BTaGFkb3cgPyAyIDogMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3Nlc0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGlzU2hhZG93UGFzcyA9IHN0eWxlLmRyb3BTaGFkb3cgJiYgaSA9PT0gMDtcbiAgICAgIGNvbnN0IGRzT2Zmc2V0VGV4dCA9IGlzU2hhZG93UGFzcyA/IE1hdGguY2VpbChNYXRoLm1heCgxLCBoZWlnaHQpICsgc3R5bGUucGFkZGluZyAqIDIpIDogMDtcbiAgICAgIGNvbnN0IGRzT2Zmc2V0U2hhZG93ID0gZHNPZmZzZXRUZXh0ICogdGhpcy5fcmVzb2x1dGlvbjtcbiAgICAgIGlmIChpc1NoYWRvd1Bhc3MpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1ciAqIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dEaXN0YW5jZSA9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSAqIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShzdHlsZS5kcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpO1xuICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gTWF0aC5jb3Moc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZSArIGRzT2Zmc2V0U2hhZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMsIG1lYXN1cmVkKTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcbiAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lUG9zaXRpb25ZU2hpZnQgPSAobGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplKSAvIDI7XG4gICAgICBpZiAobGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplIDwgMCkge1xuICAgICAgICBsaW5lUG9zaXRpb25ZU2hpZnQgPSAwO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGxpbmVzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIgKyBpMiAqIGxpbmVIZWlnaHQgKyBmb250UHJvcGVydGllcy5hc2NlbnQgKyBsaW5lUG9zaXRpb25ZU2hpZnQ7XG4gICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2kyXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaTJdKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHlsZS5zdHJva2VUaGlja25lc3MpIHtcbiAgICAgICAgICB0aGlzLmRyYXdMZXR0ZXJTcGFjaW5nKGxpbmVzW2kyXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nIC0gZHNPZmZzZXRUZXh0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuZmlsbCkge1xuICAgICAgICAgIHRoaXMuZHJhd0xldHRlclNwYWNpbmcobGluZXNbaTJdLCBsaW5lUG9zaXRpb25YICsgc3R5bGUucGFkZGluZywgbGluZVBvc2l0aW9uWSArIHN0eWxlLnBhZGRpbmcgLSBkc09mZnNldFRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICB9XG4gIGRyYXdMZXR0ZXJTcGFjaW5nKHRleHQsIHgsIHksIGlzU3Ryb2tlID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSBzdHlsZS5sZXR0ZXJTcGFjaW5nO1xuICAgIGxldCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gZmFsc2U7XG4gICAgaWYgKFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIHRoaXMuY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgICAgdGhpcy5jb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDAgfHwgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFBvc2l0aW9uID0geDtcbiAgICBjb25zdCBzdHJpbmdBcnJheSA9IFRleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyKHRleHQpO1xuICAgIGxldCBwcmV2aW91c1dpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDaGFyID0gc3RyaW5nQXJyYXlbaV07XG4gICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQoY3VycmVudENoYXIsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoY3VycmVudENoYXIsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dFN0ciA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBzdHJpbmdBcnJheS5sZW5ndGg7ICsraikge1xuICAgICAgICB0ZXh0U3RyICs9IHN0cmluZ0FycmF5W2pdO1xuICAgICAgfVxuICAgICAgY3VycmVudFdpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHRTdHIpLndpZHRoO1xuICAgICAgY3VycmVudFBvc2l0aW9uICs9IHByZXZpb3VzV2lkdGggLSBjdXJyZW50V2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgcHJldmlvdXNXaWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVGV4dHVyZSgpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBpZiAodGhpcy5fc3R5bGUudHJpbSkge1xuICAgICAgY29uc3QgdHJpbW1lZCA9IHV0aWxzLnRyaW1DYW52YXMoY2FudmFzKTtcbiAgICAgIGlmICh0cmltbWVkLmRhdGEpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdHJpbW1lZC53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNvbnRleHQucHV0SW1hZ2VEYXRhKHRyaW1tZWQuZGF0YSwgMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fc3R5bGU7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnRyaW0gPyAwIDogc3R5bGUucGFkZGluZztcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uO1xuICAgIHRleHR1cmUudHJpbS5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbjtcbiAgICB0ZXh0dXJlLnRyaW0ueCA9IC1wYWRkaW5nO1xuICAgIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmc7XG4gICAgdGV4dHVyZS5vcmlnLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggLSBwYWRkaW5nICogMjtcbiAgICB0ZXh0dXJlLm9yaWcuaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0IC0gcGFkZGluZyAqIDI7XG4gICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgYmFzZVRleHR1cmUuc2V0UmVhbFNpemUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCB0aGlzLl9yZXNvbHV0aW9uKTtcbiAgICB0ZXh0dXJlLnVwZGF0ZVV2cygpO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHN1cGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIGdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIGlmICh0aGlzLl90ZXh0dXJlSUQgPT09IC0xKSB7XG4gICAgICBza2lwVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZXRCb3VuZHMoc2tpcFVwZGF0ZSwgcmVjdCk7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xuICB9XG4gIF9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMsIG1ldHJpY3MpIHtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWxsU3R5bGUpKSB7XG4gICAgICByZXR1cm4gZmlsbFN0eWxlO1xuICAgIH0gZWxzZSBpZiAoZmlsbFN0eWxlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZpbGxTdHlsZVswXTtcbiAgICB9XG4gICAgbGV0IGdyYWRpZW50O1xuICAgIGNvbnN0IGRyb3BTaGFkb3dDb3JyZWN0aW9uID0gc3R5bGUuZHJvcFNoYWRvdyA/IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA6IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5fcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gICAgY29uc3QgZmlsbCA9IGZpbGxTdHlsZS5zbGljZSgpO1xuICAgIGNvbnN0IGZpbGxHcmFkaWVudFN0b3BzID0gc3R5bGUuZmlsbEdyYWRpZW50U3RvcHMuc2xpY2UoKTtcbiAgICBpZiAoIWZpbGxHcmFkaWVudFN0b3BzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGVuZ3RoUGx1czEgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aFBsdXMxOyArK2kpIHtcbiAgICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaChpIC8gbGVuZ3RoUGx1czEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxsLnVuc2hpZnQoZmlsbFN0eWxlWzBdKTtcbiAgICBmaWxsR3JhZGllbnRTdG9wcy51bnNoaWZ0KDApO1xuICAgIGZpbGwucHVzaChmaWxsU3R5bGVbZmlsbFN0eWxlLmxlbmd0aCAtIDFdKTtcbiAgICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpO1xuICAgIGlmIChzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBURVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTCkge1xuICAgICAgZ3JhZGllbnQgPSB0aGlzLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQod2lkdGggLyAyLCBwYWRkaW5nLCB3aWR0aCAvIDIsIGhlaWdodCArIHBhZGRpbmcpO1xuICAgICAgY29uc3QgdGV4dEhlaWdodCA9IG1ldHJpY3MuZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxhc3RMaW5lQm90dG9tID0gbWV0cmljcy5saW5lSGVpZ2h0ICogKGkgLSAxKSArIHRleHRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHRoaXNMaW5lVG9wID0gbWV0cmljcy5saW5lSGVpZ2h0ICogaTtcbiAgICAgICAgbGV0IHRoaXNMaW5lR3JhZGllbnRTdGFydCA9IHRoaXNMaW5lVG9wO1xuICAgICAgICBpZiAoaSA+IDAgJiYgbGFzdExpbmVCb3R0b20gPiB0aGlzTGluZVRvcCkge1xuICAgICAgICAgIHRoaXNMaW5lR3JhZGllbnRTdGFydCA9ICh0aGlzTGluZVRvcCArIGxhc3RMaW5lQm90dG9tKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpc0xpbmVCb3R0b20gPSB0aGlzTGluZVRvcCArIHRleHRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IG5leHRMaW5lVG9wID0gbWV0cmljcy5saW5lSGVpZ2h0ICogKGkgKyAxKTtcbiAgICAgICAgbGV0IHRoaXNMaW5lR3JhZGllbnRFbmQgPSB0aGlzTGluZUJvdHRvbTtcbiAgICAgICAgaWYgKGkgKyAxIDwgbGluZXMubGVuZ3RoICYmIG5leHRMaW5lVG9wIDwgdGhpc0xpbmVCb3R0b20pIHtcbiAgICAgICAgICB0aGlzTGluZUdyYWRpZW50RW5kID0gKHRoaXNMaW5lQm90dG9tICsgbmV4dExpbmVUb3ApIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncmFkU3RvcExpbmVIZWlnaHQgPSAodGhpc0xpbmVHcmFkaWVudEVuZCAtIHRoaXNMaW5lR3JhZGllbnRTdGFydCkgLyBoZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmlsbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCBsaW5lU3RvcCA9IDA7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tqXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbGluZVN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tqXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZVN0b3AgPSBqIC8gZmlsbC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBnbG9iYWxTdG9wID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdGhpc0xpbmVHcmFkaWVudFN0YXJ0IC8gaGVpZ2h0ICsgbGluZVN0b3AgKiBncmFkU3RvcExpbmVIZWlnaHQpKTtcbiAgICAgICAgICBnbG9iYWxTdG9wID0gTnVtYmVyKGdsb2JhbFN0b3AudG9GaXhlZCg1KSk7XG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGdsb2JhbFN0b3AsIGZpbGxbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHBhZGRpbmcsIGhlaWdodCAvIDIsIHdpZHRoICsgcGFkZGluZywgaGVpZ2h0IC8gMik7XG4gICAgICBjb25zdCB0b3RhbEl0ZXJhdGlvbnMgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbiA9IDE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN0b3A7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBzdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbaV0pO1xuICAgICAgICBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkaWVudDtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERlc3Ryb3lPcHRpb25zLCBvcHRpb25zKTtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLl9vd25DYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzLndpZHRoID0gMDtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueCkgKiB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIGNvbnN0IHMgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBjb25zdCBzID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgc3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG4gIHNldCBzdHlsZShzdHlsZSkge1xuICAgIHN0eWxlID0gc3R5bGUgfHwge307XG4gICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdHlsZSA9IG5ldyBUZXh0U3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICB9XG4gIHNldCB0ZXh0KHRleHQpIHtcbiAgICB0ZXh0ID0gU3RyaW5nKHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdm9pZCAwID8gXCJcIiA6IHRleHQpO1xuICAgIGlmICh0aGlzLl90ZXh0ID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG59O1xubGV0IFRleHQgPSBfVGV4dDtcblRleHQuZGVmYXVsdEF1dG9SZXNvbHV0aW9uID0gdHJ1ZTtcblxuZXhwb3J0IHsgVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dC5tanMubWFwXG4iLCJleHBvcnQgeyBURVhUX0dSQURJRU5UIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuZXhwb3J0IHsgVGV4dCB9IGZyb20gJy4vVGV4dC5tanMnO1xuZXhwb3J0IHsgVGV4dE1ldHJpY3MgfSBmcm9tICcuL1RleHRNZXRyaWNzLm1qcyc7XG5leHBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tICcuL1RleHRTdHlsZS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiY2xhc3MgQ291bnRMaW1pdGVyIHtcbiAgY29uc3RydWN0b3IobWF4SXRlbXNQZXJGcmFtZSkge1xuICAgIHRoaXMubWF4SXRlbXNQZXJGcmFtZSA9IG1heEl0ZW1zUGVyRnJhbWU7XG4gICAgdGhpcy5pdGVtc0xlZnQgPSAwO1xuICB9XG4gIGJlZ2luRnJhbWUoKSB7XG4gICAgdGhpcy5pdGVtc0xlZnQgPSB0aGlzLm1heEl0ZW1zUGVyRnJhbWU7XG4gIH1cbiAgYWxsb3dlZFRvVXBsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zTGVmdC0tID4gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBDb3VudExpbWl0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvdW50TGltaXRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBCYXNlVGV4dHVyZSwgVGlja2VyLCBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgVGV4dCwgVGV4dFN0eWxlLCBUZXh0TWV0cmljcyB9IGZyb20gJ0BwaXhpL3RleHQnO1xuaW1wb3J0IHsgQ291bnRMaW1pdGVyIH0gZnJvbSAnLi9Db3VudExpbWl0ZXIubWpzJztcblxuZnVuY3Rpb24gZmluZE11bHRpcGxlQmFzZVRleHR1cmVzKGl0ZW0sIHF1ZXVlKSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKGl0ZW0/Ll90ZXh0dXJlcz8ubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLl90ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGl0ZW0uX3RleHR1cmVzW2ldIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICBjb25zdCBiYXNlVGV4dHVyZSA9IGl0ZW0uX3RleHR1cmVzW2ldLmJhc2VUZXh0dXJlO1xuICAgICAgICBpZiAoIXF1ZXVlLmluY2x1ZGVzKGJhc2VUZXh0dXJlKSkge1xuICAgICAgICAgIHF1ZXVlLnB1c2goYmFzZVRleHR1cmUpO1xuICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRCYXNlVGV4dHVyZShpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbS5iYXNlVGV4dHVyZSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IGl0ZW0uYmFzZVRleHR1cmU7XG4gICAgaWYgKCFxdWV1ZS5pbmNsdWRlcyh0ZXh0dXJlKSkge1xuICAgICAgcXVldWUucHVzaCh0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZFRleHR1cmUoaXRlbSwgcXVldWUpIHtcbiAgaWYgKGl0ZW0uX3RleHR1cmUgJiYgaXRlbS5fdGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gaXRlbS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBpZiAoIXF1ZXVlLmluY2x1ZGVzKHRleHR1cmUpKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRleHR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3VGV4dChfaGVscGVyLCBpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgIGl0ZW0udXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXh0U3R5bGUoX2hlbHBlciwgaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHRTdHlsZSkge1xuICAgIGNvbnN0IGZvbnQgPSBpdGVtLnRvRm9udFN0cmluZygpO1xuICAgIFRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRUZXh0KGl0ZW0sIHF1ZXVlKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgIGlmICghcXVldWUuaW5jbHVkZXMoaXRlbS5zdHlsZSkpIHtcbiAgICAgIHF1ZXVlLnB1c2goaXRlbS5zdHlsZSk7XG4gICAgfVxuICAgIGlmICghcXVldWUuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIGlmICghcXVldWUuaW5jbHVkZXModGV4dHVyZSkpIHtcbiAgICAgIHF1ZXVlLnB1c2godGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRUZXh0U3R5bGUoaXRlbSwgcXVldWUpIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0U3R5bGUpIHtcbiAgICBpZiAoIXF1ZXVlLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBfQmFzZVByZXBhcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5saW1pdGVyID0gbmV3IENvdW50TGltaXRlcihfQmFzZVByZXBhcmUudXBsb2Fkc1BlckZyYW1lKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5hZGRIb29rcyA9IFtdO1xuICAgIHRoaXMudXBsb2FkSG9va3MgPSBbXTtcbiAgICB0aGlzLmNvbXBsZXRlcyA9IFtdO1xuICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZGVsYXllZFRpY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwYXJlSXRlbXMoKTtcbiAgICB9O1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kVGV4dCk7XG4gICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRUZXh0U3R5bGUpO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kTXVsdGlwbGVCYXNlVGV4dHVyZXMpO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kQmFzZVRleHR1cmUpO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kVGV4dHVyZSk7XG4gICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soZHJhd1RleHQpO1xuICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKGNhbGN1bGF0ZVRleHRTdHlsZSk7XG4gIH1cbiAgdXBsb2FkKGl0ZW0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHRoaXMuYWRkKGl0ZW0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGVzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgIGlmICghdGhpcy50aWNraW5nKSB7XG4gICAgICAgICAgdGhpcy50aWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICBUaWNrZXIuc3lzdGVtLmFkZE9uY2UodGhpcy50aWNrLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0aWNrKCkge1xuICAgIHNldFRpbWVvdXQodGhpcy5kZWxheWVkVGljaywgMCk7XG4gIH1cbiAgcHJlcGFyZUl0ZW1zKCkge1xuICAgIHRoaXMubGltaXRlci5iZWdpbkZyYW1lKCk7XG4gICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoICYmIHRoaXMubGltaXRlci5hbGxvd2VkVG9VcGxvYWQoKSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWVbMF07XG4gICAgICBsZXQgdXBsb2FkZWQgPSBmYWxzZTtcbiAgICAgIGlmIChpdGVtICYmICFpdGVtLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMudXBsb2FkSG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy51cGxvYWRIb29rc1tpXSh0aGlzLnVwbG9hZEhvb2tIZWxwZXIsIGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB1cGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdXBsb2FkZWQpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRpY2tpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbXBsZXRlcyA9IHRoaXMuY29tcGxldGVzLnNsaWNlKDApO1xuICAgICAgdGhpcy5jb21wbGV0ZXMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb21wbGV0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29tcGxldGVzW2ldKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIFRpY2tlci5zeXN0ZW0uYWRkT25jZSh0aGlzLnRpY2ssIHRoaXMsIFVQREFURV9QUklPUklUWS5VVElMSVRZKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJGaW5kSG9vayhhZGRIb29rKSB7XG4gICAgaWYgKGFkZEhvb2spIHtcbiAgICAgIHRoaXMuYWRkSG9va3MucHVzaChhZGRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVnaXN0ZXJVcGxvYWRIb29rKHVwbG9hZEhvb2spIHtcbiAgICBpZiAodXBsb2FkSG9vaykge1xuICAgICAgdGhpcy51cGxvYWRIb29rcy5wdXNoKHVwbG9hZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGQoaXRlbSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmFkZEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5hZGRIb29rc1tpXShpdGVtLCB0aGlzLnF1ZXVlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSBpdGVtLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMuYWRkKGl0ZW0uY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpY2tpbmcpIHtcbiAgICAgIFRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMudGljaywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuICAgIHRoaXMuYWRkSG9va3MgPSBudWxsO1xuICAgIHRoaXMudXBsb2FkSG9va3MgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuY29tcGxldGVzID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLmxpbWl0ZXIgPSBudWxsO1xuICAgIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IG51bGw7XG4gIH1cbn07XG5sZXQgQmFzZVByZXBhcmUgPSBfQmFzZVByZXBhcmU7XG5CYXNlUHJlcGFyZS51cGxvYWRzUGVyRnJhbWUgPSA0O1xuXG5leHBvcnQgeyBCYXNlUHJlcGFyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVByZXBhcmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MsIHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5leHBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVByZXBhcmUgfSBmcm9tICcuL0Jhc2VQcmVwYXJlLm1qcyc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNldHRpbmdzLCB7XG4gIFVQTE9BRFNfUEVSX0ZSQU1FOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlVQTE9BRFNfUEVSX0ZSQU1FIGlzIGRlcHJlY2F0ZWQsIHVzZSBwcmVwYXJlLkJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZVwiKTtcbiAgICAgIEJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5tanMubWFwXG4iLCJpbXBvcnQgeyBCYXNlVGV4dHVyZSwgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgR3JhcGhpY3MgfSBmcm9tICdAcGl4aS9ncmFwaGljcyc7XG5pbXBvcnQgeyBCYXNlUHJlcGFyZSB9IGZyb20gJy4vQmFzZVByZXBhcmUubWpzJztcblxuZnVuY3Rpb24gdXBsb2FkQmFzZVRleHR1cmVzKHJlbmRlcmVyLCBpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgQmFzZVRleHR1cmUpIHtcbiAgICBpZiAoIWl0ZW0uX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICByZW5kZXJlci50ZXh0dXJlLmJpbmQoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwbG9hZEdyYXBoaWNzKHJlbmRlcmVyLCBpdGVtKSB7XG4gIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBHcmFwaGljcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeyBnZW9tZXRyeSB9ID0gaXRlbTtcbiAgaXRlbS5maW5pc2hQb2x5KCk7XG4gIGdlb21ldHJ5LnVwZGF0ZUJhdGNoZXMoKTtcbiAgY29uc3QgeyBiYXRjaGVzIH0gPSBnZW9tZXRyeTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0ZXh0dXJlIH0gPSBiYXRjaGVzW2ldLnN0eWxlO1xuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB1cGxvYWRCYXNlVGV4dHVyZXMocmVuZGVyZXIsIHRleHR1cmUuYmFzZVRleHR1cmUpO1xuICAgIH1cbiAgfVxuICBpZiAoIWdlb21ldHJ5LmJhdGNoYWJsZSkge1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoZ2VvbWV0cnksIGl0ZW0uX3Jlc29sdmVEaXJlY3RTaGFkZXIocmVuZGVyZXIpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRHcmFwaGljcyhpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdyYXBoaWNzKSB7XG4gICAgcXVldWUucHVzaChpdGVtKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBQcmVwYXJlIGV4dGVuZHMgQmFzZVByZXBhcmUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kR3JhcGhpY3MpO1xuICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKHVwbG9hZEJhc2VUZXh0dXJlcyk7XG4gICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2sodXBsb2FkR3JhcGhpY3MpO1xuICB9XG59XG5QcmVwYXJlLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJwcmVwYXJlXCIsXG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW1cbn07XG5leHRlbnNpb25zLmFkZChQcmVwYXJlKTtcblxuZXhwb3J0IHsgUHJlcGFyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJlcGFyZS5tanMubWFwXG4iLCJpbXBvcnQgJy4vc2V0dGluZ3MubWpzJztcbmV4cG9ydCB7IEJhc2VQcmVwYXJlIH0gZnJvbSAnLi9CYXNlUHJlcGFyZS5tanMnO1xuZXhwb3J0IHsgQ291bnRMaW1pdGVyIH0gZnJvbSAnLi9Db3VudExpbWl0ZXIubWpzJztcbmV4cG9ydCB7IFByZXBhcmUgfSBmcm9tICcuL1ByZXBhcmUubWpzJztcbmV4cG9ydCB7IFRpbWVMaW1pdGVyIH0gZnJvbSAnLi9UaW1lTGltaXRlci5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dHVyZSwgVGlja2VyLCBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJ0BwaXhpL3Nwcml0ZSc7XG5cbmNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZXMsIGF1dG9VcGRhdGUgPSB0cnVlKSB7XG4gICAgc3VwZXIodGV4dHVyZXNbMF0gaW5zdGFuY2VvZiBUZXh0dXJlID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlc1swXS50ZXh0dXJlKTtcbiAgICB0aGlzLl90ZXh0dXJlcyA9IG51bGw7XG4gICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICB0aGlzLl9hdXRvVXBkYXRlID0gYXV0b1VwZGF0ZTtcbiAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDE7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZUFuY2hvciA9IGZhbHNlO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLm9uTG9vcCA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVzID0gdGV4dHVyZXM7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgIFRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5fcGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fYXV0b1VwZGF0ZSAmJiAhdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlcikge1xuICAgICAgVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMsIFVQREFURV9QUklPUklUWS5ISUdIKTtcbiAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnb3RvQW5kU3RvcChmcmFtZU51bWJlcikge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXI7XG4gIH1cbiAgZ290b0FuZFBsYXkoZnJhbWVOdW1iZXIpIHtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lTnVtYmVyO1xuICAgIHRoaXMucGxheSgpO1xuICB9XG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWU7XG4gICAgY29uc3QgcHJldmlvdXNGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGlmICh0aGlzLl9kdXJhdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIGxldCBsYWcgPSB0aGlzLl9jdXJyZW50VGltZSAlIDEgKiB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgbGFnICs9IGVsYXBzZWQgLyA2MCAqIDFlMztcbiAgICAgIHdoaWxlIChsYWcgPCAwKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lLS07XG4gICAgICAgIGxhZyArPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbih0aGlzLmFuaW1hdGlvblNwZWVkICogZGVsdGFUaW1lKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSk7XG4gICAgICB3aGlsZSAobGFnID49IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0pIHtcbiAgICAgICAgbGFnIC09IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0gKiBzaWduO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBzaWduO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gbGFnIC8gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gZWxhcHNlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUaW1lIDwgMCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xuICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRUaW1lID49IHRoaXMuX3RleHR1cmVzLmxlbmd0aCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICB0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzRnJhbWUgIT09IHRoaXMuY3VycmVudEZyYW1lKSB7XG4gICAgICBpZiAodGhpcy5sb29wICYmIHRoaXMub25Mb29wKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblNwZWVkID4gMCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA8IHByZXZpb3VzRnJhbWUgfHwgdGhpcy5hbmltYXRpb25TcGVlZCA8IDAgJiYgdGhpcy5jdXJyZW50RnJhbWUgPiBwcmV2aW91c0ZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5vbkxvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgY3VycmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzRnJhbWUgPT09IGN1cnJlbnRGcmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gY3VycmVudEZyYW1lO1xuICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tjdXJyZW50RnJhbWVdO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy51dnMgPSB0aGlzLl90ZXh0dXJlLl91dnMudXZzRmxvYXQzMjtcbiAgICBpZiAodGhpcy51cGRhdGVBbmNob3IpIHtcbiAgICAgIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh0aGlzLl90ZXh0dXJlLmRlZmF1bHRBbmNob3IpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vbkZyYW1lQ2hhbmdlKSB7XG4gICAgICB0aGlzLm9uRnJhbWVDaGFuZ2UodGhpcy5jdXJyZW50RnJhbWUpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLm9uTG9vcCA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGZyb21GcmFtZXMoZnJhbWVzKSB7XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdGV4dHVyZXMucHVzaChUZXh0dXJlLmZyb20oZnJhbWVzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQW5pbWF0ZWRTcHJpdGUodGV4dHVyZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSW1hZ2VzKGltYWdlcykge1xuICAgIGNvbnN0IHRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRleHR1cmVzLnB1c2goVGV4dHVyZS5mcm9tKGltYWdlc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkU3ByaXRlKHRleHR1cmVzKTtcbiAgfVxuICBnZXQgdG90YWxGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcbiAgfVxuICBnZXQgdGV4dHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICB9XG4gIHNldCB0ZXh0dXJlcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVswXSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHRoaXMuX3RleHR1cmVzID0gdmFsdWU7XG4gICAgICB0aGlzLl9kdXJhdGlvbnMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xuICAgICAgdGhpcy5fZHVyYXRpb25zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godmFsdWVbaV0udGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9ucy5wdXNoKHZhbHVlW2ldLnRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gbnVsbDtcbiAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xuICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICB9XG4gIGdldCBjdXJyZW50RnJhbWUoKSB7XG4gICAgbGV0IGN1cnJlbnRGcmFtZSA9IE1hdGguZmxvb3IodGhpcy5fY3VycmVudFRpbWUpICUgdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgIGlmIChjdXJyZW50RnJhbWUgPCAwKSB7XG4gICAgICBjdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudEZyYW1lO1xuICB9XG4gIHNldCBjdXJyZW50RnJhbWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gdGhpcy50b3RhbEZyYW1lcyAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW0FuaW1hdGVkU3ByaXRlXTogSW52YWxpZCBmcmFtZSBpbmRleCB2YWx1ZSAke3ZhbHVlfSwgZXhwZWN0ZWQgdG8gYmUgYmV0d2VlbiAwIGFuZCB0b3RhbEZyYW1lcyAke3RoaXMudG90YWxGcmFtZXN9LmApO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheWluZztcbiAgfVxuICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgYXV0b1VwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2F1dG9VcGRhdGUgJiYgIXRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgJiYgdGhpcy5fcGxheWluZykge1xuICAgICAgICBUaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBBbmltYXRlZFNwcml0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0ZWRTcHJpdGUubWpzLm1hcFxuIiwiZXhwb3J0IHsgQW5pbWF0ZWRTcHJpdGUgfSBmcm9tICcuL0FuaW1hdGVkU3ByaXRlLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCwgVHJhbnNmb3JtLCBUZXh0dXJlTWF0cml4LCBSZWN0YW5nbGUsIFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJ0BwaXhpL3Nwcml0ZSc7XG5cbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBQb2ludCgpO1xuY2xhc3MgVGlsaW5nU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCkge1xuICAgIHN1cGVyKHRleHR1cmUpO1xuICAgIHRoaXMudGlsZVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnV2TWF0cml4ID0gdGhpcy50ZXh0dXJlLnV2TWF0cml4IHx8IG5ldyBUZXh0dXJlTWF0cml4KHRleHR1cmUpO1xuICAgIHRoaXMucGx1Z2luTmFtZSA9IFwidGlsaW5nU3ByaXRlXCI7XG4gICAgdGhpcy51dlJlc3BlY3RBbmNob3IgPSBmYWxzZTtcbiAgfVxuICBnZXQgY2xhbXBNYXJnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudXZNYXRyaXguY2xhbXBNYXJnaW47XG4gIH1cbiAgc2V0IGNsYW1wTWFyZ2luKHZhbHVlKSB7XG4gICAgdGhpcy51dk1hdHJpeC5jbGFtcE1hcmdpbiA9IHZhbHVlO1xuICAgIHRoaXMudXZNYXRyaXgudXBkYXRlKHRydWUpO1xuICB9XG4gIGdldCB0aWxlU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS5zY2FsZTtcbiAgfVxuICBzZXQgdGlsZVNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy50aWxlVHJhbnNmb3JtLnNjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICBnZXQgdGlsZVBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG4gIH1cbiAgc2V0IHRpbGVQb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudGlsZVRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgX29uVGV4dHVyZVVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy51dk1hdHJpeCkge1xuICAgICAgdGhpcy51dk1hdHJpeC50ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkVGludCA9IDE2Nzc3MjE1O1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBpZiAoIXRleHR1cmUgfHwgIXRleHR1cmUudmFsaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50aWxlVHJhbnNmb3JtLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgdGhpcy51dk1hdHJpeC51cGRhdGUoKTtcbiAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pO1xuICAgIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBtaW5YID0gdGhpcy5fd2lkdGggKiAtdGhpcy5fYW5jaG9yLl94O1xuICAgIGNvbnN0IG1pblkgPSB0aGlzLl9oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLl95O1xuICAgIGNvbnN0IG1heFggPSB0aGlzLl93aWR0aCAqICgxIC0gdGhpcy5fYW5jaG9yLl94KTtcbiAgICBjb25zdCBtYXhZID0gdGhpcy5faGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3kpO1xuICAgIHRoaXMuX2JvdW5kcy5hZGRGcmFtZSh0aGlzLnRyYW5zZm9ybSwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fYm91bmRzLm1pblggPSB0aGlzLl93aWR0aCAqIC10aGlzLl9hbmNob3IuX3g7XG4gICAgICB0aGlzLl9ib3VuZHMubWluWSA9IHRoaXMuX2hlaWdodCAqIC10aGlzLl9hbmNob3IuX3k7XG4gICAgICB0aGlzLl9ib3VuZHMubWF4WCA9IHRoaXMuX3dpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSB0aGlzLl9oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSk7XG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0UmVjdGFuZ2xlKHJlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIHRlbXBQb2ludCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgY29uc3QgeDEgPSAtd2lkdGggKiB0aGlzLmFuY2hvci5feDtcbiAgICBpZiAodGVtcFBvaW50LnggPj0geDEgJiYgdGVtcFBvaW50LnggPCB4MSArIHdpZHRoKSB7XG4gICAgICBjb25zdCB5MSA9IC1oZWlnaHQgKiB0aGlzLmFuY2hvci5feTtcbiAgICAgIGlmICh0ZW1wUG9pbnQueSA+PSB5MSAmJiB0ZW1wUG9pbnQueSA8IHkxICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICB0aGlzLnRpbGVUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMudXZNYXRyaXggPSBudWxsO1xuICB9XG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHR1cmUgPSBzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlID8gc291cmNlIDogVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBUaWxpbmdTcHJpdGUodGV4dHVyZSwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCB7IFRpbGluZ1Nwcml0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsaW5nU3ByaXRlLm1qcy5tYXBcbiIsInZhciBnbDJGcmFnbWVudFNyYyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTEwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG5vdXQgdmVjNCBmcmFnbWVudENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxudW5pZm9ybSBtYXQzIHVNYXBDb29yZDtcXG51bmlmb3JtIHZlYzQgdUNsYW1wRnJhbWU7XFxudW5pZm9ybSB2ZWMyIHVDbGFtcE9mZnNldDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkICsgY2VpbCh1Q2xhbXBPZmZzZXQgLSB2VGV4dHVyZUNvb3JkKTtcXG4gICAgY29vcmQgPSAodU1hcENvb3JkICogdmVjMyhjb29yZCwgMS4wKSkueHk7XFxuICAgIHZlYzIgdW5jbGFtcGVkID0gY29vcmQ7XFxuICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVDbGFtcEZyYW1lLnh5LCB1Q2xhbXBGcmFtZS56dyk7XFxuXFxuICAgIHZlYzQgdGV4U2FtcGxlID0gdGV4dHVyZSh1U2FtcGxlciwgY29vcmQsIHVuY2xhbXBlZCA9PSBjb29yZCA/IDAuMGYgOiAtMzIuMGYpOy8vIGxvZC1iaWFzIHZlcnkgbmVnYXRpdmUgdG8gZm9yY2UgbG9kIDBcXG5cXG4gICAgZnJhZ21lbnRDb2xvciA9IHRleFNhbXBsZSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGdsMkZyYWdtZW50U3JjIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmcubWpzLm1hcFxuIiwidmFyIGdsMlZlcnRleFNyYyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTMwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbmluIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmluIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm07XFxuXFxub3V0IHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRyYW5zZm9ybSAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBnbDJWZXJ0ZXhTcmMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlLXRpbGluZzIubWpzLm1hcFxuIiwidmFyIGdsMUZyYWdtZW50U3JjID0gXCIjdmVyc2lvbiAxMDBcXG4jaWZkZWYgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxcbiAgICAjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcXG4jZW5kaWZcXG4jZGVmaW5lIFNIQURFUl9OQU1FIFRpbGluZy1TcHJpdGUtMTAwXFxuXFxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG51bmlmb3JtIG1hdDMgdU1hcENvb3JkO1xcbnVuaWZvcm0gdmVjNCB1Q2xhbXBGcmFtZTtcXG51bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgKyBjZWlsKHVDbGFtcE9mZnNldCAtIHZUZXh0dXJlQ29vcmQpO1xcbiAgICBjb29yZCA9ICh1TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcXG4gICAgdmVjMiB1bmNsYW1wZWQgPSBjb29yZDtcXG4gICAgY29vcmQgPSBjbGFtcChjb29yZCwgdUNsYW1wRnJhbWUueHksIHVDbGFtcEZyYW1lLnp3KTtcXG5cXG4gICAgI2lmZGVmIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2RcXG4gICAgICAgIHZlYzQgdGV4U2FtcGxlID0gdW5jbGFtcGVkID09IGNvb3JkXFxuICAgICAgICAgICAgPyB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKSBcXG4gICAgICAgICAgICA6IHRleHR1cmUyRExvZEVYVCh1U2FtcGxlciwgY29vcmQsIDApO1xcbiAgICAjZWxzZVxcbiAgICAgICAgdmVjNCB0ZXhTYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKTtcXG4gICAgI2VuZGlmXFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleFNhbXBsZSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGdsMUZyYWdtZW50U3JjIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmctZmFsbGJhY2subWpzLm1hcFxuIiwidmFyIGdsMVZlcnRleFNyYyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTEwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdVRyYW5zZm9ybTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRyYW5zZm9ybSAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBnbDFWZXJ0ZXhTcmMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlLXRpbGluZy1mYWxsYmFjazIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50U2ltcGxlU3JjID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIFNIQURFUl9OQU1FIFRpbGluZy1TcHJpdGUtU2ltcGxlLTEwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IHRleFNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleFNhbXBsZSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50U2ltcGxlU3JjIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmctc2ltcGxlLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCwgT2JqZWN0UmVuZGVyZXIsIFF1YWRVdiwgU3RhdGUsIFNoYWRlciwgV1JBUF9NT0RFUywgQ29sb3IsIHV0aWxzLCBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgZ2wyRnJhZ21lbnRTcmMgZnJvbSAnLi9zcHJpdGUtdGlsaW5nLm1qcyc7XG5pbXBvcnQgZ2wyVmVydGV4U3JjIGZyb20gJy4vc3ByaXRlLXRpbGluZzIubWpzJztcbmltcG9ydCBnbDFGcmFnbWVudFNyYyBmcm9tICcuL3Nwcml0ZS10aWxpbmctZmFsbGJhY2subWpzJztcbmltcG9ydCBnbDFWZXJ0ZXhTcmMgZnJvbSAnLi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrMi5tanMnO1xuaW1wb3J0IGZyYWdtZW50U2ltcGxlU3JjIGZyb20gJy4vc3ByaXRlLXRpbGluZy1zaW1wbGUubWpzJztcblxuY29uc3QgdGVtcE1hdCA9IG5ldyBNYXRyaXgoKTtcbmNsYXNzIFRpbGluZ1Nwcml0ZVJlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICByZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpO1xuICAgIHRoaXMucXVhZCA9IG5ldyBRdWFkVXYoKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHsgZ2xvYmFsczogcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMgfTtcbiAgICB0aGlzLnNpbXBsZVNoYWRlciA9IFNoYWRlci5mcm9tKGdsMVZlcnRleFNyYywgZnJhZ21lbnRTaW1wbGVTcmMsIHVuaWZvcm1zKTtcbiAgICB0aGlzLnNoYWRlciA9IHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID4gMSA/IFNoYWRlci5mcm9tKGdsMlZlcnRleFNyYywgZ2wyRnJhZ21lbnRTcmMsIHVuaWZvcm1zKSA6IFNoYWRlci5mcm9tKGdsMVZlcnRleFNyYywgZ2wxRnJhZ21lbnRTcmMsIHVuaWZvcm1zKTtcbiAgfVxuICByZW5kZXIodHMpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgcXVhZCA9IHRoaXMucXVhZDtcbiAgICBsZXQgdmVydGljZXMgPSBxdWFkLnZlcnRpY2VzO1xuICAgIHZlcnRpY2VzWzBdID0gdmVydGljZXNbNl0gPSB0cy5fd2lkdGggKiAtdHMuYW5jaG9yLng7XG4gICAgdmVydGljZXNbMV0gPSB2ZXJ0aWNlc1szXSA9IHRzLl9oZWlnaHQgKiAtdHMuYW5jaG9yLnk7XG4gICAgdmVydGljZXNbMl0gPSB2ZXJ0aWNlc1s0XSA9IHRzLl93aWR0aCAqICgxIC0gdHMuYW5jaG9yLngpO1xuICAgIHZlcnRpY2VzWzVdID0gdmVydGljZXNbN10gPSB0cy5faGVpZ2h0ICogKDEgLSB0cy5hbmNob3IueSk7XG4gICAgY29uc3QgYW5jaG9yWCA9IHRzLnV2UmVzcGVjdEFuY2hvciA/IHRzLmFuY2hvci54IDogMDtcbiAgICBjb25zdCBhbmNob3JZID0gdHMudXZSZXNwZWN0QW5jaG9yID8gdHMuYW5jaG9yLnkgOiAwO1xuICAgIHZlcnRpY2VzID0gcXVhZC51dnM7XG4gICAgdmVydGljZXNbMF0gPSB2ZXJ0aWNlc1s2XSA9IC1hbmNob3JYO1xuICAgIHZlcnRpY2VzWzFdID0gdmVydGljZXNbM10gPSAtYW5jaG9yWTtcbiAgICB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzRdID0gMSAtIGFuY2hvclg7XG4gICAgdmVydGljZXNbNV0gPSB2ZXJ0aWNlc1s3XSA9IDEgLSBhbmNob3JZO1xuICAgIHF1YWQuaW52YWxpZGF0ZSgpO1xuICAgIGNvbnN0IHRleCA9IHRzLl90ZXh0dXJlO1xuICAgIGNvbnN0IGJhc2VUZXggPSB0ZXguYmFzZVRleHR1cmU7XG4gICAgY29uc3QgcHJlbXVsdGlwbGllZCA9IGJhc2VUZXguYWxwaGFNb2RlID4gMDtcbiAgICBjb25zdCBsdCA9IHRzLnRpbGVUcmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm07XG4gICAgY29uc3QgdXYgPSB0cy51dk1hdHJpeDtcbiAgICBsZXQgaXNTaW1wbGUgPSBiYXNlVGV4LmlzUG93ZXJPZlR3byAmJiB0ZXguZnJhbWUud2lkdGggPT09IGJhc2VUZXgud2lkdGggJiYgdGV4LmZyYW1lLmhlaWdodCA9PT0gYmFzZVRleC5oZWlnaHQ7XG4gICAgaWYgKGlzU2ltcGxlKSB7XG4gICAgICBpZiAoIWJhc2VUZXguX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgIGlmIChiYXNlVGV4LndyYXBNb2RlID09PSBXUkFQX01PREVTLkNMQU1QKSB7XG4gICAgICAgICAgYmFzZVRleC53cmFwTW9kZSA9IFdSQVBfTU9ERVMuUkVQRUFUO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1NpbXBsZSA9IGJhc2VUZXgud3JhcE1vZGUgIT09IFdSQVBfTU9ERVMuQ0xBTVA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNoYWRlciA9IGlzU2ltcGxlID8gdGhpcy5zaW1wbGVTaGFkZXIgOiB0aGlzLnNoYWRlcjtcbiAgICBjb25zdCB3ID0gdGV4LndpZHRoO1xuICAgIGNvbnN0IGggPSB0ZXguaGVpZ2h0O1xuICAgIGNvbnN0IFcgPSB0cy5fd2lkdGg7XG4gICAgY29uc3QgSCA9IHRzLl9oZWlnaHQ7XG4gICAgdGVtcE1hdC5zZXQobHQuYSAqIHcgLyBXLCBsdC5iICogdyAvIEgsIGx0LmMgKiBoIC8gVywgbHQuZCAqIGggLyBILCBsdC50eCAvIFcsIGx0LnR5IC8gSCk7XG4gICAgdGVtcE1hdC5pbnZlcnQoKTtcbiAgICBpZiAoaXNTaW1wbGUpIHtcbiAgICAgIHRlbXBNYXQucHJlcGVuZCh1di5tYXBDb29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51TWFwQ29vcmQgPSB1di5tYXBDb29yZC50b0FycmF5KHRydWUpO1xuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVDbGFtcEZyYW1lID0gdXYudUNsYW1wRnJhbWU7XG4gICAgICBzaGFkZXIudW5pZm9ybXMudUNsYW1wT2Zmc2V0ID0gdXYudUNsYW1wT2Zmc2V0O1xuICAgIH1cbiAgICBzaGFkZXIudW5pZm9ybXMudVRyYW5zZm9ybSA9IHRlbXBNYXQudG9BcnJheSh0cnVlKTtcbiAgICBzaGFkZXIudW5pZm9ybXMudUNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRzLnRpbnQpLnByZW11bHRpcGx5KHRzLndvcmxkQWxwaGEsIHByZW11bHRpcGxpZWQpLnRvQXJyYXkoc2hhZGVyLnVuaWZvcm1zLnVDb2xvcik7XG4gICAgc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdHMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XG4gICAgc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gdGV4O1xuICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChxdWFkKTtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHV0aWxzLmNvcnJlY3RCbGVuZE1vZGUodHMuYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKTtcbiAgICByZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLnJlbmRlcmVyLmdsLlRSSUFOR0xFUywgNiwgMCk7XG4gIH1cbn1cblRpbGluZ1Nwcml0ZVJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJ0aWxpbmdTcHJpdGVcIixcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpblxufTtcbmV4dGVuc2lvbnMuYWRkKFRpbGluZ1Nwcml0ZVJlbmRlcmVyKTtcblxuZXhwb3J0IHsgVGlsaW5nU3ByaXRlUmVuZGVyZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGluZ1Nwcml0ZVJlbmRlcmVyLm1qcy5tYXBcbiIsImV4cG9ydCB7IFRpbGluZ1Nwcml0ZSB9IGZyb20gJy4vVGlsaW5nU3ByaXRlLm1qcyc7XG5leHBvcnQgeyBUaWxpbmdTcHJpdGVSZW5kZXJlciB9IGZyb20gJy4vVGlsaW5nU3ByaXRlUmVuZGVyZXIubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUsIEJhc2VUZXh0dXJlLCB1dGlscywgUmVjdGFuZ2xlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IF9TcHJpdGVzaGVldCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgZGF0YSwgcmVzb2x1dGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGlua2VkU2hlZXRzID0gW107XG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlID8gdGV4dHVyZSA6IG51bGw7XG4gICAgdGhpcy5iYXNlVGV4dHVyZSA9IHRleHR1cmUgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZSA/IHRleHR1cmUgOiB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSB8fCAocmVzb3VyY2UgPyByZXNvdXJjZS51cmwgOiBudWxsKSk7XG4gICAgdGhpcy5fZnJhbWVzID0gdGhpcy5kYXRhLmZyYW1lcztcbiAgICB0aGlzLl9mcmFtZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcmFtZXMpO1xuICAgIHRoaXMuX2JhdGNoSW5kZXggPSAwO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlUmVzb2x1dGlvbihyZXNvbHV0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgY29uc3QgeyBzY2FsZSB9ID0gdGhpcy5kYXRhLm1ldGE7XG4gICAgbGV0IHJlc29sdXRpb24gPSB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwocmVzb2x1dGlvbkZpbGVuYW1lLCBudWxsKTtcbiAgICBpZiAocmVzb2x1dGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmVzb2x1dGlvbiA9IHBhcnNlRmxvYXQoc2NhbGUgPz8gXCIxXCIpO1xuICAgIH1cbiAgICBpZiAocmVzb2x1dGlvbiAhPT0gMSkge1xuICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfVxuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuX2JhdGNoSW5kZXggPSAwO1xuICAgICAgaWYgKHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGggPD0gX1Nwcml0ZXNoZWV0LkJBVENIX1NJWkUpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0ZyYW1lcygwKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0FuaW1hdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fcGFyc2VDb21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmV4dEJhdGNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3Byb2Nlc3NGcmFtZXMoaW5pdGlhbEZyYW1lSW5kZXgpIHtcbiAgICBsZXQgZnJhbWVJbmRleCA9IGluaXRpYWxGcmFtZUluZGV4O1xuICAgIGNvbnN0IG1heEZyYW1lcyA9IF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFO1xuICAgIHdoaWxlIChmcmFtZUluZGV4IC0gaW5pdGlhbEZyYW1lSW5kZXggPCBtYXhGcmFtZXMgJiYgZnJhbWVJbmRleCA8IHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9mcmFtZUtleXNbZnJhbWVJbmRleF07XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5fZnJhbWVzW2ldO1xuICAgICAgY29uc3QgcmVjdCA9IGRhdGEuZnJhbWU7XG4gICAgICBpZiAocmVjdCkge1xuICAgICAgICBsZXQgZnJhbWUgPSBudWxsO1xuICAgICAgICBsZXQgdHJpbSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNpemUgPSBkYXRhLnRyaW1tZWQgIT09IGZhbHNlICYmIGRhdGEuc291cmNlU2l6ZSA/IGRhdGEuc291cmNlU2l6ZSA6IGRhdGEuZnJhbWU7XG4gICAgICAgIGNvbnN0IG9yaWcgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIE1hdGguZmxvb3Ioc291cmNlU2l6ZS53KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihzb3VyY2VTaXplLmgpIC8gdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgaWYgKGRhdGEucm90YXRlZCkge1xuICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZShNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZShNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnRyaW1tZWQgIT09IGZhbHNlICYmIGRhdGEuc3ByaXRlU291cmNlU2l6ZSkge1xuICAgICAgICAgIHRyaW0gPSBuZXcgUmVjdGFuZ2xlKE1hdGguZmxvb3IoZGF0YS5zcHJpdGVTb3VyY2VTaXplLngpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZXNbaV0gPSBuZXcgVGV4dHVyZSh0aGlzLmJhc2VUZXh0dXJlLCBmcmFtZSwgb3JpZywgdHJpbSwgZGF0YS5yb3RhdGVkID8gMiA6IDAsIGRhdGEuYW5jaG9yLCBkYXRhLmJvcmRlcnMpO1xuICAgICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGhpcy50ZXh0dXJlc1tpXSwgaSk7XG4gICAgICB9XG4gICAgICBmcmFtZUluZGV4Kys7XG4gICAgfVxuICB9XG4gIF9wcm9jZXNzQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5kYXRhLmFuaW1hdGlvbnMgfHwge307XG4gICAgZm9yIChjb25zdCBhbmltTmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuaW1hdGlvbnNbYW5pbU5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lTmFtZSA9IGFuaW1hdGlvbnNbYW5pbU5hbWVdW2ldO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdLnB1c2godGhpcy50ZXh0dXJlc1tmcmFtZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3BhcnNlQ29tcGxldGUoKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLnRleHR1cmVzKTtcbiAgfVxuICBfbmV4dEJhdGNoKCkge1xuICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXModGhpcy5fYmF0Y2hJbmRleCAqIF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFKTtcbiAgICB0aGlzLl9iYXRjaEluZGV4Kys7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fYmF0Y2hJbmRleCAqIF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFIDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfVxuICBkZXN0cm95KGRlc3Ryb3lCYXNlID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlcykge1xuICAgICAgdGhpcy50ZXh0dXJlc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lcyA9IG51bGw7XG4gICAgdGhpcy5fZnJhbWVLZXlzID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZXMgPSBudWxsO1xuICAgIGlmIChkZXN0cm95QmFzZSkge1xuICAgICAgdGhpcy5fdGV4dHVyZT8uZGVzdHJveSgpO1xuICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMubGlua2VkU2hlZXRzID0gW107XG4gIH1cbn07XG5sZXQgU3ByaXRlc2hlZXQgPSBfU3ByaXRlc2hlZXQ7XG5TcHJpdGVzaGVldC5CQVRDSF9TSVpFID0gMWUzO1xuXG5leHBvcnQgeyBTcHJpdGVzaGVldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlc2hlZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHksIGNvcHlTZWFyY2hQYXJhbXMgfSBmcm9tICdAcGl4aS9hc3NldHMnO1xuaW1wb3J0IHsgdXRpbHMsIEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBTcHJpdGVzaGVldCB9IGZyb20gJy4vU3ByaXRlc2hlZXQubWpzJztcblxuY29uc3QgdmFsaWRJbWFnZXMgPSBbXCJqcGdcIiwgXCJwbmdcIiwgXCJqcGVnXCIsIFwiYXZpZlwiLCBcIndlYnBcIl07XG5mdW5jdGlvbiBnZXRDYWNoZWFibGVBc3NldHMoa2V5cywgYXNzZXQsIGlnbm9yZU11bHRpUGFjaykge1xuICBjb25zdCBvdXQgPSB7fTtcbiAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBvdXRba2V5XSA9IGFzc2V0O1xuICB9KTtcbiAgT2JqZWN0LmtleXMoYXNzZXQudGV4dHVyZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG91dFtrZXldID0gYXNzZXQudGV4dHVyZXNba2V5XTtcbiAgfSk7XG4gIGlmICghaWdub3JlTXVsdGlQYWNrKSB7XG4gICAgY29uc3QgYmFzZVBhdGggPSB1dGlscy5wYXRoLmRpcm5hbWUoa2V5c1swXSk7XG4gICAgYXNzZXQubGlua2VkU2hlZXRzLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IG91dDIgPSBnZXRDYWNoZWFibGVBc3NldHMoW2Ake2Jhc2VQYXRofS8ke2Fzc2V0LmRhdGEubWV0YS5yZWxhdGVkX211bHRpX3BhY2tzW2ldfWBdLCBpdGVtLCB0cnVlKTtcbiAgICAgIE9iamVjdC5hc3NpZ24ob3V0LCBvdXQyKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuY29uc3Qgc3ByaXRlc2hlZXRBc3NldCA9IHtcbiAgZXh0ZW5zaW9uOiBFeHRlbnNpb25UeXBlLkFzc2V0LFxuICBjYWNoZToge1xuICAgIHRlc3Q6IChhc3NldCkgPT4gYXNzZXQgaW5zdGFuY2VvZiBTcHJpdGVzaGVldCxcbiAgICBnZXRDYWNoZWFibGVBc3NldHM6IChrZXlzLCBhc3NldCkgPT4gZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIGFzc2V0LCBmYWxzZSlcbiAgfSxcbiAgcmVzb2x2ZXI6IHtcbiAgICB0ZXN0OiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBVUkwgPSB2YWx1ZS5zcGxpdChcIj9cIilbMF07XG4gICAgICBjb25zdCBzcGxpdCA9IHRlbXBVUkwuc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gc3BsaXQucG9wKCk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBzcGxpdC5wb3AoKTtcbiAgICAgIHJldHVybiBleHRlbnNpb24gPT09IFwianNvblwiICYmIHZhbGlkSW1hZ2VzLmluY2x1ZGVzKGZvcm1hdCk7XG4gICAgfSxcbiAgICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoc2V0dGluZ3MuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICAgICAgZm9ybWF0OiBzcGxpdFtzcGxpdC5sZW5ndGggLSAyXSxcbiAgICAgICAgc3JjOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGxvYWRlcjoge1xuICAgIG5hbWU6IFwic3ByaXRlc2hlZXRMb2FkZXJcIixcbiAgICBleHRlbnNpb246IHtcbiAgICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Ob3JtYWxcbiAgICB9LFxuICAgIGFzeW5jIHRlc3RQYXJzZShhc3NldCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHV0aWxzLnBhdGguZXh0bmFtZShvcHRpb25zLnNyYykudG9Mb3dlckNhc2UoKSA9PT0gXCIuanNvblwiICYmICEhYXNzZXQuZnJhbWVzO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2UoYXNzZXQsIG9wdGlvbnMsIGxvYWRlcikge1xuICAgICAgbGV0IGJhc2VQYXRoID0gdXRpbHMucGF0aC5kaXJuYW1lKG9wdGlvbnMuc3JjKTtcbiAgICAgIGlmIChiYXNlUGF0aCAmJiBiYXNlUGF0aC5sYXN0SW5kZXhPZihcIi9cIikgIT09IGJhc2VQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgYmFzZVBhdGggKz0gXCIvXCI7XG4gICAgICB9XG4gICAgICBsZXQgaW1hZ2VQYXRoID0gYmFzZVBhdGggKyBhc3NldC5tZXRhLmltYWdlO1xuICAgICAgaW1hZ2VQYXRoID0gY29weVNlYXJjaFBhcmFtcyhpbWFnZVBhdGgsIG9wdGlvbnMuc3JjKTtcbiAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IGxvYWRlci5sb2FkKFtpbWFnZVBhdGhdKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBhc3NldHNbaW1hZ2VQYXRoXTtcbiAgICAgIGNvbnN0IHNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0KHRleHR1cmUuYmFzZVRleHR1cmUsIGFzc2V0LCBvcHRpb25zLnNyYyk7XG4gICAgICBhd2FpdCBzcHJpdGVzaGVldC5wYXJzZSgpO1xuICAgICAgY29uc3QgbXVsdGlQYWNrcyA9IGFzc2V0Py5tZXRhPy5yZWxhdGVkX211bHRpX3BhY2tzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXVsdGlQYWNrcykpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG11bHRpUGFja3MpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaXRlbVVybCA9IGJhc2VQYXRoICsgaXRlbTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhPy5pZ25vcmVNdWx0aVBhY2spIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtVXJsID0gY29weVNlYXJjaFBhcmFtcyhpdGVtVXJsLCBvcHRpb25zLnNyYyk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChsb2FkZXIubG9hZCh7XG4gICAgICAgICAgICBzcmM6IGl0ZW1VcmwsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGlnbm9yZU11bHRpUGFjazogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cyA9IHJlcztcbiAgICAgICAgcmVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpdGVtLmxpbmtlZFNoZWV0cyA9IFtzcHJpdGVzaGVldF0uY29uY2F0KHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cy5maWx0ZXIoKHNwKSA9PiBzcCAhPT0gaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcHJpdGVzaGVldDtcbiAgICB9LFxuICAgIHVubG9hZChzcHJpdGVzaGVldCkge1xuICAgICAgc3ByaXRlc2hlZXQuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5leHRlbnNpb25zLmFkZChzcHJpdGVzaGVldEFzc2V0KTtcblxuZXhwb3J0IHsgc3ByaXRlc2hlZXRBc3NldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlc2hlZXRBc3NldC5tanMubWFwXG4iLCJleHBvcnQgeyBTcHJpdGVzaGVldCB9IGZyb20gJy4vU3ByaXRlc2hlZXQubWpzJztcbmV4cG9ydCB7IHNwcml0ZXNoZWV0QXNzZXQgfSBmcm9tICcuL3Nwcml0ZXNoZWV0QXNzZXQubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNsYXNzIEJpdG1hcEZvbnREYXRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbmZvID0gW107XG4gICAgdGhpcy5jb21tb24gPSBbXTtcbiAgICB0aGlzLnBhZ2UgPSBbXTtcbiAgICB0aGlzLmNoYXIgPSBbXTtcbiAgICB0aGlzLmtlcm5pbmcgPSBbXTtcbiAgICB0aGlzLmRpc3RhbmNlRmllbGQgPSBbXTtcbiAgfVxufVxuXG5leHBvcnQgeyBCaXRtYXBGb250RGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwRm9udERhdGEubWpzLm1hcFxuIiwiaW1wb3J0IHsgQml0bWFwRm9udERhdGEgfSBmcm9tICcuLi9CaXRtYXBGb250RGF0YS5tanMnO1xuXG5jbGFzcyBUZXh0Rm9ybWF0IHtcbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLnN0YXJ0c1dpdGgoXCJpbmZvIGZhY2U9XCIpO1xuICB9XG4gIHN0YXRpYyBwYXJzZSh0eHQpIHtcbiAgICBjb25zdCBpdGVtcyA9IHR4dC5tYXRjaCgvXlthLXpdK1xccysuKyQvZ20pO1xuICAgIGNvbnN0IHJhd0RhdGEgPSB7XG4gICAgICBpbmZvOiBbXSxcbiAgICAgIGNvbW1vbjogW10sXG4gICAgICBwYWdlOiBbXSxcbiAgICAgIGNoYXI6IFtdLFxuICAgICAgY2hhcnM6IFtdLFxuICAgICAga2VybmluZzogW10sXG4gICAgICBrZXJuaW5nczogW10sXG4gICAgICBkaXN0YW5jZUZpZWxkOiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCBpIGluIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuYW1lID0gaXRlbXNbaV0ubWF0Y2goL15bYS16XSsvZ20pWzBdO1xuICAgICAgY29uc3QgYXR0cmlidXRlTGlzdCA9IGl0ZW1zW2ldLm1hdGNoKC9bYS16QS1aXSs9KFteXFxzXCInXSt8XCIoW15cIl0qKVwiKS9nbSk7XG4gICAgICBjb25zdCBpdGVtRGF0YSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpMiBpbiBhdHRyaWJ1dGVMaXN0KSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gYXR0cmlidXRlTGlzdFtpMl0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBzcGxpdFswXTtcbiAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSBzcGxpdFsxXS5yZXBsYWNlKC9cIi9nbSwgXCJcIik7XG4gICAgICAgIGNvbnN0IGZsb2F0VmFsdWUgPSBwYXJzZUZsb2F0KHN0clZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpc05hTihmbG9hdFZhbHVlKSA/IHN0clZhbHVlIDogZmxvYXRWYWx1ZTtcbiAgICAgICAgaXRlbURhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmF3RGF0YVtuYW1lXS5wdXNoKGl0ZW1EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IG5ldyBCaXRtYXBGb250RGF0YSgpO1xuICAgIHJhd0RhdGEuaW5mby5mb3JFYWNoKChpbmZvKSA9PiBmb250LmluZm8ucHVzaCh7XG4gICAgICBmYWNlOiBpbmZvLmZhY2UsXG4gICAgICBzaXplOiBwYXJzZUludChpbmZvLnNpemUsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmNvbW1vbi5mb3JFYWNoKChjb21tb24pID0+IGZvbnQuY29tbW9uLnB1c2goe1xuICAgICAgbGluZUhlaWdodDogcGFyc2VJbnQoY29tbW9uLmxpbmVIZWlnaHQsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLnBhZ2UuZm9yRWFjaCgocGFnZSkgPT4gZm9udC5wYWdlLnB1c2goe1xuICAgICAgaWQ6IHBhcnNlSW50KHBhZ2UuaWQsIDEwKSxcbiAgICAgIGZpbGU6IHBhZ2UuZmlsZVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmNoYXIuZm9yRWFjaCgoY2hhcikgPT4gZm9udC5jaGFyLnB1c2goe1xuICAgICAgaWQ6IHBhcnNlSW50KGNoYXIuaWQsIDEwKSxcbiAgICAgIHBhZ2U6IHBhcnNlSW50KGNoYXIucGFnZSwgMTApLFxuICAgICAgeDogcGFyc2VJbnQoY2hhci54LCAxMCksXG4gICAgICB5OiBwYXJzZUludChjaGFyLnksIDEwKSxcbiAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyLndpZHRoLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXIuaGVpZ2h0LCAxMCksXG4gICAgICB4b2Zmc2V0OiBwYXJzZUludChjaGFyLnhvZmZzZXQsIDEwKSxcbiAgICAgIHlvZmZzZXQ6IHBhcnNlSW50KGNoYXIueW9mZnNldCwgMTApLFxuICAgICAgeGFkdmFuY2U6IHBhcnNlSW50KGNoYXIueGFkdmFuY2UsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmtlcm5pbmcuZm9yRWFjaCgoa2VybmluZykgPT4gZm9udC5rZXJuaW5nLnB1c2goe1xuICAgICAgZmlyc3Q6IHBhcnNlSW50KGtlcm5pbmcuZmlyc3QsIDEwKSxcbiAgICAgIHNlY29uZDogcGFyc2VJbnQoa2VybmluZy5zZWNvbmQsIDEwKSxcbiAgICAgIGFtb3VudDogcGFyc2VJbnQoa2VybmluZy5hbW91bnQsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmRpc3RhbmNlRmllbGQuZm9yRWFjaCgoZGYpID0+IGZvbnQuZGlzdGFuY2VGaWVsZC5wdXNoKHtcbiAgICAgIGRpc3RhbmNlUmFuZ2U6IHBhcnNlSW50KGRmLmRpc3RhbmNlUmFuZ2UsIDEwKSxcbiAgICAgIGZpZWxkVHlwZTogZGYuZmllbGRUeXBlXG4gICAgfSkpO1xuICAgIHJldHVybiBmb250O1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHRGb3JtYXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRGb3JtYXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQml0bWFwRm9udERhdGEgfSBmcm9tICcuLi9CaXRtYXBGb250RGF0YS5tanMnO1xuXG5jbGFzcyBYTUxGb3JtYXQge1xuICBzdGF0aWMgdGVzdChkYXRhKSB7XG4gICAgY29uc3QgeG1sID0gZGF0YTtcbiAgICByZXR1cm4gXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiIGluIHhtbCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYWdlXCIpLmxlbmd0aCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbmZvXCIpWzBdLmdldEF0dHJpYnV0ZShcImZhY2VcIikgIT09IG51bGw7XG4gIH1cbiAgc3RhdGljIHBhcnNlKHhtbCkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgQml0bWFwRm9udERhdGEoKTtcbiAgICBjb25zdCBpbmZvID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5mb1wiKTtcbiAgICBjb25zdCBjb21tb24gPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb21tb25cIik7XG4gICAgY29uc3QgcGFnZSA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhZ2VcIik7XG4gICAgY29uc3QgY2hhciA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNoYXJcIik7XG4gICAgY29uc3Qga2VybmluZyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImtlcm5pbmdcIik7XG4gICAgY29uc3QgZGlzdGFuY2VGaWVsZCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpc3RhbmNlRmllbGRcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhLmluZm8ucHVzaCh7XG4gICAgICAgIGZhY2U6IGluZm9baV0uZ2V0QXR0cmlidXRlKFwiZmFjZVwiKSxcbiAgICAgICAgc2l6ZTogcGFyc2VJbnQoaW5mb1tpXS5nZXRBdHRyaWJ1dGUoXCJzaXplXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1vbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YS5jb21tb24ucHVzaCh7XG4gICAgICAgIGxpbmVIZWlnaHQ6IHBhcnNlSW50KGNvbW1vbltpXS5nZXRBdHRyaWJ1dGUoXCJsaW5lSGVpZ2h0XCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEucGFnZS5wdXNoKHtcbiAgICAgICAgaWQ6IHBhcnNlSW50KHBhZ2VbaV0uZ2V0QXR0cmlidXRlKFwiaWRcIiksIDEwKSB8fCAwLFxuICAgICAgICBmaWxlOiBwYWdlW2ldLmdldEF0dHJpYnV0ZShcImZpbGVcIilcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGNoYXJbaV07XG4gICAgICBkYXRhLmNoYXIucHVzaCh7XG4gICAgICAgIGlkOiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwiaWRcIiksIDEwKSxcbiAgICAgICAgcGFnZTogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcInBhZ2VcIiksIDEwKSB8fCAwLFxuICAgICAgICB4OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieFwiKSwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieVwiKSwgMTApLFxuICAgICAgICB3aWR0aDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpLCAxMCksXG4gICAgICAgIGhlaWdodDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgMTApLFxuICAgICAgICB4b2Zmc2V0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieG9mZnNldFwiKSwgMTApLFxuICAgICAgICB5b2Zmc2V0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieW9mZnNldFwiKSwgMTApLFxuICAgICAgICB4YWR2YW5jZTogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcInhhZHZhbmNlXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEua2VybmluZy5wdXNoKHtcbiAgICAgICAgZmlyc3Q6IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiZmlyc3RcIiksIDEwKSxcbiAgICAgICAgc2Vjb25kOiBwYXJzZUludChrZXJuaW5nW2ldLmdldEF0dHJpYnV0ZShcInNlY29uZFwiKSwgMTApLFxuICAgICAgICBhbW91bnQ6IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiYW1vdW50XCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpc3RhbmNlRmllbGQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEuZGlzdGFuY2VGaWVsZC5wdXNoKHtcbiAgICAgICAgZmllbGRUeXBlOiBkaXN0YW5jZUZpZWxkW2ldLmdldEF0dHJpYnV0ZShcImZpZWxkVHlwZVwiKSxcbiAgICAgICAgZGlzdGFuY2VSYW5nZTogcGFyc2VJbnQoZGlzdGFuY2VGaWVsZFtpXS5nZXRBdHRyaWJ1dGUoXCJkaXN0YW5jZVJhbmdlXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgeyBYTUxGb3JtYXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhNTEZvcm1hdC5tanMubWFwXG4iLCJpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgWE1MRm9ybWF0IH0gZnJvbSAnLi9YTUxGb3JtYXQubWpzJztcblxuY2xhc3MgWE1MU3RyaW5nRm9ybWF0IHtcbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLmluY2x1ZGVzKFwiPGZvbnQ+XCIpKSB7XG4gICAgICByZXR1cm4gWE1MRm9ybWF0LnRlc3Qoc2V0dGluZ3MuQURBUFRFUi5wYXJzZVhNTChkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoeG1sVHh0KSB7XG4gICAgcmV0dXJuIFhNTEZvcm1hdC5wYXJzZShzZXR0aW5ncy5BREFQVEVSLnBhcnNlWE1MKHhtbFR4dCkpO1xuICB9XG59XG5cbmV4cG9ydCB7IFhNTFN0cmluZ0Zvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9WE1MU3RyaW5nRm9ybWF0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHRGb3JtYXQgfSBmcm9tICcuL1RleHRGb3JtYXQubWpzJztcbmV4cG9ydCB7IFRleHRGb3JtYXQgfSBmcm9tICcuL1RleHRGb3JtYXQubWpzJztcbmltcG9ydCB7IFhNTEZvcm1hdCB9IGZyb20gJy4vWE1MRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBYTUxGb3JtYXQgfSBmcm9tICcuL1hNTEZvcm1hdC5tanMnO1xuaW1wb3J0IHsgWE1MU3RyaW5nRm9ybWF0IH0gZnJvbSAnLi9YTUxTdHJpbmdGb3JtYXQubWpzJztcbmV4cG9ydCB7IFhNTFN0cmluZ0Zvcm1hdCB9IGZyb20gJy4vWE1MU3RyaW5nRm9ybWF0Lm1qcyc7XG5cbmNvbnN0IGZvcm1hdHMgPSBbXG4gIFRleHRGb3JtYXQsXG4gIFhNTEZvcm1hdCxcbiAgWE1MU3RyaW5nRm9ybWF0XG5dO1xuZnVuY3Rpb24gYXV0b0RldGVjdEZvcm1hdChkYXRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChmb3JtYXRzW2ldLnRlc3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgYXV0b0RldGVjdEZvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgVEVYVF9HUkFESUVOVCB9IGZyb20gJ0BwaXhpL3RleHQnO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUZpbGxTdHlsZShjYW52YXMsIGNvbnRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBsaW5lcywgbWV0cmljcykge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsbFN0eWxlKSkge1xuICAgIHJldHVybiBmaWxsU3R5bGU7XG4gIH0gZWxzZSBpZiAoZmlsbFN0eWxlLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmaWxsU3R5bGVbMF07XG4gIH1cbiAgbGV0IGdyYWRpZW50O1xuICBjb25zdCBkcm9wU2hhZG93Q29ycmVjdGlvbiA9IHN0eWxlLmRyb3BTaGFkb3cgPyBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgOiAwO1xuICBjb25zdCBwYWRkaW5nID0gc3R5bGUucGFkZGluZyB8fCAwO1xuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aCAvIHJlc29sdXRpb24gLSBkcm9wU2hhZG93Q29ycmVjdGlvbiAtIHBhZGRpbmcgKiAyO1xuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gIGNvbnN0IGZpbGwgPSBmaWxsU3R5bGUuc2xpY2UoKTtcbiAgY29uc3QgZmlsbEdyYWRpZW50U3RvcHMgPSBzdHlsZS5maWxsR3JhZGllbnRTdG9wcy5zbGljZSgpO1xuICBpZiAoIWZpbGxHcmFkaWVudFN0b3BzLmxlbmd0aCkge1xuICAgIGNvbnN0IGxlbmd0aFBsdXMxID0gZmlsbC5sZW5ndGggKyAxO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoUGx1czE7ICsraSkge1xuICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaChpIC8gbGVuZ3RoUGx1czEpO1xuICAgIH1cbiAgfVxuICBmaWxsLnVuc2hpZnQoZmlsbFN0eWxlWzBdKTtcbiAgZmlsbEdyYWRpZW50U3RvcHMudW5zaGlmdCgwKTtcbiAgZmlsbC5wdXNoKGZpbGxTdHlsZVtmaWxsU3R5bGUubGVuZ3RoIC0gMV0pO1xuICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpO1xuICBpZiAoc3R5bGUuZmlsbEdyYWRpZW50VHlwZSA9PT0gVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQod2lkdGggLyAyLCBwYWRkaW5nLCB3aWR0aCAvIDIsIGhlaWdodCArIHBhZGRpbmcpO1xuICAgIGxldCBsYXN0SXRlcmF0aW9uU3RvcCA9IDA7XG4gICAgY29uc3QgdGV4dEhlaWdodCA9IG1ldHJpY3MuZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgY29uc3QgZ3JhZFN0b3BMaW5lSGVpZ2h0ID0gdGV4dEhlaWdodCAvIGhlaWdodDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0aGlzTGluZVRvcCA9IG1ldHJpY3MubGluZUhlaWdodCAqIGk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IGxpbmVTdG9wID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tqXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGxpbmVTdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbal07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZVN0b3AgPSBqIC8gZmlsbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2xvYmFsU3RvcCA9IHRoaXNMaW5lVG9wIC8gaGVpZ2h0ICsgbGluZVN0b3AgKiBncmFkU3RvcExpbmVIZWlnaHQ7XG4gICAgICAgIGxldCBjbGFtcGVkU3RvcCA9IE1hdGgubWF4KGxhc3RJdGVyYXRpb25TdG9wLCBnbG9iYWxTdG9wKTtcbiAgICAgICAgY2xhbXBlZFN0b3AgPSBNYXRoLm1pbihjbGFtcGVkU3RvcCwgMSk7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChjbGFtcGVkU3RvcCwgZmlsbFtqXSk7XG4gICAgICAgIGxhc3RJdGVyYXRpb25TdG9wID0gY2xhbXBlZFN0b3A7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChwYWRkaW5nLCBoZWlnaHQgLyAyLCB3aWR0aCArIHBhZGRpbmcsIGhlaWdodCAvIDIpO1xuICAgIGNvbnN0IHRvdGFsSXRlcmF0aW9ucyA9IGZpbGwubGVuZ3RoICsgMTtcbiAgICBsZXQgY3VycmVudEl0ZXJhdGlvbiA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc3RvcDtcbiAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3RvcCA9IGZpbGxHcmFkaWVudFN0b3BzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnM7XG4gICAgICB9XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgZmlsbFtpXSk7XG4gICAgICBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBncmFkaWVudDtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVGaWxsU3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlRmlsbFN0eWxlLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBnZW5lcmF0ZUZpbGxTdHlsZSB9IGZyb20gJy4vZ2VuZXJhdGVGaWxsU3R5bGUubWpzJztcblxuZnVuY3Rpb24gZHJhd0dseXBoKGNhbnZhcywgY29udGV4dCwgbWV0cmljcywgeCwgeSwgcmVzb2x1dGlvbiwgc3R5bGUpIHtcbiAgY29uc3QgY2hhciA9IG1ldHJpY3MudGV4dDtcbiAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzO1xuICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgY29udGV4dC5zY2FsZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgY29uc3QgdHggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICBjb25zdCB0eSA9IC0oc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMik7XG4gIGNvbnRleHQuZm9udCA9IHN0eWxlLnRvRm9udFN0cmluZygpO1xuICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gIGNvbnRleHQubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbjtcbiAgY29udGV4dC5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdDtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBnZW5lcmF0ZUZpbGxTdHlsZShjYW52YXMsIGNvbnRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBbY2hhcl0sIG1ldHJpY3MpO1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgIGNvbnN0IGRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcbiAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHN0eWxlLmRyb3BTaGFkb3dCbHVyICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBkcm9wU2hhZG93RGlzdGFuY2UgPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgKiByZXNvbHV0aW9uO1xuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShzdHlsZS5kcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpO1xuICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xuICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICB9XG4gIGlmIChzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgY29udGV4dC5zdHJva2VUZXh0KGNoYXIsIHR4LCB0eSArIG1ldHJpY3MubGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmRlc2NlbnQpO1xuICB9XG4gIGlmIChzdHlsZS5maWxsKSB7XG4gICAgY29udGV4dC5maWxsVGV4dChjaGFyLCB0eCwgdHkgKyBtZXRyaWNzLmxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5kZXNjZW50KTtcbiAgfVxuICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMClcIjtcbn1cblxuZXhwb3J0IHsgZHJhd0dseXBoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3R2x5cGgubWpzLm1hcFxuIiwiZXhwb3J0IHsgZHJhd0dseXBoIH0gZnJvbSAnLi9kcmF3R2x5cGgubWpzJztcbmV4cG9ydCB7IGV4dHJhY3RDaGFyQ29kZSB9IGZyb20gJy4vZXh0cmFjdENoYXJDb2RlLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUZpbGxTdHlsZSB9IGZyb20gJy4vZ2VuZXJhdGVGaWxsU3R5bGUubWpzJztcbmV4cG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH0gZnJvbSAnLi9yZXNvbHZlQ2hhcmFjdGVycy5tanMnO1xuZXhwb3J0IHsgc3BsaXRUZXh0VG9DaGFyYWN0ZXJzIH0gZnJvbSAnLi9zcGxpdFRleHRUb0NoYXJhY3RlcnMubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImZ1bmN0aW9uIHNwbGl0VGV4dFRvQ2hhcmFjdGVycyh0ZXh0KSB7XG4gIHJldHVybiBBcnJheS5mcm9tID8gQXJyYXkuZnJvbSh0ZXh0KSA6IHRleHQuc3BsaXQoXCJcIik7XG59XG5cbmV4cG9ydCB7IHNwbGl0VGV4dFRvQ2hhcmFjdGVycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qcy5tYXBcbiIsImltcG9ydCB7IHNwbGl0VGV4dFRvQ2hhcmFjdGVycyB9IGZyb20gJy4vc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVDaGFyYWN0ZXJzKGNoYXJzKSB7XG4gIGlmICh0eXBlb2YgY2hhcnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjaGFycyA9IFtjaGFyc107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBqID0gY2hhcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IGNoYXJzW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBpZiAoaXRlbS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlIGxlbmd0aCwgZXhwZWN0aW5nIDIgZ290ICR7aXRlbS5sZW5ndGh9LmApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRDb2RlID0gaXRlbVswXS5jaGFyQ29kZUF0KDApO1xuICAgICAgY29uc3QgZW5kQ29kZSA9IGl0ZW1bMV0uY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChlbmRDb2RlIDwgc3RhcnRDb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgcmFuZ2UuXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaTIgPSBzdGFydENvZGUsIGoyID0gZW5kQ29kZTsgaTIgPD0gajI7IGkyKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpMikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zcGxpdFRleHRUb0NoYXJhY3RlcnMoaXRlbSkpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogRW1wdHkgc2V0IHdoZW4gcmVzb2x2aW5nIGNoYXJhY3RlcnMuXCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ2hhcmFjdGVycy5tanMubWFwXG4iLCJmdW5jdGlvbiBleHRyYWN0Q2hhckNvZGUoc3RyKSB7XG4gIHJldHVybiBzdHIuY29kZVBvaW50QXQgPyBzdHIuY29kZVBvaW50QXQoMCkgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cblxuZXhwb3J0IHsgZXh0cmFjdENoYXJDb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0Q2hhckNvZGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMsIEFMUEhBX01PREVTLCBNSVBNQVBfTU9ERVMsIFJlY3RhbmdsZSwgVGV4dHVyZSwgc2V0dGluZ3MsIEJhc2VUZXh0dXJlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBUZXh0U3R5bGUsIFRleHRNZXRyaWNzIH0gZnJvbSAnQHBpeGkvdGV4dCc7XG5pbXBvcnQgeyBCaXRtYXBGb250RGF0YSB9IGZyb20gJy4vQml0bWFwRm9udERhdGEubWpzJztcbmltcG9ydCB7IGF1dG9EZXRlY3RGb3JtYXQgfSBmcm9tICcuL2Zvcm1hdHMvaW5kZXgubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5pbXBvcnQgeyBkcmF3R2x5cGggfSBmcm9tICcuL3V0aWxzL2RyYXdHbHlwaC5tanMnO1xuaW1wb3J0IHsgZXh0cmFjdENoYXJDb2RlIH0gZnJvbSAnLi91dGlscy9leHRyYWN0Q2hhckNvZGUubWpzJztcblxuY29uc3QgX0JpdG1hcEZvbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHRleHR1cmVzLCBvd25zVGV4dHVyZXMpIHtcbiAgICBjb25zdCBbaW5mb10gPSBkYXRhLmluZm87XG4gICAgY29uc3QgW2NvbW1vbl0gPSBkYXRhLmNvbW1vbjtcbiAgICBjb25zdCBbcGFnZV0gPSBkYXRhLnBhZ2U7XG4gICAgY29uc3QgW2Rpc3RhbmNlRmllbGRdID0gZGF0YS5kaXN0YW5jZUZpZWxkO1xuICAgIGNvbnN0IHJlcyA9IHV0aWxzLmdldFJlc29sdXRpb25PZlVybChwYWdlLmZpbGUpO1xuICAgIGNvbnN0IHBhZ2VUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuX293bnNUZXh0dXJlcyA9IG93bnNUZXh0dXJlcztcbiAgICB0aGlzLmZvbnQgPSBpbmZvLmZhY2U7XG4gICAgdGhpcy5zaXplID0gaW5mby5zaXplO1xuICAgIHRoaXMubGluZUhlaWdodCA9IGNvbW1vbi5saW5lSGVpZ2h0IC8gcmVzO1xuICAgIHRoaXMuY2hhcnMgPSB7fTtcbiAgICB0aGlzLnBhZ2VUZXh0dXJlcyA9IHBhZ2VUZXh0dXJlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEucGFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBpZCwgZmlsZSB9ID0gZGF0YS5wYWdlW2ldO1xuICAgICAgcGFnZVRleHR1cmVzW2lkXSA9IHRleHR1cmVzIGluc3RhbmNlb2YgQXJyYXkgPyB0ZXh0dXJlc1tpXSA6IHRleHR1cmVzW2ZpbGVdO1xuICAgICAgaWYgKGRpc3RhbmNlRmllbGQ/LmZpZWxkVHlwZSAmJiBkaXN0YW5jZUZpZWxkLmZpZWxkVHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgcGFnZVRleHR1cmVzW2lkXS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgPSBBTFBIQV9NT0RFUy5OT19QUkVNVUxUSVBMSUVEX0FMUEhBO1xuICAgICAgICBwYWdlVGV4dHVyZXNbaWRdLmJhc2VUZXh0dXJlLm1pcG1hcCA9IE1JUE1BUF9NT0RFUy5PRkY7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5jaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGlkLCBwYWdlOiBwYWdlMiB9ID0gZGF0YS5jaGFyW2ldO1xuICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgeG9mZnNldCwgeW9mZnNldCwgeGFkdmFuY2UgfSA9IGRhdGEuY2hhcltpXTtcbiAgICAgIHggLz0gcmVzO1xuICAgICAgeSAvPSByZXM7XG4gICAgICB3aWR0aCAvPSByZXM7XG4gICAgICBoZWlnaHQgLz0gcmVzO1xuICAgICAgeG9mZnNldCAvPSByZXM7XG4gICAgICB5b2Zmc2V0IC89IHJlcztcbiAgICAgIHhhZHZhbmNlIC89IHJlcztcbiAgICAgIGNvbnN0IHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHggKyBwYWdlVGV4dHVyZXNbcGFnZTJdLmZyYW1lLnggLyByZXMsIHkgKyBwYWdlVGV4dHVyZXNbcGFnZTJdLmZyYW1lLnkgLyByZXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jaGFyc1tpZF0gPSB7XG4gICAgICAgIHhPZmZzZXQ6IHhvZmZzZXQsXG4gICAgICAgIHlPZmZzZXQ6IHlvZmZzZXQsXG4gICAgICAgIHhBZHZhbmNlOiB4YWR2YW5jZSxcbiAgICAgICAga2VybmluZzoge30sXG4gICAgICAgIHRleHR1cmU6IG5ldyBUZXh0dXJlKHBhZ2VUZXh0dXJlc1twYWdlMl0uYmFzZVRleHR1cmUsIHJlY3QpLFxuICAgICAgICBwYWdlOiBwYWdlMlxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB7IGZpcnN0LCBzZWNvbmQsIGFtb3VudCB9ID0gZGF0YS5rZXJuaW5nW2ldO1xuICAgICAgZmlyc3QgLz0gcmVzO1xuICAgICAgc2Vjb25kIC89IHJlcztcbiAgICAgIGFtb3VudCAvPSByZXM7XG4gICAgICBpZiAodGhpcy5jaGFyc1tzZWNvbmRdKSB7XG4gICAgICAgIHRoaXMuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXN0YW5jZUZpZWxkUmFuZ2UgPSBkaXN0YW5jZUZpZWxkPy5kaXN0YW5jZVJhbmdlO1xuICAgIHRoaXMuZGlzdGFuY2VGaWVsZFR5cGUgPSBkaXN0YW5jZUZpZWxkPy5maWVsZFR5cGU/LnRvTG93ZXJDYXNlKCkgPz8gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2hhcnMpIHtcbiAgICAgIHRoaXMuY2hhcnNbaWRdLnRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jaGFyc1tpZF0udGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5wYWdlVGV4dHVyZXMpIHtcbiAgICAgIGlmICh0aGlzLl9vd25zVGV4dHVyZXMpIHtcbiAgICAgICAgdGhpcy5wYWdlVGV4dHVyZXNbaWRdLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZ2VUZXh0dXJlc1tpZF0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNoYXJzID0gbnVsbDtcbiAgICB0aGlzLnBhZ2VUZXh0dXJlcyA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGluc3RhbGwoZGF0YSwgdGV4dHVyZXMsIG93bnNUZXh0dXJlcykge1xuICAgIGxldCBmb250RGF0YTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJpdG1hcEZvbnREYXRhKSB7XG4gICAgICBmb250RGF0YSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGF1dG9EZXRlY3RGb3JtYXQoZGF0YSk7XG4gICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZGF0YSBmb3JtYXQgZm9yIGZvbnQuXCIpO1xuICAgICAgfVxuICAgICAgZm9udERhdGEgPSBmb3JtYXQucGFyc2UoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0ZXh0dXJlcyBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHRleHR1cmVzID0gW3RleHR1cmVzXTtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IG5ldyBfQml0bWFwRm9udChmb250RGF0YSwgdGV4dHVyZXMsIG93bnNUZXh0dXJlcyk7XG4gICAgX0JpdG1hcEZvbnQuYXZhaWxhYmxlW2ZvbnQuZm9udF0gPSBmb250O1xuICAgIHJldHVybiBmb250O1xuICB9XG4gIHN0YXRpYyB1bmluc3RhbGwobmFtZSkge1xuICAgIGNvbnN0IGZvbnQgPSBfQml0bWFwRm9udC5hdmFpbGFibGVbbmFtZV07XG4gICAgaWYgKCFmb250KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGZvbnQgZm91bmQgbmFtZWQgJyR7bmFtZX0nYCk7XG4gICAgfVxuICAgIGZvbnQuZGVzdHJveSgpO1xuICAgIGRlbGV0ZSBfQml0bWFwRm9udC5hdmFpbGFibGVbbmFtZV07XG4gIH1cbiAgc3RhdGljIGZyb20obmFtZSwgdGV4dFN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF0gUHJvcGVydHkgYG5hbWVgIGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2hhcnMsXG4gICAgICBwYWRkaW5nLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHRleHR1cmVXaWR0aCxcbiAgICAgIHRleHR1cmVIZWlnaHQsXG4gICAgICAuLi5iYXNlT3B0aW9uc1xuICAgIH0gPSBPYmplY3QuYXNzaWduKHt9LCBfQml0bWFwRm9udC5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgY2hhcnNMaXN0ID0gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpO1xuICAgIGNvbnN0IHN0eWxlID0gdGV4dFN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlID8gdGV4dFN0eWxlIDogbmV3IFRleHRTdHlsZSh0ZXh0U3R5bGUpO1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRleHR1cmVXaWR0aDtcbiAgICBjb25zdCBmb250RGF0YSA9IG5ldyBCaXRtYXBGb250RGF0YSgpO1xuICAgIGZvbnREYXRhLmluZm9bMF0gPSB7XG4gICAgICBmYWNlOiBzdHlsZS5mb250RmFtaWx5LFxuICAgICAgc2l6ZTogc3R5bGUuZm9udFNpemVcbiAgICB9O1xuICAgIGZvbnREYXRhLmNvbW1vblswXSA9IHtcbiAgICAgIGxpbmVIZWlnaHQ6IHN0eWxlLmZvbnRTaXplXG4gICAgfTtcbiAgICBsZXQgcG9zaXRpb25YID0gMDtcbiAgICBsZXQgcG9zaXRpb25ZID0gMDtcbiAgICBsZXQgY2FudmFzO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGxldCBiYXNlVGV4dHVyZTtcbiAgICBsZXQgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgY29uc3QgYmFzZVRleHR1cmVzID0gW107XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGV4dHVyZVdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGV4dHVyZUhlaWdodDtcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKGNhbnZhcywgeyByZXNvbHV0aW9uLCAuLi5iYXNlT3B0aW9ucyB9KTtcbiAgICAgICAgYmFzZVRleHR1cmVzLnB1c2goYmFzZVRleHR1cmUpO1xuICAgICAgICB0ZXh0dXJlcy5wdXNoKG5ldyBUZXh0dXJlKGJhc2VUZXh0dXJlKSk7XG4gICAgICAgIGZvbnREYXRhLnBhZ2UucHVzaCh7XG4gICAgICAgICAgaWQ6IHRleHR1cmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgZmlsZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGNoYXJzTGlzdFtpXTtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBUZXh0TWV0cmljcy5tZWFzdXJlVGV4dChjaGFyYWN0ZXIsIHN0eWxlLCBmYWxzZSwgY2FudmFzKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gbWV0cmljcy53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChtZXRyaWNzLmhlaWdodCk7XG4gICAgICBjb25zdCB0ZXh0dXJlR2x5cGhXaWR0aCA9IE1hdGguY2VpbCgoc3R5bGUuZm9udFN0eWxlID09PSBcIml0YWxpY1wiID8gMiA6IDEpICogd2lkdGgpO1xuICAgICAgaWYgKHBvc2l0aW9uWSA+PSB0ZXh0dXJlSGVpZ2h0IC0gaGVpZ2h0ICogcmVzb2x1dGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb25ZID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF0gdGV4dHVyZUhlaWdodCAke3RleHR1cmVIZWlnaHR9cHggaXMgdG9vIHNtYWxsIChmb250RmFtaWx5OiAnJHtzdHlsZS5mb250RmFtaWx5fScsIGZvbnRTaXplOiAke3N0eWxlLmZvbnRTaXplfXB4LCBjaGFyOiAnJHtjaGFyYWN0ZXJ9JylgKTtcbiAgICAgICAgfVxuICAgICAgICAtLWk7XG4gICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgICBiYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHBvc2l0aW9uWSA9IDA7XG4gICAgICAgIHBvc2l0aW9uWCA9IDA7XG4gICAgICAgIG1heENoYXJIZWlnaHQgPSAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1heENoYXJIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgKyBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzLmRlc2NlbnQsIG1heENoYXJIZWlnaHQpO1xuICAgICAgaWYgKHRleHR1cmVHbHlwaFdpZHRoICogcmVzb2x1dGlvbiArIHBvc2l0aW9uWCA+PSBsaW5lV2lkdGgpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uWCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0JpdG1hcEZvbnRdIHRleHR1cmVXaWR0aCAke3RleHR1cmVXaWR0aH1weCBpcyB0b28gc21hbGwgKGZvbnRGYW1pbHk6ICcke3N0eWxlLmZvbnRGYW1pbHl9JywgZm9udFNpemU6ICR7c3R5bGUuZm9udFNpemV9cHgsIGNoYXI6ICcke2NoYXJhY3Rlcn0nKWApO1xuICAgICAgICB9XG4gICAgICAgIC0taTtcbiAgICAgICAgcG9zaXRpb25ZICs9IG1heENoYXJIZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgICAgICBwb3NpdGlvblkgPSBNYXRoLmNlaWwocG9zaXRpb25ZKTtcbiAgICAgICAgcG9zaXRpb25YID0gMDtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZHJhd0dseXBoKGNhbnZhcywgY29udGV4dCwgbWV0cmljcywgcG9zaXRpb25YLCBwb3NpdGlvblksIHJlc29sdXRpb24sIHN0eWxlKTtcbiAgICAgIGNvbnN0IGlkID0gZXh0cmFjdENoYXJDb2RlKG1ldHJpY3MudGV4dCk7XG4gICAgICBmb250RGF0YS5jaGFyLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgcGFnZTogdGV4dHVyZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgeDogcG9zaXRpb25YIC8gcmVzb2x1dGlvbixcbiAgICAgICAgeTogcG9zaXRpb25ZIC8gcmVzb2x1dGlvbixcbiAgICAgICAgd2lkdGg6IHRleHR1cmVHbHlwaFdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHhvZmZzZXQ6IDAsXG4gICAgICAgIHlvZmZzZXQ6IDAsXG4gICAgICAgIHhhZHZhbmNlOiB3aWR0aCAtIChzdHlsZS5kcm9wU2hhZG93ID8gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlIDogMCkgLSAoc3R5bGUuc3Ryb2tlID8gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIDogMClcbiAgICAgIH0pO1xuICAgICAgcG9zaXRpb25YICs9ICh0ZXh0dXJlR2x5cGhXaWR0aCArIDIgKiBwYWRkaW5nKSAqIHJlc29sdXRpb247XG4gICAgICBwb3NpdGlvblggPSBNYXRoLmNlaWwocG9zaXRpb25YKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoYXJzTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgZmlyc3QgPSBjaGFyc0xpc3RbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IGNoYXJzTGlzdFtqXTtcbiAgICAgICAgY29uc3QgYzEgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0KS53aWR0aDtcbiAgICAgICAgY29uc3QgYzIgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHNlY29uZCkud2lkdGg7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gY29udGV4dC5tZWFzdXJlVGV4dChmaXJzdCArIHNlY29uZCkud2lkdGg7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHRvdGFsIC0gKGMxICsgYzIpO1xuICAgICAgICBpZiAoYW1vdW50KSB7XG4gICAgICAgICAgZm9udERhdGEua2VybmluZy5wdXNoKHtcbiAgICAgICAgICAgIGZpcnN0OiBleHRyYWN0Q2hhckNvZGUoZmlyc3QpLFxuICAgICAgICAgICAgc2Vjb25kOiBleHRyYWN0Q2hhckNvZGUoc2Vjb25kKSxcbiAgICAgICAgICAgIGFtb3VudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSBuZXcgX0JpdG1hcEZvbnQoZm9udERhdGEsIHRleHR1cmVzLCB0cnVlKTtcbiAgICBpZiAoX0JpdG1hcEZvbnQuYXZhaWxhYmxlW25hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgIF9CaXRtYXBGb250LnVuaW5zdGFsbChuYW1lKTtcbiAgICB9XG4gICAgX0JpdG1hcEZvbnQuYXZhaWxhYmxlW25hbWVdID0gZm9udDtcbiAgICByZXR1cm4gZm9udDtcbiAgfVxufTtcbmxldCBCaXRtYXBGb250ID0gX0JpdG1hcEZvbnQ7XG5CaXRtYXBGb250LkFMUEhBID0gW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgXCIgXCJdO1xuQml0bWFwRm9udC5OVU1FUklDID0gW1tcIjBcIiwgXCI5XCJdXTtcbkJpdG1hcEZvbnQuQUxQSEFOVU1FUklDID0gW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiIFwiXTtcbkJpdG1hcEZvbnQuQVNDSUkgPSBbW1wiIFwiLCBcIn5cIl1dO1xuQml0bWFwRm9udC5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgcmVzb2x1dGlvbjogMSxcbiAgdGV4dHVyZVdpZHRoOiA1MTIsXG4gIHRleHR1cmVIZWlnaHQ6IDUxMixcbiAgcGFkZGluZzogNCxcbiAgY2hhcnM6IF9CaXRtYXBGb250LkFMUEhBTlVNRVJJQ1xufTtcbkJpdG1hcEZvbnQuYXZhaWxhYmxlID0ge307XG5cbmV4cG9ydCB7IEJpdG1hcEZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcEZvbnQubWpzLm1hcFxuIiwidmFyIG1zZGZGcmFnID0gXCIvLyBQaXhpIHRleHR1cmUgaW5mb1xcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbi8vIFRpbnRcXHJcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcclxcblxcclxcbi8vIG9uIDJEIGFwcGxpY2F0aW9ucyBmd2lkdGggaXMgc2NyZWVuU2NhbGUgLyBnbHlwaEF0bGFzU2NhbGUgKiBkaXN0YW5jZUZpZWxkUmFuZ2VcXHJcXG51bmlmb3JtIGZsb2F0IHVGV2lkdGg7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpIHtcXHJcXG5cXHJcXG4gIC8vIFRvIHN0YWNrIE1TREYgYW5kIFNERiB3ZSBuZWVkIGEgbm9uLXByZS1tdWx0aXBsaWVkLWFscGhhIHRleHR1cmUuXFxyXFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG5cXHJcXG4gIC8vIE1TREZcXHJcXG4gIGZsb2F0IG1lZGlhbiA9IHRleENvbG9yLnIgKyB0ZXhDb2xvci5nICsgdGV4Q29sb3IuYiAtXFxyXFxuICAgICAgICAgICAgICAgICAgbWluKHRleENvbG9yLnIsIG1pbih0ZXhDb2xvci5nLCB0ZXhDb2xvci5iKSkgLVxcclxcbiAgICAgICAgICAgICAgICAgIG1heCh0ZXhDb2xvci5yLCBtYXgodGV4Q29sb3IuZywgdGV4Q29sb3IuYikpO1xcclxcbiAgLy8gU0RGXFxyXFxuICBtZWRpYW4gPSBtaW4obWVkaWFuLCB0ZXhDb2xvci5hKTtcXHJcXG5cXHJcXG4gIGZsb2F0IHNjcmVlblB4RGlzdGFuY2UgPSB1RldpZHRoICogKG1lZGlhbiAtIDAuNSk7XFxyXFxuICBmbG9hdCBhbHBoYSA9IGNsYW1wKHNjcmVlblB4RGlzdGFuY2UgKyAwLjUsIDAuMCwgMS4wKTtcXHJcXG4gIGlmIChtZWRpYW4gPCAwLjAxKSB7XFxyXFxuICAgIGFscGhhID0gMC4wO1xcclxcbiAgfSBlbHNlIGlmIChtZWRpYW4gPiAwLjk5KSB7XFxyXFxuICAgIGFscGhhID0gMS4wO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gR2FtbWEgY29ycmVjdGlvbiBmb3IgY292ZXJhZ2UtbGlrZSBhbHBoYVxcclxcbiAgZmxvYXQgbHVtYSA9IGRvdCh1Q29sb3IucmdiLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcXHJcXG4gIGZsb2F0IGdhbW1hID0gbWl4KDEuMCwgMS4wIC8gMi4yLCBsdW1hKTtcXHJcXG4gIGZsb2F0IGNvdmVyYWdlID0gcG93KHVDb2xvci5hICogYWxwaGEsIGdhbW1hKTsgIFxcclxcblxcclxcbiAgLy8gTlBNIFRleHR1cmVzLCBOUE0gb3V0cHV0c1xcclxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IucmdiLCBjb3ZlcmFnZSk7XFxyXFxufVxcclxcblwiO1xuXG5leHBvcnQgeyBtc2RmRnJhZyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2RmLm1qcy5tYXBcbiIsInZhciBtc2RmVmVydCA9IFwiLy8gTWVzaCBtYXRlcmlhbCBkZWZhdWx0IGZyYWdtZW50XFxyXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB1VGV4dHVyZU1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRleHR1cmVNYXRyaXggKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xcclxcbn1cXHJcXG5cIjtcblxuZXhwb3J0IHsgbXNkZlZlcnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXNkZjIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IsIE9ic2VydmFibGVQb2ludCwgc2V0dGluZ3MsIFBvaW50LCBUZXh0dXJlLCB1dGlscywgQkxFTkRfTU9ERVMsIFByb2dyYW0gfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgTWVzaEdlb21ldHJ5LCBNZXNoTWF0ZXJpYWwsIE1lc2ggfSBmcm9tICdAcGl4aS9tZXNoJztcbmltcG9ydCB7IEJpdG1hcEZvbnQgfSBmcm9tICcuL0JpdG1hcEZvbnQubWpzJztcbmltcG9ydCBtc2RmRnJhZyBmcm9tICcuL3NoYWRlci9tc2RmLm1qcyc7XG5pbXBvcnQgbXNkZlZlcnQgZnJvbSAnLi9zaGFkZXIvbXNkZjIubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgc3BsaXRUZXh0VG9DaGFyYWN0ZXJzIH0gZnJvbSAnLi91dGlscy9zcGxpdFRleHRUb0NoYXJhY3RlcnMubWpzJztcbmltcG9ydCB7IGV4dHJhY3RDaGFyQ29kZSB9IGZyb20gJy4vdXRpbHMvZXh0cmFjdENoYXJDb2RlLm1qcyc7XG5cbmNvbnN0IHBhZ2VNZXNoRGF0YURlZmF1bHRQYWdlTWVzaERhdGEgPSBbXTtcbmNvbnN0IHBhZ2VNZXNoRGF0YU1TREZQYWdlTWVzaERhdGEgPSBbXTtcbmNvbnN0IGNoYXJSZW5kZXJEYXRhUG9vbCA9IFtdO1xuY29uc3QgX0JpdG1hcFRleHQgPSBjbGFzcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHsgYWxpZ24sIHRpbnQsIG1heFdpZHRoLCBsZXR0ZXJTcGFjaW5nLCBmb250TmFtZSwgZm9udFNpemUgfSA9IE9iamVjdC5hc3NpZ24oe30sIF9CaXRtYXBUZXh0LnN0eWxlRGVmYXVsdHMsIHN0eWxlKTtcbiAgICBpZiAoIUJpdG1hcEZvbnQuYXZhaWxhYmxlW2ZvbnROYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIEJpdG1hcEZvbnQgXCIke2ZvbnROYW1lfVwiYCk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEgPSBbXTtcbiAgICB0aGlzLl90ZXh0V2lkdGggPSAwO1xuICAgIHRoaXMuX3RleHRIZWlnaHQgPSAwO1xuICAgIHRoaXMuX2FsaWduID0gYWxpZ247XG4gICAgdGhpcy5fdGludENvbG9yID0gbmV3IENvbG9yKHRpbnQpO1xuICAgIHRoaXMuX2ZvbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5fZm9udE5hbWUgPSBmb250TmFtZTtcbiAgICB0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5fbWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLl9tYXhMaW5lSGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZztcbiAgICB0aGlzLl9hbmNob3IgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KCgpID0+IHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0sIHRoaXMsIDAsIDApO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gc2V0dGluZ3MuUk9VTkRfUElYRUxTO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLl90ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgfVxuICB1cGRhdGVUZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSBCaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV07XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplO1xuICAgIGNvbnN0IHNjYWxlID0gZm9udFNpemUgLyBkYXRhLnNpemU7XG4gICAgY29uc3QgcG9zID0gbmV3IFBvaW50KCk7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gW107XG4gICAgY29uc3QgbGluZVNwYWNlcyA9IFtdO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLl90ZXh0LnJlcGxhY2UoLyg/OlxcclxcbnxcXHIpL2csIFwiXFxuXCIpIHx8IFwiIFwiO1xuICAgIGNvbnN0IGNoYXJzSW5wdXQgPSBzcGxpdFRleHRUb0NoYXJhY3RlcnModGV4dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSB0aGlzLl9tYXhXaWR0aCAqIGRhdGEuc2l6ZSAvIGZvbnRTaXplO1xuICAgIGNvbnN0IHBhZ2VNZXNoRGF0YVBvb2wgPSBkYXRhLmRpc3RhbmNlRmllbGRUeXBlID09PSBcIm5vbmVcIiA/IHBhZ2VNZXNoRGF0YURlZmF1bHRQYWdlTWVzaERhdGEgOiBwYWdlTWVzaERhdGFNU0RGUGFnZU1lc2hEYXRhO1xuICAgIGxldCBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgIGxldCBsYXN0TGluZVdpZHRoID0gMDtcbiAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICBsZXQgbGluZSA9IDA7XG4gICAgbGV0IGxhc3RCcmVha1BvcyA9IC0xO1xuICAgIGxldCBsYXN0QnJlYWtXaWR0aCA9IDA7XG4gICAgbGV0IHNwYWNlc1JlbW92ZWQgPSAwO1xuICAgIGxldCBtYXhMaW5lSGVpZ2h0ID0gMDtcbiAgICBsZXQgc3BhY2VDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyc0lucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gY2hhcnNJbnB1dFtpXTtcbiAgICAgIGNvbnN0IGNoYXJDb2RlID0gZXh0cmFjdENoYXJDb2RlKGNoYXIpO1xuICAgICAgaWYgKC8oPzpcXHMpLy50ZXN0KGNoYXIpKSB7XG4gICAgICAgIGxhc3RCcmVha1BvcyA9IGk7XG4gICAgICAgIGxhc3RCcmVha1dpZHRoID0gbGFzdExpbmVXaWR0aDtcbiAgICAgICAgc3BhY2VDb3VudCsrO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09IFwiXFxyXCIgfHwgY2hhciA9PT0gXCJcXG5cIikge1xuICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICAgIGxpbmVTcGFjZXMucHVzaCgtMSk7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdExpbmVXaWR0aCk7XG4gICAgICAgICsrbGluZTtcbiAgICAgICAgKytzcGFjZXNSZW1vdmVkO1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgIHBvcy55ICs9IGRhdGEubGluZUhlaWdodDtcbiAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgc3BhY2VDb3VudCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhckRhdGEgPSBkYXRhLmNoYXJzW2NoYXJDb2RlXTtcbiAgICAgIGlmICghY2hhckRhdGEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJldkNoYXJDb2RlICYmIGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXSkge1xuICAgICAgICBwb3MueCArPSBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV07XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyUmVuZGVyRGF0YSA9IGNoYXJSZW5kZXJEYXRhUG9vbC5wb3AoKSB8fCB7XG4gICAgICAgIHRleHR1cmU6IFRleHR1cmUuRU1QVFksXG4gICAgICAgIGxpbmU6IDAsXG4gICAgICAgIGNoYXJDb2RlOiAwLFxuICAgICAgICBwcmV2U3BhY2VzOiAwLFxuICAgICAgICBwb3NpdGlvbjogbmV3IFBvaW50KClcbiAgICAgIH07XG4gICAgICBjaGFyUmVuZGVyRGF0YS50ZXh0dXJlID0gY2hhckRhdGEudGV4dHVyZTtcbiAgICAgIGNoYXJSZW5kZXJEYXRhLmxpbmUgPSBsaW5lO1xuICAgICAgY2hhclJlbmRlckRhdGEuY2hhckNvZGUgPSBjaGFyQ29kZTtcbiAgICAgIGNoYXJSZW5kZXJEYXRhLnBvc2l0aW9uLnggPSBNYXRoLnJvdW5kKHBvcy54ICsgY2hhckRhdGEueE9mZnNldCArIHRoaXMuX2xldHRlclNwYWNpbmcgLyAyKTtcbiAgICAgIGNoYXJSZW5kZXJEYXRhLnBvc2l0aW9uLnkgPSBNYXRoLnJvdW5kKHBvcy55ICsgY2hhckRhdGEueU9mZnNldCk7XG4gICAgICBjaGFyUmVuZGVyRGF0YS5wcmV2U3BhY2VzID0gc3BhY2VDb3VudDtcbiAgICAgIGNoYXJzLnB1c2goY2hhclJlbmRlckRhdGEpO1xuICAgICAgbGFzdExpbmVXaWR0aCA9IGNoYXJSZW5kZXJEYXRhLnBvc2l0aW9uLnggKyBNYXRoLm1heChjaGFyRGF0YS54QWR2YW5jZSAtIGNoYXJEYXRhLnhPZmZzZXQsIGNoYXJEYXRhLnRleHR1cmUub3JpZy53aWR0aCk7XG4gICAgICBwb3MueCArPSBjaGFyRGF0YS54QWR2YW5jZSArIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gICAgICBtYXhMaW5lSGVpZ2h0ID0gTWF0aC5tYXgobWF4TGluZUhlaWdodCwgY2hhckRhdGEueU9mZnNldCArIGNoYXJEYXRhLnRleHR1cmUuaGVpZ2h0KTtcbiAgICAgIHByZXZDaGFyQ29kZSA9IGNoYXJDb2RlO1xuICAgICAgaWYgKGxhc3RCcmVha1BvcyAhPT0gLTEgJiYgbWF4V2lkdGggPiAwICYmIHBvcy54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgKytzcGFjZXNSZW1vdmVkO1xuICAgICAgICB1dGlscy5yZW1vdmVJdGVtcyhjaGFycywgMSArIGxhc3RCcmVha1BvcyAtIHNwYWNlc1JlbW92ZWQsIDEgKyBpIC0gbGFzdEJyZWFrUG9zKTtcbiAgICAgICAgaSA9IGxhc3RCcmVha1BvcztcbiAgICAgICAgbGFzdEJyZWFrUG9zID0gLTE7XG4gICAgICAgIGxpbmVXaWR0aHMucHVzaChsYXN0QnJlYWtXaWR0aCk7XG4gICAgICAgIGxpbmVTcGFjZXMucHVzaChjaGFycy5sZW5ndGggPiAwID8gY2hhcnNbY2hhcnMubGVuZ3RoIC0gMV0ucHJldlNwYWNlcyA6IDApO1xuICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RCcmVha1dpZHRoKTtcbiAgICAgICAgbGluZSsrO1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgIHBvcy55ICs9IGRhdGEubGluZUhlaWdodDtcbiAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgc3BhY2VDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3RDaGFyID0gY2hhcnNJbnB1dFtjaGFyc0lucHV0Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hhciAhPT0gXCJcXHJcIiAmJiBsYXN0Q2hhciAhPT0gXCJcXG5cIikge1xuICAgICAgaWYgKC8oPzpcXHMpLy50ZXN0KGxhc3RDaGFyKSkge1xuICAgICAgICBsYXN0TGluZVdpZHRoID0gbGFzdEJyZWFrV2lkdGg7XG4gICAgICB9XG4gICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpO1xuICAgICAgbGluZVNwYWNlcy5wdXNoKC0xKTtcbiAgICB9XG4gICAgY29uc3QgbGluZUFsaWduT2Zmc2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxpbmU7IGkrKykge1xuICAgICAgbGV0IGFsaWduT2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0aGlzLl9hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgIGFsaWduT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgYWxpZ25PZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIpIHtcbiAgICAgICAgYWxpZ25PZmZzZXQgPSBsaW5lU3BhY2VzW2ldIDwgMCA/IDAgOiAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyBsaW5lU3BhY2VzW2ldO1xuICAgICAgfVxuICAgICAgbGluZUFsaWduT2Zmc2V0cy5wdXNoKGFsaWduT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgbGVuQ2hhcnMgPSBjaGFycy5sZW5ndGg7XG4gICAgY29uc3QgcGFnZXNNZXNoRGF0YSA9IHt9O1xuICAgIGNvbnN0IG5ld1BhZ2VzTWVzaERhdGEgPSBbXTtcbiAgICBjb25zdCBhY3RpdmVQYWdlc01lc2hEYXRhID0gdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YTtcbiAgICBwYWdlTWVzaERhdGFQb29sLnB1c2goLi4uYWN0aXZlUGFnZXNNZXNoRGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5DaGFyczsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY2hhcnNbaV0udGV4dHVyZTtcbiAgICAgIGNvbnN0IGJhc2VUZXh0dXJlVWlkID0gdGV4dHVyZS5iYXNlVGV4dHVyZS51aWQ7XG4gICAgICBpZiAoIXBhZ2VzTWVzaERhdGFbYmFzZVRleHR1cmVVaWRdKSB7XG4gICAgICAgIGxldCBwYWdlTWVzaERhdGEgPSBwYWdlTWVzaERhdGFQb29sLnBvcCgpO1xuICAgICAgICBpZiAoIXBhZ2VNZXNoRGF0YSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IE1lc2hHZW9tZXRyeSgpO1xuICAgICAgICAgIGxldCBtYXRlcmlhbDtcbiAgICAgICAgICBsZXQgbWVzaEJsZW5kTW9kZTtcbiAgICAgICAgICBpZiAoZGF0YS5kaXN0YW5jZUZpZWxkVHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbChUZXh0dXJlLkVNUFRZKTtcbiAgICAgICAgICAgIG1lc2hCbGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbChUZXh0dXJlLkVNUFRZLCB7IHByb2dyYW06IFByb2dyYW0uZnJvbShtc2RmVmVydCwgbXNkZkZyYWcpLCB1bmlmb3JtczogeyB1RldpZHRoOiAwIH0gfSk7XG4gICAgICAgICAgICBtZXNoQmxlbmRNb2RlID0gQkxFTkRfTU9ERVMuTk9STUFMX05QTTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgbWVzaC5ibGVuZE1vZGUgPSBtZXNoQmxlbmRNb2RlO1xuICAgICAgICAgIHBhZ2VNZXNoRGF0YSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgaW5kZXhDb3VudDogMCxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgICAgICAgdXZzQ291bnQ6IDAsXG4gICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgIG1lc2gsXG4gICAgICAgICAgICB2ZXJ0aWNlczogbnVsbCxcbiAgICAgICAgICAgIHV2czogbnVsbCxcbiAgICAgICAgICAgIGluZGljZXM6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5pbmRleCA9IDA7XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5pbmRleENvdW50ID0gMDtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRleENvdW50ID0gMDtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnV2c0NvdW50ID0gMDtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnRvdGFsID0gMDtcbiAgICAgICAgY29uc3QgeyBfdGV4dHVyZUNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBfdGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlVWlkXSA9IF90ZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVVaWRdIHx8IG5ldyBUZXh0dXJlKHRleHR1cmUuYmFzZVRleHR1cmUpO1xuICAgICAgICBwYWdlTWVzaERhdGEubWVzaC50ZXh0dXJlID0gX3RleHR1cmVDYWNoZVtiYXNlVGV4dHVyZVVpZF07XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5tZXNoLnRpbnQgPSB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gICAgICAgIG5ld1BhZ2VzTWVzaERhdGEucHVzaChwYWdlTWVzaERhdGEpO1xuICAgICAgICBwYWdlc01lc2hEYXRhW2Jhc2VUZXh0dXJlVWlkXSA9IHBhZ2VNZXNoRGF0YTtcbiAgICAgIH1cbiAgICAgIHBhZ2VzTWVzaERhdGFbYmFzZVRleHR1cmVVaWRdLnRvdGFsKys7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlUGFnZXNNZXNoRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFuZXdQYWdlc01lc2hEYXRhLmluY2x1ZGVzKGFjdGl2ZVBhZ2VzTWVzaERhdGFbaV0pKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoYWN0aXZlUGFnZXNNZXNoRGF0YVtpXS5tZXNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdQYWdlc01lc2hEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobmV3UGFnZXNNZXNoRGF0YVtpXS5tZXNoLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLmFkZENoaWxkKG5ld1BhZ2VzTWVzaERhdGFbaV0ubWVzaCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEgPSBuZXdQYWdlc01lc2hEYXRhO1xuICAgIGZvciAoY29uc3QgaSBpbiBwYWdlc01lc2hEYXRhKSB7XG4gICAgICBjb25zdCBwYWdlTWVzaERhdGEgPSBwYWdlc01lc2hEYXRhW2ldO1xuICAgICAgY29uc3QgdG90YWwgPSBwYWdlTWVzaERhdGEudG90YWw7XG4gICAgICBpZiAoIShwYWdlTWVzaERhdGEuaW5kaWNlcz8ubGVuZ3RoID4gNiAqIHRvdGFsKSB8fCBwYWdlTWVzaERhdGEudmVydGljZXMubGVuZ3RoIDwgTWVzaC5CQVRDSEFCTEVfU0laRSAqIDIpIHtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSg0ICogMiAqIHRvdGFsKTtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIDIgKiB0b3RhbCk7XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KDYgKiB0b3RhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0b3RhbDIgPSBwYWdlTWVzaERhdGEudG90YWw7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gcGFnZU1lc2hEYXRhLnZlcnRpY2VzO1xuICAgICAgICBmb3IgKGxldCBpMiA9IHRvdGFsMiAqIDQgKiAyOyBpMiA8IHZlcnRpY2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIHZlcnRpY2VzW2kyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhZ2VNZXNoRGF0YS5tZXNoLnNpemUgPSA2ICogdG90YWw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuQ2hhcnM7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgbGV0IG9mZnNldCA9IGNoYXIucG9zaXRpb24ueCArIGxpbmVBbGlnbk9mZnNldHNbY2hhci5saW5lXSAqICh0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIgPyBjaGFyLnByZXZTcGFjZXMgOiAxKTtcbiAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCk7XG4gICAgICB9XG4gICAgICBjb25zdCB4UG9zID0gb2Zmc2V0ICogc2NhbGU7XG4gICAgICBjb25zdCB5UG9zID0gY2hhci5wb3NpdGlvbi55ICogc2NhbGU7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY2hhci50ZXh0dXJlO1xuICAgICAgY29uc3QgcGFnZU1lc2ggPSBwYWdlc01lc2hEYXRhW3RleHR1cmUuYmFzZVRleHR1cmUudWlkXTtcbiAgICAgIGNvbnN0IHRleHR1cmVGcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgICBjb25zdCB0ZXh0dXJlVXZzID0gdGV4dHVyZS5fdXZzO1xuICAgICAgY29uc3QgaW5kZXggPSBwYWdlTWVzaC5pbmRleCsrO1xuICAgICAgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyAwXSA9IDAgKyBpbmRleCAqIDQ7XG4gICAgICBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDFdID0gMSArIGluZGV4ICogNDtcbiAgICAgIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgMl0gPSAyICsgaW5kZXggKiA0O1xuICAgICAgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyAzXSA9IDAgKyBpbmRleCAqIDQ7XG4gICAgICBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDRdID0gMiArIGluZGV4ICogNDtcbiAgICAgIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgNV0gPSAzICsgaW5kZXggKiA0O1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMF0gPSB4UG9zO1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMV0gPSB5UG9zO1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMl0gPSB4UG9zICsgdGV4dHVyZUZyYW1lLndpZHRoICogc2NhbGU7XG4gICAgICBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyAzXSA9IHlQb3M7XG4gICAgICBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyA0XSA9IHhQb3MgKyB0ZXh0dXJlRnJhbWUud2lkdGggKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDVdID0geVBvcyArIHRleHR1cmVGcmFtZS5oZWlnaHQgKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDZdID0geFBvcztcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDddID0geVBvcyArIHRleHR1cmVGcmFtZS5oZWlnaHQgKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyAwXSA9IHRleHR1cmVVdnMueDA7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgMV0gPSB0ZXh0dXJlVXZzLnkwO1xuICAgICAgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDJdID0gdGV4dHVyZVV2cy54MTtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyAzXSA9IHRleHR1cmVVdnMueTE7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgNF0gPSB0ZXh0dXJlVXZzLngyO1xuICAgICAgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDVdID0gdGV4dHVyZVV2cy55MjtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyA2XSA9IHRleHR1cmVVdnMueDM7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgN10gPSB0ZXh0dXJlVXZzLnkzO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0V2lkdGggPSBtYXhMaW5lV2lkdGggKiBzY2FsZTtcbiAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gKHBvcy55ICsgZGF0YS5saW5lSGVpZ2h0KSAqIHNjYWxlO1xuICAgIGZvciAoY29uc3QgaSBpbiBwYWdlc01lc2hEYXRhKSB7XG4gICAgICBjb25zdCBwYWdlTWVzaERhdGEgPSBwYWdlc01lc2hEYXRhW2ldO1xuICAgICAgaWYgKHRoaXMuYW5jaG9yLnggIT09IDAgfHwgdGhpcy5hbmNob3IueSAhPT0gMCkge1xuICAgICAgICBsZXQgdmVydGV4Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBhbmNob3JPZmZzZXRYID0gdGhpcy5fdGV4dFdpZHRoICogdGhpcy5hbmNob3IueDtcbiAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0WSA9IHRoaXMuX3RleHRIZWlnaHQgKiB0aGlzLmFuY2hvci55O1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcGFnZU1lc2hEYXRhLnRvdGFsOyBpMisrKSB7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX21heExpbmVIZWlnaHQgPSBtYXhMaW5lSGVpZ2h0ICogc2NhbGU7XG4gICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBwYWdlTWVzaERhdGEubWVzaC5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIik7XG4gICAgICBjb25zdCB0ZXh0dXJlQnVmZmVyID0gcGFnZU1lc2hEYXRhLm1lc2guZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVRleHR1cmVDb29yZFwiKTtcbiAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gcGFnZU1lc2hEYXRhLm1lc2guZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIHZlcnRleEJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLnZlcnRpY2VzO1xuICAgICAgdGV4dHVyZUJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLnV2cztcbiAgICAgIGluZGV4QnVmZmVyLmRhdGEgPSBwYWdlTWVzaERhdGEuaW5kaWNlcztcbiAgICAgIHZlcnRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICAgIHRleHR1cmVCdWZmZXIudXBkYXRlKCk7XG4gICAgICBpbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhclJlbmRlckRhdGFQb29sLnB1c2goY2hhcnNbaV0pO1xuICAgIH1cbiAgICB0aGlzLl9mb250ID0gZGF0YTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy5fYXV0b1Jlc29sdXRpb24gJiYgdGhpcy5fcmVzb2x1dGlvbiAhPT0gcmVuZGVyZXIucmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBkaXN0YW5jZUZpZWxkUmFuZ2UsIGRpc3RhbmNlRmllbGRUeXBlLCBzaXplIH0gPSBCaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV07XG4gICAgaWYgKGRpc3RhbmNlRmllbGRUeXBlICE9PSBcIm5vbmVcIikge1xuICAgICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgICAgY29uc3QgZHggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICBjb25zdCBkeSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcbiAgICAgIGNvbnN0IHdvcmxkU2NhbGUgPSAoTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKSAvIDI7XG4gICAgICBjb25zdCBmb250U2NhbGUgPSB0aGlzLmZvbnRTaXplIC8gc2l6ZTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSByZW5kZXJlci5fdmlldy5yZXNvbHV0aW9uO1xuICAgICAgZm9yIChjb25zdCBtZXNoIG9mIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEpIHtcbiAgICAgICAgbWVzaC5tZXNoLnNoYWRlci51bmlmb3Jtcy51RldpZHRoID0gd29ybGRTY2FsZSAqIGRpc3RhbmNlRmllbGRSYW5nZSAqIGZvbnRTY2FsZSAqIHJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG4gIGdldExvY2FsQm91bmRzKCkge1xuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMoKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCBmb250ID0gQml0bWFwRm9udC5hdmFpbGFibGVbdGhpcy5fZm9udE5hbWVdO1xuICAgIGlmICghZm9udCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIEJpdG1hcEZvbnQgXCIke3RoaXMuX2ZvbnROYW1lfVwiYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9mb250ICE9PSBmb250KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgIH1cbiAgfVxuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudGludCA9PT0gdmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGFbaV0ubWVzaC50aW50ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBhbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gIH1cbiAgc2V0IGFsaWduKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2FsaWduICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fYWxpZ24gPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnROYW1lO1xuICB9XG4gIHNldCBmb250TmFtZSh2YWx1ZSkge1xuICAgIGlmICghQml0bWFwRm9udC5hdmFpbGFibGVbdmFsdWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgQml0bWFwRm9udCBcIiR7dmFsdWV9XCJgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZvbnROYW1lICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZm9udE5hbWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplID8/IEJpdG1hcEZvbnQuYXZhaWxhYmxlW3RoaXMuX2ZvbnROYW1lXS5zaXplO1xuICB9XG4gIHNldCBmb250U2l6ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9mb250U2l6ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2ZvbnRTaXplID0gdmFsdWU7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFuY2hvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xuICB9XG4gIHNldCBhbmNob3IodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLl9hbmNob3Iuc2V0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYW5jaG9yLmNvcHlGcm9tKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cbiAgc2V0IHRleHQodGV4dCkge1xuICAgIHRleHQgPSBTdHJpbmcodGV4dCA9PT0gbnVsbCB8fCB0ZXh0ID09PSB2b2lkIDAgPyBcIlwiIDogdGV4dCk7XG4gICAgaWYgKHRoaXMuX3RleHQgPT09IHRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgZ2V0IG1heFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhXaWR0aDtcbiAgfVxuICBzZXQgbWF4V2lkdGgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fbWF4V2lkdGggPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21heFdpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgZ2V0IG1heExpbmVIZWlnaHQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLl9tYXhMaW5lSGVpZ2h0O1xuICB9XG4gIGdldCB0ZXh0V2lkdGgoKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLl90ZXh0V2lkdGg7XG4gIH1cbiAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gIH1cbiAgc2V0IGxldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgcm91bmRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdW5kUGl4ZWxzO1xuICB9XG4gIHNldCByb3VuZFBpeGVscyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcm91bmRQaXhlbHMpIHtcbiAgICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gdmFsdWU7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRleHRIZWlnaHQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLl90ZXh0SGVpZ2h0O1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIGNvbnN0IHsgX3RleHR1cmVDYWNoZSB9ID0gdGhpcztcbiAgICBjb25zdCBkYXRhID0gQml0bWFwRm9udC5hdmFpbGFibGVbdGhpcy5fZm9udE5hbWVdO1xuICAgIGNvbnN0IHBhZ2VNZXNoRGF0YVBvb2wgPSBkYXRhLmRpc3RhbmNlRmllbGRUeXBlID09PSBcIm5vbmVcIiA/IHBhZ2VNZXNoRGF0YURlZmF1bHRQYWdlTWVzaERhdGEgOiBwYWdlTWVzaERhdGFNU0RGUGFnZU1lc2hEYXRhO1xuICAgIHBhZ2VNZXNoRGF0YVBvb2wucHVzaCguLi50aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhKTtcbiAgICBmb3IgKGNvbnN0IHBhZ2VNZXNoRGF0YSBvZiB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHBhZ2VNZXNoRGF0YS5tZXNoKTtcbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YSA9IFtdO1xuICAgIHBhZ2VNZXNoRGF0YVBvb2wuZmlsdGVyKChwYWdlKSA9PiBfdGV4dHVyZUNhY2hlW3BhZ2UubWVzaC50ZXh0dXJlLmJhc2VUZXh0dXJlLnVpZF0pLmZvckVhY2goKHBhZ2UpID0+IHtcbiAgICAgIHBhZ2UubWVzaC50ZXh0dXJlID0gVGV4dHVyZS5FTVBUWTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGlkIGluIF90ZXh0dXJlQ2FjaGUpIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBfdGV4dHVyZUNhY2hlW2lkXTtcbiAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIF90ZXh0dXJlQ2FjaGVbaWRdO1xuICAgIH1cbiAgICB0aGlzLl9mb250ID0gbnVsbDtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBudWxsO1xuICAgIHRoaXMuX3RleHR1cmVDYWNoZSA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbmxldCBCaXRtYXBUZXh0ID0gX0JpdG1hcFRleHQ7XG5CaXRtYXBUZXh0LnN0eWxlRGVmYXVsdHMgPSB7XG4gIGFsaWduOiBcImxlZnRcIixcbiAgdGludDogMTY3NzcyMTUsXG4gIG1heFdpZHRoOiAwLFxuICBsZXR0ZXJTcGFjaW5nOiAwXG59O1xuXG5leHBvcnQgeyBCaXRtYXBUZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBUZXh0Lm1qcy5tYXBcbiIsImltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5LCBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSAnQHBpeGkvYXNzZXRzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHV0aWxzLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQml0bWFwRm9udCB9IGZyb20gJy4vQml0bWFwRm9udC5tanMnO1xuaW1wb3J0ICcuL2Zvcm1hdHMvaW5kZXgubWpzJztcbmltcG9ydCB7IFRleHRGb3JtYXQgfSBmcm9tICcuL2Zvcm1hdHMvVGV4dEZvcm1hdC5tanMnO1xuaW1wb3J0IHsgWE1MU3RyaW5nRm9ybWF0IH0gZnJvbSAnLi9mb3JtYXRzL1hNTFN0cmluZ0Zvcm1hdC5tanMnO1xuXG5jb25zdCB2YWxpZEV4dGVuc2lvbnMgPSBbXCIueG1sXCIsIFwiLmZudFwiXTtcbmNvbnN0IGxvYWRCaXRtYXBGb250ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lk5vcm1hbFxuICB9LFxuICBuYW1lOiBcImxvYWRCaXRtYXBGb250XCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIHZhbGlkRXh0ZW5zaW9ucy5pbmNsdWRlcyh1dGlscy5wYXRoLmV4dG5hbWUodXJsKS50b0xvd2VyQ2FzZSgpKTtcbiAgfSxcbiAgYXN5bmMgdGVzdFBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gVGV4dEZvcm1hdC50ZXN0KGRhdGEpIHx8IFhNTFN0cmluZ0Zvcm1hdC50ZXN0KGRhdGEpO1xuICB9LFxuICBhc3luYyBwYXJzZShhc3NldCwgZGF0YSwgbG9hZGVyKSB7XG4gICAgY29uc3QgZm9udERhdGEgPSBUZXh0Rm9ybWF0LnRlc3QoYXNzZXQpID8gVGV4dEZvcm1hdC5wYXJzZShhc3NldCkgOiBYTUxTdHJpbmdGb3JtYXQucGFyc2UoYXNzZXQpO1xuICAgIGNvbnN0IHsgc3JjIH0gPSBkYXRhO1xuICAgIGNvbnN0IHsgcGFnZTogcGFnZXMgfSA9IGZvbnREYXRhO1xuICAgIGNvbnN0IHRleHR1cmVVcmxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcGFnZUZpbGUgPSBwYWdlc1tpXS5maWxlO1xuICAgICAgbGV0IGltYWdlUGF0aCA9IHV0aWxzLnBhdGguam9pbih1dGlscy5wYXRoLmRpcm5hbWUoc3JjKSwgcGFnZUZpbGUpO1xuICAgICAgaW1hZ2VQYXRoID0gY29weVNlYXJjaFBhcmFtcyhpbWFnZVBhdGgsIHNyYyk7XG4gICAgICB0ZXh0dXJlVXJscy5wdXNoKGltYWdlUGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFRleHR1cmVzID0gYXdhaXQgbG9hZGVyLmxvYWQodGV4dHVyZVVybHMpO1xuICAgIGNvbnN0IHRleHR1cmVzID0gdGV4dHVyZVVybHMubWFwKCh1cmwpID0+IGxvYWRlZFRleHR1cmVzW3VybF0pO1xuICAgIHJldHVybiBCaXRtYXBGb250Lmluc3RhbGwoZm9udERhdGEsIHRleHR1cmVzLCB0cnVlKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIF9vcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfSxcbiAgdW5sb2FkKGJpdG1hcEZvbnQpIHtcbiAgICBiaXRtYXBGb250LmRlc3Ryb3koKTtcbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKGxvYWRCaXRtYXBGb250KTtcblxuZXhwb3J0IHsgbG9hZEJpdG1hcEZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRCaXRtYXBGb250Lm1qcy5tYXBcbiIsImV4cG9ydCB7IEJpdG1hcEZvbnQgfSBmcm9tICcuL0JpdG1hcEZvbnQubWpzJztcbmV4cG9ydCB7IEJpdG1hcEZvbnREYXRhIH0gZnJvbSAnLi9CaXRtYXBGb250RGF0YS5tanMnO1xuZXhwb3J0IHsgQml0bWFwVGV4dCB9IGZyb20gJy4vQml0bWFwVGV4dC5tanMnO1xuaW1wb3J0ICcuL0JpdG1hcFRleHRTdHlsZS5tanMnO1xuZXhwb3J0IHsgYXV0b0RldGVjdEZvcm1hdCB9IGZyb20gJy4vZm9ybWF0cy9pbmRleC5tanMnO1xuZXhwb3J0IHsgbG9hZEJpdG1hcEZvbnQgfSBmcm9tICcuL2xvYWRCaXRtYXBGb250Lm1qcyc7XG5leHBvcnQgeyBUZXh0Rm9ybWF0IH0gZnJvbSAnLi9mb3JtYXRzL1RleHRGb3JtYXQubWpzJztcbmV4cG9ydCB7IFhNTEZvcm1hdCB9IGZyb20gJy4vZm9ybWF0cy9YTUxGb3JtYXQubWpzJztcbmV4cG9ydCB7IFhNTFN0cmluZ0Zvcm1hdCB9IGZyb20gJy4vZm9ybWF0cy9YTUxTdHJpbmdGb3JtYXQubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzLCB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnQHBpeGkvdGV4dCc7XG5cbmNvbnN0IF9IVE1MVGV4dFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBUZXh0U3R5bGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2ZvbnRzID0gW107XG4gICAgdGhpcy5fb3ZlcnJpZGVzID0gW107XG4gICAgdGhpcy5fc3R5bGVzaGVldCA9IFwiXCI7XG4gICAgdGhpcy5mb250c0RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGZyb20ob3JpZ2luYWxTdHlsZSkge1xuICAgIHJldHVybiBuZXcgX0hUTUxUZXh0U3R5bGUoT2JqZWN0LmtleXMoX0hUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMpLnJlZHVjZSgob2JqLCBwcm9wKSA9PiAoeyAuLi5vYmosIFtwcm9wXTogb3JpZ2luYWxTdHlsZVtwcm9wXSB9KSwge30pKTtcbiAgfVxuICBjbGVhbkZvbnRzKCkge1xuICAgIGlmICh0aGlzLl9mb250cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9mb250cy5mb3JFYWNoKChmb250KSA9PiB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZm9udC5zcmMpO1xuICAgICAgICBmb250LnJlZnMtLTtcbiAgICAgICAgaWYgKGZvbnQucmVmcyA9PT0gMCkge1xuICAgICAgICAgIGlmIChmb250LmZvbnRGYWNlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5mb250cy5kZWxldGUoZm9udC5mb250RmFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBfSFRNTFRleHRTdHlsZS5hdmFpbGFibGVGb250c1tmb250Lm9yaWdpbmFsVXJsXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIkFyaWFsXCI7XG4gICAgICB0aGlzLl9mb250cy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICB0aGlzLmZvbnRzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBsb2FkRm9udCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXZhaWxhYmxlRm9udHMgfSA9IF9IVE1MVGV4dFN0eWxlO1xuICAgIGlmIChhdmFpbGFibGVGb250c1t1cmxdKSB7XG4gICAgICBjb25zdCBmb250ID0gYXZhaWxhYmxlRm9udHNbdXJsXTtcbiAgICAgIHRoaXMuX2ZvbnRzLnB1c2goZm9udCk7XG4gICAgICBmb250LnJlZnMrKztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgdGhpcy5mb250c0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuYmxvYigpKS50aGVuKGFzeW5jIChibG9iKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKFtzcmMsIHJlYWRlci5yZXN1bHRdKTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgfSkpLnRoZW4oYXN5bmMgKFtzcmMsIGRhdGFTcmNdKSA9PiB7XG4gICAgICBjb25zdCBmb250ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGZhbWlseTogdXRpbHMucGF0aC5iYXNlbmFtZSh1cmwsIHV0aWxzLnBhdGguZXh0bmFtZSh1cmwpKSxcbiAgICAgICAgd2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAgICAgICBzdHlsZTogXCJub3JtYWxcIixcbiAgICAgICAgc3JjLFxuICAgICAgICBkYXRhU3JjLFxuICAgICAgICByZWZzOiAxLFxuICAgICAgICBvcmlnaW5hbFVybDogdXJsLFxuICAgICAgICBmb250RmFjZTogbnVsbFxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBhdmFpbGFibGVGb250c1t1cmxdID0gZm9udDtcbiAgICAgIHRoaXMuX2ZvbnRzLnB1c2goZm9udCk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGZvbnQuZmFtaWx5LCBgdXJsKCR7Zm9udC5zcmN9KWAsIHtcbiAgICAgICAgd2VpZ2h0OiBmb250LndlaWdodCxcbiAgICAgICAgc3R5bGU6IGZvbnQuc3R5bGVcbiAgICAgIH0pO1xuICAgICAgZm9udC5mb250RmFjZSA9IGZvbnRGYWNlO1xuICAgICAgYXdhaXQgZm9udEZhY2UubG9hZCgpO1xuICAgICAgZG9jdW1lbnQuZm9udHMuYWRkKGZvbnRGYWNlKTtcbiAgICAgIGF3YWl0IGRvY3VtZW50LmZvbnRzLnJlYWR5O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICB0aGlzLmZvbnRzRGlydHkgPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGFkZE92ZXJyaWRlKC4uLnZhbHVlKSB7XG4gICAgY29uc3QgdG9BZGQgPSB2YWx1ZS5maWx0ZXIoKHYpID0+ICF0aGlzLl9vdmVycmlkZXMuaW5jbHVkZXModikpO1xuICAgIGlmICh0b0FkZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9vdmVycmlkZXMucHVzaCguLi50b0FkZCk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgcmVtb3ZlT3ZlcnJpZGUoLi4udmFsdWUpIHtcbiAgICBjb25zdCB0b1JlbW92ZSA9IHZhbHVlLmZpbHRlcigodikgPT4gdGhpcy5fb3ZlcnJpZGVzLmluY2x1ZGVzKHYpKTtcbiAgICBpZiAodG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fb3ZlcnJpZGVzID0gdGhpcy5fb3ZlcnJpZGVzLmZpbHRlcigodikgPT4gIXRvUmVtb3ZlLmluY2x1ZGVzKHYpKTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICB0b0NTUyhzY2FsZSkge1xuICAgIHJldHVybiBbXG4gICAgICBgdHJhbnNmb3JtOiBzY2FsZSgke3NjYWxlfSlgLFxuICAgICAgYHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0YCxcbiAgICAgIFwiZGlzcGxheTogaW5saW5lLWJsb2NrXCIsXG4gICAgICBgY29sb3I6ICR7dGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLmZpbGwpfWAsXG4gICAgICBgZm9udC1zaXplOiAke3RoaXMuZm9udFNpemV9cHhgLFxuICAgICAgYGZvbnQtZmFtaWx5OiAke3RoaXMuZm9udEZhbWlseX1gLFxuICAgICAgYGZvbnQtd2VpZ2h0OiAke3RoaXMuZm9udFdlaWdodH1gLFxuICAgICAgYGZvbnQtc3R5bGU6ICR7dGhpcy5mb250U3R5bGV9YCxcbiAgICAgIGBmb250LXZhcmlhbnQ6ICR7dGhpcy5mb250VmFyaWFudH1gLFxuICAgICAgYGxldHRlci1zcGFjaW5nOiAke3RoaXMubGV0dGVyU3BhY2luZ31weGAsXG4gICAgICBgdGV4dC1hbGlnbjogJHt0aGlzLmFsaWdufWAsXG4gICAgICBgcGFkZGluZzogJHt0aGlzLnBhZGRpbmd9cHhgLFxuICAgICAgYHdoaXRlLXNwYWNlOiAke3RoaXMud2hpdGVTcGFjZX1gLFxuICAgICAgLi4udGhpcy5saW5lSGVpZ2h0ID8gW2BsaW5lLWhlaWdodDogJHt0aGlzLmxpbmVIZWlnaHR9cHhgXSA6IFtdLFxuICAgICAgLi4udGhpcy53b3JkV3JhcCA/IFtcbiAgICAgICAgYHdvcmQtd3JhcDogJHt0aGlzLmJyZWFrV29yZHMgPyBcImJyZWFrLWFsbFwiIDogXCJicmVhay13b3JkXCJ9YCxcbiAgICAgICAgYG1heC13aWR0aDogJHt0aGlzLndvcmRXcmFwV2lkdGh9cHhgXG4gICAgICBdIDogW10sXG4gICAgICAuLi50aGlzLnN0cm9rZVRoaWNrbmVzcyA/IFtcbiAgICAgICAgYC13ZWJraXQtdGV4dC1zdHJva2Utd2lkdGg6ICR7dGhpcy5zdHJva2VUaGlja25lc3N9cHhgLFxuICAgICAgICBgLXdlYmtpdC10ZXh0LXN0cm9rZS1jb2xvcjogJHt0aGlzLm5vcm1hbGl6ZUNvbG9yKHRoaXMuc3Ryb2tlKX1gLFxuICAgICAgICBgdGV4dC1zdHJva2Utd2lkdGg6ICR7dGhpcy5zdHJva2VUaGlja25lc3N9cHhgLFxuICAgICAgICBgdGV4dC1zdHJva2UtY29sb3I6ICR7dGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLnN0cm9rZSl9YCxcbiAgICAgICAgXCJwYWludC1vcmRlcjogc3Ryb2tlXCJcbiAgICAgIF0gOiBbXSxcbiAgICAgIC4uLnRoaXMuZHJvcFNoYWRvdyA/IFt0aGlzLmRyb3BTaGFkb3dUb0NTUygpXSA6IFtdLFxuICAgICAgLi4udGhpcy5fb3ZlcnJpZGVzXG4gICAgXS5qb2luKFwiO1wiKTtcbiAgfVxuICB0b0dsb2JhbENTUygpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udHMucmVkdWNlKChyZXN1bHQsIGZvbnQpID0+IGAke3Jlc3VsdH1cbiAgICAgICAgICAgIEBmb250LWZhY2Uge1xuICAgICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBcIiR7Zm9udC5mYW1pbHl9XCI7XG4gICAgICAgICAgICAgICAgc3JjOiB1cmwoJyR7Zm9udC5kYXRhU3JjfScpO1xuICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiAke2ZvbnQud2VpZ2h0fTtcbiAgICAgICAgICAgICAgICBmb250LXN0eWxlOiAke2ZvbnQuc3R5bGV9OyBcbiAgICAgICAgICAgIH1gLCB0aGlzLl9zdHlsZXNoZWV0KTtcbiAgfVxuICBnZXQgc3R5bGVzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVzaGVldDtcbiAgfVxuICBzZXQgc3R5bGVzaGVldCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zdHlsZXNoZWV0ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fc3R5bGVzaGVldCA9IHZhbHVlO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICBjb2xvciA9IHV0aWxzLnJnYjJoZXgoY29sb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdXRpbHMuaGV4MnN0cmluZyhjb2xvcik7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICBkcm9wU2hhZG93VG9DU1MoKSB7XG4gICAgbGV0IGNvbG9yID0gdGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLmRyb3BTaGFkb3dDb2xvcik7XG4gICAgY29uc3QgYWxwaGEgPSB0aGlzLmRyb3BTaGFkb3dBbHBoYTtcbiAgICBjb25zdCB4ID0gTWF0aC5yb3VuZChNYXRoLmNvcyh0aGlzLmRyb3BTaGFkb3dBbmdsZSkgKiB0aGlzLmRyb3BTaGFkb3dEaXN0YW5jZSk7XG4gICAgY29uc3QgeSA9IE1hdGgucm91bmQoTWF0aC5zaW4odGhpcy5kcm9wU2hhZG93QW5nbGUpICogdGhpcy5kcm9wU2hhZG93RGlzdGFuY2UpO1xuICAgIGlmIChjb2xvci5zdGFydHNXaXRoKFwiI1wiKSAmJiBhbHBoYSA8IDEpIHtcbiAgICAgIGNvbG9yICs9IChhbHBoYSAqIDI1NSB8IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gYCR7eH1weCAke3l9cHhgO1xuICAgIGlmICh0aGlzLmRyb3BTaGFkb3dCbHVyID4gMCkge1xuICAgICAgcmV0dXJuIGB0ZXh0LXNoYWRvdzogJHtwb3NpdGlvbn0gJHt0aGlzLmRyb3BTaGFkb3dCbHVyfXB4ICR7Y29sb3J9YDtcbiAgICB9XG4gICAgcmV0dXJuIGB0ZXh0LXNoYWRvdzogJHtwb3NpdGlvbn0gJHtjb2xvcn1gO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgX0hUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIG9uQmVmb3JlRHJhdygpIHtcbiAgICBjb25zdCB7IGZvbnRzRGlydHk6IHByZXZGb250c0RpcnR5IH0gPSB0aGlzO1xuICAgIHRoaXMuZm9udHNEaXJ0eSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmlzU2FmYXJpICYmIHRoaXMuX2ZvbnRzLmxlbmd0aCA+IDAgJiYgcHJldkZvbnRzRGlydHkpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGdldCBpc1NhZmFyaSgpIHtcbiAgICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gc2V0dGluZ3MuQURBUFRFUi5nZXROYXZpZ2F0b3IoKTtcbiAgICByZXR1cm4gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdCh1c2VyQWdlbnQpO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRTdG9wcyhfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gZmlsbEdyYWRpZW50U3RvcHMgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgZmlsbEdyYWRpZW50U3RvcHMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbGxHcmFkaWVudFN0b3BzO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRUeXBlKF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSBmaWxsR3JhZGllbnRUeXBlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IGZpbGxHcmFkaWVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbGxHcmFkaWVudFR5cGU7XG4gIH1cbiAgc2V0IG1pdGVyTGltaXQoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIG1pdGVyTGltaXQgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gc3VwZXIubWl0ZXJMaW1pdDtcbiAgfVxuICBzZXQgdHJpbShfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gdHJpbSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCB0cmltKCkge1xuICAgIHJldHVybiBzdXBlci50cmltO1xuICB9XG4gIHNldCB0ZXh0QmFzZWxpbmUoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIHRleHRCYXNlbGluZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCB0ZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRleHRCYXNlbGluZTtcbiAgfVxuICBzZXQgbGVhZGluZyhfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gbGVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCBsZWFkaW5nKCkge1xuICAgIHJldHVybiBzdXBlci5sZWFkaW5nO1xuICB9XG4gIHNldCBsaW5lSm9pbihfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gbGluZUpvaW4gaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgbGluZUpvaW4oKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxpbmVKb2luO1xuICB9XG59O1xubGV0IEhUTUxUZXh0U3R5bGUgPSBfSFRNTFRleHRTdHlsZTtcbkhUTUxUZXh0U3R5bGUuYXZhaWxhYmxlRm9udHMgPSB7fTtcbkhUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFsaWduOiBcImxlZnRcIixcbiAgYnJlYWtXb3JkczogZmFsc2UsXG4gIGRyb3BTaGFkb3c6IGZhbHNlLFxuICBkcm9wU2hhZG93QWxwaGE6IDEsXG4gIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXG4gIGRyb3BTaGFkb3dCbHVyOiAwLFxuICBkcm9wU2hhZG93Q29sb3I6IFwiYmxhY2tcIixcbiAgZHJvcFNoYWRvd0Rpc3RhbmNlOiA1LFxuICBmaWxsOiBcImJsYWNrXCIsXG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgZm9udFNpemU6IDI2LFxuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIGZvbnRWYXJpYW50OiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBsZXR0ZXJTcGFjaW5nOiAwLFxuICBsaW5lSGVpZ2h0OiAwLFxuICBwYWRkaW5nOiAwLFxuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgc3Ryb2tlVGhpY2tuZXNzOiAwLFxuICB3aGl0ZVNwYWNlOiBcIm5vcm1hbFwiLFxuICB3b3JkV3JhcDogZmFsc2UsXG4gIHdvcmRXcmFwV2lkdGg6IDEwMFxufTtcblxuZXhwb3J0IHsgSFRNTFRleHRTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTFRleHRTdHlsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBzZXR0aW5ncywgUmVjdGFuZ2xlLCB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAnQHBpeGkvc3ByaXRlJztcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJ0BwaXhpL3RleHQnO1xuaW1wb3J0IHsgSFRNTFRleHRTdHlsZSB9IGZyb20gJy4vSFRNTFRleHRTdHlsZS5tanMnO1xuXG5jb25zdCBfSFRNTFRleHQgPSBjbGFzcyBleHRlbmRzIFNwcml0ZSB7XG4gIGNvbnN0cnVjdG9yKHRleHQgPSBcIlwiLCBzdHlsZSA9IHt9KSB7XG4gICAgc3VwZXIoVGV4dHVyZS5FTVBUWSk7XG4gICAgdGhpcy5fdGV4dCA9IG51bGw7XG4gICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5vd25zU3R5bGUgPSBmYWxzZTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlLmZyb20oaW1hZ2UsIHtcbiAgICAgIHNjYWxlTW9kZTogc2V0dGluZ3MuU0NBTEVfTU9ERSxcbiAgICAgIHJlc291cmNlT3B0aW9uczoge1xuICAgICAgICBhdXRvTG9hZDogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXh0dXJlLm9yaWcgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGV4dHVyZS50cmltID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgY29uc3QgbnNzdmcgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgY29uc3QgbnN4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICAgIGNvbnN0IHN2Z1Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwic3ZnXCIpO1xuICAgIGNvbnN0IGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zeGh0bWwsIFwiZGl2XCIpO1xuICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcInN0eWxlXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxMDAwMFwiKTtcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjEwMDAwXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIHN2Z1Jvb3QuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gICAgdGhpcy5tYXhXaWR0aCA9IF9IVE1MVGV4dC5kZWZhdWx0TWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBfSFRNTFRleHQuZGVmYXVsdE1heEhlaWdodDtcbiAgICB0aGlzLl9kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcbiAgICB0aGlzLl9zdHlsZUVsZW1lbnQgPSBzdHlsZUVsZW1lbnQ7XG4gICAgdGhpcy5fc3ZnUm9vdCA9IHN2Z1Jvb3Q7XG4gICAgdGhpcy5fZm9yZWlnbk9iamVjdCA9IGZvcmVpZ25PYmplY3Q7XG4gICAgdGhpcy5fZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIHRoaXMuX2ZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQoZG9tRWxlbWVudCk7XG4gICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICB0aGlzLl9sb2FkSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IF9IVE1MVGV4dC5kZWZhdWx0QXV0b1Jlc29sdXRpb247XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IF9IVE1MVGV4dC5kZWZhdWx0UmVzb2x1dGlvbiA/PyBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICB9XG4gIG1lYXN1cmVUZXh0KG92ZXJyaWRlcykge1xuICAgIGNvbnN0IHsgdGV4dCwgc3R5bGUsIHJlc29sdXRpb24gfSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGV4dDogdGhpcy5fdGV4dCxcbiAgICAgIHN0eWxlOiB0aGlzLl9zdHlsZSxcbiAgICAgIHJlc29sdXRpb246IHRoaXMuX3Jlc29sdXRpb25cbiAgICB9LCBvdmVycmlkZXMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fZG9tRWxlbWVudCwge1xuICAgICAgaW5uZXJIVE1MOiB0ZXh0LFxuICAgICAgc3R5bGU6IHN0eWxlLnRvQ1NTKHJlc29sdXRpb24pXG4gICAgfSk7XG4gICAgdGhpcy5fc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gc3R5bGUudG9HbG9iYWxDU1MoKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3N2Z1Jvb3QpO1xuICAgIGNvbnN0IGNvbnRlbnRCb3VuZHMgPSB0aGlzLl9kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX3N2Z1Jvb3QucmVtb3ZlKCk7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgTWF0aC5jZWlsKGNvbnRlbnRCb3VuZHMud2lkdGgpKTtcbiAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIE1hdGguY2VpbChjb250ZW50Qm91bmRzLmhlaWdodCkpO1xuICAgIHRoaXMuX3N2Z1Jvb3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgY29udGVudFdpZHRoLnRvU3RyaW5nKCkpO1xuICAgIHRoaXMuX3N2Z1Jvb3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGNvbnRlbnRIZWlnaHQudG9TdHJpbmcoKSk7XG4gICAgaWYgKHRleHQgIT09IHRoaXMuX3RleHQpIHtcbiAgICAgIHRoaXMuX2RvbUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fdGV4dDtcbiAgICB9XG4gICAgaWYgKHN0eWxlICE9PSB0aGlzLl9zdHlsZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9kb21FbGVtZW50LCB7IHN0eWxlOiB0aGlzLl9zdHlsZT8udG9DU1MocmVzb2x1dGlvbikgfSk7XG4gICAgICB0aGlzLl9zdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLl9zdHlsZT8udG9HbG9iYWxDU1MoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjb250ZW50V2lkdGggKyBzdHlsZS5wYWRkaW5nICogMixcbiAgICAgIGhlaWdodDogY29udGVudEhlaWdodCArIHN0eWxlLnBhZGRpbmcgKiAyXG4gICAgfTtcbiAgfVxuICBhc3luYyB1cGRhdGVUZXh0KHJlc3BlY3REaXJ0eSA9IHRydWUpIHtcbiAgICBjb25zdCB7IHN0eWxlLCBfaW1hZ2U6IGltYWdlLCBfbG9hZEltYWdlOiBsb2FkSW1hZ2UgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMubG9jYWxTdHlsZUlEICE9PSBzdHlsZS5zdHlsZUlEKSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gc3R5bGUuc3R5bGVJRDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMubWVhc3VyZVRleHQoKTtcbiAgICBpbWFnZS53aWR0aCA9IGxvYWRJbWFnZS53aWR0aCA9IE1hdGguY2VpbChNYXRoLm1heCgxLCB3aWR0aCkpO1xuICAgIGltYWdlLmhlaWdodCA9IGxvYWRJbWFnZS5oZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5tYXgoMSwgaGVpZ2h0KSk7XG4gICAgaWYgKCF0aGlzLl9sb2FkaW5nKSB7XG4gICAgICB0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGxvYWRJbWFnZS5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgc3R5bGUub25CZWZvcmVEcmF3KCk7XG4gICAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGltYWdlLnNyYyA9IGxvYWRJbWFnZS5zcmM7XG4gICAgICAgICAgbG9hZEltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgbG9hZEltYWdlLnNyYyA9IFwiXCI7XG4gICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdmdVUkwgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHRoaXMuX3N2Z1Jvb3QpO1xuICAgICAgICBsb2FkSW1hZ2Uuc3JjID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQoc3ZnVVJMKX1gO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlO1xuICB9XG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgeyBzdHlsZSwgdGV4dHVyZSwgX2ltYWdlOiBpbWFnZSwgcmVzb2x1dGlvbiB9ID0gdGhpcztcbiAgICBjb25zdCB7IHBhZGRpbmcgfSA9IHN0eWxlO1xuICAgIGNvbnN0IHsgYmFzZVRleHR1cmUgfSA9IHRleHR1cmU7XG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBpbWFnZS53aWR0aCAvIHJlc29sdXRpb247XG4gICAgdGV4dHVyZS50cmltLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCA9IGltYWdlLmhlaWdodCAvIHJlc29sdXRpb247XG4gICAgdGV4dHVyZS50cmltLnggPSAtcGFkZGluZztcbiAgICB0ZXh0dXJlLnRyaW0ueSA9IC1wYWRkaW5nO1xuICAgIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gcGFkZGluZyAqIDI7XG4gICAgdGV4dHVyZS5vcmlnLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAtIHBhZGRpbmcgKiAyO1xuICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xuICAgIGJhc2VUZXh0dXJlLnNldFJlYWxTaXplKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHJlc29sdXRpb24pO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBzdXBlci5fcmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgfVxuICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHJldHVybiBzdXBlci5nZXRMb2NhbEJvdW5kcyhyZWN0KTtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKTtcbiAgfVxuICBfb25TdHlsZUNoYW5nZSgpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgX0hUTUxUZXh0LmRlZmF1bHREZXN0cm95T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICBjb25zdCBmb3JjZUNsZWFyID0gbnVsbDtcbiAgICBpZiAodGhpcy5vd25zU3R5bGUpIHtcbiAgICAgIHRoaXMuX3N0eWxlPy5jbGVhbkZvbnRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0eWxlID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9zdmdSb290Py5yZW1vdmUoKTtcbiAgICB0aGlzLl9zdmdSb290ID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9kb21FbGVtZW50Py5yZW1vdmUoKTtcbiAgICB0aGlzLl9kb21FbGVtZW50ID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9mb3JlaWduT2JqZWN0Py5yZW1vdmUoKTtcbiAgICB0aGlzLl9mb3JlaWduT2JqZWN0ID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9zdHlsZUVsZW1lbnQ/LnJlbW92ZSgpO1xuICAgIHRoaXMuX3N0eWxlRWxlbWVudCA9IGZvcmNlQ2xlYXI7XG4gICAgdGhpcy5fbG9hZEltYWdlLnNyYyA9IFwiXCI7XG4gICAgdGhpcy5fbG9hZEltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgdGhpcy5fbG9hZEltYWdlID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9pbWFnZS5zcmMgPSBcIlwiO1xuICAgIHRoaXMuX2ltYWdlID0gZm9yY2VDbGVhcjtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5faW1hZ2Uud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIGNvbnN0IHMgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl9pbWFnZS53aWR0aCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5faW1hZ2UuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgY29uc3QgcyA9IHV0aWxzLnNpZ24odGhpcy5zY2FsZS55KSB8fCAxO1xuICAgIHRoaXMuc2NhbGUueSA9IHMgKiB2YWx1ZSAvIHRoaXMuX2ltYWdlLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgc3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG4gIHNldCBzdHlsZShzdHlsZSkge1xuICAgIGlmICh0aGlzLl9zdHlsZSA9PT0gc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBIVE1MVGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLm93bnNTdHlsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRdIENsb25pbmcgVGV4dFN0eWxlLCBpZiB0aGlzIGlzIG5vdCB3aGF0IHlvdSB3YW50LCB1c2UgSFRNTFRleHRTdHlsZVwiKTtcbiAgICAgIHRoaXMub3duc1N0eWxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0eWxlID0gSFRNTFRleHRTdHlsZS5mcm9tKHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vd25zU3R5bGUgPSB0cnVlO1xuICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgSFRNTFRleHRTdHlsZShzdHlsZSk7XG4gICAgfVxuICAgIHRoaXMubG9jYWxTdHlsZUlEID0gLTE7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cbiAgc2V0IHRleHQodGV4dCkge1xuICAgIHRleHQgPSBTdHJpbmcodGV4dCA9PT0gXCJcIiB8fCB0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHZvaWQgMCA/IFwiIFwiIDogdGV4dCk7XG4gICAgdGV4dCA9IHRoaXMuc2FuaXRpc2VUZXh0KHRleHQpO1xuICAgIGlmICh0aGlzLl90ZXh0ID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIHNhbml0aXNlVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvPGJyPi9naSwgXCI8YnIvPlwiKS5yZXBsYWNlKC88aHI+L2dpLCBcIjxoci8+XCIpLnJlcGxhY2UoLyZuYnNwOy9naSwgXCImIzE2MDtcIik7XG4gIH1cbn07XG5sZXQgSFRNTFRleHQgPSBfSFRNTFRleHQ7XG5IVE1MVGV4dC5kZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XG4gIHRleHR1cmU6IHRydWUsXG4gIGNoaWxkcmVuOiBmYWxzZSxcbiAgYmFzZVRleHR1cmU6IHRydWVcbn07XG5IVE1MVGV4dC5kZWZhdWx0TWF4V2lkdGggPSAyMDI0O1xuSFRNTFRleHQuZGVmYXVsdE1heEhlaWdodCA9IDIwMjQ7XG5IVE1MVGV4dC5kZWZhdWx0QXV0b1Jlc29sdXRpb24gPSB0cnVlO1xuXG5leHBvcnQgeyBIVE1MVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTFRleHQubWpzLm1hcFxuIiwiZXhwb3J0IHsgSFRNTFRleHQgfSBmcm9tICcuL0hUTUxUZXh0Lm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dFN0eWxlIH0gZnJvbSAnLi9IVE1MVGV4dFN0eWxlLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgJ0BwaXhpL21peGluLWNhY2hlLWFzLWJpdG1hcCc7XG5pbXBvcnQgJ0BwaXhpL21peGluLWdldC1jaGlsZC1ieS1uYW1lJztcbmltcG9ydCAnQHBpeGkvbWl4aW4tZ2V0LWdsb2JhbC1wb3NpdGlvbic7XG5leHBvcnQgeyBmaWx0ZXJzIH0gZnJvbSAnLi9maWx0ZXJzLm1qcyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9hY2Nlc3NpYmlsaXR5JztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2FwcCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9hc3NldHMnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZXZlbnRzJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2V4dHJhY3QnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZmlsdGVyLWFscGhhJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2ZpbHRlci1ibHVyJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXgnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9maWx0ZXItZnhhYSc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9maWx0ZXItbm9pc2UnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZ3JhcGhpY3MnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvbWVzaCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9tZXNoLWV4dHJhcyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9wYXJ0aWNsZS1jb250YWluZXInO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvcHJlcGFyZSc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9zcHJpdGUnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvc3ByaXRlLWFuaW1hdGVkJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL3Nwcml0ZS10aWxpbmcnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvc3ByaXRlc2hlZXQnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvdGV4dCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS90ZXh0LWJpdG1hcCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS90ZXh0LWh0bWwnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///453\n')}}]);