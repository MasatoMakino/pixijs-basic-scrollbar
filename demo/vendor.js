(self.webpackChunk_masatomakino_pixijs_basic_scrollbar=self.webpackChunk_masatomakino_pixijs_basic_scrollbar||[]).push([[736],{720:module=>{"use strict";eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHdCQUF3QixvQkFBb0I7QUFDNUMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcz85ZTU2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldikgcmV0dXJuIHRyaWFuZ2xlcztcblxuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXG4gICAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xuXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcbiAgICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMzI3NjcgLyBpbnZTaXplIDogMDtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIGJyZWFrO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBpbnZTaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKGludlNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG4gICAgdmFyIGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciB4MCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTAgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgIHgxID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KTtcblxuICAgIHZhciBwID0gYy5uZXh0O1xuICAgIHdoaWxlIChwICE9PSBhKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgdmFyIGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciB4MCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTAgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgIHgxID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KTtcblxuICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG4gICAgdmFyIG1pblogPSB6T3JkZXIoeDAsIHkwLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcih4MSwgeTEsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHAgPSBlYXIucHJldlosXG4gICAgICAgIG4gPSBlYXIubmV4dFo7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG5cbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltIHwgMCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKHApO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIGJyaWRnZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKCFicmlkZ2UpIHtcbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG5cbiAgICB2YXIgYnJpZGdlUmV2ZXJzZSA9IHNwbGl0UG9seWdvbihicmlkZ2UsIGhvbGUpO1xuXG4gICAgLy8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgZmlsdGVyUG9pbnRzKGJyaWRnZVJldmVyc2UsIGJyaWRnZVJldmVyc2UubmV4dCk7XG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhicmlkZ2UsIGJyaWRnZS5uZXh0KTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcbiAgICAgICAgICAgIGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuICAgICAgICAgICAgICAgIHF4ID0geDtcbiAgICAgICAgICAgICAgICBtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkgcmV0dXJuIG07IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxlZnRtb3N0IGVuZHBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbTtcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAobG9jYWxseUluc2lkZShwLCBob2xlKSAmJlxuICAgICAgICAgICAgICAgICh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIChwLnggPiBtLnggfHwgKHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApKSkpKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RvcCk7XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gd2hldGhlciBzZWN0b3IgaW4gdmVydGV4IG0gY29udGFpbnMgc2VjdG9yIGluIHZlcnRleCBwIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5mdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSB7XG4gICAgcmV0dXJuIGFyZWEobS5wcmV2LCBtLCBwLnByZXYpIDwgMCAmJiBhcmVhKHAubmV4dCwgbSwgbS5uZXh0KSA8IDA7XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gMCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gKHggLSBtaW5YKSAqIGludlNpemUgfCAwO1xuICAgIHkgPSAoeSAtIG1pblkpICogaW52U2l6ZSB8IDA7XG5cbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54IHx8IChwLnggPT09IGxlZnRtb3N0LnggJiYgcC55IDwgbGVmdG1vc3QueSkpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpID49IChheCAtIHB4KSAqIChjeSAtIHB5KSAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgPj0gKGJ4IC0gcHgpICogKGF5IC0gcHkpICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSA+PSAoY3ggLSBweCkgKiAoYnkgLSBweSk7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJiAvLyBkb25lcyd0IGludGVyc2VjdCBvdGhlciBlZGdlc1xuICAgICAgICAgICAobG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKSAmJiAvLyBsb2NhbGx5IHZpc2libGVcbiAgICAgICAgICAgIChhcmVhKGEucHJldiwgYSwgYi5wcmV2KSB8fCBhcmVhKGEsIGIucHJldiwgYikpIHx8IC8vIGRvZXMgbm90IGNyZWF0ZSBvcHBvc2l0ZS1mYWNpbmcgc2VjdG9yc1xuICAgICAgICAgICAgZXF1YWxzKGEsIGIpICYmIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpID4gMCAmJiBhcmVhKGIucHJldiwgYiwgYi5uZXh0KSA+IDApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2Vcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICB2YXIgbzEgPSBzaWduKGFyZWEocDEsIHExLCBwMikpO1xuICAgIHZhciBvMiA9IHNpZ24oYXJlYShwMSwgcTEsIHEyKSk7XG4gICAgdmFyIG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcbiAgICB2YXIgbzQgPSBzaWduKGFyZWEocDIsIHEyLCBxMSkpO1xuXG4gICAgaWYgKG8xICE9PSBvMiAmJiBvMyAhPT0gbzQpIHJldHVybiB0cnVlOyAvLyBnZW5lcmFsIGNhc2VcblxuICAgIGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHAyIGFyZSBjb2xsaW5lYXIgYW5kIHAyIGxpZXMgb24gcDFxMVxuICAgIGlmIChvMiA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHEyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHEyIGFyZSBjb2xsaW5lYXIgYW5kIHEyIGxpZXMgb24gcDFxMVxuICAgIGlmIChvMyA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHAxLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHAxIGFyZSBjb2xsaW5lYXIgYW5kIHAxIGxpZXMgb24gcDJxMlxuICAgIGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHExIGFyZSBjb2xsaW5lYXIgYW5kIHExIGxpZXMgb24gcDJxMlxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBmb3IgY29sbGluZWFyIHBvaW50cyBwLCBxLCByLCBjaGVjayBpZiBwb2ludCBxIGxpZXMgb24gc2VnbWVudCBwclxuZnVuY3Rpb24gb25TZWdtZW50KHAsIHEsIHIpIHtcbiAgICByZXR1cm4gcS54IDw9IE1hdGgubWF4KHAueCwgci54KSAmJiBxLnggPj0gTWF0aC5taW4ocC54LCByLngpICYmIHEueSA8PSBNYXRoLm1heChwLnksIHIueSkgJiYgcS55ID49IE1hdGgubWluKHAueSwgci55KTtcbn1cblxuZnVuY3Rpb24gc2lnbihudW0pIHtcbiAgICByZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLTEgOiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBiMjtcbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgIHZhciBwID0gbmV3IE5vZGUoaSwgeCwgeSk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgcC5wcmV2ID0gcDtcbiAgICAgICAgcC5uZXh0ID0gcDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgcC5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBwO1xuICAgICAgICBsYXN0Lm5leHQgPSBwO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XG4gICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XG4gICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XG5cbiAgICBpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG4gICAgaWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xufVxuXG5mdW5jdGlvbiBOb2RlKGksIHgsIHkpIHtcbiAgICAvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGV4IG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgIHRoaXMueiA9IDA7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG5cbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XG4gICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufTtcblxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///720\n")},1379:module=>{eval("\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3OS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BhcnNlLXN2Zy1wYXRoL2luZGV4LmpzPzc2ODAiXSwic291cmNlc0NvbnRlbnQiOlsiXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG5cbi8qKlxuICogZXhwZWN0ZWQgYXJndW1lbnQgbGVuZ3Roc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG52YXIgbGVuZ3RoID0ge2E6IDcsIGM6IDYsIGg6IDEsIGw6IDIsIG06IDIsIHE6IDQsIHM6IDQsIHQ6IDIsIHY6IDEsIHo6IDB9XG5cbi8qKlxuICogc2VnbWVudCBwYXR0ZXJuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5cbnZhciBzZWdtZW50ID0gLyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZ1xuXG4vKipcbiAqIHBhcnNlIGFuIHN2ZyBwYXRoIGRhdGEgc3RyaW5nLiBHZW5lcmF0ZXMgYW4gQXJyYXlcbiAqIG9mIGNvbW1hbmRzIHdoZXJlIGVhY2ggY29tbWFuZCBpcyBhbiBBcnJheSBvZiB0aGVcbiAqIGZvcm0gYFtjb21tYW5kLCBhcmcxLCBhcmcyLCAuLi5dYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG5cdHZhciBkYXRhID0gW11cblx0cGF0aC5yZXBsYWNlKHNlZ21lbnQsIGZ1bmN0aW9uKF8sIGNvbW1hbmQsIGFyZ3Mpe1xuXHRcdHZhciB0eXBlID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpXG5cdFx0YXJncyA9IHBhcnNlVmFsdWVzKGFyZ3MpXG5cblx0XHQvLyBvdmVybG9hZGVkIG1vdmVUb1xuXHRcdGlmICh0eXBlID09ICdtJyAmJiBhcmdzLmxlbmd0aCA+IDIpIHtcblx0XHRcdGRhdGEucHVzaChbY29tbWFuZF0uY29uY2F0KGFyZ3Muc3BsaWNlKDAsIDIpKSlcblx0XHRcdHR5cGUgPSAnbCdcblx0XHRcdGNvbW1hbmQgPSBjb21tYW5kID09ICdtJyA/ICdsJyA6ICdMJ1xuXHRcdH1cblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggPT0gbGVuZ3RoW3R5cGVdKSB7XG5cdFx0XHRcdGFyZ3MudW5zaGlmdChjb21tYW5kKVxuXHRcdFx0XHRyZXR1cm4gZGF0YS5wdXNoKGFyZ3MpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggPCBsZW5ndGhbdHlwZV0pIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIHBhdGggZGF0YScpXG5cdFx0XHRkYXRhLnB1c2goW2NvbW1hbmRdLmNvbmNhdChhcmdzLnNwbGljZSgwLCBsZW5ndGhbdHlwZV0pKSlcblx0XHR9XG5cdH0pXG5cdHJldHVybiBkYXRhXG59XG5cbnZhciBudW1iZXIgPSAvLT9bMC05XSpcXC4/WzAtOV0rKD86ZVstK10/XFxkKyk/L2lnXG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWVzKGFyZ3MpIHtcblx0dmFyIG51bWJlcnMgPSBhcmdzLm1hdGNoKG51bWJlcilcblx0cmV0dXJuIG51bWJlcnMgPyBudW1iZXJzLm1hcChOdW1iZXIpIDogW11cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1379\n")},2218:module=>{"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBNkI7QUFDakM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzP2E5MjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2218\n")},4162:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ Cache)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4796);\n/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9879);\n\n\n\n"use strict";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertToList */ .S)(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)("[Cache] already has key:", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\n\n//# sourceMappingURL=Cache.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE2Mi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUNPOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzRUFBSSxzQkFBc0IsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0ZBQWE7QUFDOUI7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFJO0FBQ1o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNFQUFJLHNCQUFzQixLQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvY2FjaGUvQ2FjaGUubWpzP2EwODUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4uL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYWNoZUNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcGFyc2VycyA9IFtdO1xuICAgIHRoaXMuX2NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9jYWNoZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqIENsZWFyIGFsbCBlbnRyaWVzLiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl9jYWNoZU1hcC5jbGVhcigpO1xuICAgIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBrZXkgZXhpc3RzXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGNoZWNrXG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBlbnRyeSBieSBrZXlcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGdldFxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhY2hlLmdldChrZXkpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB3YXJuKGBbQXNzZXRzXSBBc3NldCBpZCAke2tleX0gd2FzIG5vdCBmb3VuZCBpbiB0aGUgQ2FjaGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgdmFsdWUgYnkga2V5IG9yIGtleXMgbmFtZVxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvciBrZXlzIHRvIHNldFxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RvcmUgaW4gdGhlIGNhY2hlIG9yIGZyb20gd2hpY2ggY2FjaGVhYmxlIGFzc2V0cyB3aWxsIGJlIGRlcml2ZWQuXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBjb252ZXJ0VG9MaXN0KGtleSk7XG4gICAgbGV0IGNhY2hlYWJsZUFzc2V0cztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXJzW2ldO1xuICAgICAgaWYgKHBhcnNlci50ZXN0KHZhbHVlKSkge1xuICAgICAgICBjYWNoZWFibGVBc3NldHMgPSBwYXJzZXIuZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlYWJsZU1hcCA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoY2FjaGVhYmxlQXNzZXRzIHx8IHt9KSk7XG4gICAgaWYgKCFjYWNoZWFibGVBc3NldHMpIHtcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgICBjYWNoZWFibGVNYXAuc2V0KGtleTIsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZUtleXMgPSBbLi4uY2FjaGVhYmxlTWFwLmtleXMoKV07XG4gICAgY29uc3QgY2FjaGVkQXNzZXRzID0ge1xuICAgICAgY2FjaGVLZXlzLFxuICAgICAga2V5c1xuICAgIH07XG4gICAga2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICB0aGlzLl9jYWNoZU1hcC5zZXQoa2V5MiwgY2FjaGVkQXNzZXRzKTtcbiAgICB9KTtcbiAgICBjYWNoZUtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgY29uc3QgdmFsID0gY2FjaGVhYmxlQXNzZXRzID8gY2FjaGVhYmxlQXNzZXRzW2tleTJdIDogdmFsdWU7XG4gICAgICBpZiAodGhpcy5fY2FjaGUuaGFzKGtleTIpICYmIHRoaXMuX2NhY2hlLmdldChrZXkyKSAhPT0gdmFsKSB7XG4gICAgICAgIHdhcm4oXCJbQ2FjaGVdIGFscmVhZHkgaGFzIGtleTpcIiwga2V5Mik7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZS5zZXQoa2V5MiwgY2FjaGVhYmxlTWFwLmdldChrZXkyKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBlbnRyeSBieSBrZXlcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gcmVtb3ZlIGFueSBhc3NvY2lhdGVkIGFsaWFzIGZyb20gdGhlIGNhY2hlIGFsc28uXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZShrZXkpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlTWFwLmhhcyhrZXkpKSB7XG4gICAgICB3YXJuKGBbQXNzZXRzXSBBc3NldCBpZCAke2tleX0gd2FzIG5vdCBmb3VuZCBpbiB0aGUgQ2FjaGVgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVNYXAgPSB0aGlzLl9jYWNoZU1hcC5nZXQoa2V5KTtcbiAgICBjb25zdCBjYWNoZUtleXMgPSBjYWNoZU1hcC5jYWNoZUtleXM7XG4gICAgY2FjaGVLZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShrZXkyKTtcbiAgICB9KTtcbiAgICBjYWNoZU1hcC5rZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlTWFwLmRlbGV0ZShrZXkyKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQWxsIGxvYWRlciBwYXJzZXJzIHJlZ2lzdGVyZWQgKi9cbiAgZ2V0IHBhcnNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlcnM7XG4gIH1cbn1cbmNvbnN0IENhY2hlID0gbmV3IENhY2hlQ2xhc3MoKTtcblxuZXhwb3J0IHsgQ2FjaGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4162\n')},9879:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ convertToList)\n/* harmony export */ });\n\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === "string" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\n\n//# sourceMappingURL=convertToList.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg3OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzPzg0ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjb252ZXJ0VG9MaXN0ID0gKGlucHV0LCB0cmFuc2Zvcm0sIGZvcmNlVHJhbnNmb3JtID0gZmFsc2UpID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlucHV0ID0gW2lucHV0XTtcbiAgfVxuICBpZiAoIXRyYW5zZm9ybSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICByZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiIHx8IGZvcmNlVHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBjb252ZXJ0VG9MaXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252ZXJ0VG9MaXN0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9879\n')},8409:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  I: () => (/* binding */ Color)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/colord/index.mjs\nvar r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/colord/plugins/names.mjs\n/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/color/Color.mjs\n\n\n\n"use strict";\nk([names]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter\'s parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter\'s parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error("Cannot set Color#value to null");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._normalize(value);\n      this._value = this._cloneSource(value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === "object" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out = out || this._arrayRgba;\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexadecimal string.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHex(); // returns "#ffffff"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexadecimal string with alpha.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHexa(); // returns "#ffffffff"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === "string" || typeof value === "object") {\n      if (typeof value === "string") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = w(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === "number") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from \'pixi.js\';\n   * Color.isColorLike(\'white\'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from \'pixi.js\';\n * Color.shared.setValue(0xffffff).toHex(); // \'#ffffff\'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\n\n//# sourceMappingURL=Color.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsRUFBRSxJQUFJLFVBQVUsRUFBRTtBQUM3RDs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29sb3JkL2luZGV4Lm1qcz81YzE2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvcmQvcGx1Z2lucy9uYW1lcy5tanM/OGViNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29sb3IvQ29sb3IubWpzPzRmMTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHI9e2dyYWQ6LjksdHVybjozNjAscmFkOjM2MC8oMipNYXRoLlBJKX0sdD1mdW5jdGlvbihyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygcj9yLmxlbmd0aD4wOlwibnVtYmVyXCI9PXR5cGVvZiByfSxuPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49TWF0aC5wb3coMTAsdCkpLE1hdGgucm91bmQobipyKS9uKzB9LGU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj0xKSxyPm4/bjpyPnQ/cjp0fSx1PWZ1bmN0aW9uKHIpe3JldHVybihyPWlzRmluaXRlKHIpP3IlMzYwOjApPjA/cjpyKzM2MH0sYT1mdW5jdGlvbihyKXtyZXR1cm57cjplKHIuciwwLDI1NSksZzplKHIuZywwLDI1NSksYjplKHIuYiwwLDI1NSksYTplKHIuYSl9fSxvPWZ1bmN0aW9uKHIpe3JldHVybntyOm4oci5yKSxnOm4oci5nKSxiOm4oci5iKSxhOm4oci5hLDMpfX0saT0vXiMoWzAtOWEtZl17Myw4fSkkL2kscz1mdW5jdGlvbihyKXt2YXIgdD1yLnRvU3RyaW5nKDE2KTtyZXR1cm4gdC5sZW5ndGg8Mj9cIjBcIit0OnR9LGg9ZnVuY3Rpb24ocil7dmFyIHQ9ci5yLG49ci5nLGU9ci5iLHU9ci5hLGE9TWF0aC5tYXgodCxuLGUpLG89YS1NYXRoLm1pbih0LG4sZSksaT1vP2E9PT10PyhuLWUpL286YT09PW4/MisoZS10KS9vOjQrKHQtbikvbzowO3JldHVybntoOjYwKihpPDA/aSs2OmkpLHM6YT9vL2EqMTAwOjAsdjphLzI1NSoxMDAsYTp1fX0sYj1mdW5jdGlvbihyKXt2YXIgdD1yLmgsbj1yLnMsZT1yLnYsdT1yLmE7dD10LzM2MCo2LG4vPTEwMCxlLz0xMDA7dmFyIGE9TWF0aC5mbG9vcih0KSxvPWUqKDEtbiksaT1lKigxLSh0LWEpKm4pLHM9ZSooMS0oMS10K2EpKm4pLGg9YSU2O3JldHVybntyOjI1NSpbZSxpLG8sbyxzLGVdW2hdLGc6MjU1KltzLGUsZSxpLG8sb11baF0sYjoyNTUqW28sbyxzLGUsZSxpXVtoXSxhOnV9fSxnPWZ1bmN0aW9uKHIpe3JldHVybntoOnUoci5oKSxzOmUoci5zLDAsMTAwKSxsOmUoci5sLDAsMTAwKSxhOmUoci5hKX19LGQ9ZnVuY3Rpb24ocil7cmV0dXJue2g6bihyLmgpLHM6bihyLnMpLGw6bihyLmwpLGE6bihyLmEsMyl9fSxmPWZ1bmN0aW9uKHIpe3JldHVybiBiKChuPSh0PXIpLnMse2g6dC5oLHM6KG4qPSgoZT10LmwpPDUwP2U6MTAwLWUpLzEwMCk+MD8yKm4vKGUrbikqMTAwOjAsdjplK24sYTp0LmF9KSk7dmFyIHQsbixlfSxjPWZ1bmN0aW9uKHIpe3JldHVybntoOih0PWgocikpLmgsczoodT0oMjAwLShuPXQucykpKihlPXQudikvMTAwKT4wJiZ1PDIwMD9uKmUvMTAwLyh1PD0xMDA/dToyMDAtdSkqMTAwOjAsbDp1LzIsYTp0LmF9O3ZhciB0LG4sZSx1fSxsPS9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKShkZWd8cmFkfGdyYWR8dHVybik/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspJVxccyooPzosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHA9L15oc2xhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKGRlZ3xyYWR8Z3JhZHx0dXJuKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHY9L15yZ2JhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86LFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSxtPS9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHk9e3N0cmluZzpbW2Z1bmN0aW9uKHIpe3ZhciB0PWkuZXhlYyhyKTtyZXR1cm4gdD8ocj10WzFdKS5sZW5ndGg8PTQ/e3I6cGFyc2VJbnQoclswXStyWzBdLDE2KSxnOnBhcnNlSW50KHJbMV0rclsxXSwxNiksYjpwYXJzZUludChyWzJdK3JbMl0sMTYpLGE6ND09PXIubGVuZ3RoP24ocGFyc2VJbnQoclszXStyWzNdLDE2KS8yNTUsMik6MX06Nj09PXIubGVuZ3RofHw4PT09ci5sZW5ndGg/e3I6cGFyc2VJbnQoci5zdWJzdHIoMCwyKSwxNiksZzpwYXJzZUludChyLnN1YnN0cigyLDIpLDE2KSxiOnBhcnNlSW50KHIuc3Vic3RyKDQsMiksMTYpLGE6OD09PXIubGVuZ3RoP24ocGFyc2VJbnQoci5zdWJzdHIoNiwyKSwxNikvMjU1LDIpOjF9Om51bGw6bnVsbH0sXCJoZXhcIl0sW2Z1bmN0aW9uKHIpe3ZhciB0PXYuZXhlYyhyKXx8bS5leGVjKHIpO3JldHVybiB0P3RbMl0hPT10WzRdfHx0WzRdIT09dFs2XT9udWxsOmEoe3I6TnVtYmVyKHRbMV0pLyh0WzJdPzEwMC8yNTU6MSksZzpOdW1iZXIodFszXSkvKHRbNF0/MTAwLzI1NToxKSxiOk51bWJlcih0WzVdKS8odFs2XT8xMDAvMjU1OjEpLGE6dm9pZCAwPT09dFs3XT8xOk51bWJlcih0WzddKS8odFs4XT8xMDA6MSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24odCl7dmFyIG49bC5leGVjKHQpfHxwLmV4ZWModCk7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGUsdSxhPWcoe2g6KGU9blsxXSx1PW5bMl0sdm9pZCAwPT09dSYmKHU9XCJkZWdcIiksTnVtYmVyKGUpKihyW3VdfHwxKSksczpOdW1iZXIoblszXSksbDpOdW1iZXIobls0XSksYTp2b2lkIDA9PT1uWzVdPzE6TnVtYmVyKG5bNV0pLyhuWzZdPzEwMDoxKX0pO3JldHVybiBmKGEpfSxcImhzbFwiXV0sb2JqZWN0OltbZnVuY3Rpb24ocil7dmFyIG49ci5yLGU9ci5nLHU9ci5iLG89ci5hLGk9dm9pZCAwPT09bz8xOm87cmV0dXJuIHQobikmJnQoZSkmJnQodSk/YSh7cjpOdW1iZXIobiksZzpOdW1iZXIoZSksYjpOdW1iZXIodSksYTpOdW1iZXIoaSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGU9ci5zLHU9ci5sLGE9ci5hLG89dm9pZCAwPT09YT8xOmE7aWYoIXQobil8fCF0KGUpfHwhdCh1KSlyZXR1cm4gbnVsbDt2YXIgaT1nKHtoOk51bWJlcihuKSxzOk51bWJlcihlKSxsOk51bWJlcih1KSxhOk51bWJlcihvKX0pO3JldHVybiBmKGkpfSxcImhzbFwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGE9ci5zLG89ci52LGk9ci5hLHM9dm9pZCAwPT09aT8xOmk7aWYoIXQobil8fCF0KGEpfHwhdChvKSlyZXR1cm4gbnVsbDt2YXIgaD1mdW5jdGlvbihyKXtyZXR1cm57aDp1KHIuaCksczplKHIucywwLDEwMCksdjplKHIudiwwLDEwMCksYTplKHIuYSl9fSh7aDpOdW1iZXIobiksczpOdW1iZXIoYSksdjpOdW1iZXIobyksYTpOdW1iZXIocyl9KTtyZXR1cm4gYihoKX0sXCJoc3ZcIl1dfSxOPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBlPXRbbl1bMF0ocik7aWYoZSlyZXR1cm5bZSx0W25dWzFdXX1yZXR1cm5bbnVsbCx2b2lkIDBdfSx4PWZ1bmN0aW9uKHIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiByP04oci50cmltKCkseS5zdHJpbmcpOlwib2JqZWN0XCI9PXR5cGVvZiByJiZudWxsIT09cj9OKHIseS5vYmplY3QpOltudWxsLHZvaWQgMF19LEk9ZnVuY3Rpb24ocil7cmV0dXJuIHgocilbMV19LE09ZnVuY3Rpb24ocix0KXt2YXIgbj1jKHIpO3JldHVybntoOm4uaCxzOmUobi5zKzEwMCp0LDAsMTAwKSxsOm4ubCxhOm4uYX19LEg9ZnVuY3Rpb24ocil7cmV0dXJuKDI5OSpyLnIrNTg3KnIuZysxMTQqci5iKS8xZTMvMjU1fSwkPWZ1bmN0aW9uKHIsdCl7dmFyIG49YyhyKTtyZXR1cm57aDpuLmgsczpuLnMsbDplKG4ubCsxMDAqdCwwLDEwMCksYTpuLmF9fSxqPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyKXt0aGlzLnBhcnNlZD14KHIpWzBdLHRoaXMucmdiYT10aGlzLnBhcnNlZHx8e3I6MCxnOjAsYjowLGE6MX19cmV0dXJuIHIucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucGFyc2VkfSxyLnByb3RvdHlwZS5icmlnaHRuZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG4oSCh0aGlzLnJnYmEpLDIpfSxyLnByb3RvdHlwZS5pc0Rhcms9ZnVuY3Rpb24oKXtyZXR1cm4gSCh0aGlzLnJnYmEpPC41fSxyLnByb3RvdHlwZS5pc0xpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEgodGhpcy5yZ2JhKT49LjV9LHIucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHI9byh0aGlzLnJnYmEpLHQ9ci5yLGU9ci5nLHU9ci5iLGk9KGE9ci5hKTwxP3MobigyNTUqYSkpOlwiXCIsXCIjXCIrcyh0KStzKGUpK3ModSkraTt2YXIgcix0LGUsdSxhLGl9LHIucHJvdG90eXBlLnRvUmdiPWZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcy5yZ2JhKX0sci5wcm90b3R5cGUudG9SZ2JTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcj1vKHRoaXMucmdiYSksdD1yLnIsbj1yLmcsZT1yLmIsKHU9ci5hKTwxP1wicmdiYShcIit0K1wiLCBcIituK1wiLCBcIitlK1wiLCBcIit1K1wiKVwiOlwicmdiKFwiK3QrXCIsIFwiK24rXCIsIFwiK2UrXCIpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic2w9ZnVuY3Rpb24oKXtyZXR1cm4gZChjKHRoaXMucmdiYSkpfSxyLnByb3RvdHlwZS50b0hzbFN0cmluZz1mdW5jdGlvbigpe3JldHVybiByPWQoYyh0aGlzLnJnYmEpKSx0PXIuaCxuPXIucyxlPXIubCwodT1yLmEpPDE/XCJoc2xhKFwiK3QrXCIsIFwiK24rXCIlLCBcIitlK1wiJSwgXCIrdStcIilcIjpcImhzbChcIit0K1wiLCBcIituK1wiJSwgXCIrZStcIiUpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic3Y9ZnVuY3Rpb24oKXtyZXR1cm4gcj1oKHRoaXMucmdiYSkse2g6bihyLmgpLHM6bihyLnMpLHY6bihyLnYpLGE6bihyLmEsMyl9O3ZhciByfSxyLnByb3RvdHlwZS5pbnZlcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdyh7cjoyNTUtKHI9dGhpcy5yZ2JhKS5yLGc6MjU1LXIuZyxiOjI1NS1yLmIsYTpyLmF9KTt2YXIgcn0sci5wcm90b3R5cGUuc2F0dXJhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KE0odGhpcy5yZ2JhLHIpKX0sci5wcm90b3R5cGUuZGVzYXR1cmF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoTSh0aGlzLnJnYmEsLXIpKX0sci5wcm90b3R5cGUuZ3JheXNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHcoTSh0aGlzLnJnYmEsLTEpKX0sci5wcm90b3R5cGUubGlnaHRlbj1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoJCh0aGlzLnJnYmEscikpfSxyLnByb3RvdHlwZS5kYXJrZW49ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KCQodGhpcy5yZ2JhLC1yKSl9LHIucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MTUpLHRoaXMuaHVlKHRoaXMuaHVlKCkrcil9LHIucHJvdG90eXBlLmFscGhhPWZ1bmN0aW9uKHIpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByP3coe3I6KHQ9dGhpcy5yZ2JhKS5yLGc6dC5nLGI6dC5iLGE6cn0pOm4odGhpcy5yZ2JhLmEsMyk7dmFyIHR9LHIucHJvdG90eXBlLmh1ZT1mdW5jdGlvbihyKXt2YXIgdD1jKHRoaXMucmdiYSk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/dyh7aDpyLHM6dC5zLGw6dC5sLGE6dC5hfSk6bih0LmgpfSxyLnByb3RvdHlwZS5pc0VxdWFsPWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvSGV4KCk9PT13KHIpLnRvSGV4KCl9LHJ9KCksdz1mdW5jdGlvbihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIGo/cjpuZXcgaihyKX0sUz1bXSxrPWZ1bmN0aW9uKHIpe3IuZm9yRWFjaChmdW5jdGlvbihyKXtTLmluZGV4T2Yocik8MCYmKHIoaix5KSxTLnB1c2gocikpfSl9LEU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGooe3I6MjU1Kk1hdGgucmFuZG9tKCksZzoyNTUqTWF0aC5yYW5kb20oKSxiOjI1NSpNYXRoLnJhbmRvbSgpfSl9O2V4cG9ydHtqIGFzIENvbG9yZCx3IGFzIGNvbG9yZCxrIGFzIGV4dGVuZCxJIGFzIGdldEZvcm1hdCxFIGFzIHJhbmRvbX07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlLGYpe3ZhciBhPXt3aGl0ZTpcIiNmZmZmZmZcIixiaXNxdWU6XCIjZmZlNGM0XCIsYmx1ZTpcIiMwMDAwZmZcIixjYWRldGJsdWU6XCIjNWY5ZWEwXCIsY2hhcnRyZXVzZTpcIiM3ZmZmMDBcIixjaG9jb2xhdGU6XCIjZDI2OTFlXCIsY29yYWw6XCIjZmY3ZjUwXCIsYW50aXF1ZXdoaXRlOlwiI2ZhZWJkN1wiLGFxdWE6XCIjMDBmZmZmXCIsYXp1cmU6XCIjZjBmZmZmXCIsd2hpdGVzbW9rZTpcIiNmNWY1ZjVcIixwYXBheWF3aGlwOlwiI2ZmZWZkNVwiLHBsdW06XCIjZGRhMGRkXCIsYmxhbmNoZWRhbG1vbmQ6XCIjZmZlYmNkXCIsYmxhY2s6XCIjMDAwMDAwXCIsZ29sZDpcIiNmZmQ3MDBcIixnb2xkZW5yb2Q6XCIjZGFhNTIwXCIsZ2FpbnNib3JvOlwiI2RjZGNkY1wiLGNvcm5zaWxrOlwiI2ZmZjhkY1wiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVlZFwiLGJ1cmx5d29vZDpcIiNkZWI4ODdcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGNyaW1zb246XCIjZGMxNDNjXCIsY3lhbjpcIiMwMGZmZmZcIixkYXJrYmx1ZTpcIiMwMDAwOGJcIixkYXJrY3lhbjpcIiMwMDhiOGJcIixkYXJrZ29sZGVucm9kOlwiI2I4ODYwYlwiLGRhcmtraGFraTpcIiNiZGI3NmJcIixkYXJrZ3JheTpcIiNhOWE5YTlcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsZGFya2dyZXk6XCIjYTlhOWE5XCIscGVhY2hwdWZmOlwiI2ZmZGFiOVwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLGRhcmtyZWQ6XCIjOGIwMDAwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkYXJrb3JhbmdlOlwiI2ZmOGMwMFwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzZDhiXCIsZ3JheTpcIiM4MDgwODBcIixkYXJrc2xhdGVncmF5OlwiIzJmNGY0ZlwiLGRhcmtzbGF0ZWdyZXk6XCIjMmY0ZjRmXCIsZGVlcHBpbms6XCIjZmYxNDkzXCIsZGVlcHNreWJsdWU6XCIjMDBiZmZmXCIsd2hlYXQ6XCIjZjVkZWIzXCIsZmlyZWJyaWNrOlwiI2IyMjIyMlwiLGZsb3JhbHdoaXRlOlwiI2ZmZmFmMFwiLGdob3N0d2hpdGU6XCIjZjhmOGZmXCIsZGFya3Zpb2xldDpcIiM5NDAwZDNcIixtYWdlbnRhOlwiI2ZmMDBmZlwiLGdyZWVuOlwiIzAwODAwMFwiLGRvZGdlcmJsdWU6XCIjMWU5MGZmXCIsZ3JleTpcIiM4MDgwODBcIixob25leWRldzpcIiNmMGZmZjBcIixob3RwaW5rOlwiI2ZmNjliNFwiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsZm9yZXN0Z3JlZW46XCIjMjI4YjIyXCIsbGF3bmdyZWVuOlwiIzdjZmMwMFwiLGluZGlhbnJlZDpcIiNjZDVjNWNcIixpbmRpZ286XCIjNGIwMDgyXCIsZnVjaHNpYTpcIiNmZjAwZmZcIixicm93bjpcIiNhNTJhMmFcIixtYXJvb246XCIjODAwMDAwXCIsbWVkaXVtYmx1ZTpcIiMwMDAwY2RcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLGRhcmt0dXJxdW9pc2U6XCIjMDBjZWQxXCIsbGlnaHRjeWFuOlwiI2UwZmZmZlwiLGl2b3J5OlwiI2ZmZmZmMFwiLGxpZ2h0eWVsbG93OlwiI2ZmZmZlMFwiLGxpZ2h0c2FsbW9uOlwiI2ZmYTA3YVwiLGxpZ2h0c2VhZ3JlZW46XCIjMjBiMmFhXCIsbGluZW46XCIjZmFmMGU2XCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixsZW1vbmNoaWZmb246XCIjZmZmYWNkXCIsbGltZTpcIiMwMGZmMDBcIixraGFraTpcIiNmMGU2OGNcIixtZWRpdW1zZWFncmVlbjpcIiMzY2IzNzFcIixsaW1lZ3JlZW46XCIjMzJjZDMyXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBmYTlhXCIsbGlnaHRza3libHVlOlwiIzg3Y2VmYVwiLGxpZ2h0Ymx1ZTpcIiNhZGQ4ZTZcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbGlnaHRwaW5rOlwiI2ZmYjZjMVwiLG1pc3R5cm9zZTpcIiNmZmU0ZTFcIixtb2NjYXNpbjpcIiNmZmU0YjVcIixtaW50Y3JlYW06XCIjZjVmZmZhXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbmF2YWpvd2hpdGU6XCIjZmZkZWFkXCIsbmF2eTpcIiMwMDAwODBcIixtZWRpdW12aW9sZXRyZWQ6XCIjYzcxNTg1XCIscG93ZGVyYmx1ZTpcIiNiMGUwZTZcIixwYWxlZ29sZGVucm9kOlwiI2VlZThhYVwiLG9sZGxhY2U6XCIjZmRmNWU2XCIscGFsZXR1cnF1b2lzZTpcIiNhZmVlZWVcIixtZWRpdW10dXJxdW9pc2U6XCIjNDhkMWNjXCIsbWVkaXVtb3JjaGlkOlwiI2JhNTVkM1wiLHJlYmVjY2FwdXJwbGU6XCIjNjYzMzk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLHRoaXN0bGU6XCIjZDhiZmQ4XCIsdGFuOlwiI2QyYjQ4Y1wiLG9yY2hpZDpcIiNkYTcwZDZcIixtZWRpdW1wdXJwbGU6XCIjOTM3MGRiXCIscHVycGxlOlwiIzgwMDA4MFwiLHBpbms6XCIjZmZjMGNiXCIsc2t5Ymx1ZTpcIiM4N2NlZWJcIixzcHJpbmdncmVlbjpcIiMwMGZmN2ZcIixwYWxlZ3JlZW46XCIjOThmYjk4XCIscmVkOlwiI2ZmMDAwMFwiLHllbGxvdzpcIiNmZmZmMDBcIixzbGF0ZWJsdWU6XCIjNmE1YWNkXCIsbGF2ZW5kZXJibHVzaDpcIiNmZmYwZjVcIixwZXJ1OlwiI2NkODUzZlwiLHBhbGV2aW9sZXRyZWQ6XCIjZGI3MDkzXCIsdmlvbGV0OlwiI2VlODJlZVwiLHRlYWw6XCIjMDA4MDgwXCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixhbGljZWJsdWU6XCIjZjBmOGZmXCIsZGFya3NlYWdyZWVuOlwiIzhmYmM4ZlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLGdyZWVueWVsbG93OlwiI2FkZmYyZlwiLHNlYWdyZWVuOlwiIzJlOGI1N1wiLHNlYXNoZWxsOlwiI2ZmZjVlZVwiLHRvbWF0bzpcIiNmZjYzNDdcIixzaWx2ZXI6XCIjYzBjMGMwXCIsc2llbm5hOlwiI2EwNTIyZFwiLGxhdmVuZGVyOlwiI2U2ZTZmYVwiLGxpZ2h0Z3JlZW46XCIjOTBlZTkwXCIsb3JhbmdlOlwiI2ZmYTUwMFwiLG9yYW5nZXJlZDpcIiNmZjQ1MDBcIixzdGVlbGJsdWU6XCIjNDY4MmI0XCIscm95YWxibHVlOlwiIzQxNjllMVwiLHR1cnF1b2lzZTpcIiM0MGUwZDBcIix5ZWxsb3dncmVlbjpcIiM5YWNkMzJcIixzYWxtb246XCIjZmE4MDcyXCIsc2FkZGxlYnJvd246XCIjOGI0NTEzXCIsc2FuZHlicm93bjpcIiNmNGE0NjBcIixyb3N5YnJvd246XCIjYmM4ZjhmXCIsZGFya3NhbG1vbjpcIiNlOTk2N2FcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNmYWZhZDJcIixzbm93OlwiI2ZmZmFmYVwiLGxpZ2h0Z3JleTpcIiNkM2QzZDNcIixsaWdodGdyYXk6XCIjZDNkM2QzXCIsZGltZ3JheTpcIiM2OTY5NjlcIixkaW1ncmV5OlwiIzY5Njk2OVwiLG9saXZlZHJhYjpcIiM2YjhlMjNcIixvbGl2ZTpcIiM4MDgwMDBcIn0scj17fTtmb3IodmFyIGQgaW4gYSlyW2FbZF1dPWQ7dmFyIGw9e307ZS5wcm90b3R5cGUudG9OYW1lPWZ1bmN0aW9uKGYpe2lmKCEodGhpcy5yZ2JhLmF8fHRoaXMucmdiYS5yfHx0aGlzLnJnYmEuZ3x8dGhpcy5yZ2JhLmIpKXJldHVyblwidHJhbnNwYXJlbnRcIjt2YXIgZCxpLG49clt0aGlzLnRvSGV4KCldO2lmKG4pcmV0dXJuIG47aWYobnVsbD09Zj92b2lkIDA6Zi5jbG9zZXN0KXt2YXIgbz10aGlzLnRvUmdiKCksdD0xLzAsYj1cImJsYWNrXCI7aWYoIWwubGVuZ3RoKWZvcih2YXIgYyBpbiBhKWxbY109bmV3IGUoYVtjXSkudG9SZ2IoKTtmb3IodmFyIGcgaW4gYSl7dmFyIHU9KGQ9byxpPWxbZ10sTWF0aC5wb3coZC5yLWkuciwyKStNYXRoLnBvdyhkLmctaS5nLDIpK01hdGgucG93KGQuYi1pLmIsMikpO3U8dCYmKHQ9dSxiPWcpfXJldHVybiBifX07Zi5zdHJpbmcucHVzaChbZnVuY3Rpb24oZil7dmFyIHI9Zi50b0xvd2VyQ2FzZSgpLGQ9XCJ0cmFuc3BhcmVudFwiPT09cj9cIiMwMDAwXCI6YVtyXTtyZXR1cm4gZD9uZXcgZShkKS50b1JnYigpOm51bGx9LFwibmFtZVwiXSl9XG4iLCJpbXBvcnQgeyBleHRlbmQsIGNvbG9yZCB9IGZyb20gJ0BwaXhpL2NvbG9yZCc7XG5pbXBvcnQgbmFtZXNQbHVnaW4gZnJvbSAnQHBpeGkvY29sb3JkL3BsdWdpbnMvbmFtZXMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuZChbbmFtZXNQbHVnaW5dKTtcbmNvbnN0IF9Db2xvciA9IGNsYXNzIF9Db2xvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbG9yU291cmNlfSB2YWx1ZSAtIE9wdGlvbmFsIHZhbHVlIHRvIHVzZSwgaWYgbm90IHByb3ZpZGVkLCB3aGl0ZSBpcyB1c2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUgPSAxNjc3NzIxNSkge1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICB0aGlzLl9jb21wb25lbnRzID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB0aGlzLl9jb21wb25lbnRzLmZpbGwoMSk7XG4gICAgdGhpcy5faW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBHZXQgcmVkIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCByZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMF07XG4gIH1cbiAgLyoqIEdldCBncmVlbiBjb21wb25lbnQgKDAgLSAxKSAqL1xuICBnZXQgZ3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMV07XG4gIH1cbiAgLyoqIEdldCBibHVlIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCBibHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzJdO1xuICB9XG4gIC8qKiBHZXQgYWxwaGEgY29tcG9uZW50ICgwIC0gMSkgKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzNdO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlLCBzdWl0YWJsZSBmb3IgY2hhaW5pbmdcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBzZWUgQ29sb3IudmFsdWVcbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBjb2xvciBzb3VyY2UuXG4gICAqXG4gICAqIFdoZW4gc2V0dGluZzpcbiAgICogLSBTZXR0aW5nIHRvIGFuIGluc3RhbmNlIG9mIGBDb2xvcmAgd2lsbCBjb3B5IGl0cyBjb2xvciBzb3VyY2UgYW5kIGNvbXBvbmVudHMuXG4gICAqIC0gT3RoZXJ3aXNlLCBgQ29sb3JgIHdpbGwgdHJ5IHRvIG5vcm1hbGl6ZSB0aGUgY29sb3Igc291cmNlIGFuZCBzZXQgdGhlIGNvbXBvbmVudHMuXG4gICAqICAgSWYgdGhlIGNvbG9yIHNvdXJjZSBpcyBpbnZhbGlkLCBhbiBgRXJyb3JgIHdpbGwgYmUgdGhyb3duIGFuZCB0aGUgYENvbG9yYCB3aWxsIGxlZnQgdW5jaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG51bGxgIGluIHRoZSBzZXR0ZXIncyBwYXJhbWV0ZXIgdHlwZSBpcyBhZGRlZCB0byBtYXRjaCB0aGUgVHlwZVNjcmlwdCBydWxlOiByZXR1cm4gdHlwZSBvZiBnZXR0ZXJcbiAgICogbXVzdCBiZSBhc3NpZ25hYmxlIHRvIGl0cyBzZXR0ZXIncyBwYXJhbWV0ZXIgdHlwZS4gU2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYCB3aWxsIHRocm93IGFuIGBFcnJvcmAuXG4gICAqXG4gICAqIFdoZW4gZ2V0dGluZzpcbiAgICogLSBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgbWVhbnMgdGhlIHByZXZpb3VzIHZhbHVlIHdhcyBvdmVycmlkZGVuIChlLmcuLCB7QGxpbmsgQ29sb3IubXVsdGlwbHkgbXVsdGlwbHl9LFxuICAgKiAgIHtAbGluayBDb2xvci5wcmVtdWx0aXBseSBwcmVtdWx0aXBseX0gb3Ige0BsaW5rIENvbG9yLnJvdW5kIHJvdW5kfSkuXG4gICAqIC0gT3RoZXJ3aXNlLCB0aGUgY29sb3Igc291cmNlIHVzZWQgd2hlbiBzZXR0aW5nIGlzIHJldHVybmVkLlxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX0NvbG9yKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2Nsb25lU291cmNlKHZhbHVlLl92YWx1ZSk7XG4gICAgICB0aGlzLl9pbnQgPSB2YWx1ZS5faW50O1xuICAgICAgdGhpcy5fY29tcG9uZW50cy5zZXQodmFsdWUuX2NvbXBvbmVudHMpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgQ29sb3IjdmFsdWUgdG8gbnVsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3ZhbHVlID09PSBudWxsIHx8ICF0aGlzLl9pc1NvdXJjZUVxdWFsKHRoaXMuX3ZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX25vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2Nsb25lU291cmNlKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ29weSBhIGNvbG9yIHNvdXJjZSBpbnRlcm5hbGx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBDb2xvciBzb3VyY2VcbiAgICovXG4gIF9jbG9uZVNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IC4uLnZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2sgZm9yIGNvbG9yIHNvdXJjZXMuXG4gICAqIEBwYXJhbSB2YWx1ZTEgLSBGaXJzdCBjb2xvciBzb3VyY2VcbiAgICogQHBhcmFtIHZhbHVlMiAtIFNlY29uZCBjb2xvciBzb3VyY2VcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb2xvciBzb3VyY2VzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBfaXNTb3VyY2VFcXVhbCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIGNvbnN0IHR5cGUxID0gdHlwZW9mIHZhbHVlMTtcbiAgICBjb25zdCB0eXBlMiA9IHR5cGVvZiB2YWx1ZTI7XG4gICAgaWYgKHR5cGUxICE9PSB0eXBlMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZTEgPT09IFwibnVtYmVyXCIgfHwgdHlwZTEgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUxIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTEpICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTIpKSB7XG4gICAgICBpZiAodmFsdWUxLmxlbmd0aCAhPT0gdmFsdWUyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSB2YWx1ZTJbaV0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUxICE9PSBudWxsICYmIHZhbHVlMiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyh2YWx1ZTEpO1xuICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyh2YWx1ZTIpO1xuICAgICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzMS5ldmVyeSgoa2V5KSA9PiB2YWx1ZTFba2V5XSA9PT0gdmFsdWUyW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBSR0JBIGNvbG9yIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvUmdiKCk7IC8vIHJldHVybnMgeyByOiAxLCBnOiAxLCBiOiAxLCBhOiAxIH1cbiAgICovXG4gIHRvUmdiYSgpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIFJHQiBjb2xvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcignd2hpdGUnKS50b1JnYigpOyAvLyByZXR1cm5zIHsgcjogMSwgZzogMSwgYjogMSB9XG4gICAqL1xuICB0b1JnYigpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB7IHIsIGcsIGIgfTtcbiAgfVxuICAvKiogQ29udmVydCB0byBhIENTUy1zdHlsZSByZ2JhIHN0cmluZzogYHJnYmEoMjU1LDI1NSwyNTUsMS4wKWAuICovXG4gIHRvUmdiYVN0cmluZygpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiBgcmdiYSgke3J9LCR7Z30sJHtifSwke3RoaXMuYWxwaGF9KWA7XG4gIH1cbiAgdG9VaW50OFJnYkFycmF5KG91dCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgaWYgKCF0aGlzLl9hcnJheVJnYikge1xuICAgICAgdGhpcy5fYXJyYXlSZ2IgPSBbXTtcbiAgICB9XG4gICAgb3V0ID0gb3V0IHx8IHRoaXMuX2FycmF5UmdiO1xuICAgIG91dFswXSA9IE1hdGgucm91bmQociAqIDI1NSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBvdXRbMl0gPSBNYXRoLnJvdW5kKGIgKiAyNTUpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9BcnJheShvdXQpIHtcbiAgICBpZiAoIXRoaXMuX2FycmF5UmdiYSkge1xuICAgICAgdGhpcy5fYXJyYXlSZ2JhID0gW107XG4gICAgfVxuICAgIG91dCA9IG91dCB8fCB0aGlzLl9hcnJheVJnYmE7XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICBvdXRbM10gPSBhO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9SZ2JBcnJheShvdXQpIHtcbiAgICBpZiAoIXRoaXMuX2FycmF5UmdiKSB7XG4gICAgICB0aGlzLl9hcnJheVJnYiA9IFtdO1xuICAgIH1cbiAgICBvdXQgPSBvdXQgfHwgdGhpcy5fYXJyYXlSZ2I7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoJ3doaXRlJykudG9OdW1iZXIoKTsgLy8gcmV0dXJucyAxNjc3NzIxNVxuICAgKi9cbiAgdG9OdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIEJHUiBudW1iZXJcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKDB4ZmZjYzk5KS50b0Jnck51bWJlcigpOyAvLyByZXR1cm5zIDB4OTljY2ZmXG4gICAqL1xuICB0b0Jnck51bWJlcigpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiAoYiA8PCAxNikgKyAoZyA8PCA4KSArIHI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBudW1iZXIgaW4gbGl0dGxlIGVuZGlhbiBmb3JtYXQgKGUuZy4sIEJCR0dSUikuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcigweGZmY2M5OSkudG9MaXR0bGVFbmRpYW5OdW1iZXIoKTsgLy8gcmV0dXJucyAweDk5Y2NmZlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjb2xvciBhcyBhIG51bWJlciBpbiBsaXR0bGUgZW5kaWFuIGZvcm1hdC5cbiAgICovXG4gIHRvTGl0dGxlRW5kaWFuTnVtYmVyKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5faW50O1xuICAgIHJldHVybiAodmFsdWUgPj4gMTYpICsgKHZhbHVlICYgNjUyODApICsgKCh2YWx1ZSAmIDI1NSkgPDwgMTYpO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSB3aXRoIGFub3RoZXIgY29sb3IuIFRoaXMgYWN0aW9uIGlzIGRlc3RydWN0aXZlLCBhbmQgd2lsbFxuICAgKiBvdmVycmlkZSB0aGUgcHJldmlvdXMgYHZhbHVlYCBwcm9wZXJ0eSB0byBiZSBgbnVsbGAuXG4gICAqIEBwYXJhbSB7Q29sb3JTb3VyY2V9IHZhbHVlIC0gVGhlIGNvbG9yIHRvIG11bHRpcGx5IGJ5LlxuICAgKi9cbiAgbXVsdGlwbHkodmFsdWUpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSBfQ29sb3IuX3RlbXAuc2V0VmFsdWUodmFsdWUpLl9jb21wb25lbnRzO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMF0gKj0gcjtcbiAgICB0aGlzLl9jb21wb25lbnRzWzFdICo9IGc7XG4gICAgdGhpcy5fY29tcG9uZW50c1syXSAqPSBiO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbM10gKj0gYTtcbiAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBjb2xvciB0byBhIHByZW11bHRpcGxpZWQgYWxwaGEgZm9ybWF0LiBUaGlzIGFjdGlvbiBpcyBkZXN0cnVjdGl2ZSwgYW5kIHdpbGxcbiAgICogb3ZlcnJpZGUgdGhlIHByZXZpb3VzIGB2YWx1ZWAgcHJvcGVydHkgdG8gYmUgYG51bGxgLlxuICAgKiBAcGFyYW0gYWxwaGEgLSBUaGUgYWxwaGEgdG8gbXVsdGlwbHkgYnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FwcGx5VG9SR0I9dHJ1ZV0gLSBXaGV0aGVyIHRvIHByZW11bHRpcGx5IFJHQiBjaGFubmVscy5cbiAgICogQHJldHVybnMge0NvbG9yfSAtIEl0c2VsZi5cbiAgICovXG4gIHByZW11bHRpcGx5KGFscGhhLCBhcHBseVRvUkdCID0gdHJ1ZSkge1xuICAgIGlmIChhcHBseVRvUkdCKSB7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzBdICo9IGFscGhhO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1sxXSAqPSBhbHBoYTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gKj0gYWxwaGE7XG4gICAgfVxuICAgIHRoaXMuX2NvbXBvbmVudHNbM10gPSBhbHBoYTtcbiAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQcmVtdWx0aXBsaWVzIGFscGhhIHdpdGggY3VycmVudCBjb2xvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIC0gVGhlIGFscGhhIHRvIG11bHRpcGx5IGJ5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcHBseVRvUkdCPXRydWVdIC0gV2hldGhlciB0byBwcmVtdWx0aXBseSBSR0IgY2hhbm5lbHMuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRpbnQgbXVsdGlwbGllZCBieSBhbHBoYVxuICAgKi9cbiAgdG9QcmVtdWx0aXBsaWVkKGFscGhhLCBhcHBseVRvUkdCID0gdHJ1ZSkge1xuICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgcmV0dXJuICgyNTUgPDwgMjQpICsgdGhpcy5faW50O1xuICAgIH1cbiAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgIHJldHVybiBhcHBseVRvUkdCID8gMCA6IHRoaXMuX2ludDtcbiAgICB9XG4gICAgbGV0IHIgPSB0aGlzLl9pbnQgPj4gMTYgJiAyNTU7XG4gICAgbGV0IGcgPSB0aGlzLl9pbnQgPj4gOCAmIDI1NTtcbiAgICBsZXQgYiA9IHRoaXMuX2ludCAmIDI1NTtcbiAgICBpZiAoYXBwbHlUb1JHQikge1xuICAgICAgciA9IHIgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgICBnID0gZyAqIGFscGhhICsgMC41IHwgMDtcbiAgICAgIGIgPSBiICogYWxwaGEgKyAwLjUgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gKGFscGhhICogMjU1IDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvSGV4KCk7IC8vIHJldHVybnMgXCIjZmZmZmZmXCJcbiAgICovXG4gIHRvSGV4KCkge1xuICAgIGNvbnN0IGhleFN0cmluZyA9IHRoaXMuX2ludC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGAjJHtcIjAwMDAwMFwiLnN1YnN0cmluZygwLCA2IC0gaGV4U3RyaW5nLmxlbmd0aCkgKyBoZXhTdHJpbmd9YDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyB3aXRoIGFscGhhLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoJ3doaXRlJykudG9IZXhhKCk7IC8vIHJldHVybnMgXCIjZmZmZmZmZmZcIlxuICAgKi9cbiAgdG9IZXhhKCkge1xuICAgIGNvbnN0IGFscGhhVmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMuX2NvbXBvbmVudHNbM10gKiAyNTUpO1xuICAgIGNvbnN0IGFscGhhU3RyaW5nID0gYWxwaGFWYWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKSArIFwiMDBcIi5zdWJzdHJpbmcoMCwgMiAtIGFscGhhU3RyaW5nLmxlbmd0aCkgKyBhbHBoYVN0cmluZztcbiAgfVxuICAvKipcbiAgICogU2V0IGFscGhhLCBzdWl0YWJsZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBwYXJhbSBhbHBoYVxuICAgKi9cbiAgc2V0QWxwaGEoYWxwaGEpIHtcbiAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gdGhpcy5fY2xhbXAoYWxwaGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgdGhlIGlucHV0IHZhbHVlIGludG8gcmdiYVxuICAgKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZVxuICAgKi9cbiAgX25vcm1hbGl6ZSh2YWx1ZSkge1xuICAgIGxldCByO1xuICAgIGxldCBnO1xuICAgIGxldCBiO1xuICAgIGxldCBhO1xuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDE2Nzc3MjE1KSB7XG4gICAgICBjb25zdCBpbnQgPSB2YWx1ZTtcbiAgICAgIHIgPSAoaW50ID4+IDE2ICYgMjU1KSAvIDI1NTtcbiAgICAgIGcgPSAoaW50ID4+IDggJiAyNTUpIC8gMjU1O1xuICAgICAgYiA9IChpbnQgJiAyNTUpIC8gMjU1O1xuICAgICAgYSA9IDE7XG4gICAgfSBlbHNlIGlmICgoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpICYmIHZhbHVlLmxlbmd0aCA+PSAzICYmIHZhbHVlLmxlbmd0aCA8PSA0KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX2NsYW1wKHZhbHVlKTtcbiAgICAgIFtyLCBnLCBiLCBhID0gMV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgJiYgdmFsdWUubGVuZ3RoID49IDMgJiYgdmFsdWUubGVuZ3RoIDw9IDQpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fY2xhbXAodmFsdWUsIDAsIDI1NSk7XG4gICAgICBbciwgZywgYiwgYSA9IDI1NV0gPSB2YWx1ZTtcbiAgICAgIHIgLz0gMjU1O1xuICAgICAgZyAvPSAyNTU7XG4gICAgICBiIC89IDI1NTtcbiAgICAgIGEgLz0gMjU1O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF9Db2xvci5IRVhfUEFUVEVSTi5leGVjKHZhbHVlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFsdWUgPSBgIyR7bWF0Y2hbMl19YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29sb3IgPSBjb2xvcmQodmFsdWUpO1xuICAgICAgaWYgKGNvbG9yLmlzVmFsaWQoKSkge1xuICAgICAgICAoeyByLCBnLCBiLCBhIH0gPSBjb2xvci5yZ2JhKTtcbiAgICAgICAgciAvPSAyNTU7XG4gICAgICAgIGcgLz0gMjU1O1xuICAgICAgICBiIC89IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY29tcG9uZW50c1swXSA9IHI7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzFdID0gZztcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gPSBiO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1szXSA9IGE7XG4gICAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgY29sb3IgJHt2YWx1ZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqIFJlZnJlc2ggdGhlIGludGVybmFsIGNvbG9yIHJnYiBudW1iZXIgKi9cbiAgX3JlZnJlc2hJbnQoKSB7XG4gICAgdGhpcy5fY2xhbXAodGhpcy5fY29tcG9uZW50cyk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB0aGlzLl9pbnQgPSAociAqIDI1NSA8PCAxNikgKyAoZyAqIDI1NSA8PCA4KSArIChiICogMjU1IHwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIENsYW1wcyB2YWx1ZXMgdG8gYSByYW5nZS4gV2lsbCBvdmVycmlkZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUocykgdG8gY2xhbXBcbiAgICogQHBhcmFtIG1pbiAtIE1pbmltdW0gdmFsdWVcbiAgICogQHBhcmFtIG1heCAtIE1heGltdW0gdmFsdWVcbiAgICovXG4gIF9jbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICB9XG4gICAgdmFsdWUuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgdmFsdWVbaV0gPSBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgY29sb3ItbGlrZSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBjb2xvci1saWtlIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIENvbG9yLmlzQ29sb3JMaWtlKCd3aGl0ZScpOyAvLyByZXR1cm5zIHRydWVcbiAgICogQ29sb3IuaXNDb2xvckxpa2UoMHhmZmZmZmYpOyAvLyByZXR1cm5zIHRydWVcbiAgICogQ29sb3IuaXNDb2xvckxpa2UoWzEsIDEsIDFdKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqL1xuICBzdGF0aWMgaXNDb2xvckxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIF9Db2xvciB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB2YWx1ZS5yICE9PSB2b2lkIDAgJiYgdmFsdWUuZyAhPT0gdm9pZCAwICYmIHZhbHVlLmIgIT09IHZvaWQgMCB8fCB2YWx1ZS5yICE9PSB2b2lkIDAgJiYgdmFsdWUuZyAhPT0gdm9pZCAwICYmIHZhbHVlLmIgIT09IHZvaWQgMCAmJiB2YWx1ZS5hICE9PSB2b2lkIDAgfHwgdmFsdWUuaCAhPT0gdm9pZCAwICYmIHZhbHVlLnMgIT09IHZvaWQgMCAmJiB2YWx1ZS5sICE9PSB2b2lkIDAgfHwgdmFsdWUuaCAhPT0gdm9pZCAwICYmIHZhbHVlLnMgIT09IHZvaWQgMCAmJiB2YWx1ZS5sICE9PSB2b2lkIDAgJiYgdmFsdWUuYSAhPT0gdm9pZCAwIHx8IHZhbHVlLmggIT09IHZvaWQgMCAmJiB2YWx1ZS5zICE9PSB2b2lkIDAgJiYgdmFsdWUudiAhPT0gdm9pZCAwIHx8IHZhbHVlLmggIT09IHZvaWQgMCAmJiB2YWx1ZS5zICE9PSB2b2lkIDAgJiYgdmFsdWUudiAhPT0gdm9pZCAwICYmIHZhbHVlLmEgIT09IHZvaWQgMDtcbiAgfVxufTtcbi8qKlxuICogRGVmYXVsdCBDb2xvciBvYmplY3QgZm9yIHN0YXRpYyB1c2VzXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAqIENvbG9yLnNoYXJlZC5zZXRWYWx1ZSgweGZmZmZmZikudG9IZXgoKTsgLy8gJyNmZmZmZmYnXG4gKi9cbl9Db2xvci5zaGFyZWQgPSBuZXcgX0NvbG9yKCk7XG4vKipcbiAqIFRlbXBvcmFyeSBDb2xvciBvYmplY3QgZm9yIHN0YXRpYyB1c2VzIGludGVybmFsbHkuXG4gKiBBcyB0byBub3QgY29uZmxpY3Qgd2l0aCBDb2xvci5zaGFyZWQuXG4gKiBAaWdub3JlXG4gKi9cbl9Db2xvci5fdGVtcCA9IG5ldyBfQ29sb3IoKTtcbi8qKiBQYXR0ZXJuIGZvciBoZXggc3RyaW5ncyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuX0NvbG9yLkhFWF9QQVRURVJOID0gL14oI3wweCk/KChbYS1mMC05XXszfSl7MSwyfShbYS1mMC05XXsyfSk/KSQvaTtcbmxldCBDb2xvciA9IF9Db2xvcjtcblxuZXhwb3J0IHsgQ29sb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8409\n')},3646:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  z: () => (/* binding */ DOMAdapter)\n});\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs\n\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement("canvas");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, "text/xml");\n  }\n};\n\n\n//# sourceMappingURL=BrowserAdapter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs\n\n\n"use strict";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\n\n//# sourceMappingURL=adapter.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY0Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQ3JCMkU7O0FBRTNFO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Vudmlyb25tZW50LWJyb3dzZXIvQnJvd3NlckFkYXB0ZXIubWpzPzczNzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzPzE5ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBCcm93c2VyQWRhcHRlciA9IHtcbiAgY3JlYXRlQ2FudmFzOiAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9LFxuICBnZXRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6ICgpID0+IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0OiAoKSA9PiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIGdldE5hdmlnYXRvcjogKCkgPT4gbmF2aWdhdG9yLFxuICBnZXRCYXNlVXJsOiAoKSA9PiBkb2N1bWVudC5iYXNlVVJJID8/IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICBnZXRGb250RmFjZVNldDogKCkgPT4gZG9jdW1lbnQuZm9udHMsXG4gIGZldGNoOiAodXJsLCBvcHRpb25zKSA9PiBmZXRjaCh1cmwsIG9wdGlvbnMpLFxuICBwYXJzZVhNTDogKHhtbCkgPT4ge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsIFwidGV4dC94bWxcIik7XG4gIH1cbn07XG5cbmV4cG9ydCB7IEJyb3dzZXJBZGFwdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyQWRhcHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBCcm93c2VyQWRhcHRlciB9IGZyb20gJy4uL2Vudmlyb25tZW50LWJyb3dzZXIvQnJvd3NlckFkYXB0ZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgY3VycmVudEFkYXB0ZXIgPSBCcm93c2VyQWRhcHRlcjtcbmNvbnN0IERPTUFkYXB0ZXIgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGFkYXB0ZXIuXG4gICAqIEByZXR1cm5zIHtlbnZpcm9ubWVudC5BZGFwdGVyfSBUaGUgY3VycmVudCBhZGFwdGVyLlxuICAgKi9cbiAgZ2V0KCkge1xuICAgIHJldHVybiBjdXJyZW50QWRhcHRlcjtcbiAgfSxcbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgYWRhcHRlci5cbiAgICogQHBhcmFtIGFkYXB0ZXIgLSBUaGUgbmV3IGFkYXB0ZXIuXG4gICAqL1xuICBzZXQoYWRhcHRlcikge1xuICAgIGN1cnJlbnRBZGFwdGVyID0gYWRhcHRlcjtcbiAgfVxufTtcblxuZXhwb3J0IHsgRE9NQWRhcHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3646\n')},4291:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   x: () => (/* binding */ FederatedEvent)\n/* harmony export */ });\n/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1134);\n\n\n"use strict";\nclass FederatedEvent {\n  /**\n   * @param manager - The event boundary which manages this event. Propagation can only occur\n   *  within the boundary\'s jurisdiction.\n   */\n  constructor(manager) {\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    this.bubbles = true;\n    /** @deprecated since 7.0.0 */\n    this.cancelBubble = true;\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    this.cancelable = false;\n    /**\n     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    this.composed = false;\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    this.defaultPrevented = false;\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    this.eventPhase = FederatedEvent.prototype.NONE;\n    /** Flags whether propagation was stopped. */\n    this.propagationStopped = false;\n    /** Flags whether propagation was immediately stopped. */\n    this.propagationImmediatelyStopped = false;\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    this.layer = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    this.page = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    this.NONE = 0;\n    this.CAPTURING_PHASE = 1;\n    this.AT_TARGET = 2;\n    this.BUBBLING_PHASE = 3;\n    this.manager = manager;\n  }\n  /** @readonly */\n  get layerX() {\n    return this.layer.x;\n  }\n  /** @readonly */\n  get layerY() {\n    return this.layer.y;\n  }\n  /** @readonly */\n  get pageX() {\n    return this.page.x;\n  }\n  /** @readonly */\n  get pageY() {\n    return this.page.y;\n  }\n  /**\n   * Fallback for the deprecated @code{InteractionEvent.data}.\n   * @deprecated since 7.0.0\n   */\n  get data() {\n    return this;\n  }\n  /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */\n  composedPath() {\n    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {\n      this.path = this.target ? this.manager.propagationPath(this.target) : [];\n    }\n    return this.path;\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.\n   * @deprecated\n   * @param _type\n   * @param _bubbles\n   * @param _cancelable\n   */\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.\n   * @deprecated\n   * @param _typeArg\n   * @param _bubblesArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   */\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  /** Prevent default behavior of PixiJS and the user agent. */\n  preventDefault() {\n    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n      this.nativeEvent.preventDefault();\n    }\n    this.defaultPrevented = true;\n  }\n  /**\n   * Stop this event from propagating to any addition listeners, including on the\n   * {@link FederatedEventTarget.currentTarget currentTarget} and also the following\n   * event targets on the propagation path.\n   */\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = true;\n  }\n  /**\n   * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners\n   * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\n\n//# sourceMappingURL=FederatedEvent.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI5MS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsb0NBQW9DO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBSztBQUMxQjtBQUNBLG9CQUFvQixrRUFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG9DQUFvQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxZQUFZLG9CQUFvQixZQUFZO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjLG9CQUFvQixZQUFZO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3REFBd0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDJCQUEyQjtBQUM5RSxhQUFhLHdEQUF3RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9ldmVudHMvRmVkZXJhdGVkRXZlbnQubWpzP2M0NzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEZlZGVyYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBtYW5hZ2VyIC0gVGhlIGV2ZW50IGJvdW5kYXJ5IHdoaWNoIG1hbmFnZXMgdGhpcyBldmVudC4gUHJvcGFnYXRpb24gY2FuIG9ubHkgb2NjdXJcbiAgICogIHdpdGhpbiB0aGUgYm91bmRhcnkncyBqdXJpc2RpY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgLyoqIEZsYWdzIHdoZXRoZXIgdGhpcyBldmVudCBidWJibGVzLiBUaGlzIHdpbGwgdGFrZSBlZmZlY3Qgb25seSBpZiBpdCBpcyBzZXQgYmVmb3JlIHByb3BhZ2F0aW9uLiAqL1xuICAgIHRoaXMuYnViYmxlcyA9IHRydWU7XG4gICAgLyoqIEBkZXByZWNhdGVkIHNpbmNlIDcuMC4wICovXG4gICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEZsYWdzIHdoZXRoZXIgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsZWQgdXNpbmcge0BsaW5rIEZlZGVyYXRlZEV2ZW50LnByZXZlbnREZWZhdWx0fS4gVGhpcyBpcyBhbHdheXNcbiAgICAgKiBmYWxzZSAoZm9yIG5vdykuXG4gICAgICovXG4gICAgdGhpcy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogRmxhZyBhZGRlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIERPTSB7QGNvZGUgRXZlbnR9LiBJdCBpcyBub3QgdXNlZCBpbiB0aGUgRmVkZXJhdGVkIEV2ZW50c1xuICAgICAqIEFQSS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWNvbXBvc2VkXG4gICAgICovXG4gICAgdGhpcy5jb21wb3NlZCA9IGZhbHNlO1xuICAgIC8qKiBGbGFncyB3aGV0aGVyIHRoZSBkZWZhdWx0IHJlc3BvbnNlIG9mIHRoZSB1c2VyIGFnZW50IHdhcyBwcmV2ZW50IHRocm91Z2ggdGhpcyBldmVudC4gKi9cbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvcGFnYXRpb24gcGhhc2UuXG4gICAgICogQGRlZmF1bHQge0BsaW5rIEZlZGVyYXRlZEV2ZW50Lk5PTkV9XG4gICAgICovXG4gICAgdGhpcy5ldmVudFBoYXNlID0gRmVkZXJhdGVkRXZlbnQucHJvdG90eXBlLk5PTkU7XG4gICAgLyoqIEZsYWdzIHdoZXRoZXIgcHJvcGFnYXRpb24gd2FzIHN0b3BwZWQuICovXG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICAvKiogRmxhZ3Mgd2hldGhlciBwcm9wYWdhdGlvbiB3YXMgaW1tZWRpYXRlbHkgc3RvcHBlZC4gKi9cbiAgICB0aGlzLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgLyoqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIG5lYXJlc3QgRE9NIGxheWVyLiBUaGlzIGlzIGEgbm9uLXN0YW5kYXJkIHByb3BlcnR5LiAqL1xuICAgIHRoaXMubGF5ZXIgPSBuZXcgUG9pbnQoKTtcbiAgICAvKiogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgRE9NIGRvY3VtZW50LiBUaGlzIGlzIGEgbm9uLXN0YW5kYXJkIHByb3BlcnR5LiAqL1xuICAgIHRoaXMucGFnZSA9IG5ldyBQb2ludCgpO1xuICAgIHRoaXMuTk9ORSA9IDA7XG4gICAgdGhpcy5DQVBUVVJJTkdfUEhBU0UgPSAxO1xuICAgIHRoaXMuQVRfVEFSR0VUID0gMjtcbiAgICB0aGlzLkJVQkJMSU5HX1BIQVNFID0gMztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGxheWVyWCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGxheWVyWSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci55O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IHBhZ2VYKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UueDtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBwYWdlWSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLnk7XG4gIH1cbiAgLyoqXG4gICAqIEZhbGxiYWNrIGZvciB0aGUgZGVwcmVjYXRlZCBAY29kZXtJbnRlcmFjdGlvbkV2ZW50LmRhdGF9LlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIFRoZSBwcm9wYWdhdGlvbiBwYXRoIGZvciB0aGlzIGV2ZW50LiBBbGlhcyBmb3Ige0BsaW5rIEV2ZW50Qm91bmRhcnkucHJvcGFnYXRpb25QYXRofS4gKi9cbiAgY29tcG9zZWRQYXRoKCkge1xuICAgIGlmICh0aGlzLm1hbmFnZXIgJiYgKCF0aGlzLnBhdGggfHwgdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSAhPT0gdGhpcy50YXJnZXQpKSB7XG4gICAgICB0aGlzLnBhdGggPSB0aGlzLnRhcmdldCA/IHRoaXMubWFuYWdlci5wcm9wYWdhdGlvblBhdGgodGhpcy50YXJnZXQpIDogW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW1wbGVtZW50ZWQgbWV0aG9kIGluY2x1ZGVkIGZvciBpbXBsZW1lbnRpbmcgdGhlIERPTSBpbnRlcmZhY2Uge0Bjb2RlIEV2ZW50fS4gSXQgd2lsbCB0aHJvdyBhbiB7QGNvZGUgRXJyb3J9LlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gX3R5cGVcbiAgICogQHBhcmFtIF9idWJibGVzXG4gICAqIEBwYXJhbSBfY2FuY2VsYWJsZVxuICAgKi9cbiAgaW5pdEV2ZW50KF90eXBlLCBfYnViYmxlcywgX2NhbmNlbGFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0RXZlbnQoKSBpcyBhIGxlZ2FjeSBET00gQVBJLiBJdCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIEZlZGVyYXRlZCBFdmVudHMgQVBJLlwiKTtcbiAgfVxuICAvKipcbiAgICogVW5pbXBsZW1lbnRlZCBtZXRob2QgaW5jbHVkZWQgZm9yIGltcGxlbWVudGluZyB0aGUgRE9NIGludGVyZmFjZSB7QGNvZGUgVUlFdmVudH0uIEl0IHdpbGwgdGhyb3cgYW4ge0Bjb2RlIEVycm9yfS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIF90eXBlQXJnXG4gICAqIEBwYXJhbSBfYnViYmxlc0FyZ1xuICAgKiBAcGFyYW0gX2NhbmNlbGFibGVBcmdcbiAgICogQHBhcmFtIF92aWV3QXJnXG4gICAqIEBwYXJhbSBfZGV0YWlsQXJnXG4gICAqL1xuICBpbml0VUlFdmVudChfdHlwZUFyZywgX2J1YmJsZXNBcmcsIF9jYW5jZWxhYmxlQXJnLCBfdmlld0FyZywgX2RldGFpbEFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImluaXRVSUV2ZW50KCkgaXMgYSBsZWdhY3kgRE9NIEFQSS4gSXQgaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSS5cIik7XG4gIH1cbiAgLyoqIFByZXZlbnQgZGVmYXVsdCBiZWhhdmlvciBvZiBQaXhpSlMgYW5kIHRoZSB1c2VyIGFnZW50LiAqL1xuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICBpZiAodGhpcy5uYXRpdmVFdmVudCBpbnN0YW5jZW9mIEV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5uYXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIHRoaXMgZXZlbnQgZnJvbSBwcm9wYWdhdGluZyB0byBhbnkgYWRkaXRpb24gbGlzdGVuZXJzLCBpbmNsdWRpbmcgb24gdGhlXG4gICAqIHtAbGluayBGZWRlcmF0ZWRFdmVudFRhcmdldC5jdXJyZW50VGFyZ2V0IGN1cnJlbnRUYXJnZXR9IGFuZCBhbHNvIHRoZSBmb2xsb3dpbmdcbiAgICogZXZlbnQgdGFyZ2V0cyBvbiB0aGUgcHJvcGFnYXRpb24gcGF0aC5cbiAgICovXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGlzIGV2ZW50IGZyb20gcHJvcGFnYXRpbmcgdG8gdGhlIG5leHQge0BsaW5rIEZlZGVyYXRlZEV2ZW50VGFyZ2V0fS4gVGhlIHJlc3Qgb2YgdGhlIGxpc3RlbmVyc1xuICAgKiBvbiB0aGUge0BsaW5rIEZlZGVyYXRlZEV2ZW50VGFyZ2V0LmN1cnJlbnRUYXJnZXQgY3VycmVudFRhcmdldH0gd2lsbCBzdGlsbCBiZSBub3RpZmllZC5cbiAgICovXG4gIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmVkZXJhdGVkRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZEV2ZW50Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4291\n')},3537:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   e: () => (/* binding */ FederatedMouseEvent)\n/* harmony export */ });\n/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1134);\n/* harmony import */ var _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4291);\n\n\n\n"use strict";\nclass FederatedMouseEvent extends _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_0__/* .FederatedEvent */ .x {\n  constructor() {\n    super(...arguments);\n    /** The coordinates of the mouse event relative to the canvas. */\n    this.client = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Point */ .E();\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    this.movement = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Point */ .E();\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    this.offset = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Point */ .E();\n    /** The pointer coordinates in world space. */\n    this.global = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Point */ .E();\n    /**\n     * The pointer coordinates in the renderer\'s {@link Renderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    this.screen = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Point */ .E();\n  }\n  /** @readonly */\n  get clientX() {\n    return this.client.x;\n  }\n  /** @readonly */\n  get clientY() {\n    return this.client.y;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n   * @readonly\n   */\n  get x() {\n    return this.clientX;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n   * @readonly\n   */\n  get y() {\n    return this.clientY;\n  }\n  /** @readonly */\n  get movementX() {\n    return this.movement.x;\n  }\n  /** @readonly */\n  get movementY() {\n    return this.movement.y;\n  }\n  /** @readonly */\n  get offsetX() {\n    return this.offset.x;\n  }\n  /** @readonly */\n  get offsetY() {\n    return this.offset.y;\n  }\n  /** @readonly */\n  get globalX() {\n    return this.global.x;\n  }\n  /** @readonly */\n  get globalY() {\n    return this.global.y;\n  }\n  /**\n   * The pointer coordinates in the renderer\'s screen. Alias for {@code screen.x}.\n   * @readonly\n   */\n  get screenX() {\n    return this.screen.x;\n  }\n  /**\n   * The pointer coordinates in the renderer\'s screen. Alias for {@code screen.y}.\n   * @readonly\n   */\n  get screenY() {\n    return this.screen.y;\n  }\n  /**\n   * This will return the local coordinates of the specified container for this InteractionData\n   * @param {Container} container - The Container that you would like the local\n   *  coords off\n   * @param {PointData} point - A Point object in which to store the value, optional (otherwise\n   *  will create a new point)\n   * @param {PointData} globalPos - A Point object containing your custom global coords, optional\n   *  (otherwise will use the current global coords)\n   * @returns - A point containing the coordinates of the InteractionData position relative\n   *  to the Container\n   */\n  getLocalPosition(container, point, globalPos) {\n    return container.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  /**\n   * Whether the modifier key was pressed when this event natively occurred.\n   * @param key - The modifier key.\n   */\n  getModifierState(key) {\n    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  /**\n   * Not supported.\n   * @param _typeArg\n   * @param _canBubbleArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   * @param _screenXArg\n   * @param _screenYArg\n   * @param _clientXArg\n   * @param _clientYArg\n   * @param _ctrlKeyArg\n   * @param _altKeyArg\n   * @param _shiftKeyArg\n   * @param _metaKeyArg\n   * @param _buttonArg\n   * @param _relatedTargetArg\n   * @deprecated since 7.0.0\n   */\n  // eslint-disable-next-line max-params\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error("Method not implemented.");\n  }\n}\n\n\n//# sourceMappingURL=FederatedMouseEvent.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUzNy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRDtBQUNLOztBQUV0RDtBQUNBLGtDQUFrQyx3RUFBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQUs7QUFDM0I7QUFDQSx3QkFBd0Isa0VBQUs7QUFDN0I7QUFDQSxzQkFBc0Isa0VBQUs7QUFDM0I7QUFDQSxzQkFBc0Isa0VBQUs7QUFDM0I7QUFDQSxrREFBa0QsNkJBQTZCO0FBQy9FO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBK0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL0ZlZGVyYXRlZE1vdXNlRXZlbnQubWpzPzBmMmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZEV2ZW50Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRmVkZXJhdGVkTW91c2VFdmVudCBleHRlbmRzIEZlZGVyYXRlZEV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKiogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZSBldmVudCByZWxhdGl2ZSB0byB0aGUgY2FudmFzLiAqL1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IFBvaW50KCk7XG4gICAgLyoqIFRoZSBtb3ZlbWVudCBpbiB0aGlzIHBvaW50ZXIgcmVsYXRpdmUgdG8gdGhlIGxhc3QgYG1vdXNlbW92ZWAgZXZlbnQuICovXG4gICAgdGhpcy5tb3ZlbWVudCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIHcuci50LiB0YXJnZXQgQ29udGFpbmVyIGluIHdvcmxkIHNwYWNlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC4gKi9cbiAgICB0aGlzLm9mZnNldCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKiBUaGUgcG9pbnRlciBjb29yZGluYXRlcyBpbiB3b3JsZCBzcGFjZS4gKi9cbiAgICB0aGlzLmdsb2JhbCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHtAbGluayBSZW5kZXJlci5zY3JlZW4gc2NyZWVufS4gVGhpcyBoYXMgc2xpZ2h0bHlcbiAgICAgKiBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gbmF0aXZlIFBvaW50ZXJFdmVudCBzY3JlZW5YL3NjcmVlblkuXG4gICAgICovXG4gICAgdGhpcy5zY3JlZW4gPSBuZXcgUG9pbnQoKTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBjbGllbnRYKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGNsaWVudFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lnk7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIGZvciB7QGxpbmsgRmVkZXJhdGVkTW91c2VFdmVudC5jbGllbnRYIHRoaXMuY2xpZW50WH0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50WDtcbiAgfVxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBGZWRlcmF0ZWRNb3VzZUV2ZW50LmNsaWVudFkgdGhpcy5jbGllbnRZfS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRZO1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG1vdmVtZW50WCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG1vdmVtZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC55O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG9mZnNldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0Lng7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgb2Zmc2V0WSgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQueTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBnbG9iYWxYKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGdsb2JhbFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHNjcmVlbi4gQWxpYXMgZm9yIHtAY29kZSBzY3JlZW4ueH0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlblgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLng7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHNjcmVlbi4gQWxpYXMgZm9yIHtAY29kZSBzY3JlZW4ueX0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlblkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBzcGVjaWZpZWQgY29udGFpbmVyIGZvciB0aGlzIEludGVyYWN0aW9uRGF0YVxuICAgKiBAcGFyYW0ge0NvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIENvbnRhaW5lciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSBsb2NhbFxuICAgKiAgY29vcmRzIG9mZlxuICAgKiBAcGFyYW0ge1BvaW50RGF0YX0gcG9pbnQgLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsIChvdGhlcndpc2VcbiAgICogIHdpbGwgY3JlYXRlIGEgbmV3IHBvaW50KVxuICAgKiBAcGFyYW0ge1BvaW50RGF0YX0gZ2xvYmFsUG9zIC0gQSBQb2ludCBvYmplY3QgY29udGFpbmluZyB5b3VyIGN1c3RvbSBnbG9iYWwgY29vcmRzLCBvcHRpb25hbFxuICAgKiAgKG90aGVyd2lzZSB3aWxsIHVzZSB0aGUgY3VycmVudCBnbG9iYWwgY29vcmRzKVxuICAgKiBAcmV0dXJucyAtIEEgcG9pbnQgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIEludGVyYWN0aW9uRGF0YSBwb3NpdGlvbiByZWxhdGl2ZVxuICAgKiAgdG8gdGhlIENvbnRhaW5lclxuICAgKi9cbiAgZ2V0TG9jYWxQb3NpdGlvbihjb250YWluZXIsIHBvaW50LCBnbG9iYWxQb3MpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShnbG9iYWxQb3MgfHwgdGhpcy5nbG9iYWwsIHBvaW50KTtcbiAgfVxuICAvKipcbiAgICogV2hldGhlciB0aGUgbW9kaWZpZXIga2V5IHdhcyBwcmVzc2VkIHdoZW4gdGhpcyBldmVudCBuYXRpdmVseSBvY2N1cnJlZC5cbiAgICogQHBhcmFtIGtleSAtIFRoZSBtb2RpZmllciBrZXkuXG4gICAqL1xuICBnZXRNb2RpZmllclN0YXRlKGtleSkge1xuICAgIHJldHVybiBcImdldE1vZGlmaWVyU3RhdGVcIiBpbiB0aGlzLm5hdGl2ZUV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBOb3Qgc3VwcG9ydGVkLlxuICAgKiBAcGFyYW0gX3R5cGVBcmdcbiAgICogQHBhcmFtIF9jYW5CdWJibGVBcmdcbiAgICogQHBhcmFtIF9jYW5jZWxhYmxlQXJnXG4gICAqIEBwYXJhbSBfdmlld0FyZ1xuICAgKiBAcGFyYW0gX2RldGFpbEFyZ1xuICAgKiBAcGFyYW0gX3NjcmVlblhBcmdcbiAgICogQHBhcmFtIF9zY3JlZW5ZQXJnXG4gICAqIEBwYXJhbSBfY2xpZW50WEFyZ1xuICAgKiBAcGFyYW0gX2NsaWVudFlBcmdcbiAgICogQHBhcmFtIF9jdHJsS2V5QXJnXG4gICAqIEBwYXJhbSBfYWx0S2V5QXJnXG4gICAqIEBwYXJhbSBfc2hpZnRLZXlBcmdcbiAgICogQHBhcmFtIF9tZXRhS2V5QXJnXG4gICAqIEBwYXJhbSBfYnV0dG9uQXJnXG4gICAqIEBwYXJhbSBfcmVsYXRlZFRhcmdldEFyZ1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgaW5pdE1vdXNlRXZlbnQoX3R5cGVBcmcsIF9jYW5CdWJibGVBcmcsIF9jYW5jZWxhYmxlQXJnLCBfdmlld0FyZywgX2RldGFpbEFyZywgX3NjcmVlblhBcmcsIF9zY3JlZW5ZQXJnLCBfY2xpZW50WEFyZywgX2NsaWVudFlBcmcsIF9jdHJsS2V5QXJnLCBfYWx0S2V5QXJnLCBfc2hpZnRLZXlBcmcsIF9tZXRhS2V5QXJnLCBfYnV0dG9uQXJnLCBfcmVsYXRlZFRhcmdldEFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZlZGVyYXRlZE1vdXNlRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZE1vdXNlRXZlbnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3537\n')},1265:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   n: () => (/* binding */ FederatedPointerEvent)\n/* harmony export */ });\n/* harmony import */ var _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3537);\n\n\n"use strict";\nclass FederatedPointerEvent extends _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__/* .FederatedMouseEvent */ .e {\n  constructor() {\n    super(...arguments);\n    /**\n     * The width of the pointer\'s contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    this.width = 0;\n    /**\n     * The height of the pointer\'s contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    this.height = 0;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    this.isPrimary = false;\n  }\n  // Only included for completeness for now\n  getCoalescedEvents() {\n    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {\n      return [this];\n    }\n    return [];\n  }\n  // Only included for completeness for now\n  getPredictedEvents() {\n    throw new Error("getPredictedEvents is not supported!");\n  }\n}\n\n\n//# sourceMappingURL=FederatedPointerEvent.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2NS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWdFOztBQUVoRTtBQUNBLG9DQUFvQyxrRkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanM/NTA4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRmVkZXJhdGVkUG9pbnRlckV2ZW50IGV4dGVuZHMgRmVkZXJhdGVkTW91c2VFdmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBwb2ludGVyJ3MgY29udGFjdCBhbG9uZyB0aGUgeC1heGlzLCBtZWFzdXJlZCBpbiBDU1MgcGl4ZWxzLlxuICAgICAqIHJhZGl1c1ggb2YgVG91Y2hFdmVudHMgd2lsbCBiZSByZXByZXNlbnRlZCBieSB0aGlzIHZhbHVlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BvaW50ZXJFdmVudC93aWR0aFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHBvaW50ZXIncyBjb250YWN0IGFsb25nIHRoZSB5LWF4aXMsIG1lYXN1cmVkIGluIENTUyBwaXhlbHMuXG4gICAgICogcmFkaXVzWSBvZiBUb3VjaEV2ZW50cyB3aWxsIGJlIHJlcHJlc2VudGVkIGJ5IHRoaXMgdmFsdWUuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L2hlaWdodFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIHBvaW50ZXIgZGV2aWNlIHRoYXQgY3JlYXRlZCB0aGUgZXZlbnQgaXMgdGhlIHByaW1hcnkgcG9pbnRlci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvaXNQcmltYXJ5XG4gICAgICovXG4gICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgfVxuICAvLyBPbmx5IGluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3MgZm9yIG5vd1xuICBnZXRDb2FsZXNjZWRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gXCJwb2ludGVybW92ZVwiIHx8IHRoaXMudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiB8fCB0aGlzLnR5cGUgPT09IFwidG91Y2htb3ZlXCIpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBPbmx5IGluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3MgZm9yIG5vd1xuICBnZXRQcmVkaWN0ZWRFdmVudHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0UHJlZGljdGVkRXZlbnRzIGlzIG5vdCBzdXBwb3J0ZWQhXCIpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZlZGVyYXRlZFBvaW50ZXJFdmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkUG9pbnRlckV2ZW50Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1265\n')},3489:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rw: () => (/* binding */ extensions),\n/* harmony export */   nw: () => (/* binding */ ExtensionType)\n/* harmony export */ });\n/* unused harmony export normalizeExtensionPriority */\n\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2["Application"] = "application";\n  ExtensionType2["WebGLPipes"] = "webgl-pipes";\n  ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";\n  ExtensionType2["WebGLSystem"] = "webgl-system";\n  ExtensionType2["WebGPUPipes"] = "webgpu-pipes";\n  ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";\n  ExtensionType2["WebGPUSystem"] = "webgpu-system";\n  ExtensionType2["CanvasSystem"] = "canvas-system";\n  ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";\n  ExtensionType2["CanvasPipes"] = "canvas-pipes";\n  ExtensionType2["Asset"] = "asset";\n  ExtensionType2["LoadParser"] = "load-parser";\n  ExtensionType2["ResolveParser"] = "resolve-parser";\n  ExtensionType2["CacheParser"] = "cache-parser";\n  ExtensionType2["DetectionParser"] = "detection-parser";\n  ExtensionType2["MaskEffect"] = "mask-effect";\n  ExtensionType2["BlendMode"] = "blend-mode";\n  ExtensionType2["TextureSource"] = "texture-source";\n  ExtensionType2["Environment"] = "environment";\n  ExtensionType2["ShapeBuilder"] = "shape-builder";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error("Extension class must have an extension object");\n    }\n    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === "object") {\n    ext = { ...ext };\n  } else {\n    throw new Error("Invalid extension type");\n  }\n  if (typeof ext.type === "string") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\n\n//# sourceMappingURL=Extensions.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ4OS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHNCQUFzQjtBQUNqRixZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDRCQUE0QjtBQUN4RyxtRkFBbUYsNEJBQTRCO0FBQy9HLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlFO0FBQ2pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanM/ZDdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBFeHRlbnNpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoRXh0ZW5zaW9uVHlwZTIpID0+IHtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJBcHBsaWNhdGlvblwiXSA9IFwiYXBwbGljYXRpb25cIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJXZWJHTFBpcGVzXCJdID0gXCJ3ZWJnbC1waXBlc1wiO1xuICBFeHRlbnNpb25UeXBlMltcIldlYkdMUGlwZXNBZGFwdG9yXCJdID0gXCJ3ZWJnbC1waXBlcy1hZGFwdG9yXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiV2ViR0xTeXN0ZW1cIl0gPSBcIndlYmdsLXN5c3RlbVwiO1xuICBFeHRlbnNpb25UeXBlMltcIldlYkdQVVBpcGVzXCJdID0gXCJ3ZWJncHUtcGlwZXNcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJXZWJHUFVQaXBlc0FkYXB0b3JcIl0gPSBcIndlYmdwdS1waXBlcy1hZGFwdG9yXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiV2ViR1BVU3lzdGVtXCJdID0gXCJ3ZWJncHUtc3lzdGVtXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FudmFzU3lzdGVtXCJdID0gXCJjYW52YXMtc3lzdGVtXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FudmFzUGlwZXNBZGFwdG9yXCJdID0gXCJjYW52YXMtcGlwZXMtYWRhcHRvclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkNhbnZhc1BpcGVzXCJdID0gXCJjYW52YXMtcGlwZXNcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJBc3NldFwiXSA9IFwiYXNzZXRcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJMb2FkUGFyc2VyXCJdID0gXCJsb2FkLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIlJlc29sdmVQYXJzZXJcIl0gPSBcInJlc29sdmUtcGFyc2VyXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FjaGVQYXJzZXJcIl0gPSBcImNhY2hlLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkRldGVjdGlvblBhcnNlclwiXSA9IFwiZGV0ZWN0aW9uLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIk1hc2tFZmZlY3RcIl0gPSBcIm1hc2stZWZmZWN0XCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQmxlbmRNb2RlXCJdID0gXCJibGVuZC1tb2RlXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiVGV4dHVyZVNvdXJjZVwiXSA9IFwidGV4dHVyZS1zb3VyY2VcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJFbnZpcm9ubWVudFwiXSA9IFwiZW52aXJvbm1lbnRcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJTaGFwZUJ1aWxkZXJcIl0gPSBcInNoYXBlLWJ1aWxkZXJcIjtcbiAgcmV0dXJuIEV4dGVuc2lvblR5cGUyO1xufSkoRXh0ZW5zaW9uVHlwZSB8fCB7fSk7XG5jb25zdCBub3JtYWxpemVFeHRlbnNpb24gPSAoZXh0KSA9PiB7XG4gIGlmICh0eXBlb2YgZXh0ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGV4dCA9PT0gXCJvYmplY3RcIiAmJiBleHQuZXh0ZW5zaW9uKSB7XG4gICAgaWYgKCFleHQuZXh0ZW5zaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gY2xhc3MgbXVzdCBoYXZlIGFuIGV4dGVuc2lvbiBvYmplY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0gdHlwZW9mIGV4dC5leHRlbnNpb24gIT09IFwib2JqZWN0XCIgPyB7IHR5cGU6IGV4dC5leHRlbnNpb24gfSA6IGV4dC5leHRlbnNpb247XG4gICAgZXh0ID0geyAuLi5tZXRhZGF0YSwgcmVmOiBleHQgfTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGV4dCA9IHsgLi4uZXh0IH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBleHRlbnNpb24gdHlwZVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXh0LnR5cGUgPSBbZXh0LnR5cGVdO1xuICB9XG4gIHJldHVybiBleHQ7XG59O1xuY29uc3Qgbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkgPSAoZXh0LCBkZWZhdWx0UHJpb3JpdHkpID0+IG5vcm1hbGl6ZUV4dGVuc2lvbihleHQpLnByaW9yaXR5ID8/IGRlZmF1bHRQcmlvcml0eTtcbmNvbnN0IGV4dGVuc2lvbnMgPSB7XG4gIC8qKiBAaWdub3JlICovXG4gIF9hZGRIYW5kbGVyczoge30sXG4gIC8qKiBAaWdub3JlICovXG4gIF9yZW1vdmVIYW5kbGVyczoge30sXG4gIC8qKiBAaWdub3JlICovXG4gIF9xdWV1ZToge30sXG4gIC8qKlxuICAgKiBSZW1vdmUgZXh0ZW5zaW9ucyBmcm9tIFBpeGlKUy5cbiAgICogQHBhcmFtIGV4dGVuc2lvbnMgLSBFeHRlbnNpb25zIHRvIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm5zIHtleHRlbnNpb25zfSBGb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZW1vdmUoLi4uZXh0ZW5zaW9uczIpIHtcbiAgICBleHRlbnNpb25zMi5tYXAobm9ybWFsaXplRXh0ZW5zaW9uKS5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgIGV4dC50eXBlLmZvckVhY2goKHR5cGUpID0+IHRoaXMuX3JlbW92ZUhhbmRsZXJzW3R5cGVdPy4oZXh0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBSZWdpc3RlciBuZXcgZXh0ZW5zaW9ucyB3aXRoIFBpeGlKUy5cbiAgICogQHBhcmFtIGV4dGVuc2lvbnMgLSBUaGUgc3ByZWFkIG9mIGV4dGVuc2lvbnMgdG8gYWRkIHRvIFBpeGlKUy5cbiAgICogQHJldHVybnMge2V4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZCguLi5leHRlbnNpb25zMikge1xuICAgIGV4dGVuc2lvbnMyLm1hcChub3JtYWxpemVFeHRlbnNpb24pLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgZXh0LnR5cGUuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgICAgICBpZiAoIWhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgcXVldWVbdHlwZV0gPSBxdWV1ZVt0eXBlXSB8fCBbXTtcbiAgICAgICAgICBxdWV1ZVt0eXBlXT8ucHVzaChleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzW3R5cGVdPy4oZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGV4dGVuc2lvbnMgYnkgbmFtZS5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgZXh0ZW5zaW9uIHR5cGUuXG4gICAqIEBwYXJhbSBvbkFkZCAgLSBGdW5jdGlvbiBoYW5kbGVyIHdoZW4gZXh0ZW5zaW9ucyBhcmUgYWRkZWQvcmVnaXN0ZXJlZCB7QGxpbmsgU3RyaWN0RXh0ZW5zaW9uRm9ybWF0fS5cbiAgICogQHBhcmFtIG9uUmVtb3ZlICAtIEZ1bmN0aW9uIGhhbmRsZXIgd2hlbiBleHRlbnNpb25zIGFyZSByZW1vdmVkL3VucmVnaXN0ZXJlZCB7QGxpbmsgU3RyaWN0RXh0ZW5zaW9uRm9ybWF0fS5cbiAgICogQHJldHVybnMge2V4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGhhbmRsZSh0eXBlLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBjb25zdCBhZGRIYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzO1xuICAgIGNvbnN0IHJlbW92ZUhhbmRsZXJzID0gdGhpcy5fcmVtb3ZlSGFuZGxlcnM7XG4gICAgaWYgKGFkZEhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4dGVuc2lvbiB0eXBlICR7dHlwZX0gYWxyZWFkeSBoYXMgYSBoYW5kbGVyYCk7XG4gICAgfVxuICAgIGFkZEhhbmRsZXJzW3R5cGVdID0gb25BZGQ7XG4gICAgcmVtb3ZlSGFuZGxlcnNbdHlwZV0gPSBvblJlbW92ZTtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGlmIChxdWV1ZVt0eXBlXSkge1xuICAgICAgcXVldWVbdHlwZV0/LmZvckVhY2goKGV4dCkgPT4gb25BZGQoZXh0KSk7XG4gICAgICBkZWxldGUgcXVldWVbdHlwZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogSGFuZGxlIGEgdHlwZSwgYnV0IHVzaW5nIGEgbWFwIGJ5IGBuYW1lYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHR5cGUgLSBUeXBlIG9mIGV4dGVuc2lvbiB0byBoYW5kbGUuXG4gICAqIEBwYXJhbSBtYXAgLSBUaGUgb2JqZWN0IG1hcCBvZiBuYW1lZCBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlNYXAodHlwZSwgbWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlKFxuICAgICAgdHlwZSxcbiAgICAgIChleHRlbnNpb24pID0+IHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5uYW1lKSB7XG4gICAgICAgICAgbWFwW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5yZWY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGlmIChleHRlbnNpb24ubmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSBtYXBbZXh0ZW5zaW9uLm5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfSxcbiAgLyoqXG4gICAqIEhhbmRsZSBhIHR5cGUsIGJ1dCB1c2luZyBhIGxpc3Qgb2YgZXh0ZW5zaW9ucyB3aXRoIGEgYG5hbWVgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gdHlwZSAtIFR5cGUgb2YgZXh0ZW5zaW9uIHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIG1hcCAtIFRoZSBhcnJheSBvZiBuYW1lZCBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gZGVmYXVsdFByaW9yaXR5IC0gRmFsbGJhY2sgcHJpb3JpdHkgaWYgbm9uZSBpcyBkZWZpbmVkLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlOYW1lZExpc3QodHlwZSwgbWFwLCBkZWZhdWx0UHJpb3JpdHkgPSAtMSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZShcbiAgICAgIHR5cGUsXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbWFwLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS5uYW1lID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFwLnB1c2goeyBuYW1lOiBleHRlbnNpb24ubmFtZSwgdmFsdWU6IGV4dGVuc2lvbi5yZWYgfSk7XG4gICAgICAgIG1hcC5zb3J0KChhLCBiKSA9PiBub3JtYWxpemVFeHRlbnNpb25Qcmlvcml0eShiLnZhbHVlLCBkZWZhdWx0UHJpb3JpdHkpIC0gbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkoYS52YWx1ZSwgZGVmYXVsdFByaW9yaXR5KSk7XG4gICAgICB9LFxuICAgICAgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IG1hcC5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0ubmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgbWFwLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9LFxuICAvKipcbiAgICogSGFuZGxlIGEgdHlwZSwgYnV0IHVzaW5nIGEgbGlzdCBvZiBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gdHlwZSAtIFR5cGUgb2YgZXh0ZW5zaW9uIHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIGxpc3QgLSBUaGUgbGlzdCBvZiBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gZGVmYXVsdFByaW9yaXR5IC0gVGhlIGRlZmF1bHQgcHJpb3JpdHkgdG8gdXNlIGlmIG5vbmUgaXMgc3BlY2lmaWVkLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlMaXN0KHR5cGUsIGxpc3QsIGRlZmF1bHRQcmlvcml0eSA9IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlKFxuICAgICAgdHlwZSxcbiAgICAgIChleHRlbnNpb24pID0+IHtcbiAgICAgICAgaWYgKGxpc3QuaW5jbHVkZXMoZXh0ZW5zaW9uLnJlZikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKGV4dGVuc2lvbi5yZWYpO1xuICAgICAgICBsaXN0LnNvcnQoKGEsIGIpID0+IG5vcm1hbGl6ZUV4dGVuc2lvblByaW9yaXR5KGIsIGRlZmF1bHRQcmlvcml0eSkgLSBub3JtYWxpemVFeHRlbnNpb25Qcmlvcml0eShhLCBkZWZhdWx0UHJpb3JpdHkpKTtcbiAgICAgIH0sXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdC5pbmRleE9mKGV4dGVuc2lvbi5yZWYpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucywgbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4dGVuc2lvbnMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3489\n')},6282:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U: () => (/* binding */ FilterEffect)\n/* harmony export */ });\n\nclass FilterEffect {\n  constructor() {\n    /** the pipe that knows how to handle this effect */\n    this.pipe = "filter";\n    /** the priority of this effect */\n    this.priority = 1;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\n\n//# sourceMappingURL=FilterEffect.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9GaWx0ZXJFZmZlY3QubWpzP2FkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBGaWx0ZXJFZmZlY3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogdGhlIHBpcGUgdGhhdCBrbm93cyBob3cgdG8gaGFuZGxlIHRoaXMgZWZmZWN0ICovXG4gICAgdGhpcy5waXBlID0gXCJmaWx0ZXJcIjtcbiAgICAvKiogdGhlIHByaW9yaXR5IG9mIHRoaXMgZWZmZWN0ICovXG4gICAgdGhpcy5wcmlvcml0eSA9IDE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5maWx0ZXJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5maWx0ZXJzID0gbnVsbDtcbiAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB7IEZpbHRlckVmZmVjdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyRWZmZWN0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6282\n')},15:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  MxU: () => (/* reexport */ Application),\n  W20: () => (/* reexport */ Container/* Container */.W2),\n  vpe: () => (/* reexport */ eventemitter3/* default */.Z),\n  nRP: () => (/* reexport */ FederatedPointerEvent/* FederatedPointerEvent */.n),\n  TCu: () => (/* reexport */ Graphics/* Graphics */.T),\n  E9j: () => (/* reexport */ Point/* Point */.E),\n  AeJ: () => (/* reexport */ Rectangle/* Rectangle */.A),\n  g4s: () => (/* reexport */ types/* RendererType */.g),\n  vB5: () => (/* reexport */ Ticker/* Ticker */.v),\n  DE6: () => (/* reexport */ sayHello/* sayHello */.D)\n});\n\n// UNUSED EXPORTS: AbstractBitmapFont, AbstractRenderer, AbstractText, AccessibilitySystem, AlphaFilter, AlphaMask, AlphaMaskPipe, AnimatedSprite, ApplicationInitHook, Assets, AssetsClass, BLEND_TO_NPM, BUFFER_TYPE, BackgroundLoader, BackgroundSystem, Batch, BatchGeometry, BatchTextureArray, BatchableGraphics, BatchableMesh, BatchableSprite, Batcher, BatcherPipe, BigPool, BindGroup, BindGroupSystem, BitmapFont, BitmapFontManager, BitmapText, BitmapTextPipe, BlendModeFilter, BlendModePipe, BlurFilter, BlurFilterPass, Bounds, BrowserAdapter, Buffer, BufferImageSource, BufferResource, BufferUsage, CLEAR, Cache, CanvasPool, CanvasPoolClass, CanvasSource, CanvasTextMetrics, CanvasTextPipe, CanvasTextSystem, Circle, Color, ColorBlend, ColorBurnBlend, ColorDodgeBlend, ColorMask, ColorMaskPipe, ColorMatrixFilter, CompressedSource, Culler, CullerPlugin, CustomRenderPipe, D3D10_RESOURCE_DIMENSION, D3DFMT, DATA_URI, DDS, DEG_TO_RAD, DEPRECATED_SCALE_MODES, DEPRECATED_WRAP_MODES, DOMAdapter, DRAW_MODES, DXGI_FORMAT, DXGI_TO_TEXTURE_FORMAT, DarkenBlend, DifferenceBlend, DisplacementFilter, DivideBlend, DynamicBitmapFont, Ellipse, EventBoundary, EventSystem, EventsTicker, ExclusionBlend, ExtensionType, ExtractSystem, FOURCC_TO_TEXTURE_FORMAT, FederatedContainer, FederatedEvent, FederatedMouseEvent, FederatedWheelEvent, FillGradient, FillPattern, Filter, FilterEffect, FilterPipe, FilterSystem, FontStylePromiseCache, GAUSSIAN_VALUES, GL_FORMATS, GL_INTERNAL_FORMAT, GL_TARGETS, GL_TYPES, GL_WRAP_MODES, GenerateTextureSystem, Geometry, GlBackBufferSystem, GlBatchAdaptor, GlBuffer, GlBufferSystem, GlColorMaskSystem, GlContextSystem, GlEncoderSystem, GlGeometrySystem, GlGraphicsAdaptor, GlMeshAdaptor, GlProgram, GlProgramData, GlRenderTarget, GlRenderTargetAdaptor, GlRenderTargetSystem, GlShaderSystem, GlStateSystem, GlStencilSystem, GlTexture, GlTextureSystem, GlUboSystem, GlUniformGroupSystem, GlobalUniformSystem, GpuBatchAdaptor, GpuBlendModesToPixi, GpuBufferSystem, GpuColorMaskSystem, GpuDeviceSystem, GpuEncoderSystem, GpuGraphicsAdaptor, GpuGraphicsContext, GpuMeshAdapter, GpuMipmapGenerator, GpuProgram, GpuReadBuffer, GpuRenderTarget, GpuRenderTargetAdaptor, GpuRenderTargetSystem, GpuShaderSystem, GpuStateSystem, GpuStencilModesToPixi, GpuStencilSystem, GpuTextureSystem, GpuUboSystem, GpuUniformBatchPipe, GraphicsContext, GraphicsContextRenderData, GraphicsContextSystem, GraphicsPath, GraphicsPipe, HTMLText, HTMLTextPipe, HTMLTextRenderData, HTMLTextStyle, HTMLTextSystem, HardLightBlend, HardMixBlend, HelloSystem, IGLUniformData, ImageSource, InstructionSet, KTX, LightenBlend, LinearBurnBlend, LinearDodgeBlend, LinearLightBlend, Loader, LoaderParserPriority, LuminosityBlend, MSAA_QUALITY, MaskEffectManager, MaskEffectManagerClass, MaskFilter, Matrix, Mesh, MeshGeometry, MeshPipe, MeshPlane, MeshRope, MeshSimple, NOOP, NegationBlend, NineSliceGeometry, NineSlicePlane, NineSliceSprite, NineSliceSpritePipe, NoiseFilter, ObservablePoint, OverlayBlend, PI_2, PerspectiveMesh, PerspectivePlaneGeometry, PinLightBlend, PipelineSystem, PlaneGeometry, Polygon, Pool, PoolGroupClass, PrepareBase, PrepareQueue, PrepareSystem, PrepareUpload, QuadGeometry, RAD_TO_DEG, RenderContainer, RenderGroup, RenderGroupPipe, RenderGroupSystem, RenderTarget, RenderTargetSystem, RenderTexture, RenderableGCSystem, RendererInitHook, ResizePlugin, Resolver, RopeGeometry, RoundedRectangle, SCALE_MODES, STENCIL_MODES, SVGParser, SVGToGraphicsPath, SaturationBlend, SchedulerSystem, ScissorMask, SdfShader, Shader, ShaderStage, ShapePath, SharedRenderPipes, SharedSystems, SoftLightBlend, Sprite, SpritePipe, Spritesheet, State, StencilMask, StencilMaskPipe, SubtractBlend, SystemRunner, TEXTURE_FORMAT_BLOCK_SIZE, Text, TextStyle, Texture, TextureGCSystem, TextureMatrix, TexturePool, TexturePoolClass, TextureSource, TextureStyle, TextureUvs, TickerListener, TickerPlugin, TilingSprite, TilingSpritePipe, TilingSpriteShader, Transform, Triangle, UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, UPDATE_BLEND, UPDATE_COLOR, UPDATE_PRIORITY, UPDATE_TRANSFORM, UPDATE_VISIBLE, UboBatch, UboSystem, UniformGroup, VERSION, VideoSource, ViewContainer, ViewSystem, ViewableBuffer, VividLightBlend, WGSL_ALIGN_SIZE_DATA, WGSL_TO_STD40_SIZE, WRAP_MODES, WebGLRenderer, WebGPURenderer, WebWorkerAdapter, WorkerManager, _getGlobalBounds, _getGlobalBoundsRecursive, accessibilityTarget, addBits, addMaskBounds, addMaskLocalBounds, addProgramDefines, alphaFrag, alphaWgsl, applyMatrix, applyProjectiveTransformationToPlane, applyStyleParams, assignWithIgnore, autoDetectEnvironment, autoDetectRenderer, autoDetectSource, basisTranscoderUrls, bitmapFontCachePlugin, bitmapFontTextParser, bitmapFontXMLParser, bitmapFontXMLStringParser, blendTemplateFrag, blendTemplateVert, blendTemplateWgsl, blockDataMap, blurTemplateWgsl, boundsPool, browserExt, buildAdaptiveBezier, buildAdaptiveQuadratic, buildArc, buildArcTo, buildArcToSvg, buildCircle, buildContextBatches, buildEllipse, buildGeometryFromPath, buildInstructions, buildLine, buildPolygon, buildRectangle, buildRoundedRectangle, buildSimpleUvs, buildTriangle, buildUvs, cacheTextureArray, calculateProjection, checkChildrenDidChange, checkDataUrl, checkExtension, checkMaxIfStatementsInShader, childrenHelperMixin, clearList, closePointEps, collectAllRenderables, collectRenderGroups, color32BitToUniform, colorBit, colorBitGl, colorMatrixFilterFrag, colorMatrixFilterWgsl, colorToUniform, compareModeToGlCompare, compileHighShader, compileHighShaderGl, compileHighShaderGlProgram, compileHighShaderGpuProgram, compileHooks, compileInputs, compileOutputs, compileShader, compute2DProjection, convertFormatIfRequired, convertToList, copySearchParams, createIdFromString, createLevelBuffers, createLevelBuffersFromKTX, createStringVariations, createTexture, createUboElementsSTD40, createUboElementsWGSL, createUboSyncFunction, createUboSyncFunctionSTD40, createUboSyncFunctionWGSL, crossOrigin, cullingMixin, curveEps, defaultFilterVert, defaultValue, definedProps, deprecation, detectAvif, detectBasis, detectCompressed, detectDefaults, detectMp4, detectOgv, detectVideoAlphaMode, detectWebm, detectWebp, determineCrossOrigin, displacementFrag, displacementVert, displacementWgsl, earcut, effectsMixin, ensureAttributes, ensureIsBuffer, ensureOptions, ensurePrecision, ensureTextStyle, executeInstructions, extensions, extractAttributesFromGlProgram, extractAttributesFromGpuProgram, extractFontFamilies, extractStructAndGroups, fastCopy, findHooksRx, findMixin, fontStringFromTextStyle, formatShader, fragmentGPUTemplate, fragmentGlTemplate, generateArraySyncSTD40, generateArraySyncWGSL, generateBlurFragSource, generateBlurGlProgram, generateBlurProgram, generateBlurVertSource, generateGPULayout, generateGpuLayoutGroups, generateLayout, generateLayoutHash, generateProgram, generateShaderSyncCode, generateTextStyleKey, generateTextureBatchBit, generateTextureBatchBitGl, generateUID, generateUniformsSync, getAdjustedBlendModeBlend, getAttributeInfoFromFormat, getBatchSamplersUniformGroup, getBitmapTextLayout, getCanvasBoundingBox, getCanvasFillStyle, getCanvasTexture, getDefaultUniformValue, getFastGlobalBounds, getFontCss, getFontFamilyName, getGeometryBounds, getGlTypeFromFormat, getGlobalBounds, getGlobalRenderableBounds, getLocalBounds, getMatrixRelativeToParent, getMaxFragmentPrecision, getMaxTexturesPerBatch, getOrientationOfPoints, getParent, getPo2TextureFromSource, getResolutionOfUrl, getSVGUrl, getSupportedCompressedTextureFormats, getSupportedGPUCompressedTextureFormats, getSupportedGlCompressedTextureFormats, getSupportedTextureFormats, getTemporaryCanvasFromImage, getTestContext, getTextureBatchBindGroup, getTextureDefaultMatrix, getTextureFormatFromKTXTexture, getUboData, getUniformData, getUrlExtension, glFormatToGPUFormat, glUploadBufferImageResource, glUploadCompressedTextureResource, glUploadImageResource, glUploadVideoResource, globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl, gpuFormatToBasisTranscoderFormat, gpuFormatToKTXBasisTranscoderFormat, gpuUploadBufferImageResource, gpuUploadCompressedTextureResource, gpuUploadImageResource, gpuUploadVideoResource, groupD8, hasCachedCanvasTexture, hslWgsl, hslgl, hslgpu, injectBits, insertVersion, isMobile, isPow2, isRenderingToScreen, isSafari, isSingleItem, isWebGLSupported, isWebGPUSupported, ktxTranscoderUrls, loadBasis, loadBasisOnWorker, loadBitmapFont, loadDDS, loadEnvironmentExtensions, loadFontAsBase64, loadFontCSS, loadImageBitmap, loadJson, loadKTX, loadKTX2, loadKTX2onWorker, loadSVGImage, loadSvg, loadTextures, loadTxt, loadVideoTextures, loadWebFont, localUniformBit, localUniformBitGl, localUniformBitGroup2, localUniformMSDFBit, localUniformMSDFBitGl, log2, logDebugTexture, logProgramError, logRenderGroupScene, logScene, mSDFBit, mSDFBitGl, mapFormatToGlFormat, mapFormatToGlInternalFormat, mapFormatToGlType, mapGlToVertexFormat, mapSize, mapType, mapWebGLBlendModesToPixi, maskFrag, maskVert, maskWgsl, matrixPool, measureHtmlText, measureMixin, migrateFragmentFromV7toV8, mipmapScaleModeToGlFilter, mixColors, mixHexColors, mixStandardAnd32BitColors, multiplyHexColors, nextPow2, noiseFrag, noiseWgsl, nonCompressedFormats, normalizeExtensionPriority, nssvg, nsxhtml, onRenderMixin, parseDDS, parseFunctionBody, parseKTX, path, pointInTriangle, preloadVideo, removeItems, removeStructAndGroupDuplicates, resetUids, resolveCharacters, resolveCompressedTextureUrl, resolveJsonUrl, resolveTextureUrl, resourceToTexture, roundPixelsBit, roundPixelsBitGl, roundedShapeArc, roundedShapeQuadraticCurve, scaleModeToGlFilter, setBasisTranscoderPath, setKTXTranscoderPath, setPositions, setProgramName, setUvs, shapeBuilders, sortMixin, spritesheetAsset, squaredDistanceToLineSegment, stripVersion, testImageFormat, testVideoFormat, textStyleToCSS, textureBit, textureBitGl, textureFrom, tilingBit, tilingBitGl, toFillStyle, toLocalGlobalMixin, toStrokeStyle, transformVertices, triangulateWithHoles, uboSyncFunctionsSTD40, uboSyncFunctionsWGSL, uid, uniformParsers, unpremultiplyAlpha, unsafeEvalSupported, updateLocalTransform, updateQuadBounds, updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren, updateTransformBackwards, updateWorldTransform, v8_0_0, validFormats, validateRenderables, vertexGPUTemplate, vertexGlTemplate, viewportFromFrame, vkFormatToGPUFormat, warn, webworkerExt, wrapModeToGlAddress\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-browser/browserExt.mjs\n\n\n"use strict";\nconst browserExt = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.Environment,\n    name: "browser",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(113), __webpack_require__.e(934)]).then(__webpack_require__.bind(__webpack_require__, 934));\n  }\n};\n\n\n//# sourceMappingURL=browserExt.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs\n\n\n"use strict";\nconst webworkerExt = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.Environment,\n    name: "webworker",\n    priority: 0\n  },\n  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(113), __webpack_require__.e(277)]).then(__webpack_require__.bind(__webpack_require__, 1277));\n  }\n};\n\n\n//# sourceMappingURL=webworkerExt.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/init.mjs + 7 modules\nvar init = __webpack_require__(9846);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/spritesheet/init.mjs + 8 modules\nvar spritesheet_init = __webpack_require__(342);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs + 1 modules\nvar AbstractRenderer = __webpack_require__(7400);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs\n\n\n\n"use strict";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer/* AbstractRenderer */.I.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!adapter/* DOMAdapter */.z.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = adapter/* DOMAdapter */.z.get().createCanvas();\n      let gl = canvas.getContext("webgl", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension("WEBGL_lose_context");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\n\n//# sourceMappingURL=isWebGLSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs\n\n\n"use strict";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = adapter/* DOMAdapter */.z.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\n\n//# sourceMappingURL=isWebGPUSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs\n\n\n\n\n"use strict";\nconst renderPriority = ["webgl", "webgpu", "canvas"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === "webgpu" && await isWebGPUSupported()) {\n      const { WebGPURenderer } = await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(294), __webpack_require__.e(45)]).then(__webpack_require__.bind(__webpack_require__, 7045));\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === "webgl" && isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer/* AbstractRenderer */.I.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(294), __webpack_require__.e(172)]).then(__webpack_require__.bind(__webpack_require__, 2172));\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === "canvas") {\n      finalOptions = { ...options };\n      throw new Error("CanvasRenderer is not yet implemented");\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  if (!RendererClass) {\n    throw new Error("No available renderer for the current environment");\n  }\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\n\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(8400);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/global/globalHooks.mjs\nvar globalHooks = __webpack_require__(6999);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/Application.mjs\n\n\n\n\n\n\n"use strict";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /** The root display container that\'s rendered. */\n    this.stage = new Container/* Container */.W2();\n    if (args[0] !== void 0) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Application constructor options are deprecated, please use Application.init() instead.");\n    }\n  }\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */\n  get view() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Application.view is deprecated, please use Application.canvas instead.");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer\'s screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */\n_Application._plugins = [];\nlet Application = _Application;\nExtensions/* extensions */.Rw.handleByList(Extensions/* ExtensionType */.nw.Application, Application._plugins);\nExtensions/* extensions */.Rw.add(globalHooks/* ApplicationInitHook */.l);\n\n\n//# sourceMappingURL=Application.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs\nvar FederatedPointerEvent = __webpack_require__(1265);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs\nvar textureFrom = __webpack_require__(4325);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nif (545 == __webpack_require__.j) {\nvar types = __webpack_require__(5765);\n}\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\nvar Graphics = __webpack_require__(6475);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(9366);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/sayHello.mjs\nif (545 == __webpack_require__.j) {\nvar sayHello = __webpack_require__(3921);\n}\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(browserExt, webworkerExt);\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxzS0FBMEI7QUFDcEM7QUFDQTs7QUFFc0I7QUFDdEI7OztBQ2hCNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSx1S0FBNEI7QUFDdEM7QUFDQTs7QUFFd0I7QUFDeEI7Ozs7Ozs7Ozs7O0FDaEIyRDtBQUNxQzs7QUFFaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx3Q0FBZ0I7QUFDcEY7QUFDQTtBQUNBLFdBQVcseUJBQVU7QUFDckI7QUFDQTtBQUNBLHFCQUFxQix5QkFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRTRCO0FBQzVCOzs7QUNwQzJEOztBQUUzRDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUN4QjRFO0FBQ0U7QUFDTjs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQsY0FBYyxpQkFBaUIsUUFBUSxzS0FBa0M7QUFDekU7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxNQUFNLHFDQUFxQyxnQkFBZ0I7QUFDM0QsOENBQThDLHdDQUFnQjtBQUM5RDtBQUNBLGNBQWMsZ0JBQWdCLFFBQVEsdUtBQWdDO0FBQ3RFO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCO0FBQzlCOzs7Ozs7Ozs7QUNsRHlFO0FBQ1U7QUFDdEI7QUFDUztBQUNDOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUFTO0FBQzlCO0FBQ0EsTUFBTSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBVSxjQUFjLGdDQUFhO0FBQ3JDLDZCQUFVLEtBQUssc0NBQW1COztBQUVYO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RmtFO0FBQ007QUFDZjtBQUMrQjtBQUMxRDtBQUNFO0FBQ0c7QUFDTztBQUNqQjtBQUNHO0FBQ0Q7QUFDYztBQUNaO0FBQ0k7QUFDUTtBQUNFO0FBQ2Y7QUFDSTtBQUNIO0FBQ0Y7QUFDRTtBQUNFO0FBQ0o7QUFDTTtBQUNMO0FBQ0Q7QUFDbUQ7QUFDQTtBQUNYO0FBQ1E7QUFDRTtBQUNSO0FBQ1E7QUFDUjtBQUNNO0FBQ0E7QUFDSjtBQUNBO0FBQ007QUFDRTtBQUNBO0FBQ0Y7QUFDSjtBQUNGO0FBQ0U7QUFDSTtBQUNGO0FBQ0Y7QUFDSTtBQUN6QjtBQUNFO0FBQ0E7QUFDSTtBQUNPO0FBQ2hCO0FBQ2dDO0FBQ1Q7QUFDUTtBQUNWO0FBQ0E7QUFDRTtBQUNBO0FBQ1E7QUFDQTtBQUM1QjtBQUM0QjtBQUNoQjtBQUNGO0FBQzJCO0FBQ2xCO0FBQzJCO0FBQzBDO0FBQ25EO0FBQ2Y7QUFDSTtBQUNNO0FBQ1Q7QUFDWjtBQUNJO0FBQ0Y7QUFDTTtBQUNZO0FBQ3BCO0FBQ3JCO0FBQ2dDO0FBQ0o7QUFDd0I7QUFDNEI7QUFDQztBQUM5QjtBQUN5RjtBQUN0SDtBQUNFO0FBQ0Y7QUFDRTtBQUNhO0FBQ1o7QUFDb0M7QUFDSTtBQUNVO0FBQ3RCO0FBQ2dDO0FBQ1g7QUFDckI7QUFDTDtBQUNMO0FBQ29DO0FBQzNFO0FBQ1k7QUFDQTtBQUNIO0FBQ29EO0FBQ2pDO0FBQ007QUFDckI7QUFDSjtBQUNDO0FBQ0s7QUFDVTtBQUNBO0FBQ0k7QUFDSjtBQUNzQjtBQUNBO0FBQ0E7QUFDckI7QUFDTztBQUNBO0FBQ2tCO0FBQ2E7QUFDQTtBQUNyQjtBQUNXO0FBQ0E7QUFDQTtBQUNyQjtBQUNBO0FBQ1o7QUFDQTtBQUNBO0FBQ1M7QUFDaEI7QUFDRTtBQUNTO0FBQ0g7QUFDUTtBQUNSO0FBQzJCO0FBQ0Y7QUFDRTtBQUNMO0FBQ0E7QUFDRTtBQUNyQjtBQUN6QjtBQUNZO0FBQ0o7QUFDSTtBQUNDO0FBQ047QUFDRjtBQUNtQjtBQUNQO0FBQzhCO0FBQ3pCO0FBQ3BCO0FBQ29CO0FBQ2pCO0FBQ0U7QUFDQTtBQUNJO0FBQ2M7QUFDaEI7QUFDQztBQUNFO0FBQ0U7QUFDQTtBQUNlO0FBQ2tDO0FBQ1o7QUFDZjtBQUNOO0FBQ29CO0FBQ2xCO0FBQ047QUFDQztBQUNJO0FBQ1E7QUFDNEM7QUFDakI7QUFDbkM7QUFDdUI7QUFDWDtBQUNFO0FBQ0o7QUFDSjtBQUMrRDtBQUMxRDtBQUM2QztBQUNNO0FBQ1A7QUFDMUI7QUFDWjtBQUM3QjtBQUNRO0FBQ1I7QUFDUTtBQUMwQjtBQUM1QjtBQUNBO0FBQ1E7QUFDTjtBQUNxQztBQUM1QjtBQUNWO0FBQ0E7QUFDWTtBQUN6QjtBQUM0QjtBQUNHO0FBQ1k7QUFDakI7QUFDRjtBQUNKO0FBQ0Y7QUFDRTtBQUNSO0FBQ2lDO0FBQ0Y7QUFDRjtBQUNZO0FBQ3RDO0FBQ3dCO0FBQ2Q7QUFDWTtBQUNVO0FBQ2hCO0FBQ0Y7QUFDUTtBQUM0QjtBQUM5QjtBQUNnQjtBQUNsQjtBQUNSO0FBQ1E7QUFDRTtBQUNoQjtBQUNxQjtBQUNhO0FBQ0o7QUFDSjtBQUNFO0FBQ0o7QUFDd0I7QUFDcEI7QUFDQTtBQUNKO0FBQ29DO0FBQ3pEO0FBQ3NCO0FBQ007QUFDbEM7QUFDWTtBQUNrQztBQUNZO0FBQ3hCO0FBQ0E7QUFDZDtBQUM0QztBQUN0QztBQUNnQjtBQUNwQjtBQUNxRTtBQUNuRTtBQUN4QjtBQUNLO0FBQ087QUFDSjtBQUNWO0FBQ2E7QUFDTjtBQUNFO0FBQ0E7QUFDUjtBQUNjO0FBQ0Q7QUFDYztBQUNSO0FBQ2M7QUFDRjtBQUM5QjtBQUNFO0FBQ1U7QUFDd0M7QUFDZDtBQUNZO0FBQ2xCO0FBQ0Y7QUFDSTtBQUNWO0FBQ3dCO0FBQzdCO0FBQ1Y7QUFDYztBQUNSO0FBQ2tDO0FBQzBCO0FBQ3hDO0FBQ0E7QUFDZ0M7QUFDMUM7QUFDdEI7QUFDa0I7QUFDTjtBQUNsQjtBQUNnQjtBQUNaO0FBQ007QUFDSztBQUNnQjtBQUMxQjtBQUNDO0FBQ3NCO0FBQ0o7QUFDd0I7QUFDbEI7QUFDQTtBQUNSO0FBQ1U7QUFDQTtBQUNkO0FBQ1k7QUFDRjtBQUNqQjtBQUNQO0FBQ0o7QUFDZ0M7QUFDMUI7QUFDTTtBQUN3QjtBQUNFO0FBQ2U7QUFDL0I7QUFDWDtBQUNRO0FBQ2tCO0FBQ3hDO0FBQ3VCO0FBQ2E7QUFDckI7QUFDYztBQUNvRDtBQUNyRDtBQUNWO0FBQ2dCO0FBQ1Y7QUFDUTtBQUNWO0FBQ0k7QUFDSjtBQUNoQjtBQUNnQjtBQUNKO0FBQ2M7QUFDaEI7QUFDSjtBQUNRO0FBQ2tDO0FBQ2dCO0FBQ0U7QUFDZjtBQUMvQjtBQUNGO0FBQ2Y7QUFDZjtBQUNGO0FBQ3FEO0FBQ1M7QUFDbkM7QUFDSztBQUNHO0FBQ0M7QUFDZDtBQUNOO0FBQ007QUFDRTtBQUNSO0FBQ2tCO0FBQzJCO0FBQ2hEO0FBQ0Y7QUFDUjtBQUNRO0FBQ0k7QUFDSTtBQUN5QjtBQUNiO0FBQzFCO0FBQ29CO0FBQ2Q7QUFDYztBQUNPO0FBQ3JCO0FBQ1U7QUFDTTtBQUNzRTtBQUN0RTtBQUNGO0FBQ1I7QUFDZ0I7QUFDYjtBQUNDO0FBQ2tCO0FBQ007QUFDNUI7QUFDSTtBQUNNO0FBQ2lDO0FBQ3pDO0FBQ007QUFDSTtBQUNGO0FBQ1o7QUFDQztBQUNGO0FBQ1g7QUFDYztBQUMyRDtBQUNqRTtBQUNLO0FBQzZCO0FBQ25DO0FBQ0Q7QUFDZ0I7QUFDcUI7QUFDWDtBQUNXO0FBQ1Q7QUFDSjtBQUNmO0FBQ2tCO0FBQzhCO0FBQ2pDO0FBQ2pDO0FBQ1E7QUFDVDtBQUNJO0FBQ0k7QUFDRjtBQUNHO0FBQ0M7QUFDb0I7QUFDdEM7QUFDZ0I7QUFDUjtBQUNnQjtBQUNRO0FBQ1k7QUFDUjtBQUNKO0FBQ0s7QUFDbkI7QUFDUTtBQUNKO0FBQ0U7QUFDQTtBQUNaO0FBQ0s7QUFDbEI7QUFDUTtBQUNxQjtBQUNVO0FBQ0Y7QUFDWTtBQUNDO0FBQ3JDO0FBQ2M7QUFDZDtBQUNRO0FBQ007QUFDVTtBQUNKO0FBQzFCO0FBQ1E7QUFDNEI7QUFDMUI7QUFDRTtBQUNnQjtBQUNLO0FBQ3pCO0FBQ29DO0FBQ3RCO0FBQ1Y7QUFDRTtBQUNNO0FBQ0Y7QUFDQTtBQUNFO0FBQ047QUFDSTtBQUNvQjtBQUNWO0FBQ3JCO0FBQ3VEO0FBQ3BDO0FBQ3ZDO0FBQ1U7QUFDa0I7QUFDVTtBQUNNO0FBQ25DO0FBQ007QUFDVTtBQUNqQjtBQUNSO0FBQ2dCO0FBQ21CO0FBQ3hCO0FBQ0E7QUFDZ0I7QUFDRTtBQUNJO0FBQ0M7QUFDbEM7QUFDVztBQUNHO0FBQ0w7QUFDZTtBQUNKO0FBQ3NCO0FBQ2pCO0FBQ0E7QUFDTztBQUM3QjtBQUNIO0FBQ1U7QUFDcUI7QUFDcEM7QUFDSztBQUN3QjtBQUNaO0FBQ2Q7O0FBRTNDO0FBQ0EsNkJBQVUsS0FBSyxVQUFVLEVBQUUsWUFBWTs7QUFFUztBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9lbnZpcm9ubWVudC1icm93c2VyL2Jyb3dzZXJFeHQubWpzP2QzYjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Vudmlyb25tZW50LXdlYndvcmtlci93ZWJ3b3JrZXJFeHQubWpzPzg4YjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2Jyb3dzZXIvaXNXZWJHTFN1cHBvcnRlZC5tanM/YzQxMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci9pc1dlYkdQVVN1cHBvcnRlZC5tanM/NTYwNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzPzU3NDMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9BcHBsaWNhdGlvbi5tanM/MjlhOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvaW5kZXgubWpzPzM2N2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJyb3dzZXJFeHQgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRW52aXJvbm1lbnQsXG4gICAgbmFtZTogXCJicm93c2VyXCIsXG4gICAgcHJpb3JpdHk6IC0xXG4gIH0sXG4gIHRlc3Q6ICgpID0+IHRydWUsXG4gIGxvYWQ6IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBpbXBvcnQoJy4vYnJvd3NlckFsbC5tanMnKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnJvd3NlckV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3NlckV4dC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3Qgd2Vid29ya2VyRXh0ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkVudmlyb25tZW50LFxuICAgIG5hbWU6IFwid2Vid29ya2VyXCIsXG4gICAgcHJpb3JpdHk6IDBcbiAgfSxcbiAgdGVzdDogKCkgPT4gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5Xb3JrZXJHbG9iYWxTY29wZSAhPT0gdm9pZCAwLFxuICBsb2FkOiBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgaW1wb3J0KCcuL3dlYndvcmtlckFsbC5tanMnKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgd2Vid29ya2VyRXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJ3b3JrZXJFeHQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IEFic3RyYWN0UmVuZGVyZXIgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zeXN0ZW0vQWJzdHJhY3RSZW5kZXJlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBfaXNXZWJHTFN1cHBvcnRlZDtcbmZ1bmN0aW9uIGlzV2ViR0xTdXBwb3J0ZWQoZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCkge1xuICBpZiAoX2lzV2ViR0xTdXBwb3J0ZWQgIT09IHZvaWQgMClcbiAgICByZXR1cm4gX2lzV2ViR0xTdXBwb3J0ZWQ7XG4gIF9pc1dlYkdMU3VwcG9ydGVkID0gKCgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID8/IEFic3RyYWN0UmVuZGVyZXIuZGVmYXVsdE9wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGlmICghRE9NQWRhcHRlci5nZXQoKS5nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgbGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICBjb25zdCBzdWNjZXNzID0gISFnbD8uZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKT8uc3RlbmNpbDtcbiAgICAgIGlmIChnbCkge1xuICAgICAgICBjb25zdCBsb3NlQ29udGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcbiAgICAgICAgaWYgKGxvc2VDb250ZXh0KSB7XG4gICAgICAgICAgbG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2wgPSBudWxsO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIF9pc1dlYkdMU3VwcG9ydGVkO1xufVxuXG5leHBvcnQgeyBpc1dlYkdMU3VwcG9ydGVkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1dlYkdMU3VwcG9ydGVkLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IF9pc1dlYkdQVVN1cHBvcnRlZDtcbmFzeW5jIGZ1bmN0aW9uIGlzV2ViR1BVU3VwcG9ydGVkKG9wdGlvbnMgPSB7fSkge1xuICBpZiAoX2lzV2ViR1BVU3VwcG9ydGVkICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIF9pc1dlYkdQVVN1cHBvcnRlZDtcbiAgX2lzV2ViR1BVU3VwcG9ydGVkID0gYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBncHUgPSBET01BZGFwdGVyLmdldCgpLmdldE5hdmlnYXRvcigpLmdwdTtcbiAgICBpZiAoIWdwdSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRhcHRlciA9IGF3YWl0IGdwdS5yZXF1ZXN0QWRhcHRlcihvcHRpb25zKTtcbiAgICAgIGF3YWl0IGFkYXB0ZXIucmVxdWVzdERldmljZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIF9pc1dlYkdQVVN1cHBvcnRlZDtcbn1cblxuZXhwb3J0IHsgaXNXZWJHUFVTdXBwb3J0ZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzV2ViR1BVU3VwcG9ydGVkLm1qcy5tYXBcbiIsImltcG9ydCB7IGlzV2ViR0xTdXBwb3J0ZWQgfSBmcm9tICcuLi8uLi91dGlscy9icm93c2VyL2lzV2ViR0xTdXBwb3J0ZWQubWpzJztcbmltcG9ydCB7IGlzV2ViR1BVU3VwcG9ydGVkIH0gZnJvbSAnLi4vLi4vdXRpbHMvYnJvd3Nlci9pc1dlYkdQVVN1cHBvcnRlZC5tanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RSZW5kZXJlciB9IGZyb20gJy4vc2hhcmVkL3N5c3RlbS9BYnN0cmFjdFJlbmRlcmVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgcmVuZGVyUHJpb3JpdHkgPSBbXCJ3ZWJnbFwiLCBcIndlYmdwdVwiLCBcImNhbnZhc1wiXTtcbmFzeW5jIGZ1bmN0aW9uIGF1dG9EZXRlY3RSZW5kZXJlcihvcHRpb25zKSB7XG4gIGxldCBwcmVmZXJyZWRPcmRlciA9IFtdO1xuICBpZiAob3B0aW9ucy5wcmVmZXJlbmNlKSB7XG4gICAgcHJlZmVycmVkT3JkZXIucHVzaChvcHRpb25zLnByZWZlcmVuY2UpO1xuICAgIHJlbmRlclByaW9yaXR5LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtICE9PSBvcHRpb25zLnByZWZlcmVuY2UpIHtcbiAgICAgICAgcHJlZmVycmVkT3JkZXIucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwcmVmZXJyZWRPcmRlciA9IHJlbmRlclByaW9yaXR5LnNsaWNlKCk7XG4gIH1cbiAgbGV0IFJlbmRlcmVyQ2xhc3M7XG4gIGxldCBmaW5hbE9wdGlvbnMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmZXJyZWRPcmRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IHByZWZlcnJlZE9yZGVyW2ldO1xuICAgIGlmIChyZW5kZXJlclR5cGUgPT09IFwid2ViZ3B1XCIgJiYgYXdhaXQgaXNXZWJHUFVTdXBwb3J0ZWQoKSkge1xuICAgICAgY29uc3QgeyBXZWJHUFVSZW5kZXJlciB9ID0gYXdhaXQgaW1wb3J0KCcuL2dwdS9XZWJHUFVSZW5kZXJlci5tanMnKTtcbiAgICAgIFJlbmRlcmVyQ2xhc3MgPSBXZWJHUFVSZW5kZXJlcjtcbiAgICAgIGZpbmFsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgLi4ub3B0aW9ucy53ZWJncHUgfTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocmVuZGVyZXJUeXBlID09PSBcIndlYmdsXCIgJiYgaXNXZWJHTFN1cHBvcnRlZChcbiAgICAgIG9wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA/PyBBYnN0cmFjdFJlbmRlcmVyLmRlZmF1bHRPcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXRcbiAgICApKSB7XG4gICAgICBjb25zdCB7IFdlYkdMUmVuZGVyZXIgfSA9IGF3YWl0IGltcG9ydCgnLi9nbC9XZWJHTFJlbmRlcmVyLm1qcycpO1xuICAgICAgUmVuZGVyZXJDbGFzcyA9IFdlYkdMUmVuZGVyZXI7XG4gICAgICBmaW5hbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIC4uLm9wdGlvbnMud2ViZ2wgfTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocmVuZGVyZXJUeXBlID09PSBcImNhbnZhc1wiKSB7XG4gICAgICBmaW5hbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhc1JlbmRlcmVyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICB9XG4gIGRlbGV0ZSBmaW5hbE9wdGlvbnMud2ViZ3B1O1xuICBkZWxldGUgZmluYWxPcHRpb25zLndlYmdsO1xuICBpZiAoIVJlbmRlcmVyQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdmFpbGFibGUgcmVuZGVyZXIgZm9yIHRoZSBjdXJyZW50IGVudmlyb25tZW50XCIpO1xuICB9XG4gIGNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyQ2xhc3MoKTtcbiAgYXdhaXQgcmVuZGVyZXIuaW5pdChmaW5hbE9wdGlvbnMpO1xuICByZXR1cm4gcmVuZGVyZXI7XG59XG5cbmV4cG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b0RldGVjdFJlbmRlcmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvYXV0b0RldGVjdFJlbmRlcmVyLm1qcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi9zY2VuZS9jb250YWluZXIvQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvbkluaXRIb29rIH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFsL2dsb2JhbEhvb2tzLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9BcHBsaWNhdGlvbiA9IGNsYXNzIF9BcHBsaWNhdGlvbiB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAvKiogVGhlIHJvb3QgZGlzcGxheSBjb250YWluZXIgdGhhdCdzIHJlbmRlcmVkLiAqL1xuICAgIHRoaXMuc3RhZ2UgPSBuZXcgQ29udGFpbmVyKCk7XG4gICAgaWYgKGFyZ3NbMF0gIT09IHZvaWQgMCkge1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkFwcGxpY2F0aW9uIGNvbnN0cnVjdG9yIG9wdGlvbnMgYXJlIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQXBwbGljYXRpb24uaW5pdCgpIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9uYWwgYXBwbGljYXRpb24gYW5kIHJlbmRlcmVyIHBhcmFtZXRlcnMuXG4gICAqL1xuICBhc3luYyBpbml0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5yZW5kZXJlciA9IGF3YWl0IGF1dG9EZXRlY3RSZW5kZXJlcihvcHRpb25zKTtcbiAgICBfQXBwbGljYXRpb24uX3BsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICBwbHVnaW4uaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBSZW5kZXIgdGhlIGN1cnJlbnQgc3RhZ2UuICovXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih7IGNvbnRhaW5lcjogdGhpcy5zdGFnZSB9KTtcbiAgfVxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlcidzIGNhbnZhcyBlbGVtZW50LlxuICAgKiBAcmVhZG9ubHlcbiAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqL1xuICBnZXQgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNhbnZhcztcbiAgfVxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlcidzIGNhbnZhcyBlbGVtZW50LlxuICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjBcbiAgICovXG4gIGdldCB2aWV3KCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJBcHBsaWNhdGlvbi52aWV3IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQXBwbGljYXRpb24uY2FudmFzIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNhbnZhcztcbiAgfVxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlcidzIHNjcmVlbiByZWN0YW5nbGUuIEl0cyBzYWZlIHRvIHVzZSBhcyBgZmlsdGVyQXJlYWAgb3IgYGhpdEFyZWFgIGZvciB0aGUgd2hvbGUgc2NyZWVuLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuc2NyZWVuO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgYXBwbGljYXRpb24gYW5kIGFsbCBvZiBpdHMgcmVzb3VyY2VzLlxuICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufVtyZW5kZXJlckRlc3Ryb3lPcHRpb25zPWZhbHNlXSAtIFRoZSBvcHRpb25zIGZvciBkZXN0cm95aW5nIHRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtib29sZWFufVtyZW5kZXJlckRlc3Ryb3lPcHRpb25zLnJlbW92ZVZpZXc9ZmFsc2VdIC0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9ucz1mYWxzZV0gLSBUaGUgb3B0aW9ucyBmb3IgZGVzdHJveWluZyB0aGUgc3RhZ2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gSWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyIGRlc3Ryb3kgbWV0aG9kXG4gICAqIGNhbGxlZCBhcyB3ZWxsLiBgb3B0aW9uc2Agd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkcmVuIHdpdGggdGV4dHVyZXMgZS5nLiBTcHJpdGVzLlxuICAgKiBJZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlLFxuICAgKiBpdCBzaG91bGQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIHRleHR1cmVzIGUuZy4gU3ByaXRlcy5cbiAgICogIElmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWUsXG4gICAqIGl0IHNob3VsZCBkZXN0cm95IHRoZSB0ZXh0dXJlIHNvdXJjZSBvZiB0aGUgY2hpbGQgc3ByaXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbnRleHQ9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIGdyYXBoaWNzQ29udGV4dHMgZS5nLiBHcmFwaGljcy5cbiAgICogSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSxcbiAgICogaXQgc2hvdWxkIGRlc3Ryb3kgdGhlIGNvbnRleHQgb2YgdGhlIGNoaWxkIGdyYXBoaWNzLlxuICAgKi9cbiAgZGVzdHJveShyZW5kZXJlckRlc3Ryb3lPcHRpb25zID0gZmFsc2UsIG9wdGlvbnMgPSBmYWxzZSkge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBfQXBwbGljYXRpb24uX3BsdWdpbnMuc2xpY2UoMCk7XG4gICAgcGx1Z2lucy5yZXZlcnNlKCk7XG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgIHBsdWdpbi5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfSk7XG4gICAgdGhpcy5zdGFnZS5kZXN0cm95KG9wdGlvbnMpO1xuICAgIHRoaXMuc3RhZ2UgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZXIuZGVzdHJveShyZW5kZXJlckRlc3Ryb3lPcHRpb25zKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufTtcbi8qKlxuICogQ29sbGVjdGlvbiBvZiBpbnN0YWxsZWQgcGx1Z2lucy5cbiAqIEBhbGlhcyBfcGx1Z2luc1xuICovXG5fQXBwbGljYXRpb24uX3BsdWdpbnMgPSBbXTtcbmxldCBBcHBsaWNhdGlvbiA9IF9BcHBsaWNhdGlvbjtcbmV4dGVuc2lvbnMuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuQXBwbGljYXRpb24sIEFwcGxpY2F0aW9uLl9wbHVnaW5zKTtcbmV4dGVuc2lvbnMuYWRkKEFwcGxpY2F0aW9uSW5pdEhvb2spO1xuXG5leHBvcnQgeyBBcHBsaWNhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwbGljYXRpb24ubWpzLm1hcFxuIiwiaW1wb3J0IHsgYnJvd3NlckV4dCB9IGZyb20gJy4vZW52aXJvbm1lbnQtYnJvd3Nlci9icm93c2VyRXh0Lm1qcyc7XG5pbXBvcnQgeyB3ZWJ3b3JrZXJFeHQgfSBmcm9tICcuL2Vudmlyb25tZW50LXdlYndvcmtlci93ZWJ3b3JrZXJFeHQubWpzJztcbmltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuZXhwb3J0IHsgRXh0ZW5zaW9uVHlwZSwgbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkgfSBmcm9tICcuL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0ICcuL3JlbmRlcmluZy9pbml0Lm1qcyc7XG5pbXBvcnQgJy4vc3ByaXRlc2hlZXQvaW5pdC5tanMnO1xuaW1wb3J0ICcuL2FjY2Vzc2liaWxpdHkvaW5kZXgubWpzJztcbmltcG9ydCAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2FwcC9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2Fzc2V0cy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2NvbG9yL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2N1bGxpbmcvaW5kZXgubWpzJztcbmltcG9ydCAnLi9lbnZpcm9ubWVudC9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2Vudmlyb25tZW50LWJyb3dzZXIvaW5kZXgubWpzJztcbmltcG9ydCAnLi9lbnZpcm9ubWVudC13ZWJ3b3JrZXIvaW5kZXgubWpzJztcbmltcG9ydCAnLi9ldmVudHMvaW5kZXgubWpzJztcbmltcG9ydCAnLi9leHRlbnNpb25zL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vZmlsdGVycy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL21hdGhzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vcHJlcGFyZS9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3JlbmRlcmluZy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3NjZW5lL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vc3ByaXRlc2hlZXQvaW5kZXgubWpzJztcbmltcG9ydCAnLi90aWNrZXIvaW5kZXgubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuZXhwb3J0IHsgQWNjZXNzaWJpbGl0eVN5c3RlbSB9IGZyb20gJy4vYWNjZXNzaWJpbGl0eS9BY2Nlc3NpYmlsaXR5U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBhY2Nlc3NpYmlsaXR5VGFyZ2V0IH0gZnJvbSAnLi9hY2Nlc3NpYmlsaXR5L2FjY2Vzc2liaWxpdHlUYXJnZXQubWpzJztcbmV4cG9ydCB7IENvbG9yQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0NvbG9yQmxlbmQubWpzJztcbmV4cG9ydCB7IENvbG9yQnVybkJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9Db2xvckJ1cm5CbGVuZC5tanMnO1xuZXhwb3J0IHsgQ29sb3JEb2RnZUJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9Db2xvckRvZGdlQmxlbmQubWpzJztcbmV4cG9ydCB7IERhcmtlbkJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9EYXJrZW5CbGVuZC5tanMnO1xuZXhwb3J0IHsgRGlmZmVyZW5jZUJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9EaWZmZXJlbmNlQmxlbmQubWpzJztcbmV4cG9ydCB7IERpdmlkZUJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9EaXZpZGVCbGVuZC5tanMnO1xuZXhwb3J0IHsgRXhjbHVzaW9uQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0V4Y2x1c2lvbkJsZW5kLm1qcyc7XG5leHBvcnQgeyBIYXJkTGlnaHRCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvSGFyZExpZ2h0QmxlbmQubWpzJztcbmV4cG9ydCB7IEhhcmRNaXhCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvSGFyZE1peEJsZW5kLm1qcyc7XG5leHBvcnQgeyBMaWdodGVuQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0xpZ2h0ZW5CbGVuZC5tanMnO1xuZXhwb3J0IHsgTGluZWFyQnVybkJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9MaW5lYXJCdXJuQmxlbmQubWpzJztcbmV4cG9ydCB7IExpbmVhckRvZGdlQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0xpbmVhckRvZGdlQmxlbmQubWpzJztcbmV4cG9ydCB7IExpbmVhckxpZ2h0QmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0xpbmVhckxpZ2h0QmxlbmQubWpzJztcbmV4cG9ydCB7IEx1bWlub3NpdHlCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvTHVtaW5vc2l0eUJsZW5kLm1qcyc7XG5leHBvcnQgeyBOZWdhdGlvbkJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9OZWdhdGlvbkJsZW5kLm1qcyc7XG5leHBvcnQgeyBPdmVybGF5QmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL092ZXJsYXlCbGVuZC5tanMnO1xuZXhwb3J0IHsgUGluTGlnaHRCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvUGluTGlnaHRCbGVuZC5tanMnO1xuZXhwb3J0IHsgU2F0dXJhdGlvbkJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9TYXR1cmF0aW9uQmxlbmQubWpzJztcbmV4cG9ydCB7IFNvZnRMaWdodEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9Tb2Z0TGlnaHRCbGVuZC5tanMnO1xuZXhwb3J0IHsgU3VidHJhY3RCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvU3VidHJhY3RCbGVuZC5tanMnO1xuZXhwb3J0IHsgVml2aWRMaWdodEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9WaXZpZExpZ2h0QmxlbmQubWpzJztcbmV4cG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSAnLi9hcHAvQXBwbGljYXRpb24ubWpzJztcbmV4cG9ydCB7IFJlc2l6ZVBsdWdpbiB9IGZyb20gJy4vYXBwL1Jlc2l6ZVBsdWdpbi5tanMnO1xuZXhwb3J0IHsgVGlja2VyUGx1Z2luIH0gZnJvbSAnLi9hcHAvVGlja2VyUGx1Z2luLm1qcyc7XG5leHBvcnQgeyBBc3NldHMsIEFzc2V0c0NsYXNzIH0gZnJvbSAnLi9hc3NldHMvQXNzZXRzLm1qcyc7XG5leHBvcnQgeyBCYWNrZ3JvdW5kTG9hZGVyIH0gZnJvbSAnLi9hc3NldHMvQmFja2dyb3VuZExvYWRlci5tanMnO1xuZXhwb3J0IHsgQ2FjaGUgfSBmcm9tICcuL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuZXhwb3J0IHsgY2FjaGVUZXh0dXJlQXJyYXkgfSBmcm9tICcuL2Fzc2V0cy9jYWNoZS9wYXJzZXJzL2NhY2hlVGV4dHVyZUFycmF5Lm1qcyc7XG5leHBvcnQgeyBkZXRlY3RBdmlmIH0gZnJvbSAnLi9hc3NldHMvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdEF2aWYubWpzJztcbmV4cG9ydCB7IGRldGVjdERlZmF1bHRzIH0gZnJvbSAnLi9hc3NldHMvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdERlZmF1bHRzLm1qcyc7XG5leHBvcnQgeyBkZXRlY3RNcDQgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0TXA0Lm1qcyc7XG5leHBvcnQgeyBkZXRlY3RPZ3YgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0T2d2Lm1qcyc7XG5leHBvcnQgeyBkZXRlY3RXZWJtIH0gZnJvbSAnLi9hc3NldHMvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYm0ubWpzJztcbmV4cG9ydCB7IGRldGVjdFdlYnAgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0V2VicC5tanMnO1xuZXhwb3J0IHsgdGVzdEltYWdlRm9ybWF0IH0gZnJvbSAnLi9hc3NldHMvZGV0ZWN0aW9ucy91dGlscy90ZXN0SW1hZ2VGb3JtYXQubWpzJztcbmV4cG9ydCB7IHRlc3RWaWRlb0Zvcm1hdCB9IGZyb20gJy4vYXNzZXRzL2RldGVjdGlvbnMvdXRpbHMvdGVzdFZpZGVvRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL2Fzc2V0cy9sb2FkZXIvTG9hZGVyLm1qcyc7XG5leHBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9wYXJzZXJzL0xvYWRlclBhcnNlci5tanMnO1xuZXhwb3J0IHsgbG9hZEpzb24gfSBmcm9tICcuL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy9sb2FkSnNvbi5tanMnO1xuZXhwb3J0IHsgbG9hZFR4dCB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9wYXJzZXJzL2xvYWRUeHQubWpzJztcbmV4cG9ydCB7IGdldEZvbnRGYW1pbHlOYW1lLCBsb2FkV2ViRm9udCB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9wYXJzZXJzL2xvYWRXZWJGb250Lm1qcyc7XG5leHBvcnQgeyBsb2FkU3ZnIH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFNWRy5tanMnO1xuZXhwb3J0IHsgbG9hZEltYWdlQml0bWFwLCBsb2FkVGV4dHVyZXMgfSBmcm9tICcuL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkVGV4dHVyZXMubWpzJztcbmV4cG9ydCB7IGNyb3NzT3JpZ2luLCBkZXRlcm1pbmVDcm9zc09yaWdpbiwgbG9hZFZpZGVvVGV4dHVyZXMsIHByZWxvYWRWaWRlbyB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRWaWRlb1RleHR1cmVzLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVUZXh0dXJlIH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvdXRpbHMvY3JlYXRlVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgV29ya2VyTWFuYWdlciB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci93b3JrZXJzL1dvcmtlck1hbmFnZXIubWpzJztcbmV4cG9ydCB7IHJlc29sdmVKc29uVXJsIH0gZnJvbSAnLi9hc3NldHMvcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlSnNvblVybC5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZVRleHR1cmVVcmwgfSBmcm9tICcuL2Fzc2V0cy9yZXNvbHZlci9wYXJzZXJzL3Jlc29sdmVUZXh0dXJlVXJsLm1qcyc7XG5leHBvcnQgeyBSZXNvbHZlciwgZ2V0VXJsRXh0ZW5zaW9uIH0gZnJvbSAnLi9hc3NldHMvcmVzb2x2ZXIvUmVzb2x2ZXIubWpzJztcbmV4cG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gJy4vYXNzZXRzL3V0aWxzL2NoZWNrRGF0YVVybC5tanMnO1xuZXhwb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuL2Fzc2V0cy91dGlscy9jaGVja0V4dGVuc2lvbi5tanMnO1xuZXhwb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4vYXNzZXRzL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzJztcbmV4cG9ydCB7IGNvcHlTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2Fzc2V0cy91dGlscy9jb3B5U2VhcmNoUGFyYW1zLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zIH0gZnJvbSAnLi9hc3NldHMvdXRpbHMvY3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5tanMnO1xuZXhwb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSAnLi9hc3NldHMvdXRpbHMvaXNTaW5nbGVJdGVtLm1qcyc7XG5leHBvcnQgeyBDb2xvciB9IGZyb20gJy4vY29sb3IvQ29sb3IubWpzJztcbmV4cG9ydCB7IGRldGVjdEJhc2lzIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Jhc2lzL2RldGVjdEJhc2lzLm1qcyc7XG5leHBvcnQgeyBsb2FkQmFzaXMgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMvYmFzaXMvbG9hZEJhc2lzLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVMZXZlbEJ1ZmZlcnMgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMvYmFzaXMvdXRpbHMvY3JlYXRlTGV2ZWxCdWZmZXJzLm1qcyc7XG5leHBvcnQgeyBncHVGb3JtYXRUb0Jhc2lzVHJhbnNjb2RlckZvcm1hdCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9iYXNpcy91dGlscy9ncHVGb3JtYXRUb0Jhc2lzVHJhbnNjb2RlckZvcm1hdC5tanMnO1xuZXhwb3J0IHsgYmFzaXNUcmFuc2NvZGVyVXJscywgc2V0QmFzaXNUcmFuc2NvZGVyUGF0aCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9iYXNpcy91dGlscy9zZXRCYXNpc1RyYW5zY29kZXJQYXRoLm1qcyc7XG5leHBvcnQgeyBsb2FkQmFzaXNPbldvcmtlciB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9iYXNpcy93b3JrZXIvbG9hZEJhc2lzT25Xb3JrZXIubWpzJztcbmV4cG9ydCB7IEQzRDEwX1JFU09VUkNFX0RJTUVOU0lPTiwgRDNERk1ULCBERFMsIERYR0lfRk9STUFULCBEWEdJX1RPX1RFWFRVUkVfRk9STUFULCBGT1VSQ0NfVE9fVEVYVFVSRV9GT1JNQVQsIFRFWFRVUkVfRk9STUFUX0JMT0NLX1NJWkUgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMvZGRzL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBsb2FkRERTIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Rkcy9sb2FkRERTLm1qcyc7XG5leHBvcnQgeyBwYXJzZUREUyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9kZHMvcGFyc2VERFMubWpzJztcbmV4cG9ydCB7IGxvYWRLVFggfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4L2xvYWRLVFgubWpzJztcbmV4cG9ydCB7IHBhcnNlS1RYIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eC9wYXJzZUtUWC5tanMnO1xuZXhwb3J0IHsgR0xfSU5URVJOQUxfRk9STUFULCBLVFggfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi9jb25zdC5tanMnO1xuZXhwb3J0IHsgbG9hZEtUWDIgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi9sb2FkS1RYMi5tanMnO1xuZXhwb3J0IHsgY29udmVydEZvcm1hdElmUmVxdWlyZWQgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi91dGlscy9jb252ZXJ0Rm9ybWF0SWZSZXF1aXJlZC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlTGV2ZWxCdWZmZXJzRnJvbUtUWCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2NyZWF0ZUxldmVsQnVmZmVyc0Zyb21LVFgubWpzJztcbmV4cG9ydCB7IGdldFRleHR1cmVGb3JtYXRGcm9tS1RYVGV4dHVyZSB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2dldFRleHR1cmVGb3JtYXRGcm9tS1RYVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgZ2xGb3JtYXRUb0dQVUZvcm1hdCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2dsRm9ybWF0VG9HUFVGb3JtYXQubWpzJztcbmV4cG9ydCB7IGdwdUZvcm1hdFRvS1RYQmFzaXNUcmFuc2NvZGVyRm9ybWF0IH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eDIvdXRpbHMvZ3B1Rm9ybWF0VG9LVFhCYXNpc1RyYW5zY29kZXJGb3JtYXQubWpzJztcbmV4cG9ydCB7IGt0eFRyYW5zY29kZXJVcmxzLCBzZXRLVFhUcmFuc2NvZGVyUGF0aCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL3NldEtUWFRyYW5zY29kZXJQYXRoLm1qcyc7XG5leHBvcnQgeyB2a0Zvcm1hdFRvR1BVRm9ybWF0IH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eDIvdXRpbHMvdmtGb3JtYXRUb0dQVUZvcm1hdC5tanMnO1xuZXhwb3J0IHsgbG9hZEtUWDJvbldvcmtlciB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3dvcmtlci9sb2FkS1RYMm9uV29ya2VyLm1qcyc7XG5leHBvcnQgeyBkZXRlY3RDb21wcmVzc2VkIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL3NoYXJlZC9kZXRlY3RDb21wcmVzc2VkLm1qcyc7XG5leHBvcnQgeyByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwsIHZhbGlkRm9ybWF0cyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9zaGFyZWQvcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLm1qcyc7XG5leHBvcnQgeyBDdWxsZXIgfSBmcm9tICcuL2N1bGxpbmcvQ3VsbGVyLm1qcyc7XG5leHBvcnQgeyBDdWxsZXJQbHVnaW4gfSBmcm9tICcuL2N1bGxpbmcvQ3VsbGVyUGx1Z2luLm1qcyc7XG5leHBvcnQgeyBjdWxsaW5nTWl4aW4gfSBmcm9tICcuL2N1bGxpbmcvY3VsbGluZ01peGluLm1qcyc7XG5leHBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5leHBvcnQgeyBhdXRvRGV0ZWN0RW52aXJvbm1lbnQsIGxvYWRFbnZpcm9ubWVudEV4dGVuc2lvbnMgfSBmcm9tICcuL2Vudmlyb25tZW50L2F1dG9EZXRlY3RFbnZpcm9ubWVudC5tanMnO1xuZXhwb3J0IHsgQnJvd3NlckFkYXB0ZXIgfSBmcm9tICcuL2Vudmlyb25tZW50LWJyb3dzZXIvQnJvd3NlckFkYXB0ZXIubWpzJztcbmV4cG9ydCB7IFdlYldvcmtlckFkYXB0ZXIgfSBmcm9tICcuL2Vudmlyb25tZW50LXdlYndvcmtlci9XZWJXb3JrZXJBZGFwdGVyLm1qcyc7XG5leHBvcnQgeyBFdmVudEJvdW5kYXJ5IH0gZnJvbSAnLi9ldmVudHMvRXZlbnRCb3VuZGFyeS5tanMnO1xuZXhwb3J0IHsgRXZlbnRTeXN0ZW0gfSBmcm9tICcuL2V2ZW50cy9FdmVudFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgRXZlbnRzVGlja2VyIH0gZnJvbSAnLi9ldmVudHMvRXZlbnRUaWNrZXIubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkRXZlbnQubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZENvbnRhaW5lciB9IGZyb20gJy4vZXZlbnRzL0ZlZGVyYXRlZEV2ZW50VGFyZ2V0Lm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkTW91c2VFdmVudC5tanMnO1xuZXhwb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkUG9pbnRlckV2ZW50Lm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWRXaGVlbEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBibGVuZFRlbXBsYXRlRnJhZyB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9ibGVuZC10ZW1wbGF0ZS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJsZW5kVGVtcGxhdGVWZXJ0IH0gZnJvbSAnLi9maWx0ZXJzL2JsZW5kLW1vZGVzL2JsZW5kLXRlbXBsYXRlLnZlcnQubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYmxlbmRUZW1wbGF0ZVdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvYmxlbmQtbW9kZXMvYmxlbmQtdGVtcGxhdGUud2dzbC5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoc2xXZ3NsIH0gZnJvbSAnLi9maWx0ZXJzL2JsZW5kLW1vZGVzL2hzbC53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFscGhhRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9hbHBoYS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFscGhhV2dzbCB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9hbHBoYS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJsdXJUZW1wbGF0ZVdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvYmx1ci9ncHUvYmx1ci10ZW1wbGF0ZS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbG9yTWF0cml4RmlsdGVyRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9jb2xvci1tYXRyaXgvY29sb3JNYXRyaXhGaWx0ZXIuZnJhZy5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb2xvck1hdHJpeEZpbHRlcldnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvY29sb3ItbWF0cml4L2NvbG9yTWF0cml4RmlsdGVyLndnc2wubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdEZpbHRlclZlcnQgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGVmYXVsdEZpbHRlci52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudEZyYWcgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudFZlcnQgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudFdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vaXNlRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9ub2lzZS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vaXNlV2dzbCB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9ub2lzZS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tGcmFnIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tWZXJ0IH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tXZ3NsIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay53Z3NsLm1qcyc7XG5leHBvcnQgeyBCbGVuZE1vZGVGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcnMvYmxlbmQtbW9kZXMvQmxlbmRNb2RlRmlsdGVyLm1qcyc7XG5leHBvcnQgeyBoc2xnbCB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9obHMvR0xobHMubWpzJztcbmV4cG9ydCB7IGhzbGdwdSB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9obHMvR1BVaGxzLm1qcyc7XG5leHBvcnQgeyBBbHBoYUZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9BbHBoYUZpbHRlci5tanMnO1xuZXhwb3J0IHsgQmx1ckZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL0JsdXJGaWx0ZXIubWpzJztcbmV4cG9ydCB7IEJsdXJGaWx0ZXJQYXNzIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvQmx1ckZpbHRlclBhc3MubWpzJztcbmV4cG9ydCB7IEdBVVNTSUFOX1ZBTFVFUyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUJsdXJGcmFnU291cmNlIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVCbHVyR2xQcm9ncmFtIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyR2xQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUJsdXJWZXJ0U291cmNlIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyVmVydFNvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVCbHVyUHJvZ3JhbSB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL2dwdS9nZW5lcmF0ZUJsdXJQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBDb2xvck1hdHJpeEZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9jb2xvci1tYXRyaXgvQ29sb3JNYXRyaXhGaWx0ZXIubWpzJztcbmV4cG9ydCB7IERpc3BsYWNlbWVudEZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9kaXNwbGFjZW1lbnQvRGlzcGxhY2VtZW50RmlsdGVyLm1qcyc7XG5leHBvcnQgeyBOb2lzZUZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9Ob2lzZUZpbHRlci5tanMnO1xuZXhwb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlci5tanMnO1xuZXhwb3J0IHsgRmlsdGVyRWZmZWN0IH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanMnO1xuZXhwb3J0IHsgRmlsdGVyUGlwZSB9IGZyb20gJy4vZmlsdGVycy9GaWx0ZXJQaXBlLm1qcyc7XG5leHBvcnQgeyBGaWx0ZXJTeXN0ZW0gfSBmcm9tICcuL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBNYXNrRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svTWFza0ZpbHRlci5tanMnO1xuZXhwb3J0IHsgZ3JvdXBEOCB9IGZyb20gJy4vbWF0aHMvbWF0cml4L2dyb3VwRDgubWpzJztcbmV4cG9ydCB7IE1hdHJpeCB9IGZyb20gJy4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuZXhwb3J0IHsgREVHX1RPX1JBRCwgUElfMiwgUkFEX1RPX0RFRyB9IGZyb20gJy4vbWF0aHMvbWlzYy9jb25zdC5tanMnO1xuZXhwb3J0IHsgaXNQb3cyLCBsb2cyLCBuZXh0UG93MiB9IGZyb20gJy4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5leHBvcnQgeyBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50IH0gZnJvbSAnLi9tYXRocy9taXNjL3NxdWFyZWREaXN0YW5jZVRvTGluZVNlZ21lbnQubWpzJztcbmV4cG9ydCB7IE9ic2VydmFibGVQb2ludCB9IGZyb20gJy4vbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5leHBvcnQgeyBQb2ludCB9IGZyb20gJy4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmV4cG9ydCB7IHBvaW50SW5UcmlhbmdsZSB9IGZyb20gJy4vbWF0aHMvcG9pbnQvcG9pbnRJblRyaWFuZ2xlLm1qcyc7XG5leHBvcnQgeyBDaXJjbGUgfSBmcm9tICcuL21hdGhzL3NoYXBlcy9DaXJjbGUubWpzJztcbmV4cG9ydCB7IEVsbGlwc2UgfSBmcm9tICcuL21hdGhzL3NoYXBlcy9FbGxpcHNlLm1qcyc7XG5leHBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi9tYXRocy9zaGFwZXMvUG9seWdvbi5tanMnO1xuZXhwb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5leHBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi9tYXRocy9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5tanMnO1xuZXhwb3J0IHsgVHJpYW5nbGUgfSBmcm9tICcuL21hdGhzL3NoYXBlcy9UcmlhbmdsZS5tanMnO1xuZXhwb3J0IHsgUHJlcGFyZUJhc2UgfSBmcm9tICcuL3ByZXBhcmUvUHJlcGFyZUJhc2UubWpzJztcbmV4cG9ydCB7IFByZXBhcmVRdWV1ZSB9IGZyb20gJy4vcHJlcGFyZS9QcmVwYXJlUXVldWUubWpzJztcbmV4cG9ydCB7IFByZXBhcmVTeXN0ZW0gfSBmcm9tICcuL3ByZXBhcmUvUHJlcGFyZVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgUHJlcGFyZVVwbG9hZCB9IGZyb20gJy4vcHJlcGFyZS9QcmVwYXJlVXBsb2FkLm1qcyc7XG5leHBvcnQgeyBHbEJhdGNoQWRhcHRvciB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvZ2wvR2xCYXRjaEFkYXB0b3IubWpzJztcbmV4cG9ydCB7IGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgfSBmcm9tICcuL3JlbmRlcmluZy9iYXRjaGVyL2dsL3V0aWxzL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIubWpzJztcbmV4cG9ydCB7IGdldE1heFRleHR1cmVzUGVyQmF0Y2ggfSBmcm9tICcuL3JlbmRlcmluZy9iYXRjaGVyL2dsL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlR1BVTGF5b3V0IH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvZ2VuZXJhdGVHUFVMYXlvdXQubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlTGF5b3V0IH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvZ2VuZXJhdGVMYXlvdXQubWpzJztcbmV4cG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L2dldFRleHR1cmVCYXRjaEJpbmRHcm91cC5tanMnO1xuZXhwb3J0IHsgR3B1QmF0Y2hBZGFwdG9yIH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvR3B1QmF0Y2hBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBCYXRjaCwgQmF0Y2hlciB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXIubWpzJztcbmV4cG9ydCB7IEJhdGNoZXJQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hlclBpcGUubWpzJztcbmV4cG9ydCB7IEJhdGNoR2VvbWV0cnkgfSBmcm9tICcuL3JlbmRlcmluZy9iYXRjaGVyL3NoYXJlZC9CYXRjaEdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoVGV4dHVyZUFycmF5Lm1qcyc7XG5leHBvcnQgeyBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSwgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmV4cG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyLCBjb21waWxlSGlnaFNoYWRlckdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvY29tcGlsZUhpZ2hTaGFkZXIubWpzJztcbmV4cG9ydCB7IGFkZEJpdHMgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlci91dGlscy9hZGRCaXRzLm1qcyc7XG5leHBvcnQgeyBjb21waWxlSG9va3MsIGZpbmRIb29rc1J4IH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvY29tcGlsZUhvb2tzLm1qcyc7XG5leHBvcnQgeyBjb21waWxlSW5wdXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvY29tcGlsZUlucHV0cy5tanMnO1xuZXhwb3J0IHsgY29tcGlsZU91dHB1dHMgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlci91dGlscy9jb21waWxlT3V0cHV0cy5tanMnO1xuZXhwb3J0IHsgZm9ybWF0U2hhZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvZm9ybWF0U2hhZGVyLm1qcyc7XG5leHBvcnQgeyBpbmplY3RCaXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvaW5qZWN0Qml0cy5tanMnO1xuZXhwb3J0IHsgZnJhZ21lbnRHUFVUZW1wbGF0ZSwgZnJhZ21lbnRHbFRlbXBsYXRlLCB2ZXJ0ZXhHUFVUZW1wbGF0ZSwgdmVydGV4R2xUZW1wbGF0ZSB9IGZyb20gJy4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL2RlZmF1bHRQcm9ncmFtVGVtcGxhdGUubWpzJztcbmV4cG9ydCB7IGNvbG9yQml0LCBjb2xvckJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvY29sb3JCaXQubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0LCBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQubWpzJztcbmV4cG9ydCB7IGdsb2JhbFVuaWZvcm1zQml0LCBnbG9iYWxVbmlmb3Jtc0JpdEdsLCBnbG9iYWxVbmlmb3Jtc1VCT0JpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2xvYmFsVW5pZm9ybXNCaXQubWpzJztcbmV4cG9ydCB7IGxvY2FsVW5pZm9ybUJpdCwgbG9jYWxVbmlmb3JtQml0R2wsIGxvY2FsVW5pZm9ybUJpdEdyb3VwMiB9IGZyb20gJy4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybUJpdC5tanMnO1xuZXhwb3J0IHsgcm91bmRQaXhlbHNCaXQsIHJvdW5kUGl4ZWxzQml0R2wgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9yb3VuZFBpeGVsc0JpdC5tanMnO1xuZXhwb3J0IHsgdGV4dHVyZUJpdCwgdGV4dHVyZUJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvdGV4dHVyZUJpdC5tanMnO1xuZXhwb3J0IHsgQWxwaGFNYXNrIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9hbHBoYS9BbHBoYU1hc2subWpzJztcbmV4cG9ydCB7IEFscGhhTWFza1BpcGUgfSBmcm9tICcuL3JlbmRlcmluZy9tYXNrL2FscGhhL0FscGhhTWFza1BpcGUubWpzJztcbmV4cG9ydCB7IENvbG9yTWFzayB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svY29sb3IvQ29sb3JNYXNrLm1qcyc7XG5leHBvcnQgeyBDb2xvck1hc2tQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9jb2xvci9Db2xvck1hc2tQaXBlLm1qcyc7XG5leHBvcnQgeyBNYXNrRWZmZWN0TWFuYWdlciwgTWFza0VmZmVjdE1hbmFnZXJDbGFzcyB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svTWFza0VmZmVjdE1hbmFnZXIubWpzJztcbmV4cG9ydCB7IFNjaXNzb3JNYXNrIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9zY2lzc29yL1NjaXNzb3JNYXNrLm1qcyc7XG5leHBvcnQgeyBTdGVuY2lsTWFzayB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svc3RlbmNpbC9TdGVuY2lsTWFzay5tanMnO1xuZXhwb3J0IHsgU3RlbmNpbE1hc2tQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9zdGVuY2lsL1N0ZW5jaWxNYXNrUGlwZS5tanMnO1xuZXhwb3J0IHsgYWRkTWFza0JvdW5kcyB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svdXRpbHMvYWRkTWFza0JvdW5kcy5tanMnO1xuZXhwb3J0IHsgYWRkTWFza0xvY2FsQm91bmRzLCBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50IH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay91dGlscy9hZGRNYXNrTG9jYWxCb3VuZHMubWpzJztcbmV4cG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IEJVRkZFUl9UWVBFIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL2J1ZmZlci9jb25zdC5tanMnO1xuZXhwb3J0IHsgR2xCdWZmZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvYnVmZmVyL0dsQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBHbEJ1ZmZlclN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9idWZmZXIvR2xCdWZmZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IENMRUFSIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBHbENvbnRleHRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvY29udGV4dC9HbENvbnRleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdsR2VvbWV0cnlTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvZ2VvbWV0cnkvR2xHZW9tZXRyeVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgZ2V0R2xUeXBlRnJvbUZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9nZW9tZXRyeS91dGlscy9nZXRHbFR5cGVGcm9tRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBHbEJhY2tCdWZmZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvR2xCYWNrQnVmZmVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHbENvbG9yTWFza1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbENvbG9yTWFza1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xFbmNvZGVyU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL0dsRW5jb2RlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvR2xSZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IEdsU3RlbmNpbFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbFN0ZW5jaWxTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdsVWJvU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL0dsVWJvU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHbFJlbmRlclRhcmdldEFkYXB0b3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvcmVuZGVyVGFyZ2V0L0dsUmVuZGVyVGFyZ2V0QWRhcHRvci5tanMnO1xuZXhwb3J0IHsgR2xSZW5kZXJUYXJnZXRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvcmVuZGVyVGFyZ2V0L0dsUmVuZGVyVGFyZ2V0U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZVNoYWRlclN5bmNDb2RlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HZW5lcmF0ZVNoYWRlclN5bmNDb2RlLm1qcyc7XG5leHBvcnQgeyBnZXRCYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9nZXRCYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcyc7XG5leHBvcnQgeyBHbFByb2dyYW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgR2xQcm9ncmFtRGF0YSwgSUdMVW5pZm9ybURhdGEgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsUHJvZ3JhbURhdGEubWpzJztcbmV4cG9ydCB7IEdsU2hhZGVyU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HbFNoYWRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xVbmlmb3JtR3JvdXBTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsVW5pZm9ybUdyb3VwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBtaWdyYXRlRnJhZ21lbnRGcm9tVjd0b1Y4IH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9taWdyYXRlRnJhZ21lbnRGcm9tVjd0b1Y4Lm1qcyc7XG5leHBvcnQgeyBjb21waWxlU2hhZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2NvbXBpbGVTaGFkZXIubWpzJztcbmV4cG9ydCB7IGRlZmF1bHRWYWx1ZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvcHJvZ3JhbS9kZWZhdWx0VmFsdWUubWpzJztcbmV4cG9ydCB7IGVuc3VyZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZW5zdXJlQXR0cmlidXRlcy5tanMnO1xuZXhwb3J0IHsgZXh0cmFjdEF0dHJpYnV0ZXNGcm9tR2xQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2V4dHJhY3RBdHRyaWJ1dGVzRnJvbUdsUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dlbmVyYXRlUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24ubWpzJztcbmV4cG9ydCB7IGdldFRlc3RDb250ZXh0IH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFRlc3RDb250ZXh0Lm1qcyc7XG5leHBvcnQgeyBnZXRVYm9EYXRhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFVib0RhdGEubWpzJztcbmV4cG9ydCB7IGdldFVuaWZvcm1EYXRhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFVuaWZvcm1EYXRhLm1qcyc7XG5leHBvcnQgeyBsb2dQcm9ncmFtRXJyb3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vbG9nUHJvZ3JhbUVycm9yLm1qcyc7XG5leHBvcnQgeyBtYXBTaXplIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL21hcFNpemUubWpzJztcbmV4cG9ydCB7IG1hcEdsVG9WZXJ0ZXhGb3JtYXQsIG1hcFR5cGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vbWFwVHlwZS5tanMnO1xuZXhwb3J0IHsgYWRkUHJvZ3JhbURlZmluZXMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vcHJlcHJvY2Vzc29ycy9hZGRQcm9ncmFtRGVmaW5lcy5tanMnO1xuZXhwb3J0IHsgZW5zdXJlUHJlY2lzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvZW5zdXJlUHJlY2lzaW9uLm1qcyc7XG5leHBvcnQgeyBpbnNlcnRWZXJzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvaW5zZXJ0VmVyc2lvbi5tanMnO1xuZXhwb3J0IHsgc2V0UHJvZ3JhbU5hbWUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vcHJlcHJvY2Vzc29ycy9zZXRQcm9ncmFtTmFtZS5tanMnO1xuZXhwb3J0IHsgc3RyaXBWZXJzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvc3RyaXBWZXJzaW9uLm1qcyc7XG5leHBvcnQgeyBXR1NMX1RPX1NURDQwX1NJWkUsIGNyZWF0ZVVib0VsZW1lbnRzU1RENDAgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzU1RENDAubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVVib1N5bmNGdW5jdGlvblNURDQwIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9jcmVhdGVVYm9TeW5jU1RENDAubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlQXJyYXlTeW5jU1RENDAgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3V0aWxzL2dlbmVyYXRlQXJyYXlTeW5jU1RENDAubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlVW5pZm9ybXNTeW5jIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luYy5tanMnO1xuZXhwb3J0IHsgVU5JRk9STV9UT19BUlJBWV9TRVRURVJTLCBVTklGT1JNX1RPX1NJTkdMRV9TRVRURVJTIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luY1R5cGVzLm1qcyc7XG5leHBvcnQgeyBHbFN0YXRlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3N0YXRlL0dsU3RhdGVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zdGF0ZS9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzJztcbmV4cG9ydCB7IEdMX0ZPUk1BVFMsIEdMX1RBUkdFVFMsIEdMX1RZUEVTLCBHTF9XUkFQX01PREVTIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvY29uc3QubWpzJztcbmV4cG9ydCB7IEdsVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL0dsVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgR2xUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvR2xUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZFZpZGVvUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRWaWRlb1Jlc291cmNlLm1qcyc7XG5leHBvcnQgeyBhcHBseVN0eWxlUGFyYW1zIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvdXRpbHMvYXBwbHlTdHlsZVBhcmFtcy5tanMnO1xuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkR2xDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91dGlscy9nZXRTdXBwb3J0ZWRHbENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5tanMnO1xuZXhwb3J0IHsgbWFwRm9ybWF0VG9HbEZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL21hcEZvcm1hdFRvR2xGb3JtYXQubWpzJztcbmV4cG9ydCB7IG1hcEZvcm1hdFRvR2xJbnRlcm5hbEZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL21hcEZvcm1hdFRvR2xJbnRlcm5hbEZvcm1hdC5tanMnO1xuZXhwb3J0IHsgbWFwRm9ybWF0VG9HbFR5cGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91dGlscy9tYXBGb3JtYXRUb0dsVHlwZS5tanMnO1xuZXhwb3J0IHsgY29tcGFyZU1vZGVUb0dsQ29tcGFyZSwgbWlwbWFwU2NhbGVNb2RlVG9HbEZpbHRlciwgc2NhbGVNb2RlVG9HbEZpbHRlciwgd3JhcE1vZGVUb0dsQWRkcmVzcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL3BpeGlUb0dsTWFwcy5tanMnO1xuZXhwb3J0IHsgdW5wcmVtdWx0aXBseUFscGhhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvdXRpbHMvdW5wcmVtdWx0aXBseUFscGhhLm1qcyc7XG5leHBvcnQgeyBXZWJHTFJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL1dlYkdMUmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IEJpbmRHcm91cFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvQmluZEdyb3VwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVCdWZmZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L2J1ZmZlci9HcHVCdWZmZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVJlYWRCdWZmZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L2J1ZmZlci9HcHVSZWFkQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBVYm9CYXRjaCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvYnVmZmVyL1Vib0JhdGNoLm1qcyc7XG5leHBvcnQgeyBHcHVDb2xvck1hc2tTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUNvbG9yTWFza1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgR3B1RGV2aWNlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVEZXZpY2VTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdUVuY29kZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUVuY29kZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVN0ZW5jaWxTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdVN0ZW5jaWxTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVVib1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvR3B1VWJvU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVVbmlmb3JtQmF0Y2hQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVVbmlmb3JtQmF0Y2hQaXBlLm1qcyc7XG5leHBvcnQgeyBQaXBlbGluZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvcGlwZWxpbmUvUGlwZWxpbmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGNhbGN1bGF0ZVByb2plY3Rpb24gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9jYWxjdWxhdGVQcm9qZWN0aW9uLm1qcyc7XG5leHBvcnQgeyBHcHVSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IEdwdVJlbmRlclRhcmdldEFkYXB0b3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXRBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBHcHVSZW5kZXJUYXJnZXRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEJpbmRHcm91cCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuZXhwb3J0IHsgR3B1UHJvZ3JhbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0dwdVByb2dyYW0ubWpzJztcbmV4cG9ydCB7IEdwdVNoYWRlclN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0dwdVNoYWRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgV0dTTF9BTElHTl9TSVpFX0RBVEEsIGNyZWF0ZVVib0VsZW1lbnRzV0dTTCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzV0dTTC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib1N5bmNGdW5jdGlvbldHU0wubWpzJztcbmV4cG9ydCB7IGV4dHJhY3RBdHRyaWJ1dGVzRnJvbUdwdVByb2dyYW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci91dGlscy9leHRyYWN0QXR0cmlidXRlc0Zyb21HcHVQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBleHRyYWN0U3RydWN0QW5kR3JvdXBzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvZXh0cmFjdFN0cnVjdEFuZEdyb3Vwcy5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVBcnJheVN5bmNXR1NMIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVBcnJheVN5bmNXR1NMLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUdwdUxheW91dEdyb3VwcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2dlbmVyYXRlR3B1TGF5b3V0R3JvdXBzLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUxheW91dEhhc2ggfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci91dGlscy9nZW5lcmF0ZUxheW91dEhhc2gubWpzJztcbmV4cG9ydCB7IHJlbW92ZVN0cnVjdEFuZEdyb3VwRHVwbGljYXRlcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL3JlbW92ZVN0cnVjdEFuZEdyb3VwRHVwbGljYXRlcy5tanMnO1xuZXhwb3J0IHsgR3B1QmxlbmRNb2Rlc1RvUGl4aSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc3RhdGUvR3B1QmxlbmRNb2Rlc1RvUGl4aS5tanMnO1xuZXhwb3J0IHsgR3B1U3RhdGVTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3N0YXRlL0dwdVN0YXRlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVTdGVuY2lsTW9kZXNUb1BpeGkgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3N0YXRlL0dwdVN0ZW5jaWxNb2Rlc1RvUGl4aS5tanMnO1xuZXhwb3J0IHsgR3B1VGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvdGV4dHVyZS9HcHVUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3VwbG9hZGVycy9ncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBibG9ja0RhdGFNYXAsIGdwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IGdwdVVwbG9hZEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZEltYWdlU291cmNlLm1qcyc7XG5leHBvcnQgeyBncHVVcGxvYWRWaWRlb1Jlc291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3VwbG9hZGVycy9ncHVVcGxvYWRWaWRlb1NvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkR1BVQ29tcHJlc3NlZFRleHR1cmVGb3JtYXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3V0aWxzL2dldFN1cHBvcnRlZEdQVUNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5tanMnO1xuZXhwb3J0IHsgR3B1TWlwbWFwR2VuZXJhdG9yIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3V0aWxzL0dwdU1pcG1hcEdlbmVyYXRvci5tanMnO1xuZXhwb3J0IHsgV2ViR1BVUmVuZGVyZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L1dlYkdQVVJlbmRlcmVyLm1qcyc7XG5leHBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEJsZW5kTW9kZVBpcGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2JsZW5kTW9kZXMvQmxlbmRNb2RlUGlwZS5tanMnO1xuZXhwb3J0IHsgQnVmZmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL0J1ZmZlclJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJVc2FnZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBmYXN0Q29weSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL3V0aWxzL2Zhc3RDb3B5Lm1qcyc7XG5leHBvcnQgeyBFeHRyYWN0U3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9leHRyYWN0L0V4dHJhY3RTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdlbmVyYXRlVGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZXh0cmFjdC9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IERSQVdfTU9ERVMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IGJ1aWxkU2ltcGxlVXZzLCBidWlsZFV2cyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvYnVpbGRVdnMubWpzJztcbmV4cG9ydCB7IGVuc3VyZUlzQnVmZmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy9lbnN1cmVJc0J1ZmZlci5tanMnO1xuZXhwb3J0IHsgZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2dldEF0dHJpYnV0ZUluZm9Gcm9tRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBnZXRHZW9tZXRyeUJvdW5kcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvZ2V0R2VvbWV0cnlCb3VuZHMubWpzJztcbmV4cG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy90cmFuc2Zvcm1WZXJ0aWNlcy5tanMnO1xuZXhwb3J0IHsgSW5zdHJ1Y3Rpb25TZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2luc3RydWN0aW9ucy9JbnN0cnVjdGlvblNldC5tanMnO1xuZXhwb3J0IHsgR2xvYmFsVW5pZm9ybVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L0dsb2JhbFVuaWZvcm1TeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGlzUmVuZGVyaW5nVG9TY3JlZW4gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9pc1JlbmRlcmluZ1RvU2NyZWVuLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IFJlbmRlclRhcmdldFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L1JlbmRlclRhcmdldFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgdmlld3BvcnRGcm9tRnJhbWUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC92aWV3cG9ydEZyb21GcmFtZS5tanMnO1xuZXhwb3J0IHsgU2NoZWR1bGVyU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9TY2hlZHVsZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFNoYWRlclN0YWdlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvY29uc3QubWpzJztcbmV4cG9ydCB7IFNoYWRlciB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1NoYWRlci5tanMnO1xuZXhwb3J0IHsgVU5JRk9STV9UWVBFU19NQVAsIFVOSUZPUk1fVFlQRVNfVkFMVUVTIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdHlwZXMubWpzJztcbmV4cG9ydCB7IFVib1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1Vib1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVVYm9TeW5jRnVuY3Rpb24gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci91dGlscy9jcmVhdGVVYm9TeW5jRnVuY3Rpb24ubWpzJztcbmV4cG9ydCB7IGdldERlZmF1bHRVbmlmb3JtVmFsdWUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci91dGlscy9nZXREZWZhdWx0VW5pZm9ybVZhbHVlLm1qcyc7XG5leHBvcnQgeyB1Ym9TeW5jRnVuY3Rpb25zU1RENDAsIHVib1N5bmNGdW5jdGlvbnNXR1NMIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvdWJvU3luY0Z1bmN0aW9ucy5tanMnO1xuZXhwb3J0IHsgdW5pZm9ybVBhcnNlcnMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci91dGlscy91bmlmb3JtUGFyc2Vycy5tanMnO1xuZXhwb3J0IHsgSGVsbG9TeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXJ0dXAvSGVsbG9TeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEJMRU5EX1RPX05QTSwgU1RFTkNJTF9NT0RFUyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvY29uc3QubWpzJztcbmV4cG9ydCB7IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL2dldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQubWpzJztcbmV4cG9ydCB7IFN0YXRlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9TdGF0ZS5tanMnO1xuZXhwb3J0IHsgQWJzdHJhY3RSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL0Fic3RyYWN0UmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IFNoYXJlZFJlbmRlclBpcGVzLCBTaGFyZWRTeXN0ZW1zIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zeXN0ZW0vU2hhcmVkU3lzdGVtcy5tanMnO1xuZXhwb3J0IHsgU3lzdGVtUnVubmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zeXN0ZW0vU3lzdGVtUnVubmVyLm1qcyc7XG5leHBvcnQgeyBDYW52YXNQb29sLCBDYW52YXNQb29sQ2xhc3MgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanMnO1xuZXhwb3J0IHsgREVQUkVDQVRFRF9TQ0FMRV9NT0RFUywgREVQUkVDQVRFRF9XUkFQX01PREVTLCBNU0FBX1FVQUxJVFksIFNDQUxFX01PREVTLCBXUkFQX01PREVTIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBSZW5kZXJhYmxlR0NTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvUmVuZGVyYWJsZUdDU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJUZXh0dXJlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1JlbmRlclRleHR1cmUubWpzJztcbmV4cG9ydCB7IEJ1ZmZlckltYWdlU291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQnVmZmVySW1hZ2VTb3VyY2UubWpzJztcbmV4cG9ydCB7IENhbnZhc1NvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0NhbnZhc1NvdXJjZS5tanMnO1xuZXhwb3J0IHsgQ29tcHJlc3NlZFNvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0NvbXByZXNzZWRTb3VyY2UubWpzJztcbmV4cG9ydCB7IEltYWdlU291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvSW1hZ2VTb3VyY2UubWpzJztcbmV4cG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9UZXh0dXJlU291cmNlLm1qcyc7XG5leHBvcnQgeyBWaWRlb1NvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL1ZpZGVvU291cmNlLm1qcyc7XG5leHBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmV4cG9ydCB7IFRleHR1cmVHQ1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlR0NTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFRleHR1cmVNYXRyaXggfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZU1hdHJpeC5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVBvb2wsIFRleHR1cmVQb29sQ2xhc3MgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmV4cG9ydCB7IFRleHR1cmVTdHlsZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlU3R5bGUubWpzJztcbmV4cG9ydCB7IFRleHR1cmVVdnMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVV2cy5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVVSUQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvdXRpbHMvZ2VuZXJhdGVVSUQubWpzJztcbmV4cG9ydCB7IGdldENhbnZhc1RleHR1cmUsIGhhc0NhY2hlZENhbnZhc1RleHR1cmUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvdXRpbHMvZ2V0Q2FudmFzVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkQ29tcHJlc3NlZFRleHR1cmVGb3JtYXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3V0aWxzL2dldFN1cHBvcnRlZENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5tanMnO1xuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkVGV4dHVyZUZvcm1hdHMsIG5vbkNvbXByZXNzZWRGb3JtYXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3V0aWxzL2dldFN1cHBvcnRlZFRleHR1cmVGb3JtYXRzLm1qcyc7XG5leHBvcnQgeyBhdXRvRGV0ZWN0U291cmNlLCByZXNvdXJjZVRvVGV4dHVyZSwgdGV4dHVyZUZyb20gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvdXRpbHMvdGV4dHVyZUZyb20ubWpzJztcbmV4cG9ydCB7IGNyZWF0ZUlkRnJvbVN0cmluZyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdXRpbHMvY3JlYXRlSWRGcm9tU3RyaW5nLm1qcyc7XG5leHBvcnQgeyBwYXJzZUZ1bmN0aW9uQm9keSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdXRpbHMvcGFyc2VGdW5jdGlvbkJvZHkubWpzJztcbmV4cG9ydCB7IFZpZXdTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3ZpZXcvVmlld1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgUmVuZGVyZXJUeXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5leHBvcnQgeyBCb3VuZHMgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5leHBvcnQgeyBfZ2V0R2xvYmFsQm91bmRzUmVjdXJzaXZlLCBnZXRGYXN0R2xvYmFsQm91bmRzIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldEZhc3RHbG9iYWxCb3VuZHMubWpzJztcbmV4cG9ydCB7IF9nZXRHbG9iYWxCb3VuZHMsIGdldEdsb2JhbEJvdW5kcywgdXBkYXRlVHJhbnNmb3JtQmFja3dhcmRzIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldEdsb2JhbEJvdW5kcy5tanMnO1xuZXhwb3J0IHsgZ2V0TG9jYWxCb3VuZHMsIGdldFBhcmVudCB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRMb2NhbEJvdW5kcy5tanMnO1xuZXhwb3J0IHsgZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRSZW5kZXJhYmxlQm91bmRzLm1qcyc7XG5leHBvcnQgeyBib3VuZHNQb29sLCBtYXRyaXhQb29sIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvYm91bmRzL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzJztcbmV4cG9ydCB7IGNoaWxkcmVuSGVscGVyTWl4aW4gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL2NoaWxkcmVuSGVscGVyTWl4aW4ubWpzJztcbmV4cG9ydCB7IGVmZmVjdHNNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvZWZmZWN0c01peGluLm1qcyc7XG5leHBvcnQgeyBmaW5kTWl4aW4gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL2ZpbmRNaXhpbi5tanMnO1xuZXhwb3J0IHsgbWVhc3VyZU1peGluIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9tZWFzdXJlTWl4aW4ubWpzJztcbmV4cG9ydCB7IG9uUmVuZGVyTWl4aW4gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL29uUmVuZGVyTWl4aW4ubWpzJztcbmV4cG9ydCB7IHNvcnRNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvc29ydE1peGluLm1qcyc7XG5leHBvcnQgeyB0b0xvY2FsR2xvYmFsTWl4aW4gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL3RvTG9jYWxHbG9iYWxNaXhpbi5tanMnO1xuZXhwb3J0IHsgQ29udGFpbmVyLCBVUERBVEVfQkxFTkQsIFVQREFURV9DT0xPUiwgVVBEQVRFX1RSQU5TRk9STSwgVVBEQVRFX1ZJU0lCTEUgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9Db250YWluZXIubWpzJztcbmV4cG9ydCB7IEN1c3RvbVJlbmRlclBpcGUgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9DdXN0b21SZW5kZXJQaXBlLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJDb250YWluZXIgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9SZW5kZXJDb250YWluZXIubWpzJztcbmV4cG9ydCB7IFJlbmRlckdyb3VwIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvUmVuZGVyR3JvdXAubWpzJztcbmV4cG9ydCB7IFJlbmRlckdyb3VwUGlwZSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwUGlwZS5tanMnO1xuZXhwb3J0IHsgUmVuZGVyR3JvdXBTeXN0ZW0gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9SZW5kZXJHcm91cFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgYXNzaWduV2l0aElnbm9yZSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2Fzc2lnbldpdGhJZ25vcmUubWpzJztcbmV4cG9ydCB7IGJ1aWxkSW5zdHJ1Y3Rpb25zLCBjb2xsZWN0QWxsUmVuZGVyYWJsZXMgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci91dGlscy9idWlsZEluc3RydWN0aW9ucy5tanMnO1xuZXhwb3J0IHsgY2hlY2tDaGlsZHJlbkRpZENoYW5nZSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2NoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UubWpzJztcbmV4cG9ydCB7IGNsZWFyTGlzdCB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2NsZWFyTGlzdC5tanMnO1xuZXhwb3J0IHsgY29sbGVjdFJlbmRlckdyb3VwcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2NvbGxlY3RSZW5kZXJHcm91cHMubWpzJztcbmV4cG9ydCB7IGRlZmluZWRQcm9wcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2RlZmluZWRQcm9wcy5tanMnO1xuZXhwb3J0IHsgZXhlY3V0ZUluc3RydWN0aW9ucyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2V4ZWN1dGVJbnN0cnVjdGlvbnMubWpzJztcbmV4cG9ydCB7IG1peENvbG9ycywgbWl4U3RhbmRhcmRBbmQzMkJpdENvbG9ycyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL21peENvbG9ycy5tanMnO1xuZXhwb3J0IHsgbWl4SGV4Q29sb3JzIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvdXRpbHMvbWl4SGV4Q29sb3JzLm1qcyc7XG5leHBvcnQgeyBtdWx0aXBseUhleENvbG9ycyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL211bHRpcGx5SGV4Q29sb3JzLm1qcyc7XG5leHBvcnQgeyB1cGRhdGVMb2NhbFRyYW5zZm9ybSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3VwZGF0ZUxvY2FsVHJhbnNmb3JtLm1qcyc7XG5leHBvcnQgeyB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybSwgdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zLCB1cGRhdGVUcmFuc2Zvcm1BbmRDaGlsZHJlbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3VwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3Jtcy5tanMnO1xuZXhwb3J0IHsgdXBkYXRlV29ybGRUcmFuc2Zvcm0gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci91dGlscy91cGRhdGVXb3JsZFRyYW5zZm9ybS5tanMnO1xuZXhwb3J0IHsgdmFsaWRhdGVSZW5kZXJhYmxlcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3ZhbGlkYXRlUmVuZGVyYWJsZXMubWpzJztcbmV4cG9ydCB7IEdsR3JhcGhpY3NBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9nbC9HbEdyYXBoaWNzQWRhcHRvci5tanMnO1xuZXhwb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSwgY29sb3JUb1VuaWZvcm0gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuZXhwb3J0IHsgR3B1R3JhcGhpY3NBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9ncHUvR3B1R3JhcGhpY3NBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBCYXRjaGFibGVHcmFwaGljcyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0JhdGNoYWJsZUdyYXBoaWNzLm1qcyc7XG5leHBvcnQgeyBidWlsZEFkYXB0aXZlQmV6aWVyIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcyc7XG5leHBvcnQgeyBidWlsZEFkYXB0aXZlUXVhZHJhdGljIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlUXVhZHJhdGljLm1qcyc7XG5leHBvcnQgeyBidWlsZEFyYyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmMubWpzJztcbmV4cG9ydCB7IGJ1aWxkQXJjVG8gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG8ubWpzJztcbmV4cG9ydCB7IGJ1aWxkQXJjVG9TdmcgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG9TdmcubWpzJztcbmV4cG9ydCB7IGJ1aWxkQ2lyY2xlLCBidWlsZEVsbGlwc2UsIGJ1aWxkUm91bmRlZFJlY3RhbmdsZSB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRDaXJjbGUubWpzJztcbmV4cG9ydCB7IGJ1aWxkTGluZSB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRMaW5lLm1qcyc7XG5leHBvcnQgeyBidWlsZFBvbHlnb24gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkUG9seWdvbi5tanMnO1xuZXhwb3J0IHsgYnVpbGRSZWN0YW5nbGUgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkUmVjdGFuZ2xlLm1qcyc7XG5leHBvcnQgeyBidWlsZFRyaWFuZ2xlIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZFRyaWFuZ2xlLm1qcyc7XG5leHBvcnQgeyBjbG9zZVBvaW50RXBzLCBjdXJ2ZUVwcyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBGaWxsR3JhZGllbnQgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxHcmFkaWVudC5tanMnO1xuZXhwb3J0IHsgRmlsbFBhdHRlcm4gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxQYXR0ZXJuLm1qcyc7XG5leHBvcnQgeyBHcmFwaGljcyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzLm1qcyc7XG5leHBvcnQgeyBHcmFwaGljc0NvbnRleHQgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc0NvbnRleHQubWpzJztcbmV4cG9ydCB7IEdwdUdyYXBoaWNzQ29udGV4dCwgR3JhcGhpY3NDb250ZXh0UmVuZGVyRGF0YSwgR3JhcGhpY3NDb250ZXh0U3lzdGVtIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcmFwaGljc1BpcGUgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc1BpcGUubWpzJztcbmV4cG9ydCB7IEdyYXBoaWNzUGF0aCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3BhdGgvR3JhcGhpY3NQYXRoLm1qcyc7XG5leHBvcnQgeyByb3VuZGVkU2hhcGVBcmMsIHJvdW5kZWRTaGFwZVF1YWRyYXRpY0N1cnZlIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvcGF0aC9yb3VuZFNoYXBlLm1qcyc7XG5leHBvcnQgeyBTaGFwZVBhdGggfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9wYXRoL1NoYXBlUGF0aC5tanMnO1xuZXhwb3J0IHsgU1ZHUGFyc2VyIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvc3ZnL1NWR1BhcnNlci5tanMnO1xuZXhwb3J0IHsgU1ZHVG9HcmFwaGljc1BhdGggfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9zdmcvU1ZHVG9HcmFwaGljc1BhdGgubWpzJztcbmV4cG9ydCB7IGJ1aWxkQ29udGV4dEJhdGNoZXMsIHNoYXBlQnVpbGRlcnMgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy9idWlsZENvbnRleHRCYXRjaGVzLm1qcyc7XG5leHBvcnQgeyBidWlsZEdlb21ldHJ5RnJvbVBhdGggfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy9idWlsZEdlb21ldHJ5RnJvbVBhdGgubWpzJztcbmV4cG9ydCB7IHRvRmlsbFN0eWxlLCB0b1N0cm9rZVN0eWxlIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcyc7XG5leHBvcnQgeyBnZXRPcmllbnRhdGlvbk9mUG9pbnRzIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvZ2V0T3JpZW50YXRpb25PZlBvaW50cy5tanMnO1xuZXhwb3J0IHsgdHJpYW5ndWxhdGVXaXRoSG9sZXMgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy90cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanMnO1xuZXhwb3J0IHsgUGVyc3BlY3RpdmVNZXNoIH0gZnJvbSAnLi9zY2VuZS9tZXNoLXBlcnNwZWN0aXZlL1BlcnNwZWN0aXZlTWVzaC5tanMnO1xuZXhwb3J0IHsgUGVyc3BlY3RpdmVQbGFuZUdlb21ldHJ5IH0gZnJvbSAnLi9zY2VuZS9tZXNoLXBlcnNwZWN0aXZlL1BlcnNwZWN0aXZlUGxhbmVHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgYXBwbHlQcm9qZWN0aXZlVHJhbnNmb3JtYXRpb25Ub1BsYW5lIH0gZnJvbSAnLi9zY2VuZS9tZXNoLXBlcnNwZWN0aXZlL3V0aWxzL2FwcGx5UHJvamVjdGl2ZVRyYW5zZm9ybWF0aW9uVG9QbGFuZS5tanMnO1xuZXhwb3J0IHsgY29tcHV0ZTJEUHJvamVjdGlvbiB9IGZyb20gJy4vc2NlbmUvbWVzaC1wZXJzcGVjdGl2ZS91dGlscy9jb21wdXRlMkRQcm9qZWN0aW9ucy5tanMnO1xuZXhwb3J0IHsgTWVzaFBsYW5lIH0gZnJvbSAnLi9zY2VuZS9tZXNoLXBsYW5lL01lc2hQbGFuZS5tanMnO1xuZXhwb3J0IHsgUGxhbmVHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvbWVzaC1wbGFuZS9QbGFuZUdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBNZXNoUm9wZSB9IGZyb20gJy4vc2NlbmUvbWVzaC1zaW1wbGUvTWVzaFJvcGUubWpzJztcbmV4cG9ydCB7IE1lc2hTaW1wbGUgfSBmcm9tICcuL3NjZW5lL21lc2gtc2ltcGxlL01lc2hTaW1wbGUubWpzJztcbmV4cG9ydCB7IFJvcGVHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvbWVzaC1zaW1wbGUvUm9wZUdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBHbE1lc2hBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9tZXNoL2dsL0dsTWVzaEFkYXB0b3IubWpzJztcbmV4cG9ydCB7IEdwdU1lc2hBZGFwdGVyIH0gZnJvbSAnLi9zY2VuZS9tZXNoL2dwdS9HcHVNZXNoQWRhcHRlci5tanMnO1xuZXhwb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4vc2NlbmUvbWVzaC9zaGFyZWQvQmF0Y2hhYmxlTWVzaC5tanMnO1xuZXhwb3J0IHsgZ2V0VGV4dHVyZURlZmF1bHRNYXRyaXggfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL2dldFRleHR1cmVEZWZhdWx0TWF0cml4Lm1qcyc7XG5leHBvcnQgeyBNZXNoIH0gZnJvbSAnLi9zY2VuZS9tZXNoL3NoYXJlZC9NZXNoLm1qcyc7XG5leHBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL01lc2hHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgTWVzaFBpcGUgfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL01lc2hQaXBlLm1qcyc7XG5leHBvcnQgeyBBbmltYXRlZFNwcml0ZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLWFuaW1hdGVkL0FuaW1hdGVkU3ByaXRlLm1qcyc7XG5leHBvcnQgeyBOaW5lU2xpY2VHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IE5pbmVTbGljZVBsYW5lLCBOaW5lU2xpY2VTcHJpdGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS1uaW5lLXNsaWNlL05pbmVTbGljZVNwcml0ZS5tanMnO1xuZXhwb3J0IHsgTmluZVNsaWNlU3ByaXRlUGlwZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlU3ByaXRlUGlwZS5tanMnO1xuZXhwb3J0IHsgdGlsaW5nQml0LCB0aWxpbmdCaXRHbCB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy9zaGFkZXIvdGlsaW5nQml0Lm1qcyc7XG5leHBvcnQgeyBUaWxpbmdTcHJpdGVTaGFkZXIgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS10aWxpbmcvc2hhZGVyL1RpbGluZ1Nwcml0ZVNoYWRlci5tanMnO1xuZXhwb3J0IHsgVGlsaW5nU3ByaXRlIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL1RpbGluZ1Nwcml0ZS5tanMnO1xuZXhwb3J0IHsgVGlsaW5nU3ByaXRlUGlwZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy9UaWxpbmdTcHJpdGVQaXBlLm1qcyc7XG5leHBvcnQgeyBhcHBseU1hdHJpeCB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy91dGlscy9hcHBseU1hdHJpeC5tanMnO1xuZXhwb3J0IHsgUXVhZEdlb21ldHJ5IH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL1F1YWRHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgc2V0UG9zaXRpb25zIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL3NldFBvc2l0aW9ucy5tanMnO1xuZXhwb3J0IHsgc2V0VXZzIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL3NldFV2cy5tanMnO1xuZXhwb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUvQmF0Y2hhYmxlU3ByaXRlLm1qcyc7XG5leHBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS9TcHJpdGUubWpzJztcbmV4cG9ydCB7IFNwcml0ZVBpcGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS9TcHJpdGVQaXBlLm1qcyc7XG5leHBvcnQgeyBBYnN0cmFjdEJpdG1hcEZvbnQgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL0Fic3RyYWN0Qml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgYml0bWFwRm9udFRleHRQYXJzZXIgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL2Fzc2V0L2JpdG1hcEZvbnRUZXh0UGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250WE1MUGFyc2VyIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250Q2FjaGVQbHVnaW4sIGxvYWRCaXRtYXBGb250IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9sb2FkQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgQml0bWFwRm9udCB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgQml0bWFwRm9udE1hbmFnZXIgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL0JpdG1hcEZvbnRNYW5hZ2VyLm1qcyc7XG5leHBvcnQgeyBCaXRtYXBUZXh0IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9CaXRtYXBUZXh0Lm1qcyc7XG5leHBvcnQgeyBCaXRtYXBUZXh0UGlwZSB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IER5bmFtaWNCaXRtYXBGb250IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9EeW5hbWljQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0Lm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dFBpcGUgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IVE1MVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IEhUTUxUZXh0UmVuZGVyRGF0YSwgbnNzdmcsIG5zeGh0bWwgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IVE1MVGV4dFJlbmRlckRhdGEubWpzJztcbmV4cG9ydCB7IEhUTUxUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IdG1sVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dFN5c3RlbSB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZXh0cmFjdEZvbnRGYW1pbGllcy5tanMnO1xuZXhwb3J0IHsgRm9udFN0eWxlUHJvbWlzZUNhY2hlLCBnZXRGb250Q3NzIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0Rm9udENzcy5tanMnO1xuZXhwb3J0IHsgZ2V0U1ZHVXJsIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0U1ZHVXJsLm1qcyc7XG5leHBvcnQgeyBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzJztcbmV4cG9ydCB7IGxvYWRGb250QXNCYXNlNjQgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkRm9udEFzQmFzZTY0Lm1qcyc7XG5leHBvcnQgeyBsb2FkRm9udENTUyB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL3V0aWxzL2xvYWRGb250Q1NTLm1qcyc7XG5leHBvcnQgeyBsb2FkU1ZHSW1hZ2UgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkU1ZHSW1hZ2UubWpzJztcbmV4cG9ydCB7IG1lYXN1cmVIdG1sVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL3V0aWxzL21lYXN1cmVIdG1sVGV4dC5tanMnO1xuZXhwb3J0IHsgdGV4dFN0eWxlVG9DU1MgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy90ZXh0U3R5bGVUb0NTUy5tanMnO1xuZXhwb3J0IHsgQWJzdHJhY3RUZXh0LCBlbnN1cmVPcHRpb25zIH0gZnJvbSAnLi9zY2VuZS90ZXh0L0Fic3RyYWN0VGV4dC5tanMnO1xuZXhwb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5leHBvcnQgeyBDYW52YXNUZXh0UGlwZSB9IGZyb20gJy4vc2NlbmUvdGV4dC9jYW52YXMvQ2FudmFzVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IENhbnZhc1RleHRTeXN0ZW0gfSBmcm9tICcuL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH0gZnJvbSAnLi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuZXhwb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH0gZnJvbSAnLi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9nZXRDYW52YXNGaWxsU3R5bGUubWpzJztcbmV4cG9ydCB7IFNkZlNoYWRlciB9IGZyb20gJy4vc2NlbmUvdGV4dC9zZGZTaGFkZXIvU2RmU2hhZGVyLm1qcyc7XG5leHBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfSBmcm9tICcuL3NjZW5lL3RleHQvc2RmU2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzJztcbmV4cG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9IGZyb20gJy4vc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbVNERkJpdC5tanMnO1xuZXhwb3J0IHsgVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC9UZXh0Lm1qcyc7XG5leHBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQvVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBlbnN1cmVUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQvdXRpbHMvZW5zdXJlVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZVRleHRTdHlsZUtleSB9IGZyb20gJy4vc2NlbmUvdGV4dC91dGlscy9nZW5lcmF0ZVRleHRTdHlsZUtleS5tanMnO1xuZXhwb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfSBmcm9tICcuL3NjZW5lL3RleHQvdXRpbHMvZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzJztcbmV4cG9ydCB7IFZpZXdDb250YWluZXIgfSBmcm9tICcuL3NjZW5lL3ZpZXcvVmlldy5tanMnO1xuZXhwb3J0IHsgU3ByaXRlc2hlZXQgfSBmcm9tICcuL3Nwcml0ZXNoZWV0L1Nwcml0ZXNoZWV0Lm1qcyc7XG5leHBvcnQgeyBzcHJpdGVzaGVldEFzc2V0IH0gZnJvbSAnLi9zcHJpdGVzaGVldC9zcHJpdGVzaGVldEFzc2V0Lm1qcyc7XG5leHBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICcuL3RpY2tlci9jb25zdC5tanMnO1xuZXhwb3J0IHsgVGlja2VyIH0gZnJvbSAnLi90aWNrZXIvVGlja2VyLm1qcyc7XG5leHBvcnQgeyBUaWNrZXJMaXN0ZW5lciB9IGZyb20gJy4vdGlja2VyL1RpY2tlckxpc3RlbmVyLm1qcyc7XG5leHBvcnQgeyBkZXRlY3RWaWRlb0FscGhhTW9kZSB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci9kZXRlY3RWaWRlb0FscGhhTW9kZS5tanMnO1xuZXhwb3J0IHsgaXNNb2JpbGUgfSBmcm9tICcuL3V0aWxzL2Jyb3dzZXIvaXNNb2JpbGUubWpzJztcbmV4cG9ydCB7IGlzU2FmYXJpIH0gZnJvbSAnLi91dGlscy9icm93c2VyL2lzU2FmYXJpLm1qcyc7XG5leHBvcnQgeyBpc1dlYkdMU3VwcG9ydGVkIH0gZnJvbSAnLi91dGlscy9icm93c2VyL2lzV2ViR0xTdXBwb3J0ZWQubWpzJztcbmV4cG9ydCB7IGlzV2ViR1BVU3VwcG9ydGVkIH0gZnJvbSAnLi91dGlscy9icm93c2VyL2lzV2ViR1BVU3VwcG9ydGVkLm1qcyc7XG5leHBvcnQgeyB1bnNhZmVFdmFsU3VwcG9ydGVkIH0gZnJvbSAnLi91dGlscy9icm93c2VyL3Vuc2FmZUV2YWxTdXBwb3J0ZWQubWpzJztcbmV4cG9ydCB7IGdldENhbnZhc0JvdW5kaW5nQm94IH0gZnJvbSAnLi91dGlscy9jYW52YXMvZ2V0Q2FudmFzQm91bmRpbmdCb3gubWpzJztcbmV4cG9ydCB7IERBVEFfVVJJIH0gZnJvbSAnLi91dGlscy9jb25zdC5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudGVtaXR0ZXIzJztcbmV4cG9ydCB7IHJlbW92ZUl0ZW1zIH0gZnJvbSAnLi91dGlscy9kYXRhL3JlbW92ZUl0ZW1zLm1qcyc7XG5leHBvcnQgeyByZXNldFVpZHMsIHVpZCB9IGZyb20gJy4vdXRpbHMvZGF0YS91aWQubWpzJztcbmV4cG9ydCB7IHVwZGF0ZVF1YWRCb3VuZHMgfSBmcm9tICcuL3V0aWxzL2RhdGEvdXBkYXRlUXVhZEJvdW5kcy5tanMnO1xuZXhwb3J0IHsgVmlld2FibGVCdWZmZXIgfSBmcm9tICcuL3V0aWxzL2RhdGEvVmlld2FibGVCdWZmZXIubWpzJztcbmV4cG9ydCB7IEFwcGxpY2F0aW9uSW5pdEhvb2ssIFJlbmRlcmVySW5pdEhvb2sgfSBmcm9tICcuL3V0aWxzL2dsb2JhbC9nbG9iYWxIb29rcy5tanMnO1xuZXhwb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuZXhwb3J0IHsgbG9nRGVidWdUZXh0dXJlIH0gZnJvbSAnLi91dGlscy9sb2dnaW5nL2xvZ0RlYnVnVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgbG9nUmVuZGVyR3JvdXBTY2VuZSwgbG9nU2NlbmUgfSBmcm9tICcuL3V0aWxzL2xvZ2dpbmcvbG9nU2NlbmUubWpzJztcbmV4cG9ydCB7IHdhcm4gfSBmcm9tICcuL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuZXhwb3J0IHsgTk9PUCB9IGZyb20gJy4vdXRpbHMvbWlzYy9OT09QLm1qcyc7XG5leHBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICcuL3V0aWxzL21pc2MvVHJhbnNmb3JtLm1qcyc7XG5leHBvcnQgeyBnZXRSZXNvbHV0aW9uT2ZVcmwgfSBmcm9tICcuL3V0aWxzL25ldHdvcmsvZ2V0UmVzb2x1dGlvbk9mVXJsLm1qcyc7XG5leHBvcnQgeyBwYXRoIH0gZnJvbSAnLi91dGlscy9wYXRoLm1qcyc7XG5leHBvcnQgeyBQb29sIH0gZnJvbSAnLi91dGlscy9wb29sL1Bvb2wubWpzJztcbmV4cG9ydCB7IEJpZ1Bvb2wsIFBvb2xHcm91cENsYXNzIH0gZnJvbSAnLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuZXhwb3J0IHsgVkVSU0lPTiwgc2F5SGVsbG8gfSBmcm9tICcuL3V0aWxzL3NheUhlbGxvLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVhcmN1dCB9IGZyb20gJ2VhcmN1dCc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoYnJvd3NlckV4dCwgd2Vid29ya2VyRXh0KTtcblxuZXhwb3J0IHsgYnJvd3NlckV4dCwgZXh0ZW5zaW9ucywgd2Vid29ya2VyRXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n')},5321:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   y: () => (/* binding */ Matrix)\n/* harmony export */ });\n/* harmony import */ var _misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5502);\n/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1134);\n\n\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(_misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__/* .PI_2 */ ._b - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */\n  equals(matrix) {\n    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\n\n//# sourceMappingURL=Matrix.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyMS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUNFOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLDJCQUEyQiw0REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLDJCQUEyQiw0REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQUk7QUFDckM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21hdHJpeC9NYXRyaXgubWpzPzYyZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUElfMiB9IGZyb20gJy4uL21pc2MvY29uc3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vcG9pbnQvUG9pbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBNYXRyaXgge1xuICAvKipcbiAgICogQHBhcmFtIGEgLSB4IHNjYWxlXG4gICAqIEBwYXJhbSBiIC0geSBza2V3XG4gICAqIEBwYXJhbSBjIC0geCBza2V3XG4gICAqIEBwYXJhbSBkIC0geSBzY2FsZVxuICAgKiBAcGFyYW0gdHggLSB4IHRyYW5zbGF0aW9uXG4gICAqIEBwYXJhbSB0eSAtIHkgdHJhbnNsYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgY3VycmVudCBtYXRyaXguIE9ubHkgcG9wdWxhdGVkIHdoZW4gYHRvQXJyYXlgIGlzIGNhbGxlZCAqL1xuICAgIHRoaXMuYXJyYXkgPSBudWxsO1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy50eCA9IHR4O1xuICAgIHRoaXMudHkgPSB0eTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBhID0gYXJyYXlbMF1cbiAgICogYiA9IGFycmF5WzFdXG4gICAqIGMgPSBhcnJheVszXVxuICAgKiBkID0gYXJyYXlbNF1cbiAgICogdHggPSBhcnJheVsyXVxuICAgKiB0eSA9IGFycmF5WzVdXG4gICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSB0aGF0IHRoZSBtYXRyaXggd2lsbCBiZSBwb3B1bGF0ZWQgZnJvbS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSkge1xuICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xuICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgIHRoaXMudHggPSBhcnJheVsyXTtcbiAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hdHJpeCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gYSAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIGIgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEBwYXJhbSBjIC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gZCAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIHR4IC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gdHkgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBzZXQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYyA9IGM7XG4gICAgdGhpcy5kID0gZDtcbiAgICB0aGlzLnR4ID0gdHg7XG4gICAgdGhpcy50eSA9IHR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gdGhlIGN1cnJlbnQgTWF0cml4IG9iamVjdC5cbiAgICogQHBhcmFtIHRyYW5zcG9zZSAtIFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAgICogQHBhcmFtIFtvdXQ9bmV3IEZsb2F0MzJBcnJheSg5KV0gLSBJZiBwcm92aWRlZCB0aGUgYXJyYXkgd2lsbCBiZSBhc3NpZ25lZCB0byBvdXRcbiAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIG1hdHJpeFxuICAgKi9cbiAgdG9BcnJheSh0cmFuc3Bvc2UsIG91dCkge1xuICAgIGlmICghdGhpcy5hcnJheSkge1xuICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5ID0gb3V0IHx8IHRoaXMuYXJyYXk7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgIGFycmF5WzNdID0gdGhpcy5jO1xuICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICBhcnJheVs1XSA9IDA7XG4gICAgICBhcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICBhcnJheVs3XSA9IHRoaXMudHk7XG4gICAgICBhcnJheVs4XSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgYXJyYXlbMV0gPSB0aGlzLmM7XG4gICAgICBhcnJheVsyXSA9IHRoaXMudHg7XG4gICAgICBhcnJheVszXSA9IHRoaXMuYjtcbiAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgYXJyYXlbNV0gPSB0aGlzLnR5O1xuICAgICAgYXJyYXlbNl0gPSAwO1xuICAgICAgYXJyYXlbN10gPSAwO1xuICAgICAgYXJyYXlbOF0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIHJlbmRlcmluZylcbiAgICogQHBhcmFtIHBvcyAtIFRoZSBvcmlnaW5cbiAgICogQHBhcmFtIHtQb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIG5ldyBwb2ludCwgdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgKi9cbiAgYXBwbHkocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG4gICAgY29uc3QgeCA9IHBvcy54O1xuICAgIGNvbnN0IHkgPSBwb3MueTtcbiAgICBuZXdQb3MueCA9IHRoaXMuYSAqIHggKyB0aGlzLmMgKiB5ICsgdGhpcy50eDtcbiAgICBuZXdQb3MueSA9IHRoaXMuYiAqIHggKyB0aGlzLmQgKiB5ICsgdGhpcy50eTtcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgcG9zaXRpb24gd2l0aCB0aGUgaW52ZXJzZSBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkLlxuICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlIHRvIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiBpbnB1dClcbiAgICogQHBhcmFtIHBvcyAtIFRoZSBvcmlnaW5cbiAgICogQHBhcmFtIHtQb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIG5ldyBwb2ludCwgaW52ZXJzZS10cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XG4gICAqL1xuICBhcHBseUludmVyc2UocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGMgPSB0aGlzLmM7XG4gICAgY29uc3QgZCA9IHRoaXMuZDtcbiAgICBjb25zdCB0eCA9IHRoaXMudHg7XG4gICAgY29uc3QgdHkgPSB0aGlzLnR5O1xuICAgIGNvbnN0IGlkID0gMSAvIChhICogZCArIGMgKiAtYik7XG4gICAgY29uc3QgeCA9IHBvcy54O1xuICAgIGNvbnN0IHkgPSBwb3MueTtcbiAgICBuZXdQb3MueCA9IGQgKiBpZCAqIHggKyAtYyAqIGlkICogeSArICh0eSAqIGMgLSB0eCAqIGQpICogaWQ7XG4gICAgbmV3UG9zLnkgPSBhICogaWQgKiB5ICsgLWIgKiBpZCAqIHggKyAoLXR5ICogYSArIHR4ICogYikgKiBpZDtcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkuXG4gICAqIEBwYXJhbSB4IC0gSG93IG11Y2ggdG8gdHJhbnNsYXRlIHggYnlcbiAgICogQHBhcmFtIHkgLSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeSBieVxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLnR4ICs9IHg7XG4gICAgdGhpcy50eSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cbiAgICogQHBhcmFtIHggLSBUaGUgYW1vdW50IHRvIHNjYWxlIGhvcml6b250YWxseVxuICAgKiBAcGFyYW0geSAtIFRoZSBhbW91bnQgdG8gc2NhbGUgdmVydGljYWxseVxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgc2NhbGUoeCwgeSkge1xuICAgIHRoaXMuYSAqPSB4O1xuICAgIHRoaXMuZCAqPSB5O1xuICAgIHRoaXMuYyAqPSB4O1xuICAgIHRoaXMuYiAqPSB5O1xuICAgIHRoaXMudHggKj0geDtcbiAgICB0aGlzLnR5ICo9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICAgKiBAcGFyYW0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICB0aGlzLmEgPSBhMSAqIGNvcyAtIHRoaXMuYiAqIHNpbjtcbiAgICB0aGlzLmIgPSBhMSAqIHNpbiArIHRoaXMuYiAqIGNvcztcbiAgICB0aGlzLmMgPSBjMSAqIGNvcyAtIHRoaXMuZCAqIHNpbjtcbiAgICB0aGlzLmQgPSBjMSAqIHNpbiArIHRoaXMuZCAqIGNvcztcbiAgICB0aGlzLnR4ID0gdHgxICogY29zIC0gdGhpcy50eSAqIHNpbjtcbiAgICB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBhcHBlbmQobWF0cml4KSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgdGhpcy5hID0gbWF0cml4LmEgKiBhMSArIG1hdHJpeC5iICogYzE7XG4gICAgdGhpcy5iID0gbWF0cml4LmEgKiBiMSArIG1hdHJpeC5iICogZDE7XG4gICAgdGhpcy5jID0gbWF0cml4LmMgKiBhMSArIG1hdHJpeC5kICogYzE7XG4gICAgdGhpcy5kID0gbWF0cml4LmMgKiBiMSArIG1hdHJpeC5kICogZDE7XG4gICAgdGhpcy50eCA9IG1hdHJpeC50eCAqIGExICsgbWF0cml4LnR5ICogYzEgKyB0aGlzLnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0d28gbWF0cml4J3MgYW5kIHNldHMgdGhlIHJlc3VsdCB0byB0aGlzIG1hdHJpeC4gQUIgPSBBICogQlxuICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggdG8gYXBwZW5kLlxuICAgKiBAcGFyYW0gYiAtIFRoZSBtYXRyaXggdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgYXBwZW5kRnJvbShhLCBiKSB7XG4gICAgY29uc3QgYTEgPSBhLmE7XG4gICAgY29uc3QgYjEgPSBhLmI7XG4gICAgY29uc3QgYzEgPSBhLmM7XG4gICAgY29uc3QgZDEgPSBhLmQ7XG4gICAgY29uc3QgdHggPSBhLnR4O1xuICAgIGNvbnN0IHR5ID0gYS50eTtcbiAgICBjb25zdCBhMiA9IGIuYTtcbiAgICBjb25zdCBiMiA9IGIuYjtcbiAgICBjb25zdCBjMiA9IGIuYztcbiAgICBjb25zdCBkMiA9IGIuZDtcbiAgICB0aGlzLmEgPSBhMSAqIGEyICsgYjEgKiBjMjtcbiAgICB0aGlzLmIgPSBhMSAqIGIyICsgYjEgKiBkMjtcbiAgICB0aGlzLmMgPSBjMSAqIGEyICsgZDEgKiBjMjtcbiAgICB0aGlzLmQgPSBjMSAqIGIyICsgZDEgKiBkMjtcbiAgICB0aGlzLnR4ID0gdHggKiBhMiArIHR5ICogYzIgKyBiLnR4O1xuICAgIHRoaXMudHkgPSB0eCAqIGIyICsgdHkgKiBkMiArIGIudHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hdHJpeCBiYXNlZCBvbiBhbGwgdGhlIGF2YWlsYWJsZSBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB4IC0gUG9zaXRpb24gb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0geSAtIFBvc2l0aW9uIG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHBpdm90WCAtIFBpdm90IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHBpdm90WSAtIFBpdm90IG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHNjYWxlWCAtIFNjYWxlIG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHNjYWxlWSAtIFNjYWxlIG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gUm90YXRpb24gaW4gcmFkaWFuc1xuICAgKiBAcGFyYW0gc2tld1ggLSBTa2V3IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHNrZXdZIC0gU2tldyBvbiB0aGUgeSBheGlzXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBzZXRUcmFuc2Zvcm0oeCwgeSwgcGl2b3RYLCBwaXZvdFksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZKSB7XG4gICAgdGhpcy5hID0gTWF0aC5jb3Mocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5jID0gLU1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMuZCA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMudHggPSB4IC0gKHBpdm90WCAqIHRoaXMuYSArIHBpdm90WSAqIHRoaXMuYyk7XG4gICAgdGhpcy50eSA9IHkgLSAocGl2b3RYICogdGhpcy5iICsgcGl2b3RZICogdGhpcy5kKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUHJlcGVuZHMgdGhlIGdpdmVuIE1hdHJpeCB0byB0aGlzIE1hdHJpeC5cbiAgICogQHBhcmFtIG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gcHJlcGVuZFxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgcHJlcGVuZChtYXRyaXgpIHtcbiAgICBjb25zdCB0eDEgPSB0aGlzLnR4O1xuICAgIGlmIChtYXRyaXguYSAhPT0gMSB8fCBtYXRyaXguYiAhPT0gMCB8fCBtYXRyaXguYyAhPT0gMCB8fCBtYXRyaXguZCAhPT0gMSkge1xuICAgICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgICBjb25zdCBjMSA9IHRoaXMuYztcbiAgICAgIHRoaXMuYSA9IGExICogbWF0cml4LmEgKyB0aGlzLmIgKiBtYXRyaXguYztcbiAgICAgIHRoaXMuYiA9IGExICogbWF0cml4LmIgKyB0aGlzLmIgKiBtYXRyaXguZDtcbiAgICAgIHRoaXMuYyA9IGMxICogbWF0cml4LmEgKyB0aGlzLmQgKiBtYXRyaXguYztcbiAgICAgIHRoaXMuZCA9IGMxICogbWF0cml4LmIgKyB0aGlzLmQgKiBtYXRyaXguZDtcbiAgICB9XG4gICAgdGhpcy50eCA9IHR4MSAqIG1hdHJpeC5hICsgdGhpcy50eSAqIG1hdHJpeC5jICsgbWF0cml4LnR4O1xuICAgIHRoaXMudHkgPSB0eDEgKiBtYXRyaXguYiArIHRoaXMudHkgKiBtYXRyaXguZCArIG1hdHJpeC50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVjb21wb3NlcyB0aGUgbWF0cml4ICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgYW5kIHJvdGF0aW9uKSBhbmQgc2V0cyB0aGUgcHJvcGVydGllcyBvbiB0byBhIHRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gdG8gYXBwbHkgdGhlIHByb3BlcnRpZXMgdG8uXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gd2l0aCB0aGUgbmV3bHkgYXBwbGllZCBwcm9wZXJ0aWVzXG4gICAqL1xuICBkZWNvbXBvc2UodHJhbnNmb3JtKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGMgPSB0aGlzLmM7XG4gICAgY29uc3QgZCA9IHRoaXMuZDtcbiAgICBjb25zdCBwaXZvdCA9IHRyYW5zZm9ybS5waXZvdDtcbiAgICBjb25zdCBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcbiAgICBjb25zdCBza2V3WSA9IE1hdGguYXRhbjIoYiwgYSk7XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyhza2V3WCArIHNrZXdZKTtcbiAgICBpZiAoZGVsdGEgPCAxZS01IHx8IE1hdGguYWJzKFBJXzIgLSBkZWx0YSkgPCAxZS01KSB7XG4gICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSBza2V3WTtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnggPSB0cmFuc2Zvcm0uc2tldy55ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtLnJvdGF0aW9uID0gMDtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnggPSBza2V3WDtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnkgPSBza2V3WTtcbiAgICB9XG4gICAgdHJhbnNmb3JtLnNjYWxlLnggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgdHJhbnNmb3JtLnNjYWxlLnkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLnggPSB0aGlzLnR4ICsgKHBpdm90LnggKiBhICsgcGl2b3QueSAqIGMpO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi55ID0gdGhpcy50eSArIChwaXZvdC54ICogYiArIHBpdm90LnkgKiBkKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoaXMgbWF0cml4XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBpbnZlcnQoKSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICBjb25zdCBuID0gYTEgKiBkMSAtIGIxICogYzE7XG4gICAgdGhpcy5hID0gZDEgLyBuO1xuICAgIHRoaXMuYiA9IC1iMSAvIG47XG4gICAgdGhpcy5jID0gLWMxIC8gbjtcbiAgICB0aGlzLmQgPSBhMSAvIG47XG4gICAgdGhpcy50eCA9IChjMSAqIHRoaXMudHkgLSBkMSAqIHR4MSkgLyBuO1xuICAgIHRoaXMudHkgPSAtKGExICogdGhpcy50eSAtIGIxICogdHgxKSAvIG47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIENoZWNrcyBpZiB0aGlzIG1hdHJpeCBpcyBhbiBpZGVudGl0eSBtYXRyaXggKi9cbiAgaXNJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5hID09PSAxICYmIHRoaXMuYiA9PT0gMCAmJiB0aGlzLmMgPT09IDAgJiYgdGhpcy5kID09PSAxICYmIHRoaXMudHggPT09IDAgJiYgdGhpcy50eSA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgTWF0cml4IHRvIGFuIGlkZW50aXR5IChkZWZhdWx0KSBtYXRyaXguXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBpZGVudGl0eSgpIHtcbiAgICB0aGlzLmEgPSAxO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5jID0gMDtcbiAgICB0aGlzLmQgPSAxO1xuICAgIHRoaXMudHggPSAwO1xuICAgIHRoaXMudHkgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiB0aGlzIG1hdHJpeFxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IGdpdmVuIGluIHBhcmFtZXRlciB3aXRoIGl0cyB2YWx1ZXMgdXBkYXRlZC5cbiAgICovXG4gIGNvcHlUbyhtYXRyaXgpIHtcbiAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICBtYXRyaXguYyA9IHRoaXMuYztcbiAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgIG1hdHJpeC50eSA9IHRoaXMudHk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gZ2l2ZW4gbWF0cml4XG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgdGhpc1xuICAgKi9cbiAgY29weUZyb20obWF0cml4KSB7XG4gICAgdGhpcy5hID0gbWF0cml4LmE7XG4gICAgdGhpcy5iID0gbWF0cml4LmI7XG4gICAgdGhpcy5jID0gbWF0cml4LmM7XG4gICAgdGhpcy5kID0gbWF0cml4LmQ7XG4gICAgdGhpcy50eCA9IG1hdHJpeC50eDtcbiAgICB0aGlzLnR5ID0gbWF0cml4LnR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBjaGVjayB0byBzZWUgaWYgdHdvIG1hdHJpY2VzIGFyZSB0aGUgc2FtZVxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb21wYXJlIHRvLlxuICAgKi9cbiAgZXF1YWxzKG1hdHJpeCkge1xuICAgIHJldHVybiBtYXRyaXguYSA9PT0gdGhpcy5hICYmIG1hdHJpeC5iID09PSB0aGlzLmIgJiYgbWF0cml4LmMgPT09IHRoaXMuYyAmJiBtYXRyaXguZCA9PT0gdGhpcy5kICYmIG1hdHJpeC50eCA9PT0gdGhpcy50eCAmJiBtYXRyaXgudHkgPT09IHRoaXMudHk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbcGl4aS5qczpNYXRyaXggYT0ke3RoaXMuYX0gYj0ke3RoaXMuYn0gYz0ke3RoaXMuY30gZD0ke3RoaXMuZH0gdHg9JHt0aGlzLnR4fSB0eT0ke3RoaXMudHl9XWA7XG4gIH1cbiAgLyoqXG4gICAqIEEgZGVmYXVsdCAoaWRlbnRpdHkpIG1hdHJpeC5cbiAgICpcbiAgICogVGhpcyBpcyBhIHNoYXJlZCBvYmplY3QsIGlmIHlvdSB3YW50IHRvIG1vZGlmeSBpdCBjb25zaWRlciBjcmVhdGluZyBhIG5ldyBgTWF0cml4YFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHN0YXRpYyBnZXQgSURFTlRJVFkoKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5TWF0cml4LmlkZW50aXR5KCk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3RhdGljIE1hdHJpeCB0aGF0IGNhbiBiZSB1c2VkIHRvIGF2b2lkIGNyZWF0aW5nIG5ldyBvYmplY3RzLlxuICAgKiBXaWxsIGFsd2F5cyBlbnN1cmUgdGhlIG1hdHJpeCBpcyByZXNldCB0byBpZGVudGl0eSB3aGVuIHJlcXVlc3RlZC5cbiAgICogVXNlIHRoaXMgb2JqZWN0IGZvciBmYXN0IGJ1dCB0ZW1wb3JhcnkgY2FsY3VsYXRpb25zLCBhcyBpdCBtYXkgYmUgbXV0YXRlZCBsYXRlciBvbi5cbiAgICogVGhpcyBpcyBhIGRpZmZlcmVudCBvYmplY3QgdG8gdGhlIGBJREVOVElUWWAgb2JqZWN0IGFuZCBzbyBjYW4gYmUgbW9kaWZpZWQgd2l0aG91dCBjaGFuZ2luZyBgSURFTlRJVFlgLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHN0YXRpYyBnZXQgc2hhcmVkKCkge1xuICAgIHJldHVybiB0ZW1wTWF0cml4LmlkZW50aXR5KCk7XG4gIH1cbn1cbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jb25zdCBpZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblxuZXhwb3J0IHsgTWF0cml4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRyaXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5321\n")},5502:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZX: () => (/* binding */ DEG_TO_RAD),\n/* harmony export */   _b: () => (/* binding */ PI_2),\n/* harmony export */   jl: () => (/* binding */ RAD_TO_DEG)\n/* harmony export */ });\n\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUwMi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9taXNjL2NvbnN0Lm1qcz9jMTNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgUElfMiA9IE1hdGguUEkgKiAyO1xuY29uc3QgUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5jb25zdCBERUdfVE9fUkFEID0gTWF0aC5QSSAvIDE4MDtcblxuZXhwb3J0IHsgREVHX1RPX1JBRCwgUElfMiwgUkFEX1RPX0RFRyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5502\n")},4181:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a9: () => (/* binding */ nextPow2),\n/* harmony export */   wv: () => (/* binding */ isPow2)\n/* harmony export */ });\n/* unused harmony export log2 */\n\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\n\n//# sourceMappingURL=pow2.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9taXNjL3BvdzIubWpzPzk5NWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBuZXh0UG93Mih2KSB7XG4gIHYgKz0gdiA9PT0gMCA/IDEgOiAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuZnVuY3Rpb24gaXNQb3cyKHYpIHtcbiAgcmV0dXJuICEodiAmIHYgLSAxKSAmJiAhIXY7XG59XG5mdW5jdGlvbiBsb2cyKHYpIHtcbiAgbGV0IHIgPSAodiA+IDY1NTM1ID8gMSA6IDApIDw8IDQ7XG4gIHYgPj4+PSByO1xuICBsZXQgc2hpZnQgPSAodiA+IDI1NSA/IDEgOiAwKSA8PCAzO1xuICB2ID4+Pj0gc2hpZnQ7XG4gIHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAxNSA/IDEgOiAwKSA8PCAyO1xuICB2ID4+Pj0gc2hpZnQ7XG4gIHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAzID8gMSA6IDApIDw8IDE7XG4gIHYgPj4+PSBzaGlmdDtcbiAgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCB2ID4+IDE7XG59XG5cbmV4cG9ydCB7IGlzUG93MiwgbG9nMiwgbmV4dFBvdzIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvdzIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4181\n")},4973:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ObservablePoint)\n/* harmony export */ });\n\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ObservablePoint.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEdBQUcsSUFBSSxHQUFHLFFBQVEsZUFBZTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcz9mMzUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgT2JzZXJ2YWJsZVBvaW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYE9ic2VydmFibGVQb2ludGBcbiAgICogQHBhcmFtIG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gcGFzcyB0byBsaXN0ZW4gZm9yIGNoYW5nZSBldmVudHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgeCwgeSkge1xuICAgIHRoaXMuX3ggPSB4IHx8IDA7XG4gICAgdGhpcy5feSA9IHkgfHwgMDtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG9ic2VydmVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIG9ic2VydmVyIC0gT3B0aW9uYWwgb2JzZXJ2ZXIgdG8gcGFzcyB0byB0aGUgbmV3IG9ic2VydmFibGUgcG9pbnQuXG4gICAqIEByZXR1cm5zIGEgY29weSBvZiB0aGlzIG9ic2VydmFibGUgcG9pbnRcbiAgICovXG4gIGNsb25lKG9ic2VydmVyKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUG9pbnQob2JzZXJ2ZXIgPz8gdGhpcy5fb2JzZXJ2ZXIsIHRoaXMuX3gsIHRoaXMuX3kpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyBgeGAgYW5kIGB5YCBwb3NpdGlvbi5cbiAgICogSWYgYHlgIGlzIG9taXR0ZWQsIGJvdGggYHhgIGFuZCBgeWAgd2lsbCBiZSBzZXQgdG8gYHhgLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9eF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgKiBAcmV0dXJucyBUaGUgb2JzZXJ2YWJsZSBwb2ludCBpbnN0YW5jZSBpdHNlbGZcbiAgICovXG4gIHNldCh4ID0gMCwgeSA9IHgpIHtcbiAgICBpZiAodGhpcy5feCAhPT0geCB8fCB0aGlzLl95ICE9PSB5KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuX29uVXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHggYW5kIHkgZnJvbSB0aGUgZ2l2ZW4gcG9pbnQgKGBwYClcbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY29weSBmcm9tLiBDYW4gYmUgYW55IG9mIHR5cGUgdGhhdCBpcyBvciBleHRlbmRzIGBQb2ludERhdGFgXG4gICAqIEByZXR1cm5zIFRoZSBvYnNlcnZhYmxlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgY29weUZyb20ocCkge1xuICAgIGlmICh0aGlzLl94ICE9PSBwLnggfHwgdGhpcy5feSAhPT0gcC55KSB7XG4gICAgICB0aGlzLl94ID0gcC54O1xuICAgICAgdGhpcy5feSA9IHAueTtcbiAgICAgIHRoaXMuX29ic2VydmVyLl9vblVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHBvaW50J3MgeCBhbmQgeSBpbnRvIHRoYXQgb2YgdGhlIGdpdmVuIHBvaW50IChgcGApXG4gICAqIEBwYXJhbSBwIC0gVGhlIHBvaW50IHRvIGNvcHkgdG8uIENhbiBiZSBhbnkgb2YgdHlwZSB0aGF0IGlzIG9yIGV4dGVuZHMgYFBvaW50RGF0YWBcbiAgICogQHJldHVybnMgVGhlIHBvaW50IChgcGApIHdpdGggdmFsdWVzIHVwZGF0ZWRcbiAgICovXG4gIGNvcHlUbyhwKSB7XG4gICAgcC5zZXQodGhpcy5feCwgdGhpcy5feSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VwdHMgYW5vdGhlciBwb2ludCAoYHBgKSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGVxdWFsIHRvIHRoaXMgcG9pbnRcbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMgUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBgeGAgYW5kIGB5YCBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhwKSB7XG4gICAgcmV0dXJuIHAueCA9PT0gdGhpcy5feCAmJiBwLnkgPT09IHRoaXMuX3k7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbcGl4aS5qcy9tYXRoOk9ic2VydmFibGVQb2ludCB4PSR7MH0geT0kezB9IHNjb3BlPSR7dGhpcy5fb2JzZXJ2ZXJ9XWA7XG4gIH1cbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHBvaW50IG9uIHRoZSB4IGF4aXMuICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLl94O1xuICB9XG4gIHNldCB4KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3ggIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICB0aGlzLl9vYnNlcnZlci5fb25VcGRhdGUodGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBwb2ludCBvbiB0aGUgeSBheGlzLiAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5feTtcbiAgfVxuICBzZXQgeSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl95ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuX29uVXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBPYnNlcnZhYmxlUG9pbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVQb2ludC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4973\n")},1134:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ Point)\n/* harmony export */ });\n\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\n\n//# sourceMappingURL=Point.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsSUFBSSxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWF0aHMvcG9pbnQvUG9pbnQubWpzP2UwYzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBQb2ludCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBQb2ludGBcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCkge1xuICAgIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpcyAqL1xuICAgIHRoaXMueCA9IDA7XG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzICovXG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvaW50XG4gICAqIEByZXR1cm5zIEEgY2xvbmUgb2YgdGhpcyBwb2ludFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBgeGAgYW5kIGB5YCBmcm9tIHRoZSBnaXZlbiBwb2ludCBpbnRvIHRoaXMgcG9pbnRcbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY29weSBmcm9tXG4gICAqIEByZXR1cm5zIFRoZSBwb2ludCBpbnN0YW5jZSBpdHNlbGZcbiAgICovXG4gIGNvcHlGcm9tKHApIHtcbiAgICB0aGlzLnNldChwLngsIHAueSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHBvaW50J3MgeCBhbmQgeSBpbnRvIHRoZSBnaXZlbiBwb2ludCAoYHBgKS5cbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY29weSB0by4gQ2FuIGJlIGFueSBvZiB0eXBlIHRoYXQgaXMgb3IgZXh0ZW5kcyBgUG9pbnREYXRhYFxuICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgKGBwYCkgd2l0aCB2YWx1ZXMgdXBkYXRlZFxuICAgKi9cbiAgY29weVRvKHApIHtcbiAgICBwLnNldCh0aGlzLngsIHRoaXMueSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VwdHMgYW5vdGhlciBwb2ludCAoYHBgKSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGVxdWFsIHRvIHRoaXMgcG9pbnRcbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMgUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBgeGAgYW5kIGB5YCBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhwKSB7XG4gICAgcmV0dXJuIHAueCA9PT0gdGhpcy54ICYmIHAueSA9PT0gdGhpcy55O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyBgeGAgYW5kIGB5YCBwb3NpdGlvbi5cbiAgICogSWYgYHlgIGlzIG9taXR0ZWQsIGJvdGggYHhgIGFuZCBgeWAgd2lsbCBiZSBzZXQgdG8gYHhgLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIGB4YCBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT14XSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgYHlgIGF4aXNcbiAgICogQHJldHVybnMgVGhlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgc2V0KHggPSAwLCB5ID0geCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6UG9pbnQgeD0ke3RoaXMueH0geT0ke3RoaXMueX1dYDtcbiAgfVxuICAvKipcbiAgICogQSBzdGF0aWMgUG9pbnQgb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgdmFsdWVzIG9mIGAwYC4gQ2FuIGJlIHVzZWQgdG8gYXZvaWQgY3JlYXRpbmcgbmV3IG9iamVjdHMgbXVsdGlwbGUgdGltZXMuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBzaGFyZWQoKSB7XG4gICAgdGVtcFBvaW50LnggPSAwO1xuICAgIHRlbXBQb2ludC55ID0gMDtcbiAgICByZXR1cm4gdGVtcFBvaW50O1xuICB9XG59XG5jb25zdCB0ZW1wUG9pbnQgPSBuZXcgUG9pbnQoKTtcblxuZXhwb3J0IHsgUG9pbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1134\n")},3904:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1134);\n\n\n"use strict";\nconst tempPoints = [new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'rectangle\'\n     */\n    this.type = "rectangle";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can\'t intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Rectangle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkwNC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTJDOztBQUUzQztBQUNBLHdCQUF3Qiw0REFBSyxRQUFRLDREQUFLLFFBQVEsNERBQUssUUFBUSw0REFBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUywrRUFBK0U7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxRQUFRLFFBQVEsWUFBWSxTQUFTLFlBQVk7QUFDckc7QUFDQTs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanM/ODBiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL3BvaW50L1BvaW50Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcFBvaW50cyA9IFtuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIG5ldyBQb2ludCgpLCBuZXcgUG9pbnQoKV07XG5jbGFzcyBSZWN0YW5nbGUge1xuICAvKipcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgb3ZlcmFsbCB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgb3ZlcmFsbCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICogQGRlZmF1bHQgJ3JlY3RhbmdsZSdcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInJlY3RhbmdsZVwiO1xuICAgIHRoaXMueCA9IE51bWJlcih4KTtcbiAgICB0aGlzLnkgPSBOdW1iZXIoeSk7XG4gICAgdGhpcy53aWR0aCA9IE51bWJlcih3aWR0aCk7XG4gICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIoaGVpZ2h0KTtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgbGVmdCBlZGdlIG9mIHRoZSByZWN0YW5nbGUuICovXG4gIGdldCBsZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLng7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSB0b3AgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlLiAqL1xuICBnZXQgdG9wKCkge1xuICAgIHJldHVybiB0aGlzLnk7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSByZWN0YW5nbGUuICovXG4gIGdldCBib3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICB9XG4gIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFJlY3RhbmdsZSBpcyBlbXB0eS4gKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0ID09PSB0aGlzLnJpZ2h0IHx8IHRoaXMudG9wID09PSB0aGlzLmJvdHRvbTtcbiAgfVxuICAvKiogQSBjb25zdGFudCBlbXB0eSByZWN0YW5nbGUuIFRoaXMgaXMgYSBuZXcgb2JqZWN0IGV2ZXJ5IHRpbWUgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkICovXG4gIHN0YXRpYyBnZXQgRU1QVFkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCwgMCwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJlY3RhbmdsZVxuICAgKiBAcmV0dXJucyBhIGNvcHkgb2YgdGhlIHJlY3RhbmdsZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBCb3VuZHMgb2JqZWN0IHRvIGEgUmVjdGFuZ2xlIG9iamVjdC5cbiAgICogQHBhcmFtIGJvdW5kcyAtIFRoZSBib3VuZHMgdG8gY29weSBhbmQgY29udmVydCB0byBhIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjb3B5RnJvbUJvdW5kcyhib3VuZHMpIHtcbiAgICB0aGlzLnggPSBib3VuZHMubWluWDtcbiAgICB0aGlzLnkgPSBib3VuZHMubWluWTtcbiAgICB0aGlzLndpZHRoID0gYm91bmRzLm1heFggLSBib3VuZHMubWluWDtcbiAgICB0aGlzLmhlaWdodCA9IGJvdW5kcy5tYXhZIC0gYm91bmRzLm1pblk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIHJlY3RhbmdsZSB0byB0aGlzIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKHJlY3RhbmdsZSkge1xuICAgIHRoaXMueCA9IHJlY3RhbmdsZS54O1xuICAgIHRoaXMueSA9IHJlY3RhbmdsZS55O1xuICAgIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSByZWN0YW5nbGUuaGVpZ2h0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhpcyByZWN0YW5nbGUgdG8gYW5vdGhlciBvbmUuXG4gICAqIEBwYXJhbSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgdG8uXG4gICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gcGFyYW1ldGVyLlxuICAgKi9cbiAgY29weVRvKHJlY3RhbmdsZSkge1xuICAgIHJlY3RhbmdsZS5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDwgdGhpcy54ICsgdGhpcy53aWR0aCkge1xuICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3RhbmdsZSBpbmNsdWRpbmcgdGhlIHN0cm9rZS5cbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gc3Ryb2tlV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGxpbmUgdG8gY2hlY2tcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyByZWN0YW5nbGVcbiAgICovXG4gIHN0cm9rZUNvbnRhaW5zKHgsIHksIHN0cm9rZVdpZHRoKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IF94ID0gdGhpcy54O1xuICAgIGNvbnN0IF95ID0gdGhpcy55O1xuICAgIGNvbnN0IG91dGVyTGVmdCA9IF94IC0gc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IG91dGVyUmlnaHQgPSBfeCArIHdpZHRoICsgc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IG91dGVyVG9wID0gX3kgLSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3Qgb3V0ZXJCb3R0b20gPSBfeSArIGhlaWdodCArIHN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBpbm5lckxlZnQgPSBfeCArIHN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBpbm5lclJpZ2h0ID0gX3ggKyB3aWR0aCAtIHN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBpbm5lclRvcCA9IF95ICsgc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IGlubmVyQm90dG9tID0gX3kgKyBoZWlnaHQgLSBzdHJva2VXaWR0aCAvIDI7XG4gICAgcmV0dXJuIHggPj0gb3V0ZXJMZWZ0ICYmIHggPD0gb3V0ZXJSaWdodCAmJiB5ID49IG91dGVyVG9wICYmIHkgPD0gb3V0ZXJCb3R0b20gJiYgISh4ID4gaW5uZXJMZWZ0ICYmIHggPCBpbm5lclJpZ2h0ICYmIHkgPiBpbm5lclRvcCAmJiB5IDwgaW5uZXJCb3R0b20pO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGBvdGhlcmAgUmVjdGFuZ2xlIHRyYW5zZm9ybWVkIGJ5IGB0cmFuc2Zvcm1gIGludGVyc2VjdHMgd2l0aCBgdGhpc2AgUmVjdGFuZ2xlIG9iamVjdC5cbiAgICogUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIGFyZWEgb2YgdGhlIGludGVyc2VjdGlvbiBpcyA+MCwgdGhpcyBtZWFucyB0aGF0IFJlY3RhbmdsZXNcbiAgICogc2hhcmluZyBhIHNpZGUgYXJlIG5vdCBvdmVybGFwcGluZy4gQW5vdGhlciBzaWRlIGVmZmVjdCBpcyB0aGF0IGFuIGFyZWFsZXNzIHJlY3RhbmdsZVxuICAgKiAod2lkdGggb3IgaGVpZ2h0IGVxdWFsIHRvIHplcm8pIGNhbid0IGludGVyc2VjdCBhbnkgb3RoZXIgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gb3RoZXIgLSBUaGUgUmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIGB0aGlzYC5cbiAgICogQHBhcmFtIHtNYXRyaXh9IHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgYG90aGVyYC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IEEgdmFsdWUgb2YgYHRydWVgIGlmIHRoZSB0cmFuc2Zvcm1lZCBgb3RoZXJgIFJlY3RhbmdsZSBpbnRlcnNlY3RzIHdpdGggYHRoaXNgOyBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIGludGVyc2VjdHMob3RoZXIsIHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCB4MDIgPSB0aGlzLnggPCBvdGhlci54ID8gb3RoZXIueCA6IHRoaXMueDtcbiAgICAgIGNvbnN0IHgxMiA9IHRoaXMucmlnaHQgPiBvdGhlci5yaWdodCA/IG90aGVyLnJpZ2h0IDogdGhpcy5yaWdodDtcbiAgICAgIGlmICh4MTIgPD0geDAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHkwMiA9IHRoaXMueSA8IG90aGVyLnkgPyBvdGhlci55IDogdGhpcy55O1xuICAgICAgY29uc3QgeTEyID0gdGhpcy5ib3R0b20gPiBvdGhlci5ib3R0b20gPyBvdGhlci5ib3R0b20gOiB0aGlzLmJvdHRvbTtcbiAgICAgIHJldHVybiB5MTIgPiB5MDI7XG4gICAgfVxuICAgIGNvbnN0IHgwID0gdGhpcy5sZWZ0O1xuICAgIGNvbnN0IHgxID0gdGhpcy5yaWdodDtcbiAgICBjb25zdCB5MCA9IHRoaXMudG9wO1xuICAgIGNvbnN0IHkxID0gdGhpcy5ib3R0b207XG4gICAgaWYgKHgxIDw9IHgwIHx8IHkxIDw9IHkwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGx0ID0gdGVtcFBvaW50c1swXS5zZXQob3RoZXIubGVmdCwgb3RoZXIudG9wKTtcbiAgICBjb25zdCBsYiA9IHRlbXBQb2ludHNbMV0uc2V0KG90aGVyLmxlZnQsIG90aGVyLmJvdHRvbSk7XG4gICAgY29uc3QgcnQgPSB0ZW1wUG9pbnRzWzJdLnNldChvdGhlci5yaWdodCwgb3RoZXIudG9wKTtcbiAgICBjb25zdCByYiA9IHRlbXBQb2ludHNbM10uc2V0KG90aGVyLnJpZ2h0LCBvdGhlci5ib3R0b20pO1xuICAgIGlmIChydC54IDw9IGx0LnggfHwgbGIueSA8PSBsdC55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHMgPSBNYXRoLnNpZ24odHJhbnNmb3JtLmEgKiB0cmFuc2Zvcm0uZCAtIHRyYW5zZm9ybS5iICogdHJhbnNmb3JtLmMpO1xuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyYW5zZm9ybS5hcHBseShsdCwgbHQpO1xuICAgIHRyYW5zZm9ybS5hcHBseShsYiwgbGIpO1xuICAgIHRyYW5zZm9ybS5hcHBseShydCwgcnQpO1xuICAgIHRyYW5zZm9ybS5hcHBseShyYiwgcmIpO1xuICAgIGlmIChNYXRoLm1heChsdC54LCBsYi54LCBydC54LCByYi54KSA8PSB4MCB8fCBNYXRoLm1pbihsdC54LCBsYi54LCBydC54LCByYi54KSA+PSB4MSB8fCBNYXRoLm1heChsdC55LCBsYi55LCBydC55LCByYi55KSA8PSB5MCB8fCBNYXRoLm1pbihsdC55LCBsYi55LCBydC55LCByYi55KSA+PSB5MSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBueCA9IHMgKiAobGIueSAtIGx0LnkpO1xuICAgIGNvbnN0IG55ID0gcyAqIChsdC54IC0gbGIueCk7XG4gICAgY29uc3QgbjAwID0gbnggKiB4MCArIG55ICogeTA7XG4gICAgY29uc3QgbjEwID0gbnggKiB4MSArIG55ICogeTA7XG4gICAgY29uc3QgbjAxID0gbnggKiB4MCArIG55ICogeTE7XG4gICAgY29uc3QgbjExID0gbnggKiB4MSArIG55ICogeTE7XG4gICAgaWYgKE1hdGgubWF4KG4wMCwgbjEwLCBuMDEsIG4xMSkgPD0gbnggKiBsdC54ICsgbnkgKiBsdC55IHx8IE1hdGgubWluKG4wMCwgbjEwLCBuMDEsIG4xMSkgPj0gbnggKiByYi54ICsgbnkgKiByYi55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG14ID0gcyAqIChsdC55IC0gcnQueSk7XG4gICAgY29uc3QgbXkgPSBzICogKHJ0LnggLSBsdC54KTtcbiAgICBjb25zdCBtMDAgPSBteCAqIHgwICsgbXkgKiB5MDtcbiAgICBjb25zdCBtMTAgPSBteCAqIHgxICsgbXkgKiB5MDtcbiAgICBjb25zdCBtMDEgPSBteCAqIHgwICsgbXkgKiB5MTtcbiAgICBjb25zdCBtMTEgPSBteCAqIHgxICsgbXkgKiB5MTtcbiAgICBpZiAoTWF0aC5tYXgobTAwLCBtMTAsIG0wMSwgbTExKSA8PSBteCAqIGx0LnggKyBteSAqIGx0LnkgfHwgTWF0aC5taW4obTAwLCBtMTAsIG0wMSwgbTExKSA+PSBteCAqIHJiLnggKyBteSAqIHJiLnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFBhZHMgdGhlIHJlY3RhbmdsZSBtYWtpbmcgaXQgZ3JvdyBpbiBhbGwgZGlyZWN0aW9ucy5cbiAgICogSWYgcGFkZGluZ1kgaXMgb21pdHRlZCwgYm90aCBwYWRkaW5nWCBhbmQgcGFkZGluZ1kgd2lsbCBiZSBzZXQgdG8gcGFkZGluZ1guXG4gICAqIEBwYXJhbSBwYWRkaW5nWCAtIFRoZSBob3Jpem9udGFsIHBhZGRpbmcgYW1vdW50LlxuICAgKiBAcGFyYW0gcGFkZGluZ1kgLSBUaGUgdmVydGljYWwgcGFkZGluZyBhbW91bnQuXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgcGFkKHBhZGRpbmdYID0gMCwgcGFkZGluZ1kgPSBwYWRkaW5nWCkge1xuICAgIHRoaXMueCAtPSBwYWRkaW5nWDtcbiAgICB0aGlzLnkgLT0gcGFkZGluZ1k7XG4gICAgdGhpcy53aWR0aCArPSBwYWRkaW5nWCAqIDI7XG4gICAgdGhpcy5oZWlnaHQgKz0gcGFkZGluZ1kgKiAyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBGaXRzIHRoaXMgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgcGFzc2VkIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gZml0LlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGZpdChyZWN0YW5nbGUpIHtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdGFuZ2xlLngpO1xuICAgIGNvbnN0IHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0YW5nbGUueSk7XG4gICAgY29uc3QgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB0aGlzLnggPSB4MTtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoeDIgLSB4MSwgMCk7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh5MiAtIHkxLCAwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRW5sYXJnZXMgcmVjdGFuZ2xlIHRoYXQgd2F5IGl0cyBjb3JuZXJzIGxpZSBvbiBncmlkXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gcmVzb2x1dGlvblxuICAgKiBAcGFyYW0gZXBzIC0gcHJlY2lzaW9uXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgY2VpbChyZXNvbHV0aW9uID0gMSwgZXBzID0gMWUtMykge1xuICAgIGNvbnN0IHgyID0gTWF0aC5jZWlsKCh0aGlzLnggKyB0aGlzLndpZHRoIC0gZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICBjb25zdCB5MiA9IE1hdGguY2VpbCgodGhpcy55ICsgdGhpcy5oZWlnaHQgLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIHRoaXMueCA9IE1hdGguZmxvb3IoKHRoaXMueCArIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vcigodGhpcy55ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLndpZHRoID0geDIgLSB0aGlzLng7XG4gICAgdGhpcy5oZWlnaHQgPSB5MiAtIHRoaXMueTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRW5sYXJnZXMgdGhpcyByZWN0YW5nbGUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gaW5jbHVkZS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBlbmxhcmdlKHJlY3RhbmdsZSkge1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0YW5nbGUueCk7XG4gICAgY29uc3QgeDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3RhbmdsZS55KTtcbiAgICBjb25zdCB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuICAgIHRoaXMueCA9IHgxO1xuICAgIHRoaXMud2lkdGggPSB4MiAtIHgxO1xuICAgIHRoaXMueSA9IHkxO1xuICAgIHRoaXMuaGVpZ2h0ID0geTIgLSB5MTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIHJlY3RhbmdsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICogQHBhcmFtIG91dCAtIG9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAqIEByZXR1cm5zIFRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cbiAgZ2V0Qm91bmRzKG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgb3V0LmNvcHlGcm9tKHRoaXMpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbcGl4aS5qcy9tYXRoOlJlY3RhbmdsZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSB3aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fV1gO1xuICB9XG59XG5cbmV4cG9ydCB7IFJlY3RhbmdsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVjdGFuZ2xlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3904\n')},5267:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  N: () => (/* binding */ getMaxTexturesPerBatch)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs\nvar getTestContext = __webpack_require__(8407);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs\n\nconst fragTemplate = [\n  "precision mediump float;",\n  "void main(void){",\n  "float test = 0.1;",\n  "%forloop%",\n  "gl_FragColor = vec4(0.0);",\n  "}"\n].join("\\n");\nfunction generateIfTestSrc(maxIfs) {\n  let src = "";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += "\\nelse ";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  try {\n    while (true) {\n      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n      gl.shaderSource(shader, fragmentSrc);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        maxIfs = maxIfs / 2 | 0;\n      } else {\n        break;\n      }\n    }\n  } finally {\n    gl.deleteShader(shader);\n  }\n  return maxIfs;\n}\n\n\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs\n\n\n\n"use strict";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache)\n    return maxTexturesPerBatchCache;\n  const gl = (0,getTestContext/* getTestContext */.K)();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  gl.getExtension("WEBGL_lose_context")?.loseContext();\n  return maxTexturesPerBatchCache;\n}\n\n\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI2Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0EsMkJBQTJCO0FBQzNCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQSw0QkFBNEI7QUFDNUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUUsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRXdDO0FBQ3hDOzs7QUM1Q3lGO0FBQ1A7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdDQUFjO0FBQzNCO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9iYXRjaGVyL2dsL3V0aWxzL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIubWpzPzhiZDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9iYXRjaGVyL2dsL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzPzVkNDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBmcmFnVGVtcGxhdGUgPSBbXG4gIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXG4gIFwidm9pZCBtYWluKHZvaWQpe1wiLFxuICBcImZsb2F0IHRlc3QgPSAwLjE7XCIsXG4gIFwiJWZvcmxvb3AlXCIsXG4gIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1wiLFxuICBcIn1cIlxuXS5qb2luKFwiXFxuXCIpO1xuZnVuY3Rpb24gZ2VuZXJhdGVJZlRlc3RTcmMobWF4SWZzKSB7XG4gIGxldCBzcmMgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heElmczsgKytpKSB7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBzcmMgKz0gXCJcXG5lbHNlIFwiO1xuICAgIH1cbiAgICBpZiAoaSA8IG1heElmcyAtIDEpIHtcbiAgICAgIHNyYyArPSBgaWYodGVzdCA9PSAke2l9LjApe31gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3JjO1xufVxuZnVuY3Rpb24gY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcihtYXhJZnMsIGdsKSB7XG4gIGlmIChtYXhJZnMgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIG9mIGAwYCBwYXNzZWQgdG8gYGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXJgXCIpO1xuICB9XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBmcmFnbWVudFNyYyA9IGZyYWdUZW1wbGF0ZS5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIGdlbmVyYXRlSWZUZXN0U3JjKG1heElmcykpO1xuICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgZnJhZ21lbnRTcmMpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgbWF4SWZzID0gbWF4SWZzIC8gMiB8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gIH1cbiAgcmV0dXJuIG1heElmcztcbn1cblxuZXhwb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBnZXRUZXN0Q29udGV4dCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmVycy9nbC9zaGFkZXIvcHJvZ3JhbS9nZXRUZXN0Q29udGV4dC5tanMnO1xuaW1wb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9IGZyb20gJy4vY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBtYXhUZXh0dXJlc1BlckJhdGNoQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0TWF4VGV4dHVyZXNQZXJCYXRjaCgpIHtcbiAgaWYgKG1heFRleHR1cmVzUGVyQmF0Y2hDYWNoZSlcbiAgICByZXR1cm4gbWF4VGV4dHVyZXNQZXJCYXRjaENhY2hlO1xuICBjb25zdCBnbCA9IGdldFRlc3RDb250ZXh0KCk7XG4gIG1heFRleHR1cmVzUGVyQmF0Y2hDYWNoZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gIG1heFRleHR1cmVzUGVyQmF0Y2hDYWNoZSA9IGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIoXG4gICAgbWF4VGV4dHVyZXNQZXJCYXRjaENhY2hlLFxuICAgIGdsXG4gICk7XG4gIGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKT8ubG9zZUNvbnRleHQoKTtcbiAgcmV0dXJuIG1heFRleHR1cmVzUGVyQmF0Y2hDYWNoZTtcbn1cblxuZXhwb3J0IHsgZ2V0TWF4VGV4dHVyZXNQZXJCYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5267\n')},3018:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ getTextureBatchBindGroup)\n/* harmony export */ });\n/* harmony import */ var _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9818);\n/* harmony import */ var _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5267);\n\n\n\n\n"use strict";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 2166136261;\n  for (let i = 0; i < size; i++) {\n    uid ^= textures[i].uid;\n    uid = Math.imul(uid, 16777619);\n    uid >>>= 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\nlet maxTextures = 0;\nfunction generateTextureBatchBindGroup(textures, size, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  if (!maxTextures)\n    maxTextures = (0,_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__/* .getMaxTexturesPerBatch */ .N)();\n  for (let i = 0; i < maxTextures; i++) {\n    const texture = i < size ? textures[i] : _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .v(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\n\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAxOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUU7QUFDQTtBQUNXOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUdBQXNCO0FBQ3hDLGtCQUFrQixpQkFBaUI7QUFDbkMsNkNBQTZDLG1GQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRkFBUztBQUNqQztBQUNBO0FBQ0E7O0FBRW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9iYXRjaGVyL2dwdS9nZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAubWpzPzM2MjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2dwdS9zaGFkZXIvQmluZEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IGdldE1heFRleHR1cmVzUGVyQmF0Y2ggfSBmcm9tICcuLi9nbC91dGlscy9tYXhSZWNvbW1lbmRlZFRleHR1cmVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgY2FjaGVkR3JvdXBzID0ge307XG5mdW5jdGlvbiBnZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHNpemUpIHtcbiAgbGV0IHVpZCA9IDIxNjYxMzYyNjE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdWlkIF49IHRleHR1cmVzW2ldLnVpZDtcbiAgICB1aWQgPSBNYXRoLmltdWwodWlkLCAxNjc3NzYxOSk7XG4gICAgdWlkID4+Pj0gMDtcbiAgfVxuICByZXR1cm4gY2FjaGVkR3JvdXBzW3VpZF0gfHwgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHNpemUsIHVpZCk7XG59XG5sZXQgbWF4VGV4dHVyZXMgPSAwO1xuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHNpemUsIGtleSkge1xuICBjb25zdCBiaW5kR3JvdXBSZXNvdXJjZXMgPSB7fTtcbiAgbGV0IGJpbmRJbmRleCA9IDA7XG4gIGlmICghbWF4VGV4dHVyZXMpXG4gICAgbWF4VGV4dHVyZXMgPSBnZXRNYXhUZXh0dXJlc1BlckJhdGNoKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgIGNvbnN0IHRleHR1cmUgPSBpIDwgc2l6ZSA/IHRleHR1cmVzW2ldIDogVGV4dHVyZS5FTVBUWS5zb3VyY2U7XG4gICAgYmluZEdyb3VwUmVzb3VyY2VzW2JpbmRJbmRleCsrXSA9IHRleHR1cmUuc291cmNlO1xuICAgIGJpbmRHcm91cFJlc291cmNlc1tiaW5kSW5kZXgrK10gPSB0ZXh0dXJlLnN0eWxlO1xuICB9XG4gIGNvbnN0IGJpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoYmluZEdyb3VwUmVzb3VyY2VzKTtcbiAgY2FjaGVkR3JvdXBzW2tleV0gPSBiaW5kR3JvdXA7XG4gIHJldHVybiBiaW5kR3JvdXA7XG59XG5cbmV4cG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3018\n')},37:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ BatchGeometry)\n/* harmony export */ });\n/* harmony import */ var _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7494);\n/* harmony import */ var _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5324);\n/* harmony import */ var _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1980);\n\n\n\n\n"use strict";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .Z {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .l({\n      data: placeHolderBufferData,\n      label: "attribute-batch-buffer",\n      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.VERTEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .l({\n      data: placeHolderIndexData,\n      label: "index-batch-buffer",\n      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.INDEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 0\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 2 * 4\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: "unorm8x4",\n          stride,\n          offset: 4 * 4\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: "uint16x2",\n          stride,\n          offset: 5 * 4\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\n\n//# sourceMappingURL=BatchGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtFO0FBQ0k7QUFDRTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNGQUFRO0FBQ3BDO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0ZBQU07QUFDdEM7QUFDQTtBQUNBLGFBQWEsb0ZBQVcsVUFBVSxvRkFBVztBQUM3QztBQUNBLEtBQUs7QUFDTCw0QkFBNEIsZ0ZBQU07QUFDbEM7QUFDQTtBQUNBLGFBQWEsb0ZBQVcsU0FBUyxvRkFBVztBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUV5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hHZW9tZXRyeS5tanM/MWUwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvY29uc3QubWpzJztcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHBsYWNlSG9sZGVyQnVmZmVyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5jb25zdCBwbGFjZUhvbGRlckluZGV4RGF0YSA9IG5ldyBVaW50MzJBcnJheSgxKTtcbmNsYXNzIEJhdGNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHZlcnRleFNpemUgPSA2O1xuICAgIGNvbnN0IGF0dHJpYnV0ZUJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogcGxhY2VIb2xkZXJCdWZmZXJEYXRhLFxuICAgICAgbGFiZWw6IFwiYXR0cmlidXRlLWJhdGNoLWJ1ZmZlclwiLFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgc2hyaW5rVG9GaXQ6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IHBsYWNlSG9sZGVySW5kZXhEYXRhLFxuICAgICAgbGFiZWw6IFwiaW5kZXgtYmF0Y2gtYnVmZmVyXCIsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuSU5ERVggfCBCdWZmZXJVc2FnZS5DT1BZX0RTVCxcbiAgICAgIC8vIHwgQnVmZmVyVXNhZ2UuU1RBVElDLFxuICAgICAgc2hyaW5rVG9GaXQ6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3Qgc3RyaWRlID0gdmVydGV4U2l6ZSAqIDQ7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBhUG9zaXRpb246IHtcbiAgICAgICAgICBidWZmZXI6IGF0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBhVVY6IHtcbiAgICAgICAgICBidWZmZXI6IGF0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogMiAqIDRcbiAgICAgICAgfSxcbiAgICAgICAgYUNvbG9yOiB7XG4gICAgICAgICAgYnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICAgICAgZm9ybWF0OiBcInVub3JtOHg0XCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogNCAqIDRcbiAgICAgICAgfSxcbiAgICAgICAgYVRleHR1cmVJZEFuZFJvdW5kOiB7XG4gICAgICAgICAgYnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICAgICAgZm9ybWF0OiBcInVpbnQxNngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogNSAqIDRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluZGV4QnVmZmVyXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hHZW9tZXRyeS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37\n')},4683:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  m: () => (/* binding */ Batcher)\n});\n\n// UNUSED EXPORTS: Batch\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs\n\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === "number") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case "int8":\n      case "uint8":\n        return 1;\n      case "int16":\n      case "uint16":\n        return 2;\n      case "int32":\n      case "uint32":\n      case "float32":\n        return 4;\n      default:\n        throw new Error(`${type} isn\'t a valid view type`);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ViewableBuffer.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs\nvar fastCopy = __webpack_require__(6633);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs\nvar getAdjustedBlendModeBlend = __webpack_require__(2796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs + 1 modules\nvar maxRecommendedTextures = __webpack_require__(5267);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs\n\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs\n\n\n\n\n\n\n\n"use strict";\nclass Batch {\n  constructor() {\n    this.renderPipeId = "batch";\n    this.action = "startBatch";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = "normal";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    /** unique id for this batcher */\n    this.uid = (0,uid/* uid */.h)("batcher");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? (0,maxRecommendedTextures/* getMaxTexturesPerBatch */.N)();\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { vertexSize, indexSize, maxTextures } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(\n      this.attributeBuffer.float32View,\n      this.attributeBuffer.uint32View,\n      batchableObject.location,\n      batchableObject.textureId\n    );\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart])\n      return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = (0,getAdjustedBlendModeBlend/* getAdjustedBlendModeBlend */.a)(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = "startBatch";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = (0,getAdjustedBlendModeBlend/* getAdjustedBlendModeBlend */.a)(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || blendModeChange) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = "renderBatch";\n        start = size;\n        blendMode = adjustedBlendMode;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    (0,fastCopy/* fastCopy */.T)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      (0,fastCopy/* fastCopy */.T)(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6,\n  maxTextures: null\n};\nlet Batcher = _Batcher;\n\n\n//# sourceMappingURL=Batcher.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsSUFBSSw0QkFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSw0QkFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2RhdGEvVmlld2FibGVCdWZmZXIubWpzPzYwZTUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9iYXRjaGVyL3NoYXJlZC9CYXRjaFRleHR1cmVBcnJheS5tanM/OWY0NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXIubWpzPzcyYjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBWaWV3YWJsZUJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKHNpemVPckJ1ZmZlcikge1xuICAgIGlmICh0eXBlb2Ygc2l6ZU9yQnVmZmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZU9yQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHNpemVPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlci5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB0aGlzLnNpemUgPSB0aGlzLnJhd0JpbmFyeURhdGEuYnl0ZUxlbmd0aDtcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEludDhBcnJheWAuICovXG4gIGdldCBpbnQ4VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDhWaWV3KSB7XG4gICAgICB0aGlzLl9pbnQ4VmlldyA9IG5ldyBJbnQ4QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDhWaWV3O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgVWludDhBcnJheWAuICovXG4gIGdldCB1aW50OFZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl91aW50OFZpZXcpIHtcbiAgICAgIHRoaXMuX3VpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91aW50OFZpZXc7XG4gIH1cbiAgLyoqICBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgSW50MTZBcnJheWAuICovXG4gIGdldCBpbnQxNlZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnQxNlZpZXcpIHtcbiAgICAgIHRoaXMuX2ludDE2VmlldyA9IG5ldyBJbnQxNkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnQxNlZpZXc7XG4gIH1cbiAgLyoqIFZpZXcgb24gdGhlIHJhdyBiaW5hcnkgZGF0YSBhcyBhIGBJbnQzMkFycmF5YC4gKi9cbiAgZ2V0IGludDMyVmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDMyVmlldykge1xuICAgICAgdGhpcy5faW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDMyVmlldztcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEZsb2F0NjRBcnJheWAuICovXG4gIGdldCBmbG9hdDY0VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2Zsb2F0NjRBcnJheSkge1xuICAgICAgdGhpcy5fZmxvYXQ2NEFycmF5ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmxvYXQ2NEFycmF5O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgQmlnVWludDY0QXJyYXlgLiAqL1xuICBnZXQgYmlnVWludDY0VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2JpZ1VpbnQ2NEFycmF5KSB7XG4gICAgICB0aGlzLl9iaWdVaW50NjRBcnJheSA9IG5ldyBCaWdVaW50NjRBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmlnVWludDY0QXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpZXcgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqIEBwYXJhbSB0eXBlIC0gT25lIG9mIGBpbnQ4YCwgYHVpbnQ4YCwgYGludDE2YCxcbiAgICogICAgYHVpbnQxNmAsIGBpbnQzMmAsIGB1aW50MzJgLCBhbmQgYGZsb2F0MzJgLlxuICAgKiBAcmV0dXJucyAtIHR5cGVkIGFycmF5IG9mIGdpdmVuIHR5cGVcbiAgICovXG4gIHZpZXcodHlwZSkge1xuICAgIHJldHVybiB0aGlzW2Ake3R5cGV9Vmlld2BdO1xuICB9XG4gIC8qKiBEZXN0cm95cyBhbGwgYnVmZmVyIHJlZmVyZW5jZXMuIERvIG5vdCB1c2UgYWZ0ZXIgY2FsbGluZyB0aGlzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IG51bGw7XG4gICAgdGhpcy5faW50OFZpZXcgPSBudWxsO1xuICAgIHRoaXMuX3VpbnQ4VmlldyA9IG51bGw7XG4gICAgdGhpcy5faW50MTZWaWV3ID0gbnVsbDtcbiAgICB0aGlzLnVpbnQxNlZpZXcgPSBudWxsO1xuICAgIHRoaXMuX2ludDMyVmlldyA9IG51bGw7XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbnVsbDtcbiAgICB0aGlzLmZsb2F0MzJWaWV3ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gdHlwZSBpbiBieXRlcy5cbiAgICogQHBhcmFtIHR5cGUgLSBPbmUgb2YgYGludDhgLCBgdWludDhgLCBgaW50MTZgLFxuICAgKiAgIGB1aW50MTZgLCBgaW50MzJgLCBgdWludDMyYCwgYW5kIGBmbG9hdDMyYC5cbiAgICogQHJldHVybnMgLSBzaXplIG9mIHRoZSB0eXBlIGluIGJ5dGVzXG4gICAqL1xuICBzdGF0aWMgc2l6ZU9mKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGV9IGlzbid0IGEgdmFsaWQgdmlldyB0eXBlYCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFZpZXdhYmxlQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3YWJsZUJ1ZmZlci5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJhdGNoVGV4dHVyZUFycmF5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIFJlc3BlY3RpdmUgbG9jYXRpb25zIGZvciB0ZXh0dXJlcy4gKi9cbiAgICB0aGlzLmlkcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuICAvKiogQ2xlYXIgdGhlIHRleHR1cmVzIGFuZCB0aGVpciBsb2NhdGlvbnMuICovXG4gIGNsZWFyKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy50ZXh0dXJlc1tpXTtcbiAgICAgIHRoaXMudGV4dHVyZXNbaV0gPSBudWxsO1xuICAgICAgdGhpcy5pZHNbdC51aWRdID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hUZXh0dXJlQXJyYXkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoVGV4dHVyZUFycmF5Lm1qcy5tYXBcbiIsImltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5pbXBvcnQgeyBWaWV3YWJsZUJ1ZmZlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RhdGEvVmlld2FibGVCdWZmZXIubWpzJztcbmltcG9ydCB7IGZhc3RDb3B5IH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvdXRpbHMvZmFzdENvcHkubWpzJztcbmltcG9ydCB7IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL2dldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQubWpzJztcbmltcG9ydCB7IGdldE1heFRleHR1cmVzUGVyQmF0Y2ggfSBmcm9tICcuLi9nbC91dGlscy9tYXhSZWNvbW1lbmRlZFRleHR1cmVzLm1qcyc7XG5pbXBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9IGZyb20gJy4vQmF0Y2hUZXh0dXJlQXJyYXkubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCYXRjaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJiYXRjaFwiO1xuICAgIHRoaXMuYWN0aW9uID0gXCJzdGFydEJhdGNoXCI7XG4gICAgLy8gVE9ETyAtIGV2ZW50dWFsbHkgdGhpcyBjb3VsZCBiZSB1c2VmdWwgZm9yIGZsYWdnaW5nIGJhdGNoZXMgYXMgZGlydHkgYW5kIHRoZW4gb25seSByZWJ1aWxkaW5nIHRob3NlIG9uZXNcbiAgICAvLyBwdWJsaWMgZWxlbWVudFN0YXJ0ID0gMDtcbiAgICAvLyBwdWJsaWMgZWxlbWVudFNpemUgPSAwO1xuICAgIC8vIGZvciBkcmF3aW5nLi5cbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMudGV4dHVyZXMgPSBuZXcgQmF0Y2hUZXh0dXJlQXJyYXkoKTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IFwibm9ybWFsXCI7XG4gICAgdGhpcy5jYW5CdW5kbGUgPSB0cnVlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy50ZXh0dXJlcyA9IG51bGw7XG4gICAgdGhpcy5ncHVCaW5kR3JvdXAgPSBudWxsO1xuICAgIHRoaXMuYmluZEdyb3VwID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoZXIgPSBudWxsO1xuICB9XG59XG5jb25zdCBiYXRjaFBvb2wgPSBbXTtcbmxldCBiYXRjaFBvb2xJbmRleCA9IDA7XG5mdW5jdGlvbiBnZXRCYXRjaEZyb21Qb29sKCkge1xuICByZXR1cm4gYmF0Y2hQb29sSW5kZXggPiAwID8gYmF0Y2hQb29sWy0tYmF0Y2hQb29sSW5kZXhdIDogbmV3IEJhdGNoKCk7XG59XG5mdW5jdGlvbiByZXR1cm5CYXRjaFRvUG9vbChiYXRjaCkge1xuICBiYXRjaFBvb2xbYmF0Y2hQb29sSW5kZXgrK10gPSBiYXRjaDtcbn1cbmxldCBCQVRDSF9USUNLID0gMDtcbmNvbnN0IF9CYXRjaGVyID0gY2xhc3MgX0JhdGNoZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAvKiogdW5pcXVlIGlkIGZvciB0aGlzIGJhdGNoZXIgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcImJhdGNoZXJcIik7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5iYXRjaEluZGV4ID0gMDtcbiAgICB0aGlzLmJhdGNoZXMgPSBbXTtcbiAgICAvLyBzcGVjaWZpY3MuXG4gICAgdGhpcy5fdmVydGV4U2l6ZSA9IDY7XG4gICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICBfQmF0Y2hlci5kZWZhdWx0T3B0aW9ucy5tYXhUZXh0dXJlcyA9IF9CYXRjaGVyLmRlZmF1bHRPcHRpb25zLm1heFRleHR1cmVzID8/IGdldE1heFRleHR1cmVzUGVyQmF0Y2goKTtcbiAgICBvcHRpb25zID0geyAuLi5fQmF0Y2hlci5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHsgdmVydGV4U2l6ZSwgaW5kZXhTaXplLCBtYXhUZXh0dXJlcyB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlciA9IG5ldyBWaWV3YWJsZUJ1ZmZlcih2ZXJ0ZXhTaXplICogdGhpcy5fdmVydGV4U2l6ZSAqIDQpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoaW5kZXhTaXplKTtcbiAgICB0aGlzLm1heFRleHR1cmVzID0gbWF4VGV4dHVyZXM7XG4gIH1cbiAgYmVnaW4oKSB7XG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IDA7XG4gICAgdGhpcy5lbGVtZW50U3RhcnQgPSAwO1xuICAgIHRoaXMuaW5kZXhTaXplID0gMDtcbiAgICB0aGlzLmF0dHJpYnV0ZVNpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iYXRjaEluZGV4OyBpKyspIHtcbiAgICAgIHJldHVybkJhdGNoVG9Qb29sKHRoaXMuYmF0Y2hlc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuYmF0Y2hJbmRleCA9IDA7XG4gICAgdGhpcy5fYmF0Y2hJbmRleFN0YXJ0ID0gMDtcbiAgICB0aGlzLl9iYXRjaEluZGV4U2l6ZSA9IDA7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgYWRkKGJhdGNoYWJsZU9iamVjdCkge1xuICAgIHRoaXMuX2VsZW1lbnRzW3RoaXMuZWxlbWVudFNpemUrK10gPSBiYXRjaGFibGVPYmplY3Q7XG4gICAgYmF0Y2hhYmxlT2JqZWN0LmluZGV4U3RhcnQgPSB0aGlzLmluZGV4U2l6ZTtcbiAgICBiYXRjaGFibGVPYmplY3QubG9jYXRpb24gPSB0aGlzLmF0dHJpYnV0ZVNpemU7XG4gICAgYmF0Y2hhYmxlT2JqZWN0LmJhdGNoZXIgPSB0aGlzO1xuICAgIHRoaXMuaW5kZXhTaXplICs9IGJhdGNoYWJsZU9iamVjdC5pbmRleFNpemU7XG4gICAgdGhpcy5hdHRyaWJ1dGVTaXplICs9IGJhdGNoYWJsZU9iamVjdC52ZXJ0ZXhTaXplICogdGhpcy5fdmVydGV4U2l6ZTtcbiAgfVxuICBjaGVja0FuZFVwZGF0ZVRleHR1cmUoYmF0Y2hhYmxlT2JqZWN0LCB0ZXh0dXJlKSB7XG4gICAgY29uc3QgdGV4dHVyZUlkID0gYmF0Y2hhYmxlT2JqZWN0LmJhdGNoLnRleHR1cmVzLmlkc1t0ZXh0dXJlLl9zb3VyY2UudWlkXTtcbiAgICBpZiAoIXRleHR1cmVJZCAmJiB0ZXh0dXJlSWQgIT09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgYmF0Y2hhYmxlT2JqZWN0LnRleHR1cmVJZCA9IHRleHR1cmVJZDtcbiAgICBiYXRjaGFibGVPYmplY3QudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdXBkYXRlRWxlbWVudChiYXRjaGFibGVPYmplY3QpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICBiYXRjaGFibGVPYmplY3QucGFja0F0dHJpYnV0ZXMoXG4gICAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlci5mbG9hdDMyVmlldyxcbiAgICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyLnVpbnQzMlZpZXcsXG4gICAgICBiYXRjaGFibGVPYmplY3QubG9jYXRpb24sXG4gICAgICBiYXRjaGFibGVPYmplY3QudGV4dHVyZUlkXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogYnJlYWtzIHRoZSBiYXRjaGVyLiBUaGlzIGhhcHBlbnMgd2hlbiBhIGJhdGNoIGdldHMgdG9vIGJpZyxcbiAgICogb3Igd2UgbmVlZCB0byBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHlwZSBvZiByZW5kZXJpbmcgKGEgZmlsdGVyIGZvciBleGFtcGxlKVxuICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25TZXRcbiAgICovXG4gIGJyZWFrKGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICBpZiAoIWVsZW1lbnRzW3RoaXMuZWxlbWVudFN0YXJ0XSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgYmF0Y2ggPSBnZXRCYXRjaEZyb21Qb29sKCk7XG4gICAgbGV0IHRleHR1cmVCYXRjaCA9IGJhdGNoLnRleHR1cmVzO1xuICAgIHRleHR1cmVCYXRjaC5jbGVhcigpO1xuICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IGVsZW1lbnRzW3RoaXMuZWxlbWVudFN0YXJ0XTtcbiAgICBsZXQgYmxlbmRNb2RlID0gZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZChmaXJzdEVsZW1lbnQuYmxlbmRNb2RlLCBmaXJzdEVsZW1lbnQudGV4dHVyZS5fc291cmNlKTtcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVTaXplICogNCA+IHRoaXMuYXR0cmlidXRlQnVmZmVyLnNpemUpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUF0dHJpYnV0ZUJ1ZmZlcih0aGlzLmF0dHJpYnV0ZVNpemUgKiA0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5kZXhTaXplID4gdGhpcy5pbmRleEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUluZGV4QnVmZmVyKHRoaXMuaW5kZXhTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZjMyID0gdGhpcy5hdHRyaWJ1dGVCdWZmZXIuZmxvYXQzMlZpZXc7XG4gICAgY29uc3QgdTMyID0gdGhpcy5hdHRyaWJ1dGVCdWZmZXIudWludDMyVmlldztcbiAgICBjb25zdCBpQnVmZmVyID0gdGhpcy5pbmRleEJ1ZmZlcjtcbiAgICBsZXQgc2l6ZSA9IHRoaXMuX2JhdGNoSW5kZXhTaXplO1xuICAgIGxldCBzdGFydCA9IHRoaXMuX2JhdGNoSW5kZXhTdGFydDtcbiAgICBsZXQgYWN0aW9uID0gXCJzdGFydEJhdGNoXCI7XG4gICAgY29uc3QgbWF4VGV4dHVyZXMgPSB0aGlzLm1heFRleHR1cmVzO1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmVsZW1lbnRTdGFydDsgaSA8IHRoaXMuZWxlbWVudFNpemU7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgZWxlbWVudHNbaV0gPSBudWxsO1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGVsZW1lbnQudGV4dHVyZTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuX3NvdXJjZTtcbiAgICAgIGNvbnN0IGFkanVzdGVkQmxlbmRNb2RlID0gZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZChlbGVtZW50LmJsZW5kTW9kZSwgc291cmNlKTtcbiAgICAgIGNvbnN0IGJsZW5kTW9kZUNoYW5nZSA9IGJsZW5kTW9kZSAhPT0gYWRqdXN0ZWRCbGVuZE1vZGU7XG4gICAgICBpZiAoc291cmNlLl9iYXRjaFRpY2sgPT09IEJBVENIX1RJQ0sgJiYgIWJsZW5kTW9kZUNoYW5nZSkge1xuICAgICAgICBlbGVtZW50LnRleHR1cmVJZCA9IHNvdXJjZS5fdGV4dHVyZUJpbmRMb2NhdGlvbjtcbiAgICAgICAgc2l6ZSArPSBlbGVtZW50LmluZGV4U2l6ZTtcbiAgICAgICAgZWxlbWVudC5wYWNrQXR0cmlidXRlcyhmMzIsIHUzMiwgZWxlbWVudC5sb2NhdGlvbiwgZWxlbWVudC50ZXh0dXJlSWQpO1xuICAgICAgICBlbGVtZW50LnBhY2tJbmRleChpQnVmZmVyLCBlbGVtZW50LmluZGV4U3RhcnQsIGVsZW1lbnQubG9jYXRpb24gLyB0aGlzLl92ZXJ0ZXhTaXplKTtcbiAgICAgICAgZWxlbWVudC5iYXRjaCA9IGJhdGNoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5fYmF0Y2hUaWNrID0gQkFUQ0hfVElDSztcbiAgICAgIGlmICh0ZXh0dXJlQmF0Y2guY291bnQgPj0gbWF4VGV4dHVyZXMgfHwgYmxlbmRNb2RlQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaEJhdGNoKFxuICAgICAgICAgIGJhdGNoLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIHNpemUgLSBzdGFydCxcbiAgICAgICAgICB0ZXh0dXJlQmF0Y2gsXG4gICAgICAgICAgYmxlbmRNb2RlLFxuICAgICAgICAgIGluc3RydWN0aW9uU2V0LFxuICAgICAgICAgIGFjdGlvblxuICAgICAgICApO1xuICAgICAgICBhY3Rpb24gPSBcInJlbmRlckJhdGNoXCI7XG4gICAgICAgIHN0YXJ0ID0gc2l6ZTtcbiAgICAgICAgYmxlbmRNb2RlID0gYWRqdXN0ZWRCbGVuZE1vZGU7XG4gICAgICAgIGJhdGNoID0gZ2V0QmF0Y2hGcm9tUG9vbCgpO1xuICAgICAgICB0ZXh0dXJlQmF0Y2ggPSBiYXRjaC50ZXh0dXJlcztcbiAgICAgICAgdGV4dHVyZUJhdGNoLmNsZWFyKCk7XG4gICAgICAgICsrQkFUQ0hfVElDSztcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQudGV4dHVyZUlkID0gc291cmNlLl90ZXh0dXJlQmluZExvY2F0aW9uID0gdGV4dHVyZUJhdGNoLmNvdW50O1xuICAgICAgdGV4dHVyZUJhdGNoLmlkc1tzb3VyY2UudWlkXSA9IHRleHR1cmVCYXRjaC5jb3VudDtcbiAgICAgIHRleHR1cmVCYXRjaC50ZXh0dXJlc1t0ZXh0dXJlQmF0Y2guY291bnQrK10gPSBzb3VyY2U7XG4gICAgICBlbGVtZW50LmJhdGNoID0gYmF0Y2g7XG4gICAgICBzaXplICs9IGVsZW1lbnQuaW5kZXhTaXplO1xuICAgICAgZWxlbWVudC5wYWNrQXR0cmlidXRlcyhmMzIsIHUzMiwgZWxlbWVudC5sb2NhdGlvbiwgZWxlbWVudC50ZXh0dXJlSWQpO1xuICAgICAgZWxlbWVudC5wYWNrSW5kZXgoaUJ1ZmZlciwgZWxlbWVudC5pbmRleFN0YXJ0LCBlbGVtZW50LmxvY2F0aW9uIC8gdGhpcy5fdmVydGV4U2l6ZSk7XG4gICAgfVxuICAgIGlmICh0ZXh0dXJlQmF0Y2guY291bnQgPiAwKSB7XG4gICAgICB0aGlzLl9maW5pc2hCYXRjaChcbiAgICAgICAgYmF0Y2gsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBzaXplIC0gc3RhcnQsXG4gICAgICAgIHRleHR1cmVCYXRjaCxcbiAgICAgICAgYmxlbmRNb2RlLFxuICAgICAgICBpbnN0cnVjdGlvblNldCxcbiAgICAgICAgYWN0aW9uXG4gICAgICApO1xuICAgICAgc3RhcnQgPSBzaXplO1xuICAgICAgKytCQVRDSF9USUNLO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRTdGFydCA9IHRoaXMuZWxlbWVudFNpemU7XG4gICAgdGhpcy5fYmF0Y2hJbmRleFN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fYmF0Y2hJbmRleFNpemUgPSBzaXplO1xuICB9XG4gIF9maW5pc2hCYXRjaChiYXRjaCwgaW5kZXhTdGFydCwgaW5kZXhTaXplLCB0ZXh0dXJlQmF0Y2gsIGJsZW5kTW9kZSwgaW5zdHJ1Y3Rpb25TZXQsIGFjdGlvbikge1xuICAgIGJhdGNoLmdwdUJpbmRHcm91cCA9IG51bGw7XG4gICAgYmF0Y2guYmluZEdyb3VwID0gbnVsbDtcbiAgICBiYXRjaC5hY3Rpb24gPSBhY3Rpb247XG4gICAgYmF0Y2guYmF0Y2hlciA9IHRoaXM7XG4gICAgYmF0Y2gudGV4dHVyZXMgPSB0ZXh0dXJlQmF0Y2g7XG4gICAgYmF0Y2guYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuICAgIGJhdGNoLnN0YXJ0ID0gaW5kZXhTdGFydDtcbiAgICBiYXRjaC5zaXplID0gaW5kZXhTaXplO1xuICAgICsrQkFUQ0hfVElDSztcbiAgICB0aGlzLmJhdGNoZXNbdGhpcy5iYXRjaEluZGV4KytdID0gYmF0Y2g7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKGJhdGNoKTtcbiAgfVxuICBmaW5pc2goaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICB0aGlzLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgYXR0cmlidXRlIGJ1ZmZlciB0byB0aGUgZ2l2ZW4gc2l6ZSAoMSA9IDEgZmxvYXQzMilcbiAgICogQHBhcmFtIHNpemUgLSB0aGUgc2l6ZSBpbiB2ZXJ0aWNlcyB0byBlbnN1cmUgKG5vdCBieXRlcyEpXG4gICAqL1xuICBlbnN1cmVBdHRyaWJ1dGVCdWZmZXIoc2l6ZSkge1xuICAgIGlmIChzaXplICogNCA8PSB0aGlzLmF0dHJpYnV0ZUJ1ZmZlci5zaXplKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3Jlc2l6ZUF0dHJpYnV0ZUJ1ZmZlcihzaXplICogNCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGluZGV4IGJ1ZmZlciB0byB0aGUgZ2l2ZW4gc2l6ZSAoMSA9IDEgZmxvYXQzMilcbiAgICogQHBhcmFtIHNpemUgLSB0aGUgc2l6ZSBpbiB2ZXJ0aWNlcyB0byBlbnN1cmUgKG5vdCBieXRlcyEpXG4gICAqL1xuICBlbnN1cmVJbmRleEJ1ZmZlcihzaXplKSB7XG4gICAgaWYgKHNpemUgPD0gdGhpcy5pbmRleEJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fcmVzaXplSW5kZXhCdWZmZXIoc2l6ZSk7XG4gIH1cbiAgX3Jlc2l6ZUF0dHJpYnV0ZUJ1ZmZlcihzaXplKSB7XG4gICAgY29uc3QgbmV3U2l6ZSA9IE1hdGgubWF4KHNpemUsIHRoaXMuYXR0cmlidXRlQnVmZmVyLnNpemUgKiAyKTtcbiAgICBjb25zdCBuZXdBcnJheUJ1ZmZlciA9IG5ldyBWaWV3YWJsZUJ1ZmZlcihuZXdTaXplKTtcbiAgICBmYXN0Q29weSh0aGlzLmF0dHJpYnV0ZUJ1ZmZlci5yYXdCaW5hcnlEYXRhLCBuZXdBcnJheUJ1ZmZlci5yYXdCaW5hcnlEYXRhKTtcbiAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlciA9IG5ld0FycmF5QnVmZmVyO1xuICB9XG4gIF9yZXNpemVJbmRleEJ1ZmZlcihzaXplKSB7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLmluZGV4QnVmZmVyO1xuICAgIGxldCBuZXdTaXplID0gTWF0aC5tYXgoc2l6ZSwgaW5kZXhCdWZmZXIubGVuZ3RoICogMS41KTtcbiAgICBuZXdTaXplICs9IG5ld1NpemUgJSAyO1xuICAgIGNvbnN0IG5ld0luZGV4QnVmZmVyID0gbmV3U2l6ZSA+IDY1NTM1ID8gbmV3IFVpbnQzMkFycmF5KG5ld1NpemUpIDogbmV3IFVpbnQxNkFycmF5KG5ld1NpemUpO1xuICAgIGlmIChuZXdJbmRleEJ1ZmZlci5CWVRFU19QRVJfRUxFTUVOVCAhPT0gaW5kZXhCdWZmZXIuQllURVNfUEVSX0VMRU1FTlQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3SW5kZXhCdWZmZXJbaV0gPSBpbmRleEJ1ZmZlcltpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmFzdENvcHkoaW5kZXhCdWZmZXIuYnVmZmVyLCBuZXdJbmRleEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbmV3SW5kZXhCdWZmZXI7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0dXJuQmF0Y2hUb1Bvb2wodGhpcy5iYXRjaGVzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5iYXRjaGVzID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9lbGVtZW50c1tpXS5iYXRjaCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnRzID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVCdWZmZXIgPSBudWxsO1xuICB9XG59O1xuX0JhdGNoZXIuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHZlcnRleFNpemU6IDQsXG4gIGluZGV4U2l6ZTogNixcbiAgbWF4VGV4dHVyZXM6IG51bGxcbn07XG5sZXQgQmF0Y2hlciA9IF9CYXRjaGVyO1xuXG5leHBvcnQgeyBCYXRjaCwgQmF0Y2hlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4683\n')},9846:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs\nvar Sprite = __webpack_require__(5263);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(5128);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs\n\n\n\n"use strict";\nconst tempBounds = new Bounds/* Bounds */.Y();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  (0,getGlobalBounds/* getGlobalBounds */.qW)(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\n\n//# sourceMappingURL=addMaskBounds.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(3197);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(2692);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs\n\n\n\n\n"use strict";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = matrixAndBoundsPool/* boundsPool */.W.get();\n  mask.measurable = true;\n  const tempMatrix = matrixAndBoundsPool/* matrixPool */.N.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  (0,getLocalBounds/* getLocalBounds */.a)(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixAndBoundsPool/* matrixPool */.N.return(tempMatrix);\n  matrixAndBoundsPool/* boundsPool */.W.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    (0,warn/* warn */.Z)("Mask bounds, renderable is not inside the root container");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\n\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs\n\n\n\n\n\n"use strict";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "alphaMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite/* Sprite */.j);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite/* Sprite */.j;\n  }\n}\nAlphaMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=AlphaMask.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs\n\n\n"use strict";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "colorMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === "number";\n  }\n}\nColorMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=ColorMask.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(8400);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs\n\n\n\n\n\n"use strict";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "stencilMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container/* Container */.W2;\n  }\n}\nStencilMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=StencilMask.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs\nvar BufferImageSource = __webpack_require__(9224);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs\nvar CanvasSource = __webpack_require__(6914);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(9160);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(9366);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs\n\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement("canvas");\n    const gl = canvas.getContext("webgl");\n    if (!gl) {\n      return "premultiply-alpha-on-upload";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement("video");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = "anonymous";\n      video2.preload = "auto";\n      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";\n      video2.load();\n    });\n    if (!video) {\n      return "premultiply-alpha-on-upload";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension("WEBGL_lose_context")?.loseContext();\n    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";\n  })());\n  return promise;\n}\n\n\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(5206);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs\n\n\n\n\n\n"use strict";\nconst _VideoSource = class _VideoSource extends TextureSource/* TextureSource */.p {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = "video";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker/* Ticker */.v.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener("play", this._onPlayStart);\n    source.addEventListener("pause", this._onPlayStop);\n    source.addEventListener("seeked", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener("canplay", this._onCanPlay);\n      }\n      source.addEventListener("canplaythrough", this._onCanPlayThrough);\n      source.addEventListener("error", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener("error", this._onError, true);\n    this.emit("error", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener("canplay", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener("canplaythrough", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener("play", this._onPlayStart);\n      source.removeEventListener("pause", this._onPlayStop);\n      source.removeEventListener("seeked", this._onSeeked);\n      source.removeEventListener("canplay", this._onCanPlay);\n      source.removeEventListener("canplaythrough", this._onCanPlayThrough);\n      source.removeEventListener("error", this._onError, true);\n      source.pause();\n      source.src = "";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser\'s native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video\'s state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn\'t playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker/* Ticker */.v.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker/* Ticker */.v.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker/* Ticker */.v.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;\n  }\n};\n_VideoSource.extension = Extensions/* ExtensionType */.nw.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource/* TextureSource */.p.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can\'t be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: "video/ogg",\n  mov: "video/quicktime",\n  m4v: "video/mp4"\n};\nlet VideoSource = _VideoSource;\n\n\n//# sourceMappingURL=VideoSource.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs\nvar textureFrom = __webpack_require__(4325);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/init.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource/* ImageSource */.c, CanvasSource/* CanvasSource */.D, BufferImageSource/* BufferImageSource */.A);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQkFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBYTtBQUN0QztBQUNBO0FBQ0EsS0FBSyxrQ0FBYTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVCO0FBQ3ZCOzs7OztBQ3BVMEQ7QUFDSDtBQUNBO0FBQ007QUFDZ0M7QUFDVjtBQUNGO0FBQ0E7QUFDdkI7QUFDcEI7O0FBRXRDO0FBQ0EsNkJBQVUsS0FBSyxTQUFTLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsOEJBQVcsRUFBRSxnQ0FBWSxFQUFFLDBDQUFpQjtBQUMzRyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvbWFzay91dGlscy9hZGRNYXNrQm91bmRzLm1qcz84ZWYyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvbWFzay91dGlscy9hZGRNYXNrTG9jYWxCb3VuZHMubWpzPzk5YWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9tYXNrL2FscGhhL0FscGhhTWFzay5tanM/ZTVhYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svY29sb3IvQ29sb3JNYXNrLm1qcz85ZTMyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvbWFzay9zdGVuY2lsL1N0ZW5jaWxNYXNrLm1qcz9hZWVlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9icm93c2VyL2RldGVjdFZpZGVvQWxwaGFNb2RlLm1qcz9lMDE2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvVmlkZW9Tb3VyY2UubWpzPzllMTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9pbml0Lm1qcz9hZTFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldEdsb2JhbEJvdW5kcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBhZGRNYXNrQm91bmRzKG1hc2ssIGJvdW5kcywgc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICBjb25zdCBib3VuZHNUb01hc2sgPSB0ZW1wQm91bmRzO1xuICBtYXNrLm1lYXN1cmFibGUgPSB0cnVlO1xuICBnZXRHbG9iYWxCb3VuZHMobWFzaywgc2tpcFVwZGF0ZVRyYW5zZm9ybSwgYm91bmRzVG9NYXNrKTtcbiAgYm91bmRzLmFkZEJvdW5kc01hc2soYm91bmRzVG9NYXNrKTtcbiAgbWFzay5tZWFzdXJhYmxlID0gZmFsc2U7XG59XG5cbmV4cG9ydCB7IGFkZE1hc2tCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZE1hc2tCb3VuZHMubWpzLm1hcFxuIiwiaW1wb3J0IHsgZ2V0TG9jYWxCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldExvY2FsQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBib3VuZHNQb29sLCBtYXRyaXhQb29sIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy91dGlscy9tYXRyaXhBbmRCb3VuZHNQb29sLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYWRkTWFza0xvY2FsQm91bmRzKG1hc2ssIGJvdW5kcywgbG9jYWxSb290KSB7XG4gIGNvbnN0IGJvdW5kc1RvTWFzayA9IGJvdW5kc1Bvb2wuZ2V0KCk7XG4gIG1hc2subWVhc3VyYWJsZSA9IHRydWU7XG4gIGNvbnN0IHRlbXBNYXRyaXggPSBtYXRyaXhQb29sLmdldCgpLmlkZW50aXR5KCk7XG4gIGNvbnN0IHJlbGF0aXZlTWFzayA9IGdldE1hdHJpeFJlbGF0aXZlVG9QYXJlbnQobWFzaywgbG9jYWxSb290LCB0ZW1wTWF0cml4KTtcbiAgZ2V0TG9jYWxCb3VuZHMobWFzaywgYm91bmRzVG9NYXNrLCByZWxhdGl2ZU1hc2spO1xuICBtYXNrLm1lYXN1cmFibGUgPSBmYWxzZTtcbiAgYm91bmRzLmFkZEJvdW5kc01hc2soYm91bmRzVG9NYXNrKTtcbiAgbWF0cml4UG9vbC5yZXR1cm4odGVtcE1hdHJpeCk7XG4gIGJvdW5kc1Bvb2wucmV0dXJuKGJvdW5kc1RvTWFzayk7XG59XG5mdW5jdGlvbiBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50KHRhcmdldCwgcm9vdCwgbWF0cml4KSB7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgd2FybihcIk1hc2sgYm91bmRzLCByZW5kZXJhYmxlIGlzIG5vdCBpbnNpZGUgdGhlIHJvb3QgY29udGFpbmVyXCIpO1xuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cbiAgaWYgKHRhcmdldCAhPT0gcm9vdCkge1xuICAgIGdldE1hdHJpeFJlbGF0aXZlVG9QYXJlbnQodGFyZ2V0LnBhcmVudCwgcm9vdCwgbWF0cml4KTtcbiAgICB0YXJnZXQudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICBtYXRyaXguYXBwZW5kKHRhcmdldC5sb2NhbFRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIG1hdHJpeDtcbn1cblxuZXhwb3J0IHsgYWRkTWFza0xvY2FsQm91bmRzLCBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRNYXNrTG9jYWxCb3VuZHMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvc3ByaXRlL1Nwcml0ZS5tanMnO1xuaW1wb3J0IHsgYWRkTWFza0JvdW5kcyB9IGZyb20gJy4uL3V0aWxzL2FkZE1hc2tCb3VuZHMubWpzJztcbmltcG9ydCB7IGFkZE1hc2tMb2NhbEJvdW5kcyB9IGZyb20gJy4uL3V0aWxzL2FkZE1hc2tMb2NhbEJvdW5kcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEFscGhhTWFzayB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnByaW9yaXR5ID0gMDtcbiAgICB0aGlzLnBpcGUgPSBcImFscGhhTWFza1wiO1xuICAgIGlmIChvcHRpb25zPy5tYXNrKSB7XG4gICAgICB0aGlzLmluaXQob3B0aW9ucy5tYXNrKTtcbiAgICB9XG4gIH1cbiAgaW5pdChtYXNrKSB7XG4gICAgdGhpcy5tYXNrID0gbWFzaztcbiAgICB0aGlzLnJlbmRlck1hc2tUb1RleHR1cmUgPSAhKG1hc2sgaW5zdGFuY2VvZiBTcHJpdGUpO1xuICAgIHRoaXMubWFzay5yZW5kZXJhYmxlID0gdGhpcy5yZW5kZXJNYXNrVG9UZXh0dXJlO1xuICAgIHRoaXMubWFzay5pbmNsdWRlSW5CdWlsZCA9ICF0aGlzLnJlbmRlck1hc2tUb1RleHR1cmU7XG4gICAgdGhpcy5tYXNrLm1lYXN1cmFibGUgPSBmYWxzZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLm1hc2subWVhc3VyYWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXNrID0gbnVsbDtcbiAgfVxuICBhZGRCb3VuZHMoYm91bmRzLCBza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgYWRkTWFza0JvdW5kcyh0aGlzLm1hc2ssIGJvdW5kcywgc2tpcFVwZGF0ZVRyYW5zZm9ybSk7XG4gIH1cbiAgYWRkTG9jYWxCb3VuZHMoYm91bmRzLCBsb2NhbFJvb3QpIHtcbiAgICBhZGRNYXNrTG9jYWxCb3VuZHModGhpcy5tYXNrLCBib3VuZHMsIGxvY2FsUm9vdCk7XG4gIH1cbiAgY29udGFpbnNQb2ludChwb2ludCwgaGl0VGVzdEZuKSB7XG4gICAgY29uc3QgbWFzayA9IHRoaXMubWFzaztcbiAgICByZXR1cm4gaGl0VGVzdEZuKG1hc2ssIHBvaW50KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICBzdGF0aWMgdGVzdChtYXNrKSB7XG4gICAgcmV0dXJuIG1hc2sgaW5zdGFuY2VvZiBTcHJpdGU7XG4gIH1cbn1cbkFscGhhTWFzay5leHRlbnNpb24gPSBFeHRlbnNpb25UeXBlLk1hc2tFZmZlY3Q7XG5cbmV4cG9ydCB7IEFscGhhTWFzayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWxwaGFNYXNrLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDb2xvck1hc2sge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5wcmlvcml0eSA9IDA7XG4gICAgdGhpcy5waXBlID0gXCJjb2xvck1hc2tcIjtcbiAgICBpZiAob3B0aW9ucz8ubWFzaykge1xuICAgICAgdGhpcy5pbml0KG9wdGlvbnMubWFzayk7XG4gICAgfVxuICB9XG4gIGluaXQobWFzaykge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxuICBzdGF0aWMgdGVzdChtYXNrKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtYXNrID09PSBcIm51bWJlclwiO1xuICB9XG59XG5Db2xvck1hc2suZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5NYXNrRWZmZWN0O1xuXG5leHBvcnQgeyBDb2xvck1hc2sgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yTWFzay5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9jb250YWluZXIvQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgeyBhZGRNYXNrQm91bmRzIH0gZnJvbSAnLi4vdXRpbHMvYWRkTWFza0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgYWRkTWFza0xvY2FsQm91bmRzIH0gZnJvbSAnLi4vdXRpbHMvYWRkTWFza0xvY2FsQm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgU3RlbmNpbE1hc2sge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5wcmlvcml0eSA9IDA7XG4gICAgdGhpcy5waXBlID0gXCJzdGVuY2lsTWFza1wiO1xuICAgIGlmIChvcHRpb25zPy5tYXNrKSB7XG4gICAgICB0aGlzLmluaXQob3B0aW9ucy5tYXNrKTtcbiAgICB9XG4gIH1cbiAgaW5pdChtYXNrKSB7XG4gICAgdGhpcy5tYXNrID0gbWFzaztcbiAgICB0aGlzLm1hc2suaW5jbHVkZUluQnVpbGQgPSBmYWxzZTtcbiAgICB0aGlzLm1hc2subWVhc3VyYWJsZSA9IGZhbHNlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMubWFzay5tZWFzdXJhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLm1hc2suaW5jbHVkZUluQnVpbGQgPSB0cnVlO1xuICAgIHRoaXMubWFzayA9IG51bGw7XG4gIH1cbiAgYWRkQm91bmRzKGJvdW5kcywgc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgIGFkZE1hc2tCb3VuZHModGhpcy5tYXNrLCBib3VuZHMsIHNraXBVcGRhdGVUcmFuc2Zvcm0pO1xuICB9XG4gIGFkZExvY2FsQm91bmRzKGJvdW5kcywgbG9jYWxSb290KSB7XG4gICAgYWRkTWFza0xvY2FsQm91bmRzKHRoaXMubWFzaywgYm91bmRzLCBsb2NhbFJvb3QpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocG9pbnQsIGhpdFRlc3RGbikge1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLm1hc2s7XG4gICAgcmV0dXJuIGhpdFRlc3RGbihtYXNrLCBwb2ludCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgc3RhdGljIHRlc3QobWFzaykge1xuICAgIHJldHVybiBtYXNrIGluc3RhbmNlb2YgQ29udGFpbmVyO1xuICB9XG59XG5TdGVuY2lsTWFzay5leHRlbnNpb24gPSBFeHRlbnNpb25UeXBlLk1hc2tFZmZlY3Q7XG5cbmV4cG9ydCB7IFN0ZW5jaWxNYXNrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGVuY2lsTWFzay5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmxldCBwcm9taXNlO1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0VmlkZW9BbHBoYU1vZGUoKSB7XG4gIHByb21pc2UgPz8gKHByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgIHJldHVybiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiO1xuICAgIH1cbiAgICBjb25zdCB2aWRlbyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCB2aWRlbzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICB2aWRlbzIub25sb2FkZWRkYXRhID0gKCkgPT4gcmVzb2x2ZSh2aWRlbzIpO1xuICAgICAgdmlkZW8yLm9uZXJyb3IgPSAoKSA9PiByZXNvbHZlKG51bGwpO1xuICAgICAgdmlkZW8yLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgICB2aWRlbzIuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgdmlkZW8yLnByZWxvYWQgPSBcImF1dG9cIjtcbiAgICAgIHZpZGVvMi5zcmMgPSBcImRhdGE6dmlkZW8vd2VibTtiYXNlNjQsR2tYZm81OUNob0VCUXZlQkFVTHlnUVJDODRFSVFvS0VkMlZpYlVLSGdRSkNoWUVDR0ZPQVp3RUFBQUFBQUFIVEVVMmJkTHBOdTR0VHE0UVZTYWxtVTZ5Qm9VMjdpMU9yaEJaVXJtdFRySUhHVGJ1TVU2dUVFbFREWjFPc2dnRVhUYnVNVTZ1RUhGTzdhMU9zZ2dHOTdBRUFBQUFBQUFCWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVlNhbG1vQ3JYc1lNUFFrQk5nSVJNWVhabVYwR0VUR0YyWmtTSmlFQkVBQUFBQUFBQUZsU3VhOHl1QVFBQUFBQUFBRVBYZ1FGenhZZ0FBQUFBQUFBQUFaeUJBQ0sxbklOMWJtU0lnUUNHaFZaZlZsQTVnNEVCSStPRGhBSmlXZ0RnbExDQkFycUJBcHFCQWxQQWdRRlZzSVJWdVlFQkVsVERaOVZ6YzlKandJdGp4WWdBQUFBQUFBQUFBV2ZJbkVXamgwVk9RMDlFUlZKRWg0OU1ZWFpqSUd4cFluWndlQzEyY0RsbnlLSkZvNGhFVlZKQlZFbFBUa1NIbERBd09qQXdPakF3TGpBME1EQXdNREF3TUFBQUgwTzJkY2ZuZ1FDZ3dxR2dnUUFBQUlKSmcwSUFBQkFBRmdBNEpCd1lTZ0FBSUNBQUViLy8vNHIrQUFCMW9aMm1tKzZCQWFXV2drbURRZ0FBRUFBV0FEZ2tIQmhLQUFBZ0lBQklRQnhUdTJ1UnU0K3pnUUMzaXZlQkFmR0NBWEh3Z1FNPVwiO1xuICAgICAgdmlkZW8yLmxvYWQoKTtcbiAgICB9KTtcbiAgICBpZiAoIXZpZGVvKSB7XG4gICAgICByZXR1cm4gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgIHRleHR1cmUsXG4gICAgICAwXG4gICAgKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBnbC5OT05FKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHZpZGVvKTtcbiAgICBjb25zdCBwaXhlbCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWwpO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKT8ubG9zZUNvbnRleHQoKTtcbiAgICByZXR1cm4gcGl4ZWxbMF0gPD0gcGl4ZWxbM10gPyBcInByZW11bHRpcGxpZWQtYWxwaGFcIiA6IFwicHJlbXVsdGlwbHktYWxwaGEtb24tdXBsb2FkXCI7XG4gIH0pKCkpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZXhwb3J0IHsgZGV0ZWN0VmlkZW9BbHBoYU1vZGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdFZpZGVvQWxwaGFNb2RlLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRpY2tlciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3RpY2tlci9UaWNrZXIubWpzJztcbmltcG9ydCB7IGRldGVjdFZpZGVvQWxwaGFNb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvYnJvd3Nlci9kZXRlY3RWaWRlb0FscGhhTW9kZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9WaWRlb1NvdXJjZSA9IGNsYXNzIF9WaWRlb1NvdXJjZSBleHRlbmRzIFRleHR1cmVTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgLy8gUHVibGljXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB2aWRlbyBpcyByZWFkeSB0byBwbGF5LiAqL1xuICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICAgIC8qKiBUaGUgdXBsb2FkIG1ldGhvZCBmb3IgdGhpcyB0ZXh0dXJlLiAqL1xuICAgIHRoaXMudXBsb2FkTWV0aG9kSWQgPSBcInZpZGVvXCI7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLl9WaWRlb1NvdXJjZS5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICB0aGlzLl91cGRhdGVGUFMgPSBvcHRpb25zLnVwZGF0ZUZQUyB8fCAwO1xuICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICB0aGlzLmF1dG9QbGF5ID0gb3B0aW9ucy5hdXRvUGxheSAhPT0gZmFsc2U7XG4gICAgdGhpcy5hbHBoYU1vZGUgPSBvcHRpb25zLmFscGhhTW9kZSA/PyBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiO1xuICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgPSB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IG51bGw7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9vbkNhblBsYXkgPSB0aGlzLl9vbkNhblBsYXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNhblBsYXlUaHJvdWdoID0gdGhpcy5fb25DYW5QbGF5VGhyb3VnaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25QbGF5U3RhcnQgPSB0aGlzLl9vblBsYXlTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUGxheVN0b3AgPSB0aGlzLl9vblBsYXlTdG9wLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TZWVrZWQgPSB0aGlzLl9vblNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdm9pZCB0aGlzLmxvYWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqIFVwZGF0ZSB0aGUgdmlkZW8gZnJhbWUgaWYgdGhlIHNvdXJjZSBpcyBub3QgZGVzdHJveWVkIGFuZCBtZWV0cyBjZXJ0YWluIGNvbmRpdGlvbnMuICovXG4gIHVwZGF0ZUZyYW1lKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdXBkYXRlRlBTKSB7XG4gICAgICBjb25zdCBlbGFwc2VkTVMgPSBUaWNrZXIuc2hhcmVkLmVsYXBzZWRNUyAqIHRoaXMucmVzb3VyY2UucGxheWJhY2tSYXRlO1xuICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSBNYXRoLmZsb29yKHRoaXMuX21zVG9OZXh0VXBkYXRlIC0gZWxhcHNlZE1TKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl91cGRhdGVGUFMgfHwgdGhpcy5fbXNUb05leHRVcGRhdGUgPD0gMCkge1xuICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSB0aGlzLl91cGRhdGVGUFMgPyBNYXRoLmZsb29yKDFlMyAvIHRoaXMuX3VwZGF0ZUZQUykgOiAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICAvKiogQ2FsbGJhY2sgdG8gdXBkYXRlIHRoZSB2aWRlbyBmcmFtZSBhbmQgcG90ZW50aWFsbHkgcmVxdWVzdCB0aGUgbmV4dCBmcmFtZSB1cGRhdGUuICovXG4gIF92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrKCkge1xuICAgIHRoaXMudXBkYXRlRnJhbWUoKTtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gdGhpcy5yZXNvdXJjZS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKFxuICAgICAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSByZXNvdXJjZSBoYXMgdmFsaWQgZGltZW5zaW9ucy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgc2V0LCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLnJlc291cmNlLnZpZGVvV2lkdGggJiYgISF0aGlzLnJlc291cmNlLnZpZGVvSGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBwcmVsb2FkaW5nIHRoZSB2aWRlbyByZXNvdXJjZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcbiAgICovXG4gIGFzeW5jIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc291cmNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRU5PVUdIX0RBVEEgfHwgc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0ZVVFVSRV9EQVRBKSAmJiBzb3VyY2Uud2lkdGggJiYgc291cmNlLmhlaWdodCkge1xuICAgICAgc291cmNlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5XCIsIHRoaXMuX29uUGxheVN0YXJ0KTtcbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIHRoaXMuX29uUGxheVN0b3ApO1xuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIHRoaXMuX29uU2Vla2VkKTtcbiAgICBpZiAoIXRoaXMuX2lzU291cmNlUmVhZHkoKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnByZWxvYWQpIHtcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgICB9XG4gICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX29uQ2FuUGxheVRocm91Z2gpO1xuICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWVkaWFSZWFkeSgpO1xuICAgIH1cbiAgICB0aGlzLmFscGhhTW9kZSA9IGF3YWl0IGRldGVjdFZpZGVvQWxwaGFNb2RlKCk7XG4gICAgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIGlmIChvcHRpb25zLnByZWxvYWRUaW1lb3V0TXMgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMuX3ByZWxvYWRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKG5ldyBFcnJvckV2ZW50KGBQcmVsb2FkIGV4Y2VlZGVkIHRpbWVvdXQgb2YgJHtvcHRpb25zLnByZWxvYWRUaW1lb3V0TXN9bXNgKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlLmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHZpZGVvIGVycm9yIGV2ZW50cy5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGVycm9yIGV2ZW50XG4gICAqL1xuICBfb25FcnJvcihldmVudCkge1xuICAgIHRoaXMucmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX29uRXJyb3IsIHRydWUpO1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5fcmVqZWN0KSB7XG4gICAgICB0aGlzLl9yZWplY3QoZXZlbnQpO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyBwbGF5aW5nLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHBsYXlpbmcuXG4gICAqL1xuICBfaXNTb3VyY2VQbGF5aW5nKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb3VyY2U7XG4gICAgcmV0dXJuICFzb3VyY2UucGF1c2VkICYmICFzb3VyY2UuZW5kZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdW5kZXJseWluZyBzb3VyY2UgaXMgcmVhZHkgZm9yIHBsYXlpbmcuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgcmVhZHkuXG4gICAqL1xuICBfaXNTb3VyY2VSZWFkeSgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc291cmNlO1xuICAgIHJldHVybiBzb3VyY2UucmVhZHlTdGF0ZSA+IDI7XG4gIH1cbiAgLyoqIFJ1bnMgdGhlIHVwZGF0ZSBsb29wIHdoZW4gdGhlIHZpZGVvIGlzIHJlYWR5IHRvIHBsYXkuICovXG4gIF9vblBsYXlTdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgdGhpcy5fbWVkaWFSZWFkeSgpO1xuICAgIH1cbiAgICB0aGlzLl9jb25maWd1cmVBdXRvVXBkYXRlKCk7XG4gIH1cbiAgLyoqIFN0b3BzIHRoZSB1cGRhdGUgbG9vcCB3aGVuIGEgcGF1c2UgZXZlbnQgaXMgdHJpZ2dlcmVkLiAqL1xuICBfb25QbGF5U3RvcCgpIHtcbiAgICB0aGlzLl9jb25maWd1cmVBdXRvVXBkYXRlKCk7XG4gIH1cbiAgLyoqIEhhbmRsZXMgYmVoYXZpb3Igd2hlbiB0aGUgdmlkZW8gY29tcGxldGVzIHNlZWtpbmcgdG8gdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24uICovXG4gIF9vblNlZWtlZCgpIHtcbiAgICBpZiAodGhpcy5fYXV0b1VwZGF0ZSAmJiAhdGhpcy5faXNTb3VyY2VQbGF5aW5nKCkpIHtcbiAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICAgIHRoaXMudXBkYXRlRnJhbWUoKTtcbiAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICB9XG4gIH1cbiAgX29uQ2FuUGxheSgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc291cmNlO1xuICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgIHRoaXMuX21lZGlhUmVhZHkoKTtcbiAgfVxuICBfb25DYW5QbGF5VGhyb3VnaCgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc291cmNlO1xuICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICBpZiAodGhpcy5fcHJlbG9hZFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wcmVsb2FkVGltZW91dCk7XG4gICAgICB0aGlzLl9wcmVsb2FkVGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgdGhpcy5fbWVkaWFSZWFkeSgpO1xuICB9XG4gIC8qKiBGaXJlZCB3aGVuIHRoZSB2aWRlbyBpcyBsb2FkZWQgYW5kIHJlYWR5IHRvIHBsYXkuICovXG4gIF9tZWRpYVJlYWR5KCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb3VyY2U7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplKHNvdXJjZS52aWRlb1dpZHRoLCBzb3VyY2UudmlkZW9IZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDA7XG4gICAgdGhpcy51cGRhdGVGcmFtZSgpO1xuICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICBpZiAodGhpcy5fcmVzb2x2ZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzKTtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU291cmNlUGxheWluZygpKSB7XG4gICAgICB0aGlzLl9vblBsYXlTdGFydCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvUGxheSkge1xuICAgICAgdm9pZCB0aGlzLnJlc291cmNlLnBsYXkoKTtcbiAgICB9XG4gIH1cbiAgLyoqIENsZWFucyB1cCByZXNvdXJjZXMgYW5kIGV2ZW50IGxpc3RlbmVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZXh0dXJlLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc291cmNlO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheVwiLCB0aGlzLl9vblBsYXlTdGFydCk7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIHRoaXMuX29uUGxheVN0b3ApO1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgdGhpcy5fb25TZWVrZWQpO1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX29uQ2FuUGxheVRocm91Z2gpO1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCB0cnVlKTtcbiAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgc291cmNlLnNyYyA9IFwiXCI7XG4gICAgICBzb3VyY2UubG9hZCgpO1xuICAgIH1cbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgLyoqIFNob3VsZCB0aGUgYmFzZSB0ZXh0dXJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlIGl0c2VsZiwgc2V0IHRvIHRydWUgYnkgZGVmYXVsdC4gKi9cbiAgZ2V0IGF1dG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9VcGRhdGU7XG4gIH1cbiAgc2V0IGF1dG9VcGRhdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2F1dG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhvdyBtYW55IHRpbWVzIGEgc2Vjb25kIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSB2aWRlby5cbiAgICogTGVhdmUgYXQgMCB0byB1cGRhdGUgYXQgZXZlcnkgcmVuZGVyLlxuICAgKiBBIGxvd2VyIGZwcyBjYW4gaGVscCBwZXJmb3JtYW5jZSwgYXMgdXBkYXRpbmcgdGhlIHRleHR1cmUgYXQgNjBmcHMgb24gYSAzMHBzIHZpZGVvIG1heSBub3QgYmUgZWZmaWNpZW50LlxuICAgKi9cbiAgZ2V0IHVwZGF0ZUZQUygpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRlBTO1xuICB9XG4gIHNldCB1cGRhdGVGUFModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3VwZGF0ZUZQUykge1xuICAgICAgdGhpcy5fdXBkYXRlRlBTID0gdmFsdWU7XG4gICAgICB0aGlzLl9jb25maWd1cmVBdXRvVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHRoZSB1cGRhdGluZyBtZWNoYW5pc20gYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHNldHRpbmdzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkZWNpZGVzIGJldHdlZW4gdXNpbmcgdGhlIGJyb3dzZXIncyBuYXRpdmUgdmlkZW8gZnJhbWUgY2FsbGJhY2sgb3IgYSBjdXN0b20gdGlja2VyXG4gICAqIGZvciB1cGRhdGluZyB0aGUgdmlkZW8gZnJhbWUuIEl0IGVuc3VyZXMgb3B0aW1hbCBwZXJmb3JtYW5jZSBhbmQgcmVzcG9uc2l2ZW5lc3NcbiAgICogYmFzZWQgb24gdGhlIHZpZGVvJ3Mgc3RhdGUsIHBsYXliYWNrIHN0YXR1cywgYW5kIHRoZSBkZXNpcmVkIGZyYW1lcy1wZXItc2Vjb25kIHNldHRpbmcuXG4gICAqXG4gICAqIC0gSWYgYF9hdXRvVXBkYXRlYCBpcyBlbmFibGVkIGFuZCB0aGUgdmlkZW8gc291cmNlIGlzIHBsYXlpbmc6XG4gICAqICAgLSBJdCB3aWxsIHByZWZlciB0aGUgbmF0aXZlIHZpZGVvIGZyYW1lIGNhbGxiYWNrIGlmIGF2YWlsYWJsZSBhbmQgbm8gc3BlY2lmaWMgRlBTIGlzIHNldC5cbiAgICogICAtIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgYSBjdXN0b20gdGlja2VyIGZvciBtYW51YWwgdXBkYXRlcy5cbiAgICogLSBJZiBgX2F1dG9VcGRhdGVgIGlzIGRpc2FibGVkIG9yIHRoZSB2aWRlbyBpc24ndCBwbGF5aW5nLCBhbnkgYWN0aXZlIHVwZGF0ZSBtZWNoYW5pc21zIGFyZSBoYWx0ZWQuXG4gICAqL1xuICBfY29uZmlndXJlQXV0b1VwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fYXV0b1VwZGF0ZSAmJiB0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSkge1xuICAgICAgaWYgKCF0aGlzLl91cGRhdGVGUFMgJiYgdGhpcy5yZXNvdXJjZS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyKSB7XG4gICAgICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGVGcmFtZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSB0aGlzLnJlc291cmNlLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soXG4gICAgICAgICAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlc291cmNlLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlKTtcbiAgICAgICAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgICAgICBUaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZUZyYW1lLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZXNvdXJjZS5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2sodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSk7XG4gICAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGVGcmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgdGVzdChyZXNvdXJjZSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkhUTUxWaWRlb0VsZW1lbnQgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50O1xuICB9XG59O1xuX1ZpZGVvU291cmNlLmV4dGVuc2lvbiA9IEV4dGVuc2lvblR5cGUuVGV4dHVyZVNvdXJjZTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB2aWRlbyBzb3VyY2VzLiAqL1xuX1ZpZGVvU291cmNlLmRlZmF1bHRPcHRpb25zID0ge1xuICAuLi5UZXh0dXJlU291cmNlLmRlZmF1bHRPcHRpb25zLFxuICAvKiogSWYgdHJ1ZSwgdGhlIHZpZGVvIHdpbGwgc3RhcnQgbG9hZGluZyBpbW1lZGlhdGVseS4gKi9cbiAgYXV0b0xvYWQ6IHRydWUsXG4gIC8qKiBJZiB0cnVlLCB0aGUgdmlkZW8gd2lsbCBzdGFydCBwbGF5aW5nIGFzIHNvb24gYXMgaXQgaXMgbG9hZGVkLiAqL1xuICBhdXRvUGxheTogdHJ1ZSxcbiAgLyoqIFRoZSBudW1iZXIgb2YgdGltZXMgYSBzZWNvbmQgdG8gdXBkYXRlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIHZpZGVvLiBMZWF2ZSBhdCAwIHRvIHVwZGF0ZSBhdCBldmVyeSByZW5kZXIuICovXG4gIHVwZGF0ZUZQUzogMCxcbiAgLyoqIElmIHRydWUsIHRoZSB2aWRlbyB3aWxsIGJlIGxvYWRlZCB3aXRoIHRoZSBgY3Jvc3NvcmlnaW5gIGF0dHJpYnV0ZS4gKi9cbiAgY3Jvc3NvcmlnaW46IHRydWUsXG4gIC8qKiBJZiB0cnVlLCB0aGUgdmlkZW8gd2lsbCBsb29wIHdoZW4gaXQgZW5kcy4gKi9cbiAgbG9vcDogZmFsc2UsXG4gIC8qKiBJZiB0cnVlLCB0aGUgdmlkZW8gd2lsbCBiZSBtdXRlZC4gKi9cbiAgbXV0ZWQ6IHRydWUsXG4gIC8qKiBJZiB0cnVlLCB0aGUgdmlkZW8gd2lsbCBwbGF5IGlubGluZS4gKi9cbiAgcGxheXNpbmxpbmU6IHRydWUsXG4gIC8qKiBJZiB0cnVlLCB0aGUgdmlkZW8gd2lsbCBiZSBwcmVsb2FkZWQuICovXG4gIHByZWxvYWQ6IGZhbHNlXG59O1xuLyoqXG4gKiBNYXAgb2YgdmlkZW8gTUlNRSB0eXBlcyB0aGF0IGNhbid0IGJlIGRpcmVjdGx5IGRlcml2ZWQgZnJvbSBmaWxlIGV4dGVuc2lvbnMuXG4gKiBAcmVhZG9ubHlcbiAqL1xuX1ZpZGVvU291cmNlLk1JTUVfVFlQRVMgPSB7XG4gIG9ndjogXCJ2aWRlby9vZ2dcIixcbiAgbW92OiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBtNHY6IFwidmlkZW8vbXA0XCJcbn07XG5sZXQgVmlkZW9Tb3VyY2UgPSBfVmlkZW9Tb3VyY2U7XG5cbmV4cG9ydCB7IFZpZGVvU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWRlb1NvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBBbHBoYU1hc2sgfSBmcm9tICcuL21hc2svYWxwaGEvQWxwaGFNYXNrLm1qcyc7XG5pbXBvcnQgeyBDb2xvck1hc2sgfSBmcm9tICcuL21hc2svY29sb3IvQ29sb3JNYXNrLm1qcyc7XG5pbXBvcnQgeyBTdGVuY2lsTWFzayB9IGZyb20gJy4vbWFzay9zdGVuY2lsL1N0ZW5jaWxNYXNrLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJJbWFnZVNvdXJjZSB9IGZyb20gJy4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQnVmZmVySW1hZ2VTb3VyY2UubWpzJztcbmltcG9ydCB7IENhbnZhc1NvdXJjZSB9IGZyb20gJy4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQ2FudmFzU291cmNlLm1qcyc7XG5pbXBvcnQgeyBJbWFnZVNvdXJjZSB9IGZyb20gJy4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvSW1hZ2VTb3VyY2UubWpzJztcbmltcG9ydCB7IFZpZGVvU291cmNlIH0gZnJvbSAnLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9WaWRlb1NvdXJjZS5tanMnO1xuaW1wb3J0ICcuL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy90ZXh0dXJlRnJvbS5tanMnO1xuaW1wb3J0ICcuL21hc2svTWFza0VmZmVjdE1hbmFnZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChBbHBoYU1hc2ssIENvbG9yTWFzaywgU3RlbmNpbE1hc2ssIFZpZGVvU291cmNlLCBJbWFnZVNvdXJjZSwgQ2FudmFzU291cmNlLCBCdWZmZXJJbWFnZVNvdXJjZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9846\n')},6582:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ CLEAR)\n/* harmony export */ });\n\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2["NONE"] = 0] = "NONE";\n  CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";\n  CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";\n  CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";\n  CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";\n  CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";\n  CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";\n  CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";\n  return CLEAR2;\n})(CLEAR || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOztBQUVHO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvY29uc3QubWpzP2VhZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ0xFQVIgPSAvKiBAX19QVVJFX18gKi8gKChDTEVBUjIpID0+IHtcbiAgQ0xFQVIyW0NMRUFSMltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBDTEVBUjJbQ0xFQVIyW1wiQ09MT1JcIl0gPSAxNjM4NF0gPSBcIkNPTE9SXCI7XG4gIENMRUFSMltDTEVBUjJbXCJTVEVOQ0lMXCJdID0gMTAyNF0gPSBcIlNURU5DSUxcIjtcbiAgQ0xFQVIyW0NMRUFSMltcIkRFUFRIXCJdID0gMjU2XSA9IFwiREVQVEhcIjtcbiAgQ0xFQVIyW0NMRUFSMltcIkNPTE9SX0RFUFRIXCJdID0gMTY2NDBdID0gXCJDT0xPUl9ERVBUSFwiO1xuICBDTEVBUjJbQ0xFQVIyW1wiQ09MT1JfU1RFTkNJTFwiXSA9IDE3NDA4XSA9IFwiQ09MT1JfU1RFTkNJTFwiO1xuICBDTEVBUjJbQ0xFQVIyW1wiREVQVEhfU1RFTkNJTFwiXSA9IDEyODBdID0gXCJERVBUSF9TVEVOQ0lMXCI7XG4gIENMRUFSMltDTEVBUjJbXCJBTExcIl0gPSAxNzY2NF0gPSBcIkFMTFwiO1xuICByZXR1cm4gQ0xFQVIyO1xufSkoQ0xFQVIgfHwge30pO1xuXG5leHBvcnQgeyBDTEVBUiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6582\n')},8407:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   K: () => (/* binding */ getTestContext)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n\n\n"use strict";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n    context = canvas.getContext("webgl", {});\n  }\n  return context;\n}\n\n\n//# sourceMappingURL=getTestContext.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQwNy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBVTtBQUM3QiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFRlc3RDb250ZXh0Lm1qcz85ZDk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IGNvbnRleHQ7XG5mdW5jdGlvbiBnZXRUZXN0Q29udGV4dCgpIHtcbiAgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQ/LmlzQ29udGV4dExvc3QoKSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwge30pO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgeyBnZXRUZXN0Q29udGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VGVzdENvbnRleHQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8407\n')},9818:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   v: () => (/* binding */ BindGroup)\n/* harmony export */ });\n\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join("|");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    resource.on?.("change", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to \'touch\' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\n\n//# sourceMappingURL=BindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgxOC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanM/Njg0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJpbmRHcm91cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UgZW9mIHRoZSBCaW5kIEdyb3VwLlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIC0gVGhlIHJlc291cmNlcyB0aGF0IGFyZSBib3VuZCB0b2dldGhlciBmb3IgdXNlIGJ5IGEgc2hhZGVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzb3VyY2VzKSB7XG4gICAgLyoqIFRoZSByZXNvdXJjZXMgdGhhdCBhcmUgYm91bmQgdG9nZXRoZXIgZm9yIHVzZSBieSBhIHNoYWRlci4gKi9cbiAgICB0aGlzLnJlc291cmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzW2ldO1xuICAgICAgdGhpcy5zZXRSZXNvdXJjZShyZXNvdXJjZSwgaW5kZXgrKyk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUtleSgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBrZXkgaWYgaXRzIGZsYWdnZWQgYXMgZGlydHkuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvXG4gICAqIG1hdGNoIHRoaXMgYmluZCBncm91cCB0byBhIFdlYkdQVSBCaW5kR3JvdXAuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfdXBkYXRlS2V5KCkge1xuICAgIGlmICghdGhpcy5fZGlydHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICBjb25zdCBrZXlQYXJ0cyA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMucmVzb3VyY2VzKSB7XG4gICAgICBrZXlQYXJ0c1tpbmRleCsrXSA9IHRoaXMucmVzb3VyY2VzW2ldLl9yZXNvdXJjZUlkO1xuICAgIH1cbiAgICB0aGlzLl9rZXkgPSBrZXlQYXJ0cy5qb2luKFwifFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgcmVzb3VyY2UgYXQgYSBnaXZlbiBpbmRleC4gdGhpcyBmdW5jdGlvbiB3aWxsXG4gICAqIGVuc3VyZSB0aGF0IGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgKiBhbmQgYWRkZWQgdG8gdGhlIG5ldyByZXNvdXJjZS5cbiAgICogQHBhcmFtIHJlc291cmNlIC0gVGhlIHJlc291cmNlIHRvIHNldC5cbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIHNldCB0aGUgcmVzb3VyY2UgYXQuXG4gICAqL1xuICBzZXRSZXNvdXJjZShyZXNvdXJjZSwgaW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50UmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1tpbmRleF07XG4gICAgaWYgKHJlc291cmNlID09PSBjdXJyZW50UmVzb3VyY2UpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGN1cnJlbnRSZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2Uub2ZmPy4oXCJjaGFuZ2VcIiwgdGhpcy5vblJlc291cmNlQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgcmVzb3VyY2Uub24/LihcImNoYW5nZVwiLCB0aGlzLm9uUmVzb3VyY2VDaGFuZ2UsIHRoaXMpO1xuICAgIHRoaXMucmVzb3VyY2VzW2luZGV4XSA9IHJlc291cmNlO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb3VyY2UgYXQgdGhlIGN1cnJlbnQgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJlc291cmNlIHRvIGdldC5cbiAgICogQHJldHVybnMgLSBUaGUgcmVzb3VyY2UgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICovXG4gIGdldFJlc291cmNlKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzW2luZGV4XTtcbiAgfVxuICAvKipcbiAgICogVXNlZCBpbnRlcm5hbGx5IHRvICd0b3VjaCcgZWFjaCByZXNvdXJjZSwgdG8gZW5zdXJlIHRoYXQgdGhlIEdDXG4gICAqIGtub3dzIHRoYXQgYWxsIHJlc291cmNlcyBpbiB0aGlzIGJpbmQgZ3JvdXAgYXJlIHN0aWxsIGJlaW5nIHVzZWQuXG4gICAqIEBwYXJhbSB0aWNrIC0gVGhlIGN1cnJlbnQgdGljay5cbiAgICogQGludGVybmFsXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF90b3VjaCh0aWNrKSB7XG4gICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5yZXNvdXJjZXM7XG4gICAgZm9yIChjb25zdCBpIGluIHJlc291cmNlcykge1xuICAgICAgcmVzb3VyY2VzW2ldLl90b3VjaGVkID0gdGljaztcbiAgICB9XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgYmluZCBncm91cCBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMucmVzb3VyY2VzO1xuICAgIGZvciAoY29uc3QgaSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzW2ldO1xuICAgICAgcmVzb3VyY2Uub2ZmPy4oXCJjaGFuZ2VcIiwgdGhpcy5vblJlc291cmNlQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5yZXNvdXJjZXMgPSBudWxsO1xuICB9XG4gIG9uUmVzb3VyY2VDaGFuZ2UocmVzb3VyY2UpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgaWYgKHJlc291cmNlLmRlc3Ryb3llZCkge1xuICAgICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5yZXNvdXJjZXM7XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gcmVzb3VyY2VzKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZXNbaV0gPT09IHJlc291cmNlKSB7XG4gICAgICAgICAgcmVzb3VyY2VzW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVLZXkoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQmluZEdyb3VwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaW5kR3JvdXAubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9818\n')},7494:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l: () => (/* binding */ Buffer)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1580);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6258);\n/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5324);\n\n\n\n\n"use strict";\nclass Buffer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("buffer");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = "buffer";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC;\n    } else {\n      this.descriptor.usage &= ~_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit("update", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit("update", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n        this.emit("change", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit("update", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit("update", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.emit("change", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\n\n//# sourceMappingURL=Buffer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUM7QUFDWTtBQUNYOztBQUUxQztBQUNBLHFCQUFxQiw4REFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0REFBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQVc7QUFDMUMsTUFBTTtBQUNOLGdDQUFnQyw0REFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkJBQTJCLGlFQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvQnVmZmVyLm1qcz9jY2MyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgQnVmZmVyVXNhZ2UgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQnVmZmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQnVmZmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb3B0aW9ucyBmb3IgdGhlIGJ1ZmZlclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGxldCB7IGRhdGEsIHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyB1c2FnZSwgbGFiZWwsIHNocmlua1RvRml0IH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogZW1pdHMgd2hlbiB0aGUgdW5kZXJseWluZyBidWZmZXIgaGFzIGNoYW5nZWQgc2hhcGUgKGkuZS4gcmVzaXplZClcbiAgICAgKiBsZXR0aW5nIHRoZSByZW5kZXJlciBrbm93IHRoYXQgaXQgbmVlZHMgdG8gZGlzY2FyZCB0aGUgb2xkIGJ1ZmZlciBvbiB0aGUgR1BVIGFuZCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGVtaXRzIHdoZW4gdGhlIHVuZGVybHlpbmcgYnVmZmVyIGRhdGEgaGFzIGJlZW4gdXBkYXRlZC4gbGV0dGluZyB0aGUgcmVuZGVyZXIga25vd1xuICAgICAqIHRoYXQgaXQgbmVlZHMgdG8gdXBkYXRlIHRoZSBidWZmZXIgb24gdGhlIEdQVVxuICAgICAqIEBldmVudCB1cGRhdGVcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBlbWl0cyB3aGVuIHRoZSBidWZmZXIgaXMgZGVzdHJveWVkLiBsZXR0aW5nIHRoZSByZW5kZXJlciBrbm93IHRoYXQgaXQgbmVlZHMgdG8gZGVzdHJveSB0aGUgYnVmZmVyIG9uIHRoZSBHUFVcbiAgICAgKiBAZXZlbnQgZGVzdHJveVxuICAgICAqL1xuICAgIC8qKiBhIHVuaXF1ZSBpZCBmb3IgdGhpcyB1bmlmb3JtIGdyb3VwIHVzZWQgdGhyb3VnaCB0aGUgcmVuZGVyZXIgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcImJ1ZmZlclwiKTtcbiAgICAvKipcbiAgICAgKiBhIHJlc291cmNlIHR5cGUsIHVzZWQgdG8gaWRlbnRpZnkgaG93IHRvIGhhbmRsZSBpdCB3aGVuIGl0cyBpbiBhIGJpbmQgZ3JvdXAgLyBzaGFkZXIgcmVzb3VyY2VcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcmVzb3VyY2VUeXBlID0gXCJidWZmZXJcIjtcbiAgICAvKipcbiAgICAgKiB0aGUgcmVzb3VyY2UgaWQgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSByZW5kZXJlciB0byBidWlsZCBiaW5kIGdyb3VwIGtleXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgIC8qKlxuICAgICAqIHVzZWQgaW50ZXJuYWxseSB0byBrbm93IGlmIGEgdW5pZm9ybSBncm91cCB3YXMgdXNlZCBpbiB0aGUgbGFzdCByZW5kZXIgcGFzc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl90b3VjaGVkID0gMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fdXBkYXRlSUQgPSAxO1xuICAgIC8qKlxuICAgICAqIHNob3VsZCB0aGUgR1BVIGJ1ZmZlciBiZSBzaHJ1bmsgd2hlbiB0aGUgZGF0YSBiZWNvbWVzIHNtYWxsZXI/XG4gICAgICogY2hhbmdpbmcgdGhpcyB3aWxsIGNhdXNlIHRoZSBidWZmZXIgdG8gYmUgZGVzdHJveWVkIGFuZCBhIG5ldyBvbmUgY3JlYXRlZCBvbiB0aGUgR1BVXG4gICAgICogdGhpcyBjYW4gYmUgZXhwZW5zaXZlLCBlc3BlY2lhbGx5IGlmIHRoZSBidWZmZXIgaXMgYWxyZWFkeSBiaWcgZW5vdWdoIVxuICAgICAqIHNldHRpbmcgdGhpcyB0byBmYWxzZSB3aWxsIHByZXZlbnQgdGhlIGJ1ZmZlciBmcm9tIGJlaW5nIHNocnVuay4gVGhpcyB3aWxsIHlpZWxkIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAqIGlmIHlvdSBhcmUgY29uc3RhbnRseSBzZXR0aW5nIGRhdGEgdGhhdCBpcyBjaGFuZ2luZyBzaXplIG9mdGVuLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLnNocmlua1RvRml0ID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIGJ1ZmZlciBiZWVuIGRlc3Ryb3llZD9cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICBzaXplID0gc2l6ZSA/PyBkYXRhPy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IG1hcHBlZEF0Q3JlYXRpb24gPSAhIWRhdGE7XG4gICAgdGhpcy5kZXNjcmlwdG9yID0ge1xuICAgICAgc2l6ZSxcbiAgICAgIHVzYWdlLFxuICAgICAgbWFwcGVkQXRDcmVhdGlvbixcbiAgICAgIGxhYmVsXG4gICAgfTtcbiAgICB0aGlzLnNocmlua1RvRml0ID0gc2hyaW5rVG9GaXQgPz8gdHJ1ZTtcbiAgfVxuICAvKiogdGhlIGRhdGEgaW4gdGhlIGJ1ZmZlciAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0RGF0YVdpdGhTaXplKHZhbHVlLCB2YWx1ZS5sZW5ndGgsIHRydWUpO1xuICB9XG4gIC8qKiB3aGV0aGVyIHRoZSBidWZmZXIgaXMgc3RhdGljIG9yIG5vdCAqL1xuICBnZXQgc3RhdGljKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRlc2NyaXB0b3IudXNhZ2UgJiBCdWZmZXJVc2FnZS5TVEFUSUMpO1xuICB9XG4gIHNldCBzdGF0aWModmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRvci51c2FnZSB8PSBCdWZmZXJVc2FnZS5TVEFUSUM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRvci51c2FnZSAmPSB+QnVmZmVyVXNhZ2UuU1RBVElDO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGF0YSBpbiB0aGUgYnVmZmVyIHRvIHRoZSBnaXZlbiB2YWx1ZS4gVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHVwZGF0ZSB0aGUgYnVmZmVyIG9uIHRoZSBHUFUuXG4gICAqIElmIHlvdSBvbmx5IHdhbnQgdG8gdXBkYXRlIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIsIHlvdSBjYW4gcGFzcyBpbiB0aGUgc2l6ZSBvZiB0aGUgZGF0YS5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIGRhdGEgdG8gc2V0XG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGRhdGEgaW4gYnl0ZXNcbiAgICogQHBhcmFtIHN5bmNHUFUgLSBzaG91bGQgdGhlIGJ1ZmZlciBiZSB1cGRhdGVkIG9uIHRoZSBHUFUgaW1tZWRpYXRlbHk/XG4gICAqL1xuICBzZXREYXRhV2l0aFNpemUodmFsdWUsIHNpemUsIHN5bmNHUFUpIHtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIHRoaXMuX3VwZGF0ZVNpemUgPSBzaXplICogdmFsdWUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgaWYgKHRoaXMuX2RhdGEgPT09IHZhbHVlKSB7XG4gICAgICBpZiAoc3luY0dQVSlcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB0aGlzLl9kYXRhID0gdmFsdWU7XG4gICAgaWYgKG9sZERhdGEubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGlmICghdGhpcy5zaHJpbmtUb0ZpdCAmJiB2YWx1ZS5ieXRlTGVuZ3RoIDwgb2xkRGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChzeW5jR1BVKVxuICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRvci5zaXplID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzeW5jR1BVKVxuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiB1cGRhdGVzIHRoZSBidWZmZXIgb24gdGhlIEdQVSB0byByZWZsZWN0IHRoZSBkYXRhIGluIHRoZSBidWZmZXIuXG4gICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCB1cGRhdGUgdGhlIGVudGlyZSBidWZmZXIuIElmIHlvdSBvbmx5IHdhbnQgdG8gdXBkYXRlIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIsXG4gICAqIHlvdSBjYW4gcGFzcyBpbiB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHNpemVJbkJ5dGVzIC0gdGhlIG5ldyBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXNcbiAgICovXG4gIHVwZGF0ZShzaXplSW5CeXRlcykge1xuICAgIHRoaXMuX3VwZGF0ZVNpemUgPSBzaXplSW5CeXRlcyA/PyB0aGlzLl91cGRhdGVTaXplO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgYnVmZmVyICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIiwgdGhpcyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHRoaXMpO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIHRoaXMuZGVzY3JpcHRvciA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBCdWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7494\n')},5324:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ BufferUsage)\n/* harmony export */ });\n\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";\n  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";\n  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";\n  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";\n  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";\n  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";\n  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";\n  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";\n  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";\n  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";\n  BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";\n  return BufferUsage2;\n})(BufferUsage || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7O0FBRUc7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL2NvbnN0Lm1qcz80NjkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIEJ1ZmZlclVzYWdlID0gLyogQF9fUFVSRV9fICovICgoQnVmZmVyVXNhZ2UyKSA9PiB7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJNQVBfUkVBRFwiXSA9IDFdID0gXCJNQVBfUkVBRFwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiTUFQX1dSSVRFXCJdID0gMl0gPSBcIk1BUF9XUklURVwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiQ09QWV9TUkNcIl0gPSA0XSA9IFwiQ09QWV9TUkNcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIkNPUFlfRFNUXCJdID0gOF0gPSBcIkNPUFlfRFNUXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJJTkRFWFwiXSA9IDE2XSA9IFwiSU5ERVhcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIlZFUlRFWFwiXSA9IDMyXSA9IFwiVkVSVEVYXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJVTklGT1JNXCJdID0gNjRdID0gXCJVTklGT1JNXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJTVE9SQUdFXCJdID0gMTI4XSA9IFwiU1RPUkFHRVwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiSU5ESVJFQ1RcIl0gPSAyNTZdID0gXCJJTkRJUkVDVFwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiUVVFUllfUkVTT0xWRVwiXSA9IDUxMl0gPSBcIlFVRVJZX1JFU09MVkVcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIlNUQVRJQ1wiXSA9IDEwMjRdID0gXCJTVEFUSUNcIjtcbiAgcmV0dXJuIEJ1ZmZlclVzYWdlMjtcbn0pKEJ1ZmZlclVzYWdlIHx8IHt9KTtcblxuZXhwb3J0IHsgQnVmZmVyVXNhZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5324\n')},6633:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ fastCopy)\n/* harmony export */ });\n\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\n\n//# sourceMappingURL=fastCopy.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYzMy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL3V0aWxzL2Zhc3RDb3B5Lm1qcz8wYjM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZmFzdENvcHkoc291cmNlQnVmZmVyLCBkZXN0aW5hdGlvbkJ1ZmZlcikge1xuICBjb25zdCBsZW5ndGhEb3VibGUgPSBzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aCAvIDggfCAwO1xuICBjb25zdCBzb3VyY2VGbG9hdDY0VmlldyA9IG5ldyBGbG9hdDY0QXJyYXkoc291cmNlQnVmZmVyLCAwLCBsZW5ndGhEb3VibGUpO1xuICBjb25zdCBkZXN0aW5hdGlvbkZsb2F0NjRWaWV3ID0gbmV3IEZsb2F0NjRBcnJheShkZXN0aW5hdGlvbkJ1ZmZlciwgMCwgbGVuZ3RoRG91YmxlKTtcbiAgZGVzdGluYXRpb25GbG9hdDY0Vmlldy5zZXQoc291cmNlRmxvYXQ2NFZpZXcpO1xuICBjb25zdCByZW1haW5pbmdCeXRlcyA9IHNvdXJjZUJ1ZmZlci5ieXRlTGVuZ3RoIC0gbGVuZ3RoRG91YmxlICogODtcbiAgaWYgKHJlbWFpbmluZ0J5dGVzID4gMCkge1xuICAgIGNvbnN0IHNvdXJjZVVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KHNvdXJjZUJ1ZmZlciwgbGVuZ3RoRG91YmxlICogOCwgcmVtYWluaW5nQnl0ZXMpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uVWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGVzdGluYXRpb25CdWZmZXIsIGxlbmd0aERvdWJsZSAqIDgsIHJlbWFpbmluZ0J5dGVzKTtcbiAgICBkZXN0aW5hdGlvblVpbnQ4Vmlldy5zZXQoc291cmNlVWludDhWaWV3KTtcbiAgfVxufVxuXG5leHBvcnQgeyBmYXN0Q29weSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFzdENvcHkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6633\n")},1980:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: () => (/* binding */ Geometry)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs\nvar Buffer = __webpack_require__(7494);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(5324);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs\n\n\n\n"use strict";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer/* Buffer */.l)) {\n    let usage = index ? buffer_const/* BufferUsage */.F.INDEX : buffer_const/* BufferUsage */.F.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = buffer_const/* BufferUsage */.F.INDEX | buffer_const/* BufferUsage */.F.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = buffer_const/* BufferUsage */.F.VERTEX | buffer_const/* BufferUsage */.F.COPY_DST;\n      }\n    }\n    buffer = new Buffer/* Buffer */.l({\n      data: buffer,\n      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",\n      usage\n    });\n  }\n  return buffer;\n}\n\n\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs\n\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getGeometryBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs\n\n\n\n\n\n\n\n"use strict";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer/* Buffer */.l || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends eventemitter3/* default */.Z {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options) {\n    const { attributes, indexBuffer, topology } = options;\n    super();\n    /** The unique id of the geometry. */\n    this.uid = (0,uid/* uid */.h)("geometry");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n    this.attributes = attributes;\n    this.buffers = [];\n    this.instanceCount = options.instanceCount || 1;\n    for (const i in attributes) {\n      const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n      const bufferIndex = this.buffers.indexOf(attribute.buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(attribute.buffer);\n        attribute.buffer.on("update", this.onBufferUpdate, this);\n        attribute.buffer.on("change", this.onBufferUpdate, this);\n      }\n    }\n    if (indexBuffer) {\n      this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n      this.buffers.push(this.indexBuffer);\n    }\n    this.topology = topology || "triangle-list";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit("update", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, "aPosition", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\n\n//# sourceMappingURL=Geometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNJOztBQUVyRDtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFNO0FBQ2hDLHdCQUF3QiwrQkFBVyxTQUFTLCtCQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBVyxTQUFTLCtCQUFXO0FBQy9DLFFBQVE7QUFDUjtBQUNBLGdCQUFnQiwrQkFBVyxVQUFVLCtCQUFXO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQzFCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUN0Q3lDO0FBQzhCO0FBQ2xCO0FBQ1A7QUFDYztBQUNNOztBQUVsRTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBLGVBQWUsa0JBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy9lbnN1cmVJc0J1ZmZlci5tanM/ZThhZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvZ2V0R2VvbWV0cnlCb3VuZHMubWpzP2Q1NzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcz8xNjk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uLy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vLi4vYnVmZmVyL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW5zdXJlSXNCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgbGV0IHVzYWdlID0gaW5kZXggPyBCdWZmZXJVc2FnZS5JTkRFWCA6IEJ1ZmZlclVzYWdlLlZFUlRFWDtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGlmIChpbmRleCkge1xuICAgICAgICBidWZmZXIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdXNhZ2UgPSBCdWZmZXJVc2FnZS5JTkRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICB1c2FnZSA9IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IGJ1ZmZlcixcbiAgICAgIGxhYmVsOiBpbmRleCA/IFwiaW5kZXgtbWVzaC1idWZmZXJcIiA6IFwidmVydGV4LW1lc2gtYnVmZmVyXCIsXG4gICAgICB1c2FnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmV4cG9ydCB7IGVuc3VyZUlzQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnN1cmVJc0J1ZmZlci5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldEdlb21ldHJ5Qm91bmRzKGdlb21ldHJ5LCBhdHRyaWJ1dGVJZCwgYm91bmRzKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVJZCk7XG4gIGlmICghYXR0cmlidXRlKSB7XG4gICAgYm91bmRzLm1pblggPSAwO1xuICAgIGJvdW5kcy5taW5ZID0gMDtcbiAgICBib3VuZHMubWF4WCA9IDA7XG4gICAgYm91bmRzLm1heFkgPSAwO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbiAgY29uc3QgZGF0YSA9IGF0dHJpYnV0ZS5idWZmZXIuZGF0YTtcbiAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgbGV0IG1pblkgPSBJbmZpbml0eTtcbiAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gIGxldCBtYXhZID0gLUluZmluaXR5O1xuICBjb25zdCBieXRlU2l6ZSA9IGRhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG4gIGNvbnN0IG9mZnNldCA9IChhdHRyaWJ1dGUub2Zmc2V0IHx8IDApIC8gYnl0ZVNpemU7XG4gIGNvbnN0IHN0cmlkZSA9IChhdHRyaWJ1dGUuc3RyaWRlIHx8IDIgKiA0KSAvIGJ5dGVTaXplO1xuICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeCA9IGRhdGFbaV07XG4gICAgY29uc3QgeSA9IGRhdGFbaSArIDFdO1xuICAgIGlmICh4ID4gbWF4WClcbiAgICAgIG1heFggPSB4O1xuICAgIGlmICh5ID4gbWF4WSlcbiAgICAgIG1heFkgPSB5O1xuICAgIGlmICh4IDwgbWluWClcbiAgICAgIG1pblggPSB4O1xuICAgIGlmICh5IDwgbWluWSlcbiAgICAgIG1pblkgPSB5O1xuICB9XG4gIGJvdW5kcy5taW5YID0gbWluWDtcbiAgYm91bmRzLm1pblkgPSBtaW5ZO1xuICBib3VuZHMubWF4WCA9IG1heFg7XG4gIGJvdW5kcy5tYXhZID0gbWF4WTtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZXhwb3J0IHsgZ2V0R2VvbWV0cnlCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEdlb21ldHJ5Qm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IGVuc3VyZUlzQnVmZmVyIH0gZnJvbSAnLi91dGlscy9lbnN1cmVJc0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgZ2V0R2VvbWV0cnlCb3VuZHMgfSBmcm9tICcuL3V0aWxzL2dldEdlb21ldHJ5Qm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW5zdXJlSXNBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gIGlmIChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBCdWZmZXIgfHwgQXJyYXkuaXNBcnJheShhdHRyaWJ1dGUpIHx8IGF0dHJpYnV0ZS5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgIGJ1ZmZlcjogYXR0cmlidXRlXG4gICAgfTtcbiAgfVxuICBhdHRyaWJ1dGUuYnVmZmVyID0gZW5zdXJlSXNCdWZmZXIoYXR0cmlidXRlLmJ1ZmZlciwgZmFsc2UpO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuY2xhc3MgR2VvbWV0cnkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgZ2VvbWV0cnlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGdlb21ldHJ5LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcywgaW5kZXhCdWZmZXIsIHRvcG9sb2d5IH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIFRoZSB1bmlxdWUgaWQgb2YgdGhlIGdlb21ldHJ5LiAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiZ2VvbWV0cnlcIik7XG4gICAgLyoqXG4gICAgICogdGhlIGxheW91dCBrZXkgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgV2ViR1BVIGFsbCBnZW9tZXRyaWVzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmVcbiAgICAgKiB3aWxsIGhhdmUgdGhlIHNhbWUgbGF5b3V0IGtleS4gVGhpcyBpcyB1c2VkIHRvIGNhY2hlIHRoZSBwaXBlbGluZSBsYXlvdXRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fbGF5b3V0S2V5ID0gMDtcbiAgICAvKiogdGhlIGluc3RhbmNlIGNvdW50IG9mIHRoZSBnZW9tZXRyeSB0byBkcmF3ICovXG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gMTtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gb3B0aW9ucy5pbnN0YW5jZUNvdW50IHx8IDE7XG4gICAgZm9yIChjb25zdCBpIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV0gPSBlbnN1cmVJc0F0dHJpYnV0ZShhdHRyaWJ1dGVzW2ldKTtcbiAgICAgIGNvbnN0IGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYXR0cmlidXRlLmJ1ZmZlcik7XG4gICAgICBpZiAoYnVmZmVySW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGF0dHJpYnV0ZS5idWZmZXIpO1xuICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyLm9uKFwidXBkYXRlXCIsIHRoaXMub25CdWZmZXJVcGRhdGUsIHRoaXMpO1xuICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyLm9uKFwiY2hhbmdlXCIsIHRoaXMub25CdWZmZXJVcGRhdGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5kZXhCdWZmZXIpIHtcbiAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBlbnN1cmVJc0J1ZmZlcihpbmRleEJ1ZmZlciwgdHJ1ZSk7XG4gICAgICB0aGlzLmJ1ZmZlcnMucHVzaCh0aGlzLmluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy50b3BvbG9neSA9IHRvcG9sb2d5IHx8IFwidHJpYW5nbGUtbGlzdFwiO1xuICB9XG4gIG9uQnVmZmVyVXBkYXRlKCkge1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgcmVxdWlyZWRcbiAgICogQHJldHVybnMgLSBUaGUgYXR0cmlidXRlIHJlcXVlc3RlZC5cbiAgICovXG4gIGdldEF0dHJpYnV0ZShpZCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbaWRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBidWZmZXJcbiAgICogQHJldHVybnMgLSBUaGUgaW5kZXggYnVmZmVyLlxuICAgKi9cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBidWZmZXIuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgcmVxdWlyZWQuXG4gICAqIEByZXR1cm5zIC0gVGhlIGJ1ZmZlciByZXF1ZXN0ZWQuXG4gICAqL1xuICBnZXRCdWZmZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoaWQpLmJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBmaWd1cmUgb3V0IGhvdyBtYW55IHZlcnRpY2VzIHRoZXJlIGFyZSBpbiB0aGlzIGdlb21ldHJ5XG4gICAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGdlb21ldHJ5XG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tpXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XG4gICAgICByZXR1cm4gYnVmZmVyLmRhdGEubGVuZ3RoIC8gKGF0dHJpYnV0ZS5zdHJpZGUgLyA0IHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgZ2VvbWV0cnkuICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgaWYgKCF0aGlzLl9ib3VuZHNEaXJ0eSlcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICByZXR1cm4gZ2V0R2VvbWV0cnlCb3VuZHModGhpcywgXCJhUG9zaXRpb25cIiwgdGhpcy5fYm91bmRzKTtcbiAgfVxuICAvKipcbiAgICogZGVzdHJveXMgdGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0gZGVzdHJveUJ1ZmZlcnMgLSBkZXN0cm95IHRoZSBidWZmZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGdlb21ldHJ5XG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lCdWZmZXJzID0gZmFsc2UpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgaWYgKGRlc3Ryb3lCdWZmZXJzKSB7XG4gICAgICB0aGlzLmJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiBidWZmZXIuZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1980\n')},1854:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ InstructionSet)\n/* harmony export */ });\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n"use strict";\nlet _tick = 0;\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("instructionSet");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n    this.renderables = [];\n    this.tick = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n    this.tick = _tick++;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, ["type", "action"]);\n  }\n}\n\n\n//# sourceMappingURL=InstructionSet.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1NC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9pbnN0cnVjdGlvbnMvSW5zdHJ1Y3Rpb25TZXQubWpzP2ZlNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgX3RpY2sgPSAwO1xuY2xhc3MgSW5zdHJ1Y3Rpb25TZXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogYSB1bmlxdWUgaWQgZm9yIHRoaXMgaW5zdHJ1Y3Rpb24gc2V0IHVzZWQgdGhyb3VnaCB0aGUgcmVuZGVyZXIgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcImluc3RydWN0aW9uU2V0XCIpO1xuICAgIC8qKiB0aGUgYXJyYXkgb2YgaW5zdHJ1Y3Rpb25zICovXG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAvKiogdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBhcnJheSAoYW55IGluc3RydWN0aW9ucyBwYXNzZWQgdGhpcyBzaG91bGQgYmUgaWdub3JlZCkgKi9cbiAgICB0aGlzLmluc3RydWN0aW9uU2l6ZSA9IDA7XG4gICAgdGhpcy5yZW5kZXJhYmxlcyA9IFtdO1xuICAgIHRoaXMudGljayA9IDA7XG4gIH1cbiAgLyoqIHJlc2V0IHRoZSBpbnN0cnVjdGlvbiBzZXQgc28gaXQgY2FuIGJlIHJldXNlZCBzZXQgc2l6ZSBiYWNrIHRvIDAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvblNpemUgPSAwO1xuICAgIHRoaXMudGljayA9IF90aWNrKys7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhbiBpbnN0cnVjdGlvbiB0byB0aGUgc2V0XG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvbiAtIGFkZCBhbiBpbnN0cnVjdGlvbiB0byB0aGUgc2V0XG4gICAqL1xuICBhZGQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9uU2l6ZSsrXSA9IGluc3RydWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBMb2cgdGhlIGluc3RydWN0aW9ucyB0byB0aGUgY29uc29sZSAoZm9yIGRlYnVnZ2luZylcbiAgICogQGludGVybmFsXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGxvZygpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPSB0aGlzLmluc3RydWN0aW9uU2l6ZTtcbiAgICBjb25zb2xlLnRhYmxlKHRoaXMuaW5zdHJ1Y3Rpb25zLCBbXCJ0eXBlXCIsIFwiYWN0aW9uXCJdKTtcbiAgfVxufVxuXG5leHBvcnQgeyBJbnN0cnVjdGlvblNldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5zdHJ1Y3Rpb25TZXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1854\n')},2475:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ STENCIL_MODES),\n/* harmony export */   f: () => (/* binding */ BLEND_TO_NPM)\n/* harmony export */ });\n\nconst BLEND_TO_NPM = {\n  normal: "normal-npm",\n  add: "add-npm",\n  screen: "screen-npm"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";\n  STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";\n  STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3NS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFaUI7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvY29uc3QubWpzPzQ4YzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBCTEVORF9UT19OUE0gPSB7XG4gIG5vcm1hbDogXCJub3JtYWwtbnBtXCIsXG4gIGFkZDogXCJhZGQtbnBtXCIsXG4gIHNjcmVlbjogXCJzY3JlZW4tbnBtXCJcbn07XG52YXIgU1RFTkNJTF9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNURU5DSUxfTU9ERVMyKSA9PiB7XG4gIFNURU5DSUxfTU9ERVMyW1NURU5DSUxfTU9ERVMyW1wiRElTQUJMRURcIl0gPSAwXSA9IFwiRElTQUJMRURcIjtcbiAgU1RFTkNJTF9NT0RFUzJbU1RFTkNJTF9NT0RFUzJbXCJSRU5ERVJJTkdfTUFTS19BRERcIl0gPSAxXSA9IFwiUkVOREVSSU5HX01BU0tfQUREXCI7XG4gIFNURU5DSUxfTU9ERVMyW1NURU5DSUxfTU9ERVMyW1wiTUFTS19BQ1RJVkVcIl0gPSAyXSA9IFwiTUFTS19BQ1RJVkVcIjtcbiAgU1RFTkNJTF9NT0RFUzJbU1RFTkNJTF9NT0RFUzJbXCJSRU5ERVJJTkdfTUFTS19SRU1PVkVcIl0gPSAzXSA9IFwiUkVOREVSSU5HX01BU0tfUkVNT1ZFXCI7XG4gIFNURU5DSUxfTU9ERVMyW1NURU5DSUxfTU9ERVMyW1wiTk9ORVwiXSA9IDRdID0gXCJOT05FXCI7XG4gIHJldHVybiBTVEVOQ0lMX01PREVTMjtcbn0pKFNURU5DSUxfTU9ERVMgfHwge30pO1xuXG5leHBvcnQgeyBCTEVORF9UT19OUE0sIFNURU5DSUxfTU9ERVMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2475\n')},2796:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ getAdjustedBlendModeBlend)\n/* harmony export */ });\n/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2475);\n\n\n"use strict";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === "no-premultiply-alpha") {\n    return _const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .BLEND_TO_NPM */ .f[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\n\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc5Ni5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFcUM7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZC5tanM/YjFlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCTEVORF9UT19OUE0gfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZChibGVuZE1vZGUsIHRleHR1cmVTb3VyY2UpIHtcbiAgaWYgKHRleHR1cmVTb3VyY2UuYWxwaGFNb2RlID09PSBcIm5vLXByZW11bHRpcGx5LWFscGhhXCIpIHtcbiAgICByZXR1cm4gQkxFTkRfVE9fTlBNW2JsZW5kTW9kZV0gfHwgYmxlbmRNb2RlO1xuICB9XG4gIHJldHVybiBibGVuZE1vZGU7XG59XG5cbmV4cG9ydCB7IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2796\n')},7400:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  I: () => (/* binding */ AbstractRenderer)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs\n\n\n"use strict";\nconst environments = [];\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.Environment, environments);\nasync function loadEnvironmentExtensions(skip) {\n  if (skip)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\nasync function autoDetectEnvironment(add) {\n  return loadEnvironmentExtensions(!add);\n}\n\n\n//# sourceMappingURL=autoDetectEnvironment.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(8400);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs\nvar unsafeEvalSupported = __webpack_require__(1013);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(6582);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs\nvar SystemRunner = __webpack_require__(7051);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst defaultRunners = [\n  "init",\n  "destroy",\n  "contextChange",\n  "resolutionChange",\n  "reset",\n  "renderEnd",\n  "renderStart",\n  "render",\n  "update",\n  "postrender",\n  "prerender"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends eventemitter3/* default */.Z {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    this.runners = /* @__PURE__ */ Object.create(null);\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    this.config = config;\n    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n    await loadEnvironmentExtensions(skip);\n    this._addSystems(this.config.systems);\n    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof Container/* Container */.W2) {\n      options = { container: options };\n      if (deprecated) {\n        (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "passing a second argument is deprecated, please use render options instead");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor = this.background.colorRgba;\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : Color/* Color */.I.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    const previousResolution = this.view.resolution;\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);\n    if (resolution !== void 0 && resolution !== previousResolution) {\n      this.runners.resolutionChange.emit(resolution);\n    }\n  }\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = gl_const/* CLEAR */.E.ALL);\n    const { clear, clearColor, target } = options;\n    Color/* Color */.I.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, Color/* Color */.I.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new SystemRunner/* SystemRunner */.P(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn\'t collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name "${name}" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn\'t support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!(0,unsafeEvalSupported/* unsafeEvalSupported */.O)()) {\n      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");\n    }\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\n\n//# sourceMappingURL=AbstractRenderer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5RTs7QUFFekU7QUFDQTtBQUNBLDZCQUFVLG1CQUFtQixnQ0FBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0RDtBQUM1RDs7Ozs7Ozs7Ozs7Ozs7O0FDckJvRDtBQUMwQztBQUN4QjtBQUNrQjtBQUNSO0FBQzNDO0FBQ007QUFDTztBQUNUOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDRCQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUFTO0FBQ3BDLGtCQUFrQjtBQUNsQjtBQUNBLFFBQVEsa0NBQVcsQ0FBQyx5QkFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxrQkFBSztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQUs7QUFDM0MsWUFBWSw0QkFBNEI7QUFDeEMsSUFBSSxrQkFBSztBQUNULCtDQUErQyxrQkFBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFZO0FBQy9DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtEQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9lbnZpcm9ubWVudC9hdXRvRGV0ZWN0RW52aXJvbm1lbnQubWpzP2NkYWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N5c3RlbS9BYnN0cmFjdFJlbmRlcmVyLm1qcz8xMDQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBlbnZpcm9ubWVudHMgPSBbXTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlOYW1lZExpc3QoRXh0ZW5zaW9uVHlwZS5FbnZpcm9ubWVudCwgZW52aXJvbm1lbnRzKTtcbmFzeW5jIGZ1bmN0aW9uIGxvYWRFbnZpcm9ubWVudEV4dGVuc2lvbnMoc2tpcCkge1xuICBpZiAoc2tpcClcbiAgICByZXR1cm47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW52aXJvbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZW52ID0gZW52aXJvbm1lbnRzW2ldO1xuICAgIGlmIChlbnYudmFsdWUudGVzdCgpKSB7XG4gICAgICBhd2FpdCBlbnYudmFsdWUubG9hZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYXV0b0RldGVjdEVudmlyb25tZW50KGFkZCkge1xuICByZXR1cm4gbG9hZEVudmlyb25tZW50RXh0ZW5zaW9ucyghYWRkKTtcbn1cblxuZXhwb3J0IHsgYXV0b0RldGVjdEVudmlyb25tZW50LCBsb2FkRW52aXJvbm1lbnRFeHRlbnNpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvRGV0ZWN0RW52aXJvbm1lbnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgbG9hZEVudmlyb25tZW50RXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2F1dG9EZXRlY3RFbnZpcm9ubWVudC5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2Jyb3dzZXIvdW5zYWZlRXZhbFN1cHBvcnRlZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCAnLi4vLi4vLi4vLi4vdXRpbHMvdXRpbHMubWpzJztcbmltcG9ydCB7IENMRUFSIH0gZnJvbSAnLi4vLi4vZ2wvY29uc3QubWpzJztcbmltcG9ydCB7IFN5c3RlbVJ1bm5lciB9IGZyb20gJy4vU3lzdGVtUnVubmVyLm1qcyc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRlZmF1bHRSdW5uZXJzID0gW1xuICBcImluaXRcIixcbiAgXCJkZXN0cm95XCIsXG4gIFwiY29udGV4dENoYW5nZVwiLFxuICBcInJlc29sdXRpb25DaGFuZ2VcIixcbiAgXCJyZXNldFwiLFxuICBcInJlbmRlckVuZFwiLFxuICBcInJlbmRlclN0YXJ0XCIsXG4gIFwicmVuZGVyXCIsXG4gIFwidXBkYXRlXCIsXG4gIFwicG9zdHJlbmRlclwiLFxuICBcInByZXJlbmRlclwiXG5dO1xuY29uc3QgX0Fic3RyYWN0UmVuZGVyZXIgPSBjbGFzcyBfQWJzdHJhY3RSZW5kZXJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBTZXQgdXAgYSBzeXN0ZW0gd2l0aCBhIGNvbGxlY3Rpb24gb2YgU3lzdGVtQ2xhc3NlcyBhbmQgcnVubmVycy5cbiAgICogU3lzdGVtcyBhcmUgYXR0YWNoZWQgZHluYW1pY2FsbHkgdG8gdGhpcyBjbGFzcyB3aGVuIGFkZGVkLlxuICAgKiBAcGFyYW0gY29uZmlnIC0gdGhlIGNvbmZpZyBmb3IgdGhlIHN5c3RlbSBtYW5hZ2VyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucnVubmVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMucmVuZGVyUGlwZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9pbml0T3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuX3N5c3RlbXNIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50eXBlID0gY29uZmlnLnR5cGU7XG4gICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgY29uc3QgY29tYmluZWRSdW5uZXJzID0gWy4uLmRlZmF1bHRSdW5uZXJzLCAuLi50aGlzLmNvbmZpZy5ydW5uZXJzID8/IFtdXTtcbiAgICB0aGlzLl9hZGRSdW5uZXJzKC4uLmNvbWJpbmVkUnVubmVycyk7XG4gICAgdGhpcy5fdW5zYWZlRXZhbENoZWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHVzZSB0byBjcmVhdGUgdGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgYXN5bmMgaW5pdChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBza2lwID0gb3B0aW9ucy5za2lwRXh0ZW5zaW9uSW1wb3J0cyA9PT0gdHJ1ZSA/IHRydWUgOiBvcHRpb25zLm1hbmFnZUltcG9ydHMgPT09IGZhbHNlO1xuICAgIGF3YWl0IGxvYWRFbnZpcm9ubWVudEV4dGVuc2lvbnMoc2tpcCk7XG4gICAgdGhpcy5fYWRkU3lzdGVtcyh0aGlzLmNvbmZpZy5zeXN0ZW1zKTtcbiAgICB0aGlzLl9hZGRQaXBlcyh0aGlzLmNvbmZpZy5yZW5kZXJQaXBlcywgdGhpcy5jb25maWcucmVuZGVyUGlwZUFkYXB0b3JzKTtcbiAgICBmb3IgKGNvbnN0IHN5c3RlbU5hbWUgaW4gdGhpcy5fc3lzdGVtc0hhc2gpIHtcbiAgICAgIGNvbnN0IHN5c3RlbSA9IHRoaXMuX3N5c3RlbXNIYXNoW3N5c3RlbU5hbWVdO1xuICAgICAgY29uc3QgZGVmYXVsdFN5c3RlbU9wdGlvbnMgPSBzeXN0ZW0uY29uc3RydWN0b3IuZGVmYXVsdE9wdGlvbnM7XG4gICAgICBvcHRpb25zID0geyAuLi5kZWZhdWx0U3lzdGVtT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi5fQWJzdHJhY3RSZW5kZXJlci5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gb3B0aW9ucy5yb3VuZFBpeGVscyA/IDEgOiAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uZXJzLmluaXQuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF3YWl0IHRoaXMucnVubmVycy5pbml0Lml0ZW1zW2ldLmluaXQob3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRPcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICByZW5kZXIoYXJncywgZGVwcmVjYXRlZCkge1xuICAgIGxldCBvcHRpb25zID0gYXJncztcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgb3B0aW9ucyA9IHsgY29udGFpbmVyOiBvcHRpb25zIH07XG4gICAgICBpZiAoZGVwcmVjYXRlZCkge1xuICAgICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwicGFzc2luZyBhIHNlY29uZCBhcmd1bWVudCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlbmRlciBvcHRpb25zIGluc3RlYWRcIik7XG4gICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gZGVwcmVjYXRlZC5yZW5kZXJUZXh0dXJlO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zLnRhcmdldCB8fCAob3B0aW9ucy50YXJnZXQgPSB0aGlzLnZpZXcucmVuZGVyVGFyZ2V0KTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQgPT09IHRoaXMudmlldy5yZW5kZXJUYXJnZXQpIHtcbiAgICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgb3B0aW9ucy5jbGVhckNvbG9yID0gdGhpcy5iYWNrZ3JvdW5kLmNvbG9yUmdiYTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2xlYXJDb2xvcikge1xuICAgICAgY29uc3QgaXNSR0JBQXJyYXkgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2xlYXJDb2xvcikgJiYgb3B0aW9ucy5jbGVhckNvbG9yLmxlbmd0aCA9PT0gNDtcbiAgICAgIG9wdGlvbnMuY2xlYXJDb2xvciA9IGlzUkdCQUFycmF5ID8gb3B0aW9ucy5jbGVhckNvbG9yIDogQ29sb3Iuc2hhcmVkLnNldFZhbHVlKG9wdGlvbnMuY2xlYXJDb2xvcikudG9BcnJheSgpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudHJhbnNmb3JtKSB7XG4gICAgICBvcHRpb25zLmNvbnRhaW5lci51cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgb3B0aW9ucy50cmFuc2Zvcm0gPSBvcHRpb25zLmNvbnRhaW5lci5sb2NhbFRyYW5zZm9ybTtcbiAgICB9XG4gICAgdGhpcy5ydW5uZXJzLnByZXJlbmRlci5lbWl0KG9wdGlvbnMpO1xuICAgIHRoaXMucnVubmVycy5yZW5kZXJTdGFydC5lbWl0KG9wdGlvbnMpO1xuICAgIHRoaXMucnVubmVycy5yZW5kZXIuZW1pdChvcHRpb25zKTtcbiAgICB0aGlzLnJ1bm5lcnMucmVuZGVyRW5kLmVtaXQob3B0aW9ucyk7XG4gICAgdGhpcy5ydW5uZXJzLnBvc3RyZW5kZXIuZW1pdChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgV2ViR0wgdmlldyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSBkZXNpcmVkU2NyZWVuV2lkdGggLSBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gZGVzaXJlZFNjcmVlbkhlaWdodCAtIFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlci5cbiAgICovXG4gIHJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICBjb25zdCBwcmV2aW91c1Jlc29sdXRpb24gPSB0aGlzLnZpZXcucmVzb2x1dGlvbjtcbiAgICB0aGlzLnZpZXcucmVzaXplKGRlc2lyZWRTY3JlZW5XaWR0aCwgZGVzaXJlZFNjcmVlbkhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgdGhpcy5lbWl0KFwicmVzaXplXCIsIHRoaXMudmlldy5zY3JlZW4ud2lkdGgsIHRoaXMudmlldy5zY3JlZW4uaGVpZ2h0LCB0aGlzLnZpZXcucmVzb2x1dGlvbik7XG4gICAgaWYgKHJlc29sdXRpb24gIT09IHZvaWQgMCAmJiByZXNvbHV0aW9uICE9PSBwcmV2aW91c1Jlc29sdXRpb24pIHtcbiAgICAgIHRoaXMucnVubmVycy5yZXNvbHV0aW9uQ2hhbmdlLmVtaXQocmVzb2x1dGlvbik7XG4gICAgfVxuICB9XG4gIGNsZWFyKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcztcbiAgICBvcHRpb25zLnRhcmdldCB8fCAob3B0aW9ucy50YXJnZXQgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQucmVuZGVyVGFyZ2V0KTtcbiAgICBvcHRpb25zLmNsZWFyQ29sb3IgfHwgKG9wdGlvbnMuY2xlYXJDb2xvciA9IHRoaXMuYmFja2dyb3VuZC5jb2xvclJnYmEpO1xuICAgIG9wdGlvbnMuY2xlYXIgPz8gKG9wdGlvbnMuY2xlYXIgPSBDTEVBUi5BTEwpO1xuICAgIGNvbnN0IHsgY2xlYXIsIGNsZWFyQ29sb3IsIHRhcmdldCB9ID0gb3B0aW9ucztcbiAgICBDb2xvci5zaGFyZWQuc2V0VmFsdWUoY2xlYXJDb2xvciA/PyB0aGlzLmJhY2tncm91bmQuY29sb3JSZ2JhKTtcbiAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuY2xlYXIodGFyZ2V0LCBjbGVhciwgQ29sb3Iuc2hhcmVkLnRvQXJyYXkoKSk7XG4gIH1cbiAgLyoqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlci4gKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy52aWV3LnJlc29sdXRpb24gPSB2YWx1ZTtcbiAgICB0aGlzLnJ1bm5lcnMucmVzb2x1dGlvbkNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogU2FtZSBhcyB2aWV3LndpZHRoLCBhY3R1YWwgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGUgY2FudmFzIGJ5IGhvcml6b250YWwuXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZWZhdWx0IDgwMFxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgfVxuICAvKipcbiAgICogU2FtZSBhcyB2aWV3LmhlaWdodCwgYWN0dWFsIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlIGNhbnZhcyBieSB2ZXJ0aWNhbC5cbiAgICogQGRlZmF1bHQgNjAwXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gIH1cbiAgLy8gTk9URTogdGhpcyB3YXMgYHZpZXdgIGluIHY3XG4gIC8qKlxuICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvLlxuICAgKiBAdHlwZSB7ZW52aXJvbm1lbnQuSUNhbnZhc31cbiAgICovXG4gIGdldCBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5jYW52YXM7XG4gIH1cbiAgLyoqXG4gICAqIHRoZSBsYXN0IG9iamVjdCByZW5kZXJlZCBieSB0aGUgcmVuZGVyZXIuIFVzZWZ1bCBmb3Igb3RoZXIgcGx1Z2lucyBsaWtlIGludGVyYWN0aW9uIG1hbmFnZXJzXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGxhc3RPYmplY3RSZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkO1xuICB9XG4gIC8qKlxuICAgKiBGbGFnIGlmIHdlIGFyZSByZW5kZXJpbmcgdG8gdGhlIHNjcmVlbiB2cyByZW5kZXJUZXh0dXJlXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBnZXQgcmVuZGVyaW5nVG9TY3JlZW4oKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzO1xuICAgIHJldHVybiByZW5kZXJlci5yZW5kZXJUYXJnZXQucmVuZGVyaW5nVG9TY3JlZW47XG4gIH1cbiAgLyoqXG4gICAqIE1lYXN1cmVtZW50cyBvZiB0aGUgc2NyZWVuLiAoMCwgMCwgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkuXG4gICAqXG4gICAqIEl0cyBzYWZlIHRvIHVzZSBhcyBmaWx0ZXJBcmVhIG9yIGhpdEFyZWEgZm9yIHRoZSB3aG9sZSBzdGFnZS5cbiAgICovXG4gIGdldCBzY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5zY3JlZW47XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJ1bmNoIG9mIHJ1bm5lcnMgYmFzZWQgb2YgYSBjb2xsZWN0aW9uIG9mIGlkc1xuICAgKiBAcGFyYW0gcnVubmVySWRzIC0gdGhlIHJ1bm5lciBpZHMgdG8gYWRkXG4gICAqL1xuICBfYWRkUnVubmVycyguLi5ydW5uZXJJZHMpIHtcbiAgICBydW5uZXJJZHMuZm9yRWFjaCgocnVubmVySWQpID0+IHtcbiAgICAgIHRoaXMucnVubmVyc1tydW5uZXJJZF0gPSBuZXcgU3lzdGVtUnVubmVyKHJ1bm5lcklkKTtcbiAgICB9KTtcbiAgfVxuICBfYWRkU3lzdGVtcyhzeXN0ZW1zKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpIGluIHN5c3RlbXMpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHN5c3RlbXNbaV07XG4gICAgICB0aGlzLl9hZGRTeXN0ZW0odmFsLnZhbHVlLCB2YWwubmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgc3lzdGVtIHRvIHRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIENsYXNzUmVmIC0gQ2xhc3MgcmVmZXJlbmNlXG4gICAqIEBwYXJhbSBuYW1lIC0gUHJvcGVydHkgbmFtZSBmb3Igc3lzdGVtLCBpZiBub3Qgc3BlY2lmaWVkXG4gICAqICAgICAgICB3aWxsIHVzZSBhIHN0YXRpYyBgbmFtZWAgcHJvcGVydHkgb24gdGhlIGNsYXNzIGl0c2VsZi4gVGhpc1xuICAgKiAgICAgICAgbmFtZSB3aWxsIGJlIGFzc2lnbmVkIGFzIHMgcHJvcGVydHkgb24gdGhlIFJlbmRlcmVyIHNvIG1ha2VcbiAgICogICAgICAgIHN1cmUgaXQgZG9lc24ndCBjb2xsaWRlIHdpdGggcHJvcGVydGllcyBvbiBSZW5kZXJlci5cbiAgICogQHJldHVybnMgUmV0dXJuIGluc3RhbmNlIG9mIHJlbmRlcmVyXG4gICAqL1xuICBfYWRkU3lzdGVtKENsYXNzUmVmLCBuYW1lKSB7XG4gICAgY29uc3Qgc3lzdGVtID0gbmV3IENsYXNzUmVmKHRoaXMpO1xuICAgIGlmICh0aGlzW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdob29wcyEgVGhlIG5hbWUgXCIke25hbWV9XCIgaXMgYWxyZWFkeSBpbiB1c2VgKTtcbiAgICB9XG4gICAgdGhpc1tuYW1lXSA9IHN5c3RlbTtcbiAgICB0aGlzLl9zeXN0ZW1zSGFzaFtuYW1lXSA9IHN5c3RlbTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5ydW5uZXJzKSB7XG4gICAgICB0aGlzLnJ1bm5lcnNbaV0uYWRkKHN5c3RlbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9hZGRQaXBlcyhwaXBlcywgcGlwZUFkYXB0b3JzKSB7XG4gICAgY29uc3QgYWRhcHRvcnMgPSBwaXBlQWRhcHRvcnMucmVkdWNlKChhY2MsIGFkYXB0b3IpID0+IHtcbiAgICAgIGFjY1thZGFwdG9yLm5hbWVdID0gYWRhcHRvci52YWx1ZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHBpcGVzLmZvckVhY2goKHBpcGUpID0+IHtcbiAgICAgIGNvbnN0IFBpcGVDbGFzcyA9IHBpcGUudmFsdWU7XG4gICAgICBjb25zdCBuYW1lID0gcGlwZS5uYW1lO1xuICAgICAgY29uc3QgQWRhcHRvciA9IGFkYXB0b3JzW25hbWVdO1xuICAgICAgdGhpcy5yZW5kZXJQaXBlc1tuYW1lXSA9IG5ldyBQaXBlQ2xhc3MoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIEFkYXB0b3IgPyBuZXcgQWRhcHRvcigpIDogbnVsbFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMgPSBmYWxzZSkge1xuICAgIHRoaXMucnVubmVycy5kZXN0cm95Lml0ZW1zLnJldmVyc2UoKTtcbiAgICB0aGlzLnJ1bm5lcnMuZGVzdHJveS5lbWl0KG9wdGlvbnMpO1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5ydW5uZXJzKS5mb3JFYWNoKChydW5uZXIpID0+IHtcbiAgICAgIHJ1bm5lci5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgdGhpcy5fc3lzdGVtc0hhc2ggPSBudWxsO1xuICAgIHRoaXMucmVuZGVyUGlwZXMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRleHR1cmUgZnJvbSBhIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIG9yIGNvbnRhaW5lciB0YXJnZXQgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyB0aGUgdGV4dHVyZVxuICAgKiBAcmV0dXJucyBhIHRleHR1cmVcbiAgICovXG4gIGdlbmVyYXRlVGV4dHVyZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZUdlbmVyYXRvci5nZW5lcmF0ZVRleHR1cmUob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHdpbGwgcm91bmQgY29vcmRpbmF0ZXMgdG8gd2hvbGUgcGl4ZWxzIHdoZW4gcmVuZGVyaW5nLlxuICAgKiBDYW4gYmUgb3ZlcnJpZGRlbiBvbiBhIHBlciBzY2VuZSBpdGVtIGJhc2lzLlxuICAgKi9cbiAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3JvdW5kUGl4ZWxzO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBmdW5jdGlvbiBieSBgcGl4aS5qcy91bnNhZmUtZXZhbGAgdG8gc2lsZW5jZVxuICAgKiB0aHJvd2luZyBhbiBlcnJvciBpZiBwbGF0Zm9ybSBkb2Vzbid0IHN1cHBvcnQgdW5zYWZlLWV2YWxzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfdW5zYWZlRXZhbENoZWNrKCkge1xuICAgIGlmICghdW5zYWZlRXZhbFN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IGFsbG93IHVuc2FmZS1ldmFsLCBwbGVhc2UgdXNlIHBpeGkuanMvdW5zYWZlLWV2YWwgbW9kdWxlIHRvIGVuYWJsZSBzdXBwb3J0LlwiKTtcbiAgICB9XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIHJlbmRlcmVyLiAqL1xuX0Fic3RyYWN0UmVuZGVyZXIuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHJlbmRlcmVyLlxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICByZXNvbHV0aW9uOiAxLFxuICAvKipcbiAgICogU2hvdWxkIHRoZSBgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdGAgZmxhZyBiZSBlbmFibGVkIGFzIGEgY29udGV4dCBvcHRpb24gdXNlZCBpbiB0aGUgYGlzV2ViR0xTdXBwb3J0ZWRgXG4gICAqIGZ1bmN0aW9uLiBJZiBzZXQgdG8gdHJ1ZSwgYSBXZWJHTCByZW5kZXJlciBjYW4gZmFpbCB0byBiZSBjcmVhdGVkIGlmIHRoZSBicm93c2VyIHRoaW5rcyB0aGVyZSBjb3VsZCBiZVxuICAgKiBwZXJmb3JtYW5jZSBpc3N1ZXMgd2hlbiB1c2luZyBXZWJHTC5cbiAgICpcbiAgICogSW4gUGl4aUpTIHY2IHRoaXMgaGFzIGNoYW5nZWQgZnJvbSB0cnVlIHRvIGZhbHNlIGJ5IGRlZmF1bHQsIHRvIGFsbG93IFdlYkdMIHRvIHdvcmsgaW4gYXMgbWFueVxuICAgKiBzY2VuYXJpb3MgYXMgcG9zc2libGUuIEhvd2V2ZXIsIHNvbWUgdXNlcnMgbWF5IGhhdmUgYSBwb29yIGV4cGVyaWVuY2UsIGZvciBleGFtcGxlLCBpZiBhIHVzZXIgaGFzIGEgZ3B1IG9yXG4gICAqIGRyaXZlciB2ZXJzaW9uIGJsYWNrbGlzdGVkIGJ5IHRoZVxuICAgKiBicm93c2VyLlxuICAgKlxuICAgKiBJZiB5b3VyIGFwcGxpY2F0aW9uIHJlcXVpcmVzIGhpZ2ggcGVyZm9ybWFuY2UgcmVuZGVyaW5nLCB5b3UgbWF5IHdpc2ggdG8gc2V0IHRoaXMgdG8gZmFsc2UuXG4gICAqIFdlIHJlY29tbWVuZCBvbmUgb2YgdHdvIG9wdGlvbnMgaWYgeW91IGRlY2lkZSB0byBzZXQgdGhpcyBmbGFnIHRvIGZhbHNlOlxuICAgKlxuICAgKiAxOiBVc2UgdGhlIENhbnZhcyByZW5kZXJlciBhcyBhIGZhbGxiYWNrIGluIGNhc2UgaGlnaCBwZXJmb3JtYW5jZSBXZWJHTCBpc1xuICAgKiAgICBub3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiAyOiBDYWxsIGBpc1dlYkdMU3VwcG9ydGVkYCAod2hpY2ggaWYgZm91bmQgaW4gdGhlIHV0aWxzIHBhY2thZ2UpIGluIHlvdXIgY29kZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBjcmVhdGUgYVxuICAgKiAgICBQaXhpSlMgcmVuZGVyZXIsIGFuZCBzaG93IGFuIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHVzZXIgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIGV4cGxhaW5pbmcgdGhhdCB0aGVpclxuICAgKiAgICBkZXZpY2UgJiBicm93c2VyIGNvbWJpbmF0aW9uIGRvZXMgbm90IHN1cHBvcnQgaGlnaCBwZXJmb3JtYW5jZSBXZWJHTC5cbiAgICogICAgVGhpcyBpcyBhIG11Y2ggYmV0dGVyIHN0cmF0ZWd5IHRoYW4gdHJ5aW5nIHRvIGNyZWF0ZSBhIFBpeGlKUyByZW5kZXJlciBhbmQgZmluZGluZyBpdCB0aGVuIGZhaWxzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogZmFsc2UsXG4gIC8qKlxuICAgKiBTaG91bGQgcm91bmQgcGl4ZWxzIGJlIGZvcmNlZCB3aGVuIHJlbmRlcmluZz9cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJvdW5kUGl4ZWxzOiBmYWxzZVxufTtcbmxldCBBYnN0cmFjdFJlbmRlcmVyID0gX0Fic3RyYWN0UmVuZGVyZXI7XG5cbmV4cG9ydCB7IEFic3RyYWN0UmVuZGVyZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0UmVuZGVyZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7400\n')},7051:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ SystemRunner)\n/* harmony export */ });\n\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\n\n//# sourceMappingURL=SystemRunner.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA1MS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N5c3RlbS9TeXN0ZW1SdW5uZXIubWpzP2ZjNmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBTeXN0ZW1SdW5uZXIge1xuICAvKipcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgZnVuY3Rpb24gbmFtZSB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgb24gdGhlIGxpc3RlbmVycyBhZGRlZCB0byB0aGlzIFJ1bm5lci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLml0ZW1zID0gW107XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1wYXJhbSwganNkb2MvY2hlY2stcGFyYW0tbmFtZXMgKi9cbiAgLyoqXG4gICAqIERpc3BhdGNoL0Jyb2FkY2FzdCBSdW5uZXIgdG8gYWxsIGxpc3RlbmVycyBhZGRlZCB0byB0aGUgcXVldWUuXG4gICAqIEBwYXJhbSB7Li4uYW55fSBwYXJhbXMgLSAob3B0aW9uYWwpIHBhcmFtZXRlcnMgdG8gcGFzcyB0byBlYWNoIGxpc3RlbmVyXG4gICAqL1xuICAvKiAgZXNsaW50LWVuYWJsZSBqc2RvYy9yZXF1aXJlLXBhcmFtLCBqc2RvYy9jaGVjay1wYXJhbS1uYW1lcyAqL1xuICBlbWl0KGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgIGNvbnN0IHsgbmFtZSwgaXRlbXMgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtc1tpXVtuYW1lXShhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIFJ1bm5lclxuICAgKlxuICAgKiBSdW5uZXJzIGRvIG5vdCBuZWVkIHRvIGhhdmUgc2NvcGUgb3IgZnVuY3Rpb25zIHBhc3NlZCB0byB0aGVtLlxuICAgKiBBbGwgdGhhdCBpcyByZXF1aXJlZCBpcyB0byBwYXNzIHRoZSBsaXN0ZW5pbmcgb2JqZWN0IGFuZCBlbnN1cmUgdGhhdCBpdCBoYXMgY29udGFpbnMgYSBmdW5jdGlvbiB0aGF0IGhhcyB0aGUgc2FtZSBuYW1lXG4gICAqIGFzIHRoZSBuYW1lIHByb3ZpZGVkIHRvIHRoZSBSdW5uZXIgd2hlbiBpdCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogRWcgQSBsaXN0ZW5lciBwYXNzZWQgdG8gdGhpcyBSdW5uZXIgd2lsbCByZXF1aXJlIGEgJ2NvbXBsZXRlJyBmdW5jdGlvbi5cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCB7IFJ1bm5lciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBjb25zdCBjb21wbGV0ZSA9IG5ldyBSdW5uZXIoJ2NvbXBsZXRlJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgc2NvcGUgdXNlZCB3aWxsIGJlIHRoZSBvYmplY3QgaXRzZWxmLlxuICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGxpc3RlbmluZy5cbiAgICovXG4gIGFkZChpdGVtKSB7XG4gICAgaWYgKGl0ZW1bdGhpcy5fbmFtZV0pIHtcbiAgICAgIHRoaXMucmVtb3ZlKGl0ZW0pO1xuICAgICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgc2luZ2xlIGxpc3RlbmVyIGZyb20gdGhlIGRpc3BhdGNoIHF1ZXVlLlxuICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBsaXN0ZW5lciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZShpdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBsaXN0ZW5lciBpcyBhbHJlYWR5IGluIHRoZSBSdW5uZXJcbiAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgbGlzdGVuZXIgdGhhdCB5b3Ugd291bGQgbGlrZSB0byBjaGVjay5cbiAgICovXG4gIGNvbnRhaW5zKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbiAgfVxuICAvKiogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgUnVubmVyICovXG4gIHJlbW92ZUFsbCgpIHtcbiAgICB0aGlzLml0ZW1zLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIFJlbW92ZSBhbGwgcmVmZXJlbmNlcywgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLml0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9uYW1lID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogYHRydWVgIGlmIHRoZXJlIGFyZSBubyB0aGlzIFJ1bm5lciBjb250YWlucyBubyBsaXN0ZW5lcnNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID09PSAwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcnVubmVyLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG59XG5cbmV4cG9ydCB7IFN5c3RlbVJ1bm5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3lzdGVtUnVubmVyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7051\n")},9853:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  x: () => (/* binding */ Texture)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs\n\n\n"use strict";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix/* Matrix */.y();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135/225 | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90/270  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45/315  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don\'t.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn\'t work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\n\n//# sourceMappingURL=groupD8.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/misc/NOOP.mjs\n\nconst NOOP = () => {\n};\n\n\n//# sourceMappingURL=NOOP.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs\nvar BufferImageSource = __webpack_require__(9224);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(5206);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs\nvar TextureMatrix = __webpack_require__(575);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass Texture extends eventemitter3/* default */.Z {\n  /**\n   * @param {rendering.TextureOptions} options - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = (0,uid/* uid */.h)("texture");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle/* Rectangle */.A();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on(\'update\', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource/* TextureSource */.p();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off("resize", this.update, this);\n    }\n    this._source = value;\n    value.on("resize", this.update, this);\n    this.emit("update", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix/* TextureMatrix */.U(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n  }\n  /** call this if you have modified the `texture outside` of the constructor */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit("update", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Texture.baseTexture is now Texture.source");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: "EMPTY",\n  source: new TextureSource/* TextureSource */.p({\n    label: "EMPTY"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource/* BufferImageSource */.A({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: "premultiply-alpha-on-upload",\n    label: "WHITE"\n  }),\n  label: "WHITE"\n});\nTexture.WHITE.destroy = NOOP;\n\n\n//# sourceMappingURL=Texture.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg1My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQkFBb0Isb0JBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUI7QUFDbkI7Ozs7Ozs7OztBQ3JRYTtBQUNiO0FBQ0E7O0FBRWdCO0FBQ2hCOzs7Ozs7Ozs7QUNMeUM7QUFDc0I7QUFDSTtBQUNkO0FBQzJCO0FBQ3pCO0FBQ2E7QUFDUjtBQUNSOztBQUVwRDtBQUNBLHNCQUFzQiw0QkFBWTtBQUNsQztBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0EsZUFBZSxrQkFBRztBQUNsQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sYUFBYSxPQUFPO0FBQzFDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLGVBQWUsT0FBTztBQUN0Qix5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQyxlQUFlLE9BQU87QUFDdEIseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEMsZUFBZSxPQUFPO0FBQ3RCLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0NBQVcsQ0FBQyx5QkFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBYTtBQUMzQjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Qsd0JBQXdCLElBQUk7QUFDNUI7QUFDQSxjQUFjLDBDQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELHdCQUF3QixJQUFJOztBQUVUO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21hdHJpeC9ncm91cEQ4Lm1qcz85ZGY0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9taXNjL05PT1AubWpzPzYzNTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanM/MjA2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuL01hdHJpeC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHV4ID0gWzEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDFdO1xuY29uc3QgdXkgPSBbMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV07XG5jb25zdCB2eCA9IFswLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbmNvbnN0IHZ5ID0gWzEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTFdO1xuY29uc3Qgcm90YXRpb25DYXlsZXkgPSBbXTtcbmNvbnN0IHJvdGF0aW9uTWF0cmljZXMgPSBbXTtcbmNvbnN0IHNpZ251bSA9IE1hdGguc2lnbjtcbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgIHJvdGF0aW9uQ2F5bGV5LnB1c2gocm93KTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgIGNvbnN0IF91eCA9IHNpZ251bSh1eFtpXSAqIHV4W2pdICsgdnhbaV0gKiB1eVtqXSk7XG4gICAgICBjb25zdCBfdXkgPSBzaWdudW0odXlbaV0gKiB1eFtqXSArIHZ5W2ldICogdXlbal0pO1xuICAgICAgY29uc3QgX3Z4ID0gc2lnbnVtKHV4W2ldICogdnhbal0gKyB2eFtpXSAqIHZ5W2pdKTtcbiAgICAgIGNvbnN0IF92eSA9IHNpZ251bSh1eVtpXSAqIHZ4W2pdICsgdnlbaV0gKiB2eVtqXSk7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IDE2OyBrKyspIHtcbiAgICAgICAgaWYgKHV4W2tdID09PSBfdXggJiYgdXlba10gPT09IF91eSAmJiB2eFtrXSA9PT0gX3Z4ICYmIHZ5W2tdID09PSBfdnkpIHtcbiAgICAgICAgICByb3cucHVzaChrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgbWF0LnNldCh1eFtpXSwgdXlbaV0sIHZ4W2ldLCB2eVtpXSwgMCwgMCk7XG4gICAgcm90YXRpb25NYXRyaWNlcy5wdXNoKG1hdCk7XG4gIH1cbn1cbmluaXQoKTtcbmNvbnN0IGdyb3VwRDggPSB7XG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uIHwgRGlyZWN0aW9uIHxcbiAgICogfC0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgMMKwICAgICAgIHwgRWFzdCAgICAgIHxcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIEU6IDAsXG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uIHwgRGlyZWN0aW9uIHxcbiAgICogfC0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgNDXCsOKGuyAgICAgfCBTb3V0aGVhc3QgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgU0U6IDEsXG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uIHwgRGlyZWN0aW9uIHxcbiAgICogfC0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgOTDCsOKGuyAgICAgfCBTb3V0aCAgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgUzogMixcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCAxMzXCsOKGuyAgICB8IFNvdXRod2VzdCB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBTVzogMyxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCAxODDCsCAgICAgfCBXZXN0ICAgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgVzogNCxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gICAgfCBEaXJlY3Rpb24gICAgfFxuICAgKiB8LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICogfCAtMTM1wrAvMjI1wrDihrsgfCBOb3J0aHdlc3QgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgTlc6IDUsXG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uICAgIHwgRGlyZWN0aW9uICAgIHxcbiAgICogfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS18XG4gICAqIHwgLTkwwrAvMjcwwrDihrsgIHwgTm9ydGggICAgICAgIHxcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIE46IDYsXG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uICAgIHwgRGlyZWN0aW9uICAgIHxcbiAgICogfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS18XG4gICAqIHwgLTQ1wrAvMzE1wrDihrsgIHwgTm9ydGhlYXN0ICAgIHxcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIE5FOiA3LFxuICAvKipcbiAgICogUmVmbGVjdGlvbiBhYm91dCBZLWF4aXMuXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBNSVJST1JfVkVSVElDQUw6IDgsXG4gIC8qKlxuICAgKiBSZWZsZWN0aW9uIGFib3V0IHRoZSBtYWluIGRpYWdvbmFsLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgTUFJTl9ESUFHT05BTDogMTAsXG4gIC8qKlxuICAgKiBSZWZsZWN0aW9uIGFib3V0IFgtYXhpcy5cbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIE1JUlJPUl9IT1JJWk9OVEFMOiAxMixcbiAgLyoqXG4gICAqIFJlZmxlY3Rpb24gYWJvdXQgcmV2ZXJzZSBkaWFnb25hbC5cbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIFJFVkVSU0VfRElBR09OQUw6IDE0LFxuICAvKipcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQHBhcmFtIHtHRDhTeW1tZXRyeX0gaW5kIC0gc3ByaXRlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IFRoZSBYLWNvbXBvbmVudCBvZiB0aGUgVS1heGlzXG4gICAqICAgIGFmdGVyIHJvdGF0aW5nIHRoZSBheGVzLlxuICAgKi9cbiAgdVg6IChpbmQpID0+IHV4W2luZF0sXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtHRDhTeW1tZXRyeX0gVGhlIFktY29tcG9uZW50IG9mIHRoZSBVLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB1WTogKGluZCkgPT4gdXlbaW5kXSxcbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IGluZCAtIHNwcml0ZSByb3RhdGlvbiBhbmdsZS5cbiAgICogQHJldHVybnMge0dEOFN5bW1ldHJ5fSBUaGUgWC1jb21wb25lbnQgb2YgdGhlIFYtYXhpc1xuICAgKiAgICBhZnRlciByb3RhdGluZyB0aGUgYXhlcy5cbiAgICovXG4gIHZYOiAoaW5kKSA9PiB2eFtpbmRdLFxuICAvKipcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQHBhcmFtIHtHRDhTeW1tZXRyeX0gaW5kIC0gc3ByaXRlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IFRoZSBZLWNvbXBvbmVudCBvZiB0aGUgVi1heGlzXG4gICAqICAgIGFmdGVyIHJvdGF0aW5nIHRoZSBheGVzLlxuICAgKi9cbiAgdlk6IChpbmQpID0+IHZ5W2luZF0sXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvbiAtIHN5bW1ldHJ5IHdob3NlIG9wcG9zaXRlXG4gICAqICAgaXMgbmVlZGVkLiBPbmx5IHJvdGF0aW9ucyBoYXZlIG9wcG9zaXRlIHN5bW1ldHJpZXMgd2hpbGVcbiAgICogICByZWZsZWN0aW9ucyBkb24ndC5cbiAgICogQHJldHVybnMge0dEOFN5bW1ldHJ5fSBUaGUgb3Bwb3NpdGUgc3ltbWV0cnkgb2YgYHJvdGF0aW9uYFxuICAgKi9cbiAgaW52OiAocm90YXRpb24pID0+IHtcbiAgICBpZiAocm90YXRpb24gJiA4KSB7XG4gICAgICByZXR1cm4gcm90YXRpb24gJiAxNTtcbiAgICB9XG4gICAgcmV0dXJuIC1yb3RhdGlvbiAmIDc7XG4gIH0sXG4gIC8qKlxuICAgKiBDb21wb3NlcyB0aGUgdHdvIEQ4IG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIFRha2luZyBgXmAgYXMgcmVmbGVjdGlvbjpcbiAgICpcbiAgICogfCAgICAgICB8IEU9MCB8IFM9MiB8IFc9NCB8IE49NiB8IEVePTggfCBTXj0xMCB8IFdePTEyIHwgTl49MTQgfFxuICAgKiB8LS0tLS0tLXwtLS0tLXwtLS0tLXwtLS0tLXwtLS0tLXwtLS0tLS18LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XG4gICAqIHwgRT0wICAgfCBFICAgfCBTICAgfCBXICAgfCBOICAgfCBFXiAgIHwgU14gICAgfCBXXiAgICB8IE5eICAgIHxcbiAgICogfCBTPTIgICB8IFMgICB8IFcgICB8IE4gICB8IEUgICB8IFNeICAgfCBXXiAgICB8IE5eICAgIHwgRV4gICAgfFxuICAgKiB8IFc9NCAgIHwgVyAgIHwgTiAgIHwgRSAgIHwgUyAgIHwgV14gICB8IE5eICAgIHwgRV4gICAgfCBTXiAgICB8XG4gICAqIHwgTj02ICAgfCBOICAgfCBFICAgfCBTICAgfCBXICAgfCBOXiAgIHwgRV4gICAgfCBTXiAgICB8IFdeICAgIHxcbiAgICogfCBFXj04ICB8IEVeICB8IE5eICB8IFdeICB8IFNeICB8IEUgICAgfCBOICAgICB8IFcgICAgIHwgUyAgICAgfFxuICAgKiB8IFNePTEwIHwgU14gIHwgRV4gIHwgTl4gIHwgV14gIHwgUyAgICB8IEUgICAgIHwgTiAgICAgfCBXICAgICB8XG4gICAqIHwgV149MTIgfCBXXiAgfCBTXiAgfCBFXiAgfCBOXiAgfCBXICAgIHwgUyAgICAgfCBFICAgICB8IE4gICAgIHxcbiAgICogfCBOXj0xNCB8IE5eICB8IFdeICB8IFNeICB8IEVeICB8IE4gICAgfCBXICAgICB8IFMgICAgIHwgRSAgICAgfFxuICAgKlxuICAgKiBbVGhpcyBpcyBhIENheWxleSB0YWJsZV17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F5bGV5X3RhYmxlfVxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvblNlY29uZCAtIFNlY29uZCBvcGVyYXRpb24sIHdoaWNoXG4gICAqICAgaXMgdGhlIHJvdyBpbiB0aGUgYWJvdmUgY2F5bGV5IHRhYmxlLlxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvbkZpcnN0IC0gRmlyc3Qgb3BlcmF0aW9uLCB3aGljaFxuICAgKiAgIGlzIHRoZSBjb2x1bW4gaW4gdGhlIGFib3ZlIGNheWxleSB0YWJsZS5cbiAgICogQHJldHVybnMge0dEOFN5bW1ldHJ5fSBDb21wb3NlZCBvcGVyYXRpb25cbiAgICovXG4gIGFkZDogKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSA9PiByb3RhdGlvbkNheWxleVtyb3RhdGlvblNlY29uZF1bcm90YXRpb25GaXJzdF0sXG4gIC8qKlxuICAgKiBSZXZlcnNlIG9mIGBhZGRgLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvblNlY29uZCAtIFNlY29uZCBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtHRDhTeW1tZXRyeX0gcm90YXRpb25GaXJzdCAtIEZpcnN0IG9wZXJhdGlvblxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IFJlc3VsdFxuICAgKi9cbiAgc3ViOiAocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpID0+IHJvdGF0aW9uQ2F5bGV5W3JvdGF0aW9uU2Vjb25kXVtncm91cEQ4Lmludihyb3RhdGlvbkZpcnN0KV0sXG4gIC8qKlxuICAgKiBBZGRzIDE4MCBkZWdyZWVzIHRvIHJvdGF0aW9uLCB3aGljaCBpcyBhIGNvbW11dGF0aXZlXG4gICAqIG9wZXJhdGlvbi5cbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gVGhlIG51bWJlciB0byByb3RhdGUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJvdGF0ZWQgbnVtYmVyXG4gICAqL1xuICByb3RhdGUxODA6IChyb3RhdGlvbikgPT4gcm90YXRpb24gXiA0LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSByb3RhdGlvbiBhbmdsZSBpcyB2ZXJ0aWNhbCwgaS5lLiBzb3V0aFxuICAgKiBvciBub3J0aC4gSXQgZG9lc24ndCB3b3JrIGZvciByZWZsZWN0aW9ucy5cbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQHBhcmFtIHtHRDhTeW1tZXRyeX0gcm90YXRpb24gLSBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbFxuICAgKi9cbiAgaXNWZXJ0aWNhbDogKHJvdGF0aW9uKSA9PiAocm90YXRpb24gJiAzKSA9PT0gMixcbiAgLy8gcm90YXRpb24gJSA0ID09PSAyXG4gIC8qKlxuICAgKiBBcHByb3hpbWF0ZXMgdGhlIHZlY3RvciBgVihkeCxkeSlgIGludG8gb25lIG9mIHRoZVxuICAgKiBlaWdodCBkaXJlY3Rpb25zIHByb3ZpZGVkIGJ5IGBncm91cEQ4YC5cbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gWC1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBZLWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gICAqIEByZXR1cm5zIHtHRDhTeW1tZXRyeX0gQXBwcm94aW1hdGlvbiBvZiB0aGUgdmVjdG9yIGludG9cbiAgICogIG9uZSBvZiB0aGUgZWlnaHQgc3ltbWV0cmllcy5cbiAgICovXG4gIGJ5RGlyZWN0aW9uOiAoZHgsIGR5KSA9PiB7XG4gICAgaWYgKE1hdGguYWJzKGR4KSAqIDIgPD0gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBpZiAoZHkgPj0gMCkge1xuICAgICAgICByZXR1cm4gZ3JvdXBEOC5TO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwRDguTjtcbiAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGR5KSAqIDIgPD0gTWF0aC5hYnMoZHgpKSB7XG4gICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgIHJldHVybiBncm91cEQ4LkU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5XO1xuICAgIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgIHJldHVybiBncm91cEQ4LlNFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwRDguU1c7XG4gICAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgIHJldHVybiBncm91cEQ4Lk5FO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBEOC5OVztcbiAgfSxcbiAgLyoqXG4gICAqIEhlbHBzIHNwcml0ZSB0byBjb21wZW5zYXRlIHRleHR1cmUgcGFja2VyIHJvdGF0aW9uLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IC0gc3ByaXRlIHdvcmxkIG1hdHJpeFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBmYWN0b3IgdG8gdXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHggLSBzcHJpdGUgYW5jaG9yaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAtIHNwcml0ZSBhbmNob3JpbmdcbiAgICovXG4gIG1hdHJpeEFwcGVuZFJvdGF0aW9uSW52OiAobWF0cml4LCByb3RhdGlvbiwgdHggPSAwLCB0eSA9IDApID0+IHtcbiAgICBjb25zdCBtYXQgPSByb3RhdGlvbk1hdHJpY2VzW2dyb3VwRDguaW52KHJvdGF0aW9uKV07XG4gICAgbWF0LnR4ID0gdHg7XG4gICAgbWF0LnR5ID0gdHk7XG4gICAgbWF0cml4LmFwcGVuZChtYXQpO1xuICB9XG59O1xuXG5leHBvcnQgeyBncm91cEQ4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cEQ4Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbn07XG5cbmV4cG9ydCB7IE5PT1AgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5PT1AubWpzLm1hcFxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IGdyb3VwRDggfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9tYXRyaXgvZ3JvdXBEOC5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5pbXBvcnQgeyBOT09QIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbWlzYy9OT09QLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJJbWFnZVNvdXJjZSB9IGZyb20gJy4vc291cmNlcy9CdWZmZXJJbWFnZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vc291cmNlcy9UZXh0dXJlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlTWF0cml4IH0gZnJvbSAnLi9UZXh0dXJlTWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGV4dHVyZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3JlbmRlcmluZy5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSB0ZXh0dXJlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc291cmNlLFxuICAgIGxhYmVsLFxuICAgIGZyYW1lLFxuICAgIG9yaWcsXG4gICAgdHJpbSxcbiAgICBkZWZhdWx0QW5jaG9yLFxuICAgIGRlZmF1bHRCb3JkZXJzLFxuICAgIHJvdGF0ZSxcbiAgICBkeW5hbWljXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIHVuaXF1ZSBpZCBmb3IgdGhpcyB0ZXh0dXJlICovXG4gICAgdGhpcy51aWQgPSB1aWQoXCJ0ZXh0dXJlXCIpO1xuICAgIC8qKiBBIHV2cyBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGZyYW1lIGFuZCB0aGUgdGV4dHVyZSBzb3VyY2UgKi9cbiAgICB0aGlzLnV2cyA9IHsgeDA6IDAsIHkwOiAwLCB4MTogMCwgeTE6IDAsIHgyOiAwLCB5MjogMCwgeDM6IDAsIHkzOiAwIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgYXJlYSBvZiB0aGUgQmFzZVRleHR1cmUgaW1hZ2UgdG8gYWN0dWFsbHkgY29weSB0byB0aGUgQ2FudmFzIC8gV2ViR0wgd2hlbiByZW5kZXJpbmcsXG4gICAgICogaXJyZXNwZWN0aXZlIG9mIHRoZSBhY3R1YWwgZnJhbWUgc2l6ZSBvciBwbGFjZW1lbnQgKHdoaWNoIGNhbiBiZSBpbmZsdWVuY2VkIGJ5IHRyaW1tZWQgdGV4dHVyZSBhdGxhc2VzKVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGlzIFRleHR1cmUgaGF2ZSBhbnkgZnJhbWUgZGF0YSBhc3NpZ25lZCB0byBpdD9cbiAgICAgKlxuICAgICAqIFRoaXMgbW9kZSBpcyBlbmFibGVkIGF1dG9tYXRpY2FsbHkgaWYgbm8gZnJhbWUgd2FzIHBhc3NlZCBpbnNpZGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIG1vZGUgdGV4dHVyZSBpcyBzdWJzY3JpYmVkIHRvIGJhc2VUZXh0dXJlIGV2ZW50cywgYW5kIGZpcmVzIGB1cGRhdGVgIG9uIGFueSBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBCZXdhcmUsIGFmdGVyIGxvYWRpbmcgb3IgcmVzaXplIG9mIGJhc2VUZXh0dXJlIGV2ZW50IGNhbiBmaXJlZCB0d28gdGltZXMhXG4gICAgICogSWYgeW91IHdhbnQgbW9yZSBjb250cm9sLCBzdWJzY3JpYmUgb24gYmFzZVRleHR1cmUgaXRzZWxmLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdGV4dHVyZS5vbigndXBkYXRlJywgKCkgPT4ge30pO1xuICAgICAqL1xuICAgIHRoaXMubm9GcmFtZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSBwbGFuIG9uIG1vZGlmeWluZyB0aGUgdXZzIG9mIHRoaXMgdGV4dHVyZS5cbiAgICAgKiBXaGVuIHRoaXMgaXMgdGhlIGNhc2UsIHNwcml0ZXMgYW5kIG90aGVyIG9iamVjdHMgdXNpbmcgdGhlIHRleHR1cmUgd2lsbFxuICAgICAqIG1ha2Ugc3VyZSB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIHV2cyBhbmQgdXBkYXRlIHRoZWlyIHZlcnRpY2VzIGFjY29yZGluZ2x5LlxuICAgICAqL1xuICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlO1xuICAgIC8qKiBpcyBpdCBhIHRleHR1cmU/IHllcyEgdXNlZCBmb3IgdHlwZSBjaGVja2luZyAqL1xuICAgIHRoaXMuaXNUZXh0dXJlID0gdHJ1ZTtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U/LnNvdXJjZSA/PyBuZXcgVGV4dHVyZVNvdXJjZSgpO1xuICAgIHRoaXMubm9GcmFtZSA9ICFmcmFtZTtcbiAgICBpZiAoZnJhbWUpIHtcbiAgICAgIHRoaXMuZnJhbWUuY29weUZyb20oZnJhbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX3NvdXJjZTtcbiAgICAgIHRoaXMuZnJhbWUud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuZnJhbWUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLm9yaWcgPSBvcmlnIHx8IHRoaXMuZnJhbWU7XG4gICAgdGhpcy50cmltID0gdHJpbTtcbiAgICB0aGlzLnJvdGF0ZSA9IHJvdGF0ZSA/PyAwO1xuICAgIHRoaXMuZGVmYXVsdEFuY2hvciA9IGRlZmF1bHRBbmNob3I7XG4gICAgdGhpcy5kZWZhdWx0Qm9yZGVycyA9IGRlZmF1bHRCb3JkZXJzO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5keW5hbWljID0gZHluYW1pYyB8fCBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIHNldCBzb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub2ZmKFwicmVzaXplXCIsIHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fc291cmNlID0gdmFsdWU7XG4gICAgdmFsdWUub24oXCJyZXNpemVcIiwgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogdGhlIHVuZGVybHlpbmcgc291cmNlIG9mIHRoZSB0ZXh0dXJlIChlcXVpdmFsZW50IG9mIGJhc2VUZXh0dXJlIGluIHY3KSAqL1xuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIH1cbiAgLyoqIHJldHVybnMgYSBUZXh0dXJlTWF0cml4IGluc3RhbmNlIGZvciB0aGlzIHRleHR1cmUuIEJ5IGRlZmF1bHQsIHRoYXQgb2JqZWN0IGlzIG5vdCBjcmVhdGVkIGJlY2F1c2UgaXRzIGhlYXZ5LiAqL1xuICBnZXQgdGV4dHVyZU1hdHJpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3RleHR1cmVNYXRyaXgpIHtcbiAgICAgIHRoaXMuX3RleHR1cmVNYXRyaXggPSBuZXcgVGV4dHVyZU1hdHJpeCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVNYXRyaXg7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnLndpZHRoO1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy4gKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnLmhlaWdodDtcbiAgfVxuICAvKiogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4geW91IGhhdmUgbW9kaWZpZWQgdGhlIGZyYW1lIG9mIHRoaXMgdGV4dHVyZS4gKi9cbiAgdXBkYXRlVXZzKCkge1xuICAgIGNvbnN0IHsgdXZzLCBmcmFtZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX3NvdXJjZTtcbiAgICBjb25zdCBuWCA9IGZyYW1lLnggLyB3aWR0aDtcbiAgICBjb25zdCBuWSA9IGZyYW1lLnkgLyBoZWlnaHQ7XG4gICAgY29uc3QgblcgPSBmcmFtZS53aWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IG5IID0gZnJhbWUuaGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGxldCByb3RhdGUgPSB0aGlzLnJvdGF0ZTtcbiAgICBpZiAocm90YXRlKSB7XG4gICAgICBjb25zdCB3MiA9IG5XIC8gMjtcbiAgICAgIGNvbnN0IGgyID0gbkggLyAyO1xuICAgICAgY29uc3QgY1ggPSBuWCArIHcyO1xuICAgICAgY29uc3QgY1kgPSBuWSArIGgyO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCBncm91cEQ4Lk5XKTtcbiAgICAgIHV2cy54MCA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTAgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MSA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTEgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MiA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTIgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MyA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTMgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dnMueDAgPSBuWDtcbiAgICAgIHV2cy55MCA9IG5ZO1xuICAgICAgdXZzLngxID0gblggKyBuVztcbiAgICAgIHV2cy55MSA9IG5ZO1xuICAgICAgdXZzLngyID0gblggKyBuVztcbiAgICAgIHV2cy55MiA9IG5ZICsgbkg7XG4gICAgICB1dnMueDMgPSBuWDtcbiAgICAgIHV2cy55MyA9IG5ZICsgbkg7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICogQHBhcmFtIGRlc3Ryb3lTb3VyY2UgLSBEZXN0cm95IHRoZSBzb3VyY2Ugd2hlbiB0aGUgdGV4dHVyZSBpcyBkZXN0cm95ZWQuXG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lTb3VyY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGlmIChkZXN0cm95U291cmNlKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmVNYXRyaXggPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqIGNhbGwgdGhpcyBpZiB5b3UgaGF2ZSBtb2RpZmllZCB0aGUgYHRleHR1cmUgb3V0c2lkZWAgb2YgdGhlIGNvbnN0cnVjdG9yICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICB0aGlzLmZyYW1lLndpZHRoID0gdGhpcy5fc291cmNlLndpZHRoO1xuICAgICAgdGhpcy5mcmFtZS5oZWlnaHQgPSB0aGlzLl9zb3VyY2UuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgKi9cbiAgZ2V0IGJhc2VUZXh0dXJlKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJUZXh0dXJlLmJhc2VUZXh0dXJlIGlzIG5vdyBUZXh0dXJlLnNvdXJjZVwiKTtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICB9XG59XG5UZXh0dXJlLkVNUFRZID0gbmV3IFRleHR1cmUoe1xuICBsYWJlbDogXCJFTVBUWVwiLFxuICBzb3VyY2U6IG5ldyBUZXh0dXJlU291cmNlKHtcbiAgICBsYWJlbDogXCJFTVBUWVwiXG4gIH0pXG59KTtcblRleHR1cmUuRU1QVFkuZGVzdHJveSA9IE5PT1A7XG5UZXh0dXJlLldISVRFID0gbmV3IFRleHR1cmUoe1xuICBzb3VyY2U6IG5ldyBCdWZmZXJJbWFnZVNvdXJjZSh7XG4gICAgcmVzb3VyY2U6IG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMjU1LCAyNTVdKSxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgYWxwaGFNb2RlOiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiLFxuICAgIGxhYmVsOiBcIldISVRFXCJcbiAgfSksXG4gIGxhYmVsOiBcIldISVRFXCJcbn0pO1xuVGV4dHVyZS5XSElURS5kZXN0cm95ID0gTk9PUDtcblxuZXhwb3J0IHsgVGV4dHVyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9853\n')},575:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U: () => (/* binding */ TextureMatrix)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n\n\n"use strict";\nconst tempMat = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === "undefined") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener("update", this.update, this);\n    this._texture = value;\n    this._texture.addListener("update", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset / texBase._resolution;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=TextureMatrix.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBNkQ7O0FBRTdEO0FBQ0Esb0JBQW9CLHFFQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxRUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZU1hdHJpeC5tanM/NDA4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcE1hdCA9IG5ldyBNYXRyaXgoKTtcbmNsYXNzIFRleHR1cmVNYXRyaXgge1xuICAvKipcbiAgICogQHBhcmFtIHRleHR1cmUgLSBvYnNlcnZlZCB0ZXh0dXJlXG4gICAqIEBwYXJhbSBjbGFtcE1hcmdpbiAtIENoYW5nZXMgZnJhbWUgY2xhbXBpbmcsIDAuNSBieSBkZWZhdWx0LiBVc2UgLTAuNSBmb3IgZXh0cmEgYm9yZGVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgY2xhbXBNYXJnaW4pIHtcbiAgICB0aGlzLm1hcENvb3JkID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMudUNsYW1wRnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHRoaXMudUNsYW1wT2Zmc2V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgdGhpcy5jbGFtcE9mZnNldCA9IDA7XG4gICAgaWYgKHR5cGVvZiBjbGFtcE1hcmdpbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5jbGFtcE1hcmdpbiA9IHRleHR1cmUud2lkdGggPCAxMCA/IDAgOiAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xhbXBNYXJnaW4gPSBjbGFtcE1hcmdpbjtcbiAgICB9XG4gICAgdGhpcy5pc1NpbXBsZSA9IGZhbHNlO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gIH1cbiAgLyoqIFRleHR1cmUgcHJvcGVydHkuICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudGV4dHVyZSA9PT0gdmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fdGV4dHVyZT8ucmVtb3ZlTGlzdGVuZXIoXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIHRoaXMuX3RleHR1cmUgPSB2YWx1ZTtcbiAgICB0aGlzLl90ZXh0dXJlLmFkZExpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHV2cyBhcnJheSB0byB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHV2cyAtIG1lc2ggdXZzXG4gICAqIEBwYXJhbSBbb3V0PXV2c10gLSBvdXRwdXRcbiAgICogQHJldHVybnMgLSBvdXRwdXRcbiAgICovXG4gIG11bHRpcGx5VXZzKHV2cywgb3V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7XG4gICAgICBvdXQgPSB1dnM7XG4gICAgfVxuICAgIGNvbnN0IG1hdCA9IHRoaXMubWFwQ29vcmQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB1dnNbaV07XG4gICAgICBjb25zdCB5ID0gdXZzW2kgKyAxXTtcbiAgICAgIG91dFtpXSA9IHggKiBtYXQuYSArIHkgKiBtYXQuYyArIG1hdC50eDtcbiAgICAgIG91dFtpICsgMV0gPSB4ICogbWF0LmIgKyB5ICogbWF0LmQgKyBtYXQudHk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgbWF0cmljZXMgaWYgdGV4dHVyZSB3YXMgY2hhbmdlZFxuICAgKiBAcmV0dXJucyAtIHdoZXRoZXIgb3Igbm90IGl0IHdhcyB1cGRhdGVkXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdGV4ID0gdGhpcy5fdGV4dHVyZTtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIGNvbnN0IHV2cyA9IHRleC51dnM7XG4gICAgdGhpcy5tYXBDb29yZC5zZXQodXZzLngxIC0gdXZzLngwLCB1dnMueTEgLSB1dnMueTAsIHV2cy54MyAtIHV2cy54MCwgdXZzLnkzIC0gdXZzLnkwLCB1dnMueDAsIHV2cy55MCk7XG4gICAgY29uc3Qgb3JpZyA9IHRleC5vcmlnO1xuICAgIGNvbnN0IHRyaW0gPSB0ZXgudHJpbTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgdGVtcE1hdC5zZXQoXG4gICAgICAgIG9yaWcud2lkdGggLyB0cmltLndpZHRoLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBvcmlnLmhlaWdodCAvIHRyaW0uaGVpZ2h0LFxuICAgICAgICAtdHJpbS54IC8gdHJpbS53aWR0aCxcbiAgICAgICAgLXRyaW0ueSAvIHRyaW0uaGVpZ2h0XG4gICAgICApO1xuICAgICAgdGhpcy5tYXBDb29yZC5hcHBlbmQodGVtcE1hdCk7XG4gICAgfVxuICAgIGNvbnN0IHRleEJhc2UgPSB0ZXguc291cmNlO1xuICAgIGNvbnN0IGZyYW1lID0gdGhpcy51Q2xhbXBGcmFtZTtcbiAgICBjb25zdCBtYXJnaW4gPSB0aGlzLmNsYW1wTWFyZ2luIC8gdGV4QmFzZS5fcmVzb2x1dGlvbjtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmNsYW1wT2Zmc2V0IC8gdGV4QmFzZS5fcmVzb2x1dGlvbjtcbiAgICBmcmFtZVswXSA9ICh0ZXguZnJhbWUueCArIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoO1xuICAgIGZyYW1lWzFdID0gKHRleC5mcmFtZS55ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgIGZyYW1lWzJdID0gKHRleC5mcmFtZS54ICsgdGV4LmZyYW1lLndpZHRoIC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2Uud2lkdGg7XG4gICAgZnJhbWVbM10gPSAodGV4LmZyYW1lLnkgKyB0ZXguZnJhbWUuaGVpZ2h0IC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgIHRoaXMudUNsYW1wT2Zmc2V0WzBdID0gdGhpcy5jbGFtcE9mZnNldCAvIHRleEJhc2UucGl4ZWxXaWR0aDtcbiAgICB0aGlzLnVDbGFtcE9mZnNldFsxXSA9IHRoaXMuY2xhbXBPZmZzZXQgLyB0ZXhCYXNlLnBpeGVsSGVpZ2h0O1xuICAgIHRoaXMuaXNTaW1wbGUgPSB0ZXguZnJhbWUud2lkdGggPT09IHRleEJhc2Uud2lkdGggJiYgdGV4LmZyYW1lLmhlaWdodCA9PT0gdGV4QmFzZS5oZWlnaHQgJiYgdGV4LnJvdGF0ZSA9PT0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBUZXh0dXJlTWF0cml4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlTWF0cml4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///575\n')},9224:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ BufferImageSource)\n/* harmony export */ });\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3489);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n"use strict";\nclass BufferImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = "rgba32float";\n      } else if (buffer instanceof Int32Array) {\n        format = "rgba32uint";\n      } else if (buffer instanceof Uint32Array) {\n        format = "rgba32uint";\n      } else if (buffer instanceof Int16Array) {\n        format = "rgba16uint";\n      } else if (buffer instanceof Uint16Array) {\n        format = "rgba16uint";\n      } else if (buffer instanceof Int8Array) {\n        format = "bgra8unorm";\n      } else {\n        format = "bgra8unorm";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = "buffer";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=BufferImageSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIyNC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5RTtBQUNyQjs7QUFFcEQ7QUFDQSxnQ0FBZ0Msc0VBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrRUFBYTs7QUFFZDtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQnVmZmVySW1hZ2VTb3VyY2UubWpzPzMyYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJ1ZmZlckltYWdlU291cmNlIGV4dGVuZHMgVGV4dHVyZVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWZmZXIgPSBvcHRpb25zLnJlc291cmNlIHx8IG5ldyBGbG9hdDMyQXJyYXkob3B0aW9ucy53aWR0aCAqIG9wdGlvbnMuaGVpZ2h0ICogNCk7XG4gICAgbGV0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIGZvcm1hdCA9IFwicmdiYTMyZmxvYXRcIjtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICBmb3JtYXQgPSBcInJnYmEzMnVpbnRcIjtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJyZ2JhMzJ1aW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJyZ2JhMTZ1aW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGZvcm1hdCA9IFwicmdiYTE2dWludFwiO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJiZ3JhOHVub3JtXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBcImJncmE4dW5vcm1cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHJlc291cmNlOiBidWZmZXIsXG4gICAgICBmb3JtYXRcbiAgICB9KTtcbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gXCJidWZmZXJcIjtcbiAgfVxuICBzdGF0aWMgdGVzdChyZXNvdXJjZSkge1xuICAgIHJldHVybiByZXNvdXJjZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuQnVmZmVySW1hZ2VTb3VyY2UuZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5UZXh0dXJlU291cmNlO1xuXG5leHBvcnQgeyBCdWZmZXJJbWFnZVNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVySW1hZ2VTb3VyY2UubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9224\n')},6914:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ CanvasSource)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3646);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3489);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n\n"use strict";\nclass CanvasSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__/* .DOMAdapter */ .z.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = "image";\n    this.autoDensity = options.autoDensity;\n    const canvas = options.resource;\n    if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {\n      this.resizeCanvas();\n    }\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n}\nCanvasSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=CanvasSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkxNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0U7QUFDSztBQUNyQjs7QUFFcEQ7QUFDQSwyQkFBMkIsc0VBQWE7QUFDeEM7QUFDQTtBQUNBLHlCQUF5Qix5RUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRCxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtFQUFhOztBQUVkO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9DYW52YXNTb3VyY2UubWpzP2E3OTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuL1RleHR1cmVTb3VyY2UubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYW52YXNTb3VyY2UgZXh0ZW5kcyBUZXh0dXJlU291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5yZXNvdXJjZSkge1xuICAgICAgb3B0aW9ucy5yZXNvdXJjZSA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy53aWR0aCkge1xuICAgICAgb3B0aW9ucy53aWR0aCA9IG9wdGlvbnMucmVzb3VyY2Uud2lkdGg7XG4gICAgICBpZiAoIW9wdGlvbnMuYXV0b0RlbnNpdHkpIHtcbiAgICAgICAgb3B0aW9ucy53aWR0aCAvPSBvcHRpb25zLnJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gb3B0aW9ucy5yZXNvdXJjZS5oZWlnaHQ7XG4gICAgICBpZiAoIW9wdGlvbnMuYXV0b0RlbnNpdHkpIHtcbiAgICAgICAgb3B0aW9ucy5oZWlnaHQgLz0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gXCJpbWFnZVwiO1xuICAgIHRoaXMuYXV0b0RlbnNpdHkgPSBvcHRpb25zLmF1dG9EZW5zaXR5O1xuICAgIGNvbnN0IGNhbnZhcyA9IG9wdGlvbnMucmVzb3VyY2U7XG4gICAgaWYgKHRoaXMucGl4ZWxXaWR0aCAhPT0gY2FudmFzLndpZHRoIHx8IHRoaXMucGl4ZWxXaWR0aCAhPT0gY2FudmFzLmhlaWdodCkge1xuICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc3BhcmVudCA9ICEhb3B0aW9ucy50cmFuc3BhcmVudDtcbiAgfVxuICByZXNpemVDYW52YXMoKSB7XG4gICAgaWYgKHRoaXMuYXV0b0RlbnNpdHkpIHtcbiAgICAgIHRoaXMucmVzb3VyY2Uuc3R5bGUud2lkdGggPSBgJHt0aGlzLndpZHRofXB4YDtcbiAgICAgIHRoaXMucmVzb3VyY2Uuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5oZWlnaHR9cHhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNvdXJjZS53aWR0aCAhPT0gdGhpcy5waXhlbFdpZHRoIHx8IHRoaXMucmVzb3VyY2UuaGVpZ2h0ICE9PSB0aGlzLnBpeGVsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlc291cmNlLndpZHRoID0gdGhpcy5waXhlbFdpZHRoO1xuICAgICAgdGhpcy5yZXNvdXJjZS5oZWlnaHQgPSB0aGlzLnBpeGVsSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXNpemUod2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodCwgcmVzb2x1dGlvbiA9IHRoaXMuX3Jlc29sdXRpb24pIHtcbiAgICBjb25zdCBkaWRSZXNpemUgPSBzdXBlci5yZXNpemUod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgaWYgKGRpZFJlc2l6ZSkge1xuICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZFJlc2l6ZTtcbiAgfVxuICBzdGF0aWMgdGVzdChyZXNvdXJjZSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkhUTUxDYW52YXNFbGVtZW50ICYmIHJlc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHwgZ2xvYmFsVGhpcy5PZmZzY3JlZW5DYW52YXMgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXM7XG4gIH1cbn1cbkNhbnZhc1NvdXJjZS5leHRlbnNpb24gPSBFeHRlbnNpb25UeXBlLlRleHR1cmVTb3VyY2U7XG5cbmV4cG9ydCB7IENhbnZhc1NvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzU291cmNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6914\n')},9160:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ ImageSource)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3646);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3489);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4796);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n\n\n"use strict";\nclass ImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__/* .DOMAdapter */ .z.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext("2d");\n      context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n      options.resource = canvas;\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__/* .warn */ .Z)("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");\n    }\n    super(options);\n    this.uploadMethodId = "image";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n}\nImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=ImageSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE2MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9FO0FBQ0s7QUFDWjtBQUNUOztBQUVwRDtBQUNBLDBCQUEwQixzRUFBYTtBQUN2QztBQUNBO0FBQ0EscUJBQXFCLHlFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0VBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0VBQWE7O0FBRWQ7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0ltYWdlU291cmNlLm1qcz84NzExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlU291cmNlIH0gZnJvbSAnLi9UZXh0dXJlU291cmNlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgSW1hZ2VTb3VyY2UgZXh0ZW5kcyBUZXh0dXJlU291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlc291cmNlICYmIChnbG9iYWxUaGlzLkhUTUxJbWFnZUVsZW1lbnQgJiYgb3B0aW9ucy5yZXNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcyhvcHRpb25zLnJlc291cmNlLndpZHRoLCBvcHRpb25zLnJlc291cmNlLmhlaWdodCk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG9wdGlvbnMucmVzb3VyY2UsIDAsIDAsIG9wdGlvbnMucmVzb3VyY2Uud2lkdGgsIG9wdGlvbnMucmVzb3VyY2UuaGVpZ2h0KTtcbiAgICAgIG9wdGlvbnMucmVzb3VyY2UgPSBjYW52YXM7XG4gICAgICB3YXJuKFwiSW1hZ2VTb3VyY2U6IEltYWdlIGVsZW1lbnQgcGFzc2VkLCBjb252ZXJ0aW5nIHRvIGNhbnZhcy4gVXNlIENhbnZhc1NvdXJjZSBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy51cGxvYWRNZXRob2RJZCA9IFwiaW1hZ2VcIjtcbiAgICB0aGlzLmF1dG9HYXJiYWdlQ29sbGVjdCA9IHRydWU7XG4gIH1cbiAgc3RhdGljIHRlc3QocmVzb3VyY2UpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5IVE1MSW1hZ2VFbGVtZW50ICYmIHJlc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCB0eXBlb2YgSW1hZ2VCaXRtYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCB8fCBnbG9iYWxUaGlzLlZpZGVvRnJhbWUgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBWaWRlb0ZyYW1lO1xuICB9XG59XG5JbWFnZVNvdXJjZS5leHRlbnNpb24gPSBFeHRlbnNpb25UeXBlLlRleHR1cmVTb3VyY2U7XG5cbmV4cG9ydCB7IEltYWdlU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZVNvdXJjZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9160\n')},5206:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  p: () => (/* binding */ TextureSource)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(4181);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs\n\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=definedProps.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs\n\n\n\n\n"use strict";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = (0,uid/* uid */.h)("resource");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends eventemitter3/* default */.Z {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = "textureSampler";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "TextureStyle.wrapMode is now TextureStyle.addressMode");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = "linear";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit("change", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.emit("change", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: "clamp-to-edge",\n  scaleMode: "linear"\n};\nlet TextureStyle = _TextureStyle;\n\n\n//# sourceMappingURL=TextureStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs\n\n\n\n\n\n\n"use strict";\nconst _TextureSource = class _TextureSource extends eventemitter3/* default */.Z {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = (0,uid/* uid */.h)("textureSource");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = "textureSource";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = "unknown";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = "rgba8unorm";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = "2d";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? "";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off("change", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on("change", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit("styleChange", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit("update", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.emit("change", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    this.emit("change", this);\n    this.emit("unload", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution = resolution || this._resolution;\n    width = width || this.width;\n    height = height || this.height;\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit("resize", this);\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    this.emit("change", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don\'t want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit("updateMipmaps", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = (0,pow2/* isPow2 */.wv)(this.pixelWidth) && (0,pow2/* isPow2 */.wv)(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error("Unimplemented");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: "bgra8unorm",\n  alphaMode: "premultiply-alpha-on-upload",\n  dimensions: "2d",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\n\n//# sourceMappingURL=TextureSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUFNLHFCQUFxQix1QkFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9kZWZpbmVkUHJvcHMubWpzPzNmMzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVN0eWxlLm1qcz9iYzBmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvVGV4dHVyZVNvdXJjZS5tanM/NDI0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGRlZmluZWRQcm9wcyhvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmpba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBkZWZpbmVkUHJvcHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmluZWRQcm9wcy5tanMubWFwXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgaWRIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBjcmVhdGVSZXNvdXJjZUlkRnJvbVN0cmluZyh2YWx1ZSkge1xuICBjb25zdCBpZCA9IGlkSGFzaFt2YWx1ZV07XG4gIGlmIChpZCA9PT0gdm9pZCAwKSB7XG4gICAgaWRIYXNoW3ZhbHVlXSA9IHVpZChcInJlc291cmNlXCIpO1xuICB9XG4gIHJldHVybiBpZDtcbn1cbmNvbnN0IF9UZXh0dXJlU3R5bGUgPSBjbGFzcyBfVGV4dHVyZVN0eWxlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIHN0eWxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3Jlc291cmNlVHlwZSA9IFwidGV4dHVyZVNhbXBsZXJcIjtcbiAgICB0aGlzLl90b3VjaGVkID0gMDtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIG1heGltdW0gYW5pc290cm9weSB2YWx1ZSBjbGFtcCB1c2VkIGJ5IHRoZSBzYW1wbGVyLlxuICAgICAqIE5vdGU6IE1vc3QgaW1wbGVtZW50YXRpb25zIHN1cHBvcnQge0BsaW5rIEdQVVNhbXBsZXJEZXNjcmlwdG9yI21heEFuaXNvdHJvcHl9IHZhbHVlcyBpbiByYW5nZVxuICAgICAqIGJldHdlZW4gMSBhbmQgMTYsIGluY2x1c2l2ZS4gVGhlIHVzZWQgdmFsdWUgb2Yge0BsaW5rIEdQVVNhbXBsZXJEZXNjcmlwdG9yI21heEFuaXNvdHJvcHl9IHdpbGxcbiAgICAgKiBiZSBjbGFtcGVkIHRvIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIHBsYXRmb3JtIHN1cHBvcnRzLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9tYXhBbmlzb3Ryb3B5ID0gMTtcbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIHN0eWxlIGJlZW4gZGVzdHJveWVkP1xuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgb3B0aW9ucyA9IHsgLi4uX1RleHR1cmVTdHlsZS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuYWRkcmVzc01vZGUgPSBvcHRpb25zLmFkZHJlc3NNb2RlO1xuICAgIHRoaXMuYWRkcmVzc01vZGVVID0gb3B0aW9ucy5hZGRyZXNzTW9kZVUgPz8gdGhpcy5hZGRyZXNzTW9kZVU7XG4gICAgdGhpcy5hZGRyZXNzTW9kZVYgPSBvcHRpb25zLmFkZHJlc3NNb2RlViA/PyB0aGlzLmFkZHJlc3NNb2RlVjtcbiAgICB0aGlzLmFkZHJlc3NNb2RlVyA9IG9wdGlvbnMuYWRkcmVzc01vZGVXID8/IHRoaXMuYWRkcmVzc01vZGVXO1xuICAgIHRoaXMuc2NhbGVNb2RlID0gb3B0aW9ucy5zY2FsZU1vZGU7XG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBvcHRpb25zLm1hZ0ZpbHRlciA/PyB0aGlzLm1hZ0ZpbHRlcjtcbiAgICB0aGlzLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyID8/IHRoaXMubWluRmlsdGVyO1xuICAgIHRoaXMubWlwbWFwRmlsdGVyID0gb3B0aW9ucy5taXBtYXBGaWx0ZXIgPz8gdGhpcy5taXBtYXBGaWx0ZXI7XG4gICAgdGhpcy5sb2RNaW5DbGFtcCA9IG9wdGlvbnMubG9kTWluQ2xhbXA7XG4gICAgdGhpcy5sb2RNYXhDbGFtcCA9IG9wdGlvbnMubG9kTWF4Q2xhbXA7XG4gICAgdGhpcy5jb21wYXJlID0gb3B0aW9ucy5jb21wYXJlO1xuICAgIHRoaXMubWF4QW5pc290cm9weSA9IG9wdGlvbnMubWF4QW5pc290cm9weSA/PyAxO1xuICB9XG4gIHNldCBhZGRyZXNzTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuYWRkcmVzc01vZGVVID0gdmFsdWU7XG4gICAgdGhpcy5hZGRyZXNzTW9kZVYgPSB2YWx1ZTtcbiAgICB0aGlzLmFkZHJlc3NNb2RlVyA9IHZhbHVlO1xuICB9XG4gIC8qKiBzZXR0aW5nIHRoaXMgd2lsbCBzZXQgd3JhcE1vZGVVLHdyYXBNb2RlViBhbmQgd3JhcE1vZGVXIGFsbCBhdCBvbmNlISAqL1xuICBnZXQgYWRkcmVzc01vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc01vZGVVO1xuICB9XG4gIHNldCB3cmFwTW9kZSh2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJUZXh0dXJlU3R5bGUud3JhcE1vZGUgaXMgbm93IFRleHR1cmVTdHlsZS5hZGRyZXNzTW9kZVwiKTtcbiAgICB0aGlzLmFkZHJlc3NNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHdyYXBNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3NNb2RlO1xuICB9XG4gIHNldCBzY2FsZU1vZGUodmFsdWUpIHtcbiAgICB0aGlzLm1hZ0ZpbHRlciA9IHZhbHVlO1xuICAgIHRoaXMubWluRmlsdGVyID0gdmFsdWU7XG4gICAgdGhpcy5taXBtYXBGaWx0ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKiogc2V0dGluZyB0aGlzIHdpbGwgc2V0IG1hZ0ZpbHRlcixtaW5GaWx0ZXIgYW5kIG1pcG1hcEZpbHRlciBhbGwgYXQgb25jZSEgICovXG4gIGdldCBzY2FsZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFnRmlsdGVyO1xuICB9XG4gIC8qKiBTcGVjaWZpZXMgdGhlIG1heGltdW0gYW5pc290cm9weSB2YWx1ZSBjbGFtcCB1c2VkIGJ5IHRoZSBzYW1wbGVyLiAqL1xuICBzZXQgbWF4QW5pc290cm9weSh2YWx1ZSkge1xuICAgIHRoaXMuX21heEFuaXNvdHJvcHkgPSBNYXRoLm1pbih2YWx1ZSwgMTYpO1xuICAgIGlmICh0aGlzLl9tYXhBbmlzb3Ryb3B5ID4gMSkge1xuICAgICAgdGhpcy5zY2FsZU1vZGUgPSBcImxpbmVhclwiO1xuICAgIH1cbiAgfVxuICBnZXQgbWF4QW5pc290cm9weSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4QW5pc290cm9weTtcbiAgfVxuICAvLyBUT0RPIC0gbW92ZSB0aGlzIHRvIFdlYkdMP1xuICBnZXQgX3Jlc291cmNlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZFJlc291cmNlSWQgfHwgdGhpcy5fZ2VuZXJhdGVSZXNvdXJjZUlkKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB0aGlzKTtcbiAgICB0aGlzLl9zaGFyZWRSZXNvdXJjZUlkID0gbnVsbDtcbiAgfVxuICBfZ2VuZXJhdGVSZXNvdXJjZUlkKCkge1xuICAgIGNvbnN0IGJpZ0tleSA9IGAke3RoaXMuYWRkcmVzc01vZGVVfS0ke3RoaXMuYWRkcmVzc01vZGVWfS0ke3RoaXMuYWRkcmVzc01vZGVXfS0ke3RoaXMubWFnRmlsdGVyfS0ke3RoaXMubWluRmlsdGVyfS0ke3RoaXMubWlwbWFwRmlsdGVyfS0ke3RoaXMubG9kTWluQ2xhbXB9LSR7dGhpcy5sb2RNYXhDbGFtcH0tJHt0aGlzLmNvbXBhcmV9LSR7dGhpcy5fbWF4QW5pc290cm9weX1gO1xuICAgIHRoaXMuX3NoYXJlZFJlc291cmNlSWQgPSBjcmVhdGVSZXNvdXJjZUlkRnJvbVN0cmluZyhiaWdLZXkpO1xuICAgIHJldHVybiB0aGlzLl9yZXNvdXJjZUlkO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgc3R5bGUgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxufTtcbi8qKiBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBzdHlsZSAqL1xuX1RleHR1cmVTdHlsZS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWRkcmVzc01vZGU6IFwiY2xhbXAtdG8tZWRnZVwiLFxuICBzY2FsZU1vZGU6IFwibGluZWFyXCJcbn07XG5sZXQgVGV4dHVyZVN0eWxlID0gX1RleHR1cmVTdHlsZTtcblxuZXhwb3J0IHsgVGV4dHVyZVN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlU3R5bGUubWpzLm1hcFxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IGlzUG93MiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL21hdGhzL21pc2MvcG93Mi5tanMnO1xuaW1wb3J0IHsgZGVmaW5lZFByb3BzIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2RlZmluZWRQcm9wcy5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IFRleHR1cmVTdHlsZSB9IGZyb20gJy4uL1RleHR1cmVTdHlsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9UZXh0dXJlU291cmNlID0gY2xhc3MgX1RleHR1cmVTb3VyY2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIGZvciBjcmVhdGluZyBhIG5ldyBUZXh0dXJlU291cmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLyoqIHVuaXF1ZSBpZCBmb3IgdGhpcyBUZXh0dXJlIHNvdXJjZSAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwidGV4dHVyZVNvdXJjZVwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb3VyY2UgdHlwZSB1c2VkIGJ5IHRoaXMgVGV4dHVyZVNvdXJjZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBiaW5kIGdyb3VwcyB0byBkZXRlcm1pbmVcbiAgICAgKiBob3cgdG8gaGFuZGxlIHRoaXMgcmVzb3VyY2UuXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX3Jlc291cmNlVHlwZSA9IFwidGV4dHVyZVNvdXJjZVwiO1xuICAgIC8qKlxuICAgICAqIGkgdW5pcXVlIHJlc291cmNlIGlkLCB1c2VkIGJ5IHRoZSBiaW5kIGdyb3VwIHN5c3RlbXMuXG4gICAgICogVGhpcyBjYW4gY2hhbmdlIGlmIHRoZSB0ZXh0dXJlIGlzIHJlc2l6ZWQgb3IgaXRzIHJlc291cmNlIGNoYW5nZXNcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvdXJjZUlkID0gdWlkKFwicmVzb3VyY2VcIik7XG4gICAgLyoqXG4gICAgICogdGhpcyBpcyBob3cgdGhlIGJhY2tlbmRzIGtub3cgaG93IHRvIHVwbG9hZCB0aGlzIHRleHR1cmUgdG8gdGhlIEdQVVxuICAgICAqIEl0IGNoYW5nZXMgZGVwZW5kaW5nIG9uIHRoZSByZXNvdXJjZSB0eXBlLiBDbGFzc2VzIHRoYXQgZXh0ZW5kIFRleHR1cmVTb3VyY2VcbiAgICAgKiBzaG91bGQgb3ZlcnJpZGUgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy51cGxvYWRNZXRob2RJZCA9IFwidW5rbm93blwiO1xuICAgIC8vIGRpbWVuc2lvbnNcbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gMTtcbiAgICAvKiogdGhlIHBpeGVsIHdpZHRoIG9mIHRoaXMgdGV4dHVyZSBzb3VyY2UuIFRoaXMgaXMgdGhlIFJFQUwgcHVyZSBudW1iZXIsIG5vdCBhY2NvdW50aW5nIHJlc29sdXRpb24gKi9cbiAgICB0aGlzLnBpeGVsV2lkdGggPSAxO1xuICAgIC8qKiB0aGUgcGl4ZWwgaGVpZ2h0IG9mIHRoaXMgdGV4dHVyZSBzb3VyY2UuIFRoaXMgaXMgdGhlIFJFQUwgcHVyZSBudW1iZXIsIG5vdCBhY2NvdW50aW5nIHJlc29sdXRpb24gKi9cbiAgICB0aGlzLnBpeGVsSGVpZ2h0ID0gMTtcbiAgICAvKipcbiAgICAgKiB0aGUgd2lkdGggb2YgdGhpcyB0ZXh0dXJlIHNvdXJjZSwgYWNjb3VudGluZyBmb3IgcmVzb2x1dGlvblxuICAgICAqIGVnIHBpeGVsV2lkdGggMjAwLCByZXNvbHV0aW9uIDIsIHRoZW4gd2lkdGggd2lsbCBiZSAxMDBcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICAvKipcbiAgICAgKiB0aGUgaGVpZ2h0IG9mIHRoaXMgdGV4dHVyZSBzb3VyY2UsIGFjY291bnRpbmcgZm9yIHJlc29sdXRpb25cbiAgICAgKiBlZyBwaXhlbEhlaWdodCAyMDAsIHJlc29sdXRpb24gMiwgdGhlbiBoZWlnaHQgd2lsbCBiZSAxMDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBzYW1wbGVzIG9mIGEgbXVsdGlzYW1wbGUgdGV4dHVyZS4gVGhpcyBpcyBhbHdheXMgMSBmb3Igbm9uLW11bHRpc2FtcGxlIHRleHR1cmVzLlxuICAgICAqIFRvIGVuYWJsZSBtdWx0aXNhbXBsZSBmb3IgYSB0ZXh0dXJlLCBzZXQgYW50aWFsaWFzIHRvIHRydWVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5zYW1wbGVDb3VudCA9IDE7XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgbWlwIGxldmVscyB0byBnZW5lcmF0ZSBmb3IgdGhpcyB0ZXh0dXJlLiB0aGlzIGlzICBvdmVycmlkZGVuIGlmIGF1dG9HZW5lcmF0ZU1pcG1hcHMgaXMgdHJ1ZSAqL1xuICAgIHRoaXMubWlwTGV2ZWxDb3VudCA9IDE7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIHdlIGF1dG8gZ2VuZXJhdGUgbWlwbWFwcyBmb3IgdGhpcyB0ZXh0dXJlPyBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBnZW5lcmF0ZSBtaXBtYXBzXG4gICAgICogZm9yIHRoaXMgdGV4dHVyZSB3aGVuIHVwbG9hZGluZyB0byB0aGUgR1BVLiBNaXBtYXBwZWQgdGV4dHVyZXMgdGFrZSB1cCBtb3JlIG1lbW9yeSwgYnV0XG4gICAgICogY2FuIGxvb2sgYmV0dGVyIHdoZW4gc2NhbGVkIGRvd24uXG4gICAgICpcbiAgICAgKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgaXMgcmVjb21tZW5kZWQgdG8gTk9UIHVzZSB0aGlzIHdpdGggUmVuZGVyVGV4dHVyZXMsIGFzIHRoZXkgYXJlIG9mdGVuIHVwZGF0ZWQgZXZlcnkgZnJhbWUuXG4gICAgICogSWYgeW91IGRvLCBtYWtlIHN1cmUgdG8gY2FsbCBgdXBkYXRlTWlwbWFwc2AgYWZ0ZXIgeW91IHVwZGF0ZSB0aGUgdGV4dHVyZS5cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9HZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAvKiogdGhlIGZvcm1hdCB0aGF0IHRoZSB0ZXh0dXJlIGRhdGEgaGFzICovXG4gICAgdGhpcy5mb3JtYXQgPSBcInJnYmE4dW5vcm1cIjtcbiAgICAvKiogaG93IG1hbnkgZGltZW5zaW9ucyBkb2VzIHRoaXMgdGV4dHVyZSBoYXZlPyBjdXJyZW50bHkgdjggb25seSBzdXBwb3J0cyAyZCAqL1xuICAgIHRoaXMuZGltZW5zaW9uID0gXCIyZFwiO1xuICAgIC8qKlxuICAgICAqIE9ubHkgcmVhbGx5IGFmZmVjdHMgUmVuZGVyVGV4dHVyZXMuXG4gICAgICogU2hvdWxkIHdlIHVzZSBhbnRpYWxpYXNpbmcgZm9yIHRoaXMgdGV4dHVyZS4gSXQgd2lsbCBsb29rIGJldHRlciwgYnV0IG1heSBpbXBhY3QgcGVyZm9ybWFuY2UgYXMgYVxuICAgICAqIEJsaXQgb3BlcmF0aW9uIHdpbGwgYmUgcmVxdWlyZWQgdG8gcmVzb2x2ZSB0aGUgdGV4dHVyZS5cbiAgICAgKi9cbiAgICB0aGlzLmFudGlhbGlhcyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYXV0b21hdGljIHRleHR1cmUgR2FyYmFnZSBDb2xsZWN0aW9uLCBzdG9yZXMgbGFzdCBHQyB0aWNrIHdoZW4gaXQgd2FzIGJvdW5kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX3RvdWNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgdGhlIGJhdGNoZXIgdG8gYnVpbGQgdGV4dHVyZSBiYXRjaGVzLiBmYXN0ZXIgdG8gaGF2ZSB0aGUgdmFyaWFibGUgaGVyZSFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fYmF0Y2hUaWNrID0gLTE7XG4gICAgLyoqXG4gICAgICogQSB0ZW1wb3JhcnkgYmF0Y2ggbG9jYXRpb24gZm9yIHRoZSB0ZXh0dXJlIGJhdGNoaW5nLiBIZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIG9ubHkhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX3RleHR1cmVCaW5kTG9jYXRpb24gPSAtMTtcbiAgICBvcHRpb25zID0geyAuLi5fVGV4dHVyZVNvdXJjZS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMubGFiZWwgPSBvcHRpb25zLmxhYmVsID8/IFwiXCI7XG4gICAgdGhpcy5yZXNvdXJjZSA9IG9wdGlvbnMucmVzb3VyY2U7XG4gICAgdGhpcy5hdXRvR2FyYmFnZUNvbGxlY3QgPSBvcHRpb25zLmF1dG9HYXJiYWdlQ29sbGVjdDtcbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgIGlmIChvcHRpb25zLndpZHRoKSB7XG4gICAgICB0aGlzLnBpeGVsV2lkdGggPSBvcHRpb25zLndpZHRoICogdGhpcy5fcmVzb2x1dGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5waXhlbFdpZHRoID0gdGhpcy5yZXNvdXJjZSA/IHRoaXMucmVzb3VyY2VXaWR0aCA/PyAxIDogMTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLnBpeGVsSGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKiB0aGlzLl9yZXNvbHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBpeGVsSGVpZ2h0ID0gdGhpcy5yZXNvdXJjZSA/IHRoaXMucmVzb3VyY2VIZWlnaHQgPz8gMSA6IDE7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB0aGlzLnBpeGVsV2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5waXhlbEhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb247XG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgICB0aGlzLmRpbWVuc2lvbiA9IG9wdGlvbnMuZGltZW5zaW9ucztcbiAgICB0aGlzLm1pcExldmVsQ291bnQgPSBvcHRpb25zLm1pcExldmVsQ291bnQ7XG4gICAgdGhpcy5hdXRvR2VuZXJhdGVNaXBtYXBzID0gb3B0aW9ucy5hdXRvR2VuZXJhdGVNaXBtYXBzO1xuICAgIHRoaXMuc2FtcGxlQ291bnQgPSBvcHRpb25zLnNhbXBsZUNvdW50O1xuICAgIHRoaXMuYW50aWFsaWFzID0gb3B0aW9ucy5hbnRpYWxpYXM7XG4gICAgdGhpcy5hbHBoYU1vZGUgPSBvcHRpb25zLmFscGhhTW9kZTtcbiAgICB0aGlzLnN0eWxlID0gbmV3IFRleHR1cmVTdHlsZShkZWZpbmVkUHJvcHMob3B0aW9ucykpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICB9XG4gIC8qKiByZXR1cm5zIGl0c2VsZiAqL1xuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiB0aGUgc3R5bGUgb2YgdGhlIHRleHR1cmUgKi9cbiAgZ2V0IHN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgfVxuICBzZXQgc3R5bGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gdmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fc3R5bGU/Lm9mZihcImNoYW5nZVwiLCB0aGlzLl9vblN0eWxlQ2hhbmdlLCB0aGlzKTtcbiAgICB0aGlzLl9zdHlsZSA9IHZhbHVlO1xuICAgIHRoaXMuX3N0eWxlPy5vbihcImNoYW5nZVwiLCB0aGlzLl9vblN0eWxlQ2hhbmdlLCB0aGlzKTtcbiAgICB0aGlzLl9vblN0eWxlQ2hhbmdlKCk7XG4gIH1cbiAgLyoqIHNldHRpbmcgdGhpcyB3aWxsIHNldCB3cmFwTW9kZVUsd3JhcE1vZGVWIGFuZCB3cmFwTW9kZVcgYWxsIGF0IG9uY2UhICovXG4gIGdldCBhZGRyZXNzTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUuYWRkcmVzc01vZGU7XG4gIH1cbiAgc2V0IGFkZHJlc3NNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUuYWRkcmVzc01vZGUgPSB2YWx1ZTtcbiAgfVxuICAvKiogc2V0dGluZyB0aGlzIHdpbGwgc2V0IHdyYXBNb2RlVSx3cmFwTW9kZVYgYW5kIHdyYXBNb2RlVyBhbGwgYXQgb25jZSEgKi9cbiAgZ2V0IHJlcGVhdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlLmFkZHJlc3NNb2RlO1xuICB9XG4gIHNldCByZXBlYXRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUuYWRkcmVzc01vZGUgPSB2YWx1ZTtcbiAgfVxuICAvKiogU3BlY2lmaWVzIHRoZSBzYW1wbGluZyBiZWhhdmlvciB3aGVuIHRoZSBzYW1wbGUgZm9vdHByaW50IGlzIHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0byBvbmUgdGV4ZWwuICovXG4gIGdldCBtYWdGaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlLm1hZ0ZpbHRlcjtcbiAgfVxuICBzZXQgbWFnRmlsdGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUubWFnRmlsdGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqIFNwZWNpZmllcyB0aGUgc2FtcGxpbmcgYmVoYXZpb3Igd2hlbiB0aGUgc2FtcGxlIGZvb3RwcmludCBpcyBsYXJnZXIgdGhhbiBvbmUgdGV4ZWwuICovXG4gIGdldCBtaW5GaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlLm1pbkZpbHRlcjtcbiAgfVxuICBzZXQgbWluRmlsdGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUubWluRmlsdGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqIFNwZWNpZmllcyBiZWhhdmlvciBmb3Igc2FtcGxpbmcgYmV0d2VlbiBtaXBtYXAgbGV2ZWxzLiAqL1xuICBnZXQgbWlwbWFwRmlsdGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS5taXBtYXBGaWx0ZXI7XG4gIH1cbiAgc2V0IG1pcG1hcEZpbHRlcih2YWx1ZSkge1xuICAgIHRoaXMuX3N0eWxlLm1pcG1hcEZpbHRlciA9IHZhbHVlO1xuICB9XG4gIC8qKiBTcGVjaWZpZXMgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGV2ZWxzIG9mIGRldGFpbCwgcmVzcGVjdGl2ZWx5LCB1c2VkIGludGVybmFsbHkgd2hlbiBzYW1wbGluZyBhIHRleHR1cmUuICovXG4gIGdldCBsb2RNaW5DbGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUubG9kTWluQ2xhbXA7XG4gIH1cbiAgc2V0IGxvZE1pbkNsYW1wKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUubG9kTWluQ2xhbXAgPSB2YWx1ZTtcbiAgfVxuICAvKiogU3BlY2lmaWVzIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxldmVscyBvZiBkZXRhaWwsIHJlc3BlY3RpdmVseSwgdXNlZCBpbnRlcm5hbGx5IHdoZW4gc2FtcGxpbmcgYSB0ZXh0dXJlLiAqL1xuICBnZXQgbG9kTWF4Q2xhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlLmxvZE1heENsYW1wO1xuICB9XG4gIHNldCBsb2RNYXhDbGFtcCh2YWx1ZSkge1xuICAgIHRoaXMuX3N0eWxlLmxvZE1heENsYW1wID0gdmFsdWU7XG4gIH1cbiAgX29uU3R5bGVDaGFuZ2UoKSB7XG4gICAgdGhpcy5lbWl0KFwic3R5bGVDaGFuZ2VcIiwgdGhpcyk7XG4gIH1cbiAgLyoqIGNhbGwgdGhpcyBpZiB5b3UgaGF2ZSBtb2RpZmllZCB0aGUgdGV4dHVyZSBvdXRzaWRlIG9mIHRoZSBjb25zdHJ1Y3RvciAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMucmVzb3VyY2UpIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLl9yZXNvbHV0aW9uO1xuICAgICAgY29uc3QgZGlkUmVzaXplID0gdGhpcy5yZXNpemUodGhpcy5yZXNvdXJjZVdpZHRoIC8gcmVzb2x1dGlvbiwgdGhpcy5yZXNvdXJjZUhlaWdodCAvIHJlc29sdXRpb24pO1xuICAgICAgaWYgKGRpZFJlc2l6ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZSBzb3VyY2UgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgaWYgKHRoaXMuX3N0eWxlKSB7XG4gICAgICB0aGlzLl9zdHlsZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMudXBsb2FkTWV0aG9kSWQgPSBudWxsO1xuICAgIHRoaXMucmVzb3VyY2UgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCB1bmxvYWQgdGhlIFRleHR1cmUgc291cmNlIGZyb20gdGhlIEdQVS4gVGhpcyB3aWxsIGZyZWUgdXAgdGhlIEdQVSBtZW1vcnlcbiAgICogQXMgc29vbiBhcyBpdCBpcyByZXF1aXJlZCBmb3JlIHJlbmRlcmluZywgaXQgd2lsbCBiZSByZS11cGxvYWRlZC5cbiAgICovXG4gIHVubG9hZCgpIHtcbiAgICB0aGlzLl9yZXNvdXJjZUlkID0gdWlkKFwicmVzb3VyY2VcIik7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHRoaXMpO1xuICAgIHRoaXMuZW1pdChcInVubG9hZFwiLCB0aGlzKTtcbiAgfVxuICAvKiogdGhlIHdpZHRoIG9mIHRoZSByZXNvdXJjZS4gVGhpcyBpcyB0aGUgUkVBTCBwdXJlIG51bWJlciwgbm90IGFjY291bnRpbmcgcmVzb2x1dGlvbiAgICovXG4gIGdldCByZXNvdXJjZVdpZHRoKCkge1xuICAgIGNvbnN0IHsgcmVzb3VyY2UgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHJlc291cmNlLm5hdHVyYWxXaWR0aCB8fCByZXNvdXJjZS52aWRlb1dpZHRoIHx8IHJlc291cmNlLmRpc3BsYXlXaWR0aCB8fCByZXNvdXJjZS53aWR0aDtcbiAgfVxuICAvKiogdGhlIGhlaWdodCBvZiB0aGUgcmVzb3VyY2UuIFRoaXMgaXMgdGhlIFJFQUwgcHVyZSBudW1iZXIsIG5vdCBhY2NvdW50aW5nIHJlc29sdXRpb24gKi9cbiAgZ2V0IHJlc291cmNlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHsgcmVzb3VyY2UgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHJlc291cmNlLm5hdHVyYWxIZWlnaHQgfHwgcmVzb3VyY2UudmlkZW9IZWlnaHQgfHwgcmVzb3VyY2UuZGlzcGxheUhlaWdodCB8fCByZXNvdXJjZS5oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlLiBDaGFuZ2luZyB0aGlzIG51bWJlciwgd2lsbCBub3QgY2hhbmdlIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZSBhY3R1YWwgdGV4dHVyZVxuICAgKiBidXQgd2lsbCB0aGUgc2l6ZSBvZiB0aGUgdGV4dHVyZSB3aGVuIHJlbmRlcmVkLlxuICAgKlxuICAgKiBjaGFuZ2luZyB0aGUgcmVzb2x1dGlvbiBvZiB0aGlzIHRleHR1cmUgdG8gMiBmb3IgZXhhbXBsZSB3aWxsIG1ha2UgaXQgYXBwZWFyIHR3aWNlIGFzIHNtYWxsIHdoZW4gcmVuZGVyZWQgKGFzIHBpeGVsXG4gICAqIGRlbnNpdHkgd2lsbCBoYXZlIGluY3JlYXNlZClcbiAgICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gcmVzb2x1dGlvbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5waXhlbFdpZHRoIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMucGl4ZWxIZWlnaHQgLyByZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIHRleHR1cmUsIHRoaXMgaXMgaGFuZHkgaWYgeW91IHdhbnQgdG8gdXNlIHRoZSB0ZXh0dXJlIGFzIGEgcmVuZGVyIHRleHR1cmVcbiAgICogQHBhcmFtIHdpZHRoIC0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSB0aGUgbmV3IHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmVcbiAgICogQHJldHVybnMgLSBpZiB0aGUgdGV4dHVyZSB3YXMgcmVzaXplZFxuICAgKi9cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICByZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCB0aGlzLl9yZXNvbHV0aW9uO1xuICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbmV3UGl4ZWxXaWR0aCA9IE1hdGgucm91bmQod2lkdGggKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBuZXdQaXhlbEhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogcmVzb2x1dGlvbik7XG4gICAgdGhpcy53aWR0aCA9IG5ld1BpeGVsV2lkdGggLyByZXNvbHV0aW9uO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3UGl4ZWxIZWlnaHQgLyByZXNvbHV0aW9uO1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIGlmICh0aGlzLnBpeGVsV2lkdGggPT09IG5ld1BpeGVsV2lkdGggJiYgdGhpcy5waXhlbEhlaWdodCA9PT0gbmV3UGl4ZWxIZWlnaHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICAgIHRoaXMucGl4ZWxXaWR0aCA9IG5ld1BpeGVsV2lkdGg7XG4gICAgdGhpcy5waXhlbEhlaWdodCA9IG5ld1BpeGVsSGVpZ2h0O1xuICAgIHRoaXMuZW1pdChcInJlc2l6ZVwiLCB0aGlzKTtcbiAgICB0aGlzLl9yZXNvdXJjZUlkID0gdWlkKFwicmVzb3VyY2VcIik7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHRoaXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBMZXRzIHRoZSByZW5kZXJlciBrbm93IHRoYXQgdGhpcyB0ZXh0dXJlIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIGl0cyBtaXBtYXBzIHNob3VsZCBiZSByZS1nZW5lcmF0ZWQuXG4gICAqIFRoaXMgaXMgb25seSBpbXBvcnRhbnQgZm9yIFJlbmRlclRleHR1cmUgaW5zdGFuY2VzLCBhcyBzdGFuZGFyZCBUZXh0dXJlIGluc3RhbmNlcyB3aWxsIGhhdmUgdGhlaXJcbiAgICogbWlwbWFwcyBnZW5lcmF0ZWQgb24gdXBsb2FkLiBZb3Ugc2hvdWxkIGNhbGwgdGhpcyBtZXRob2QgYWZ0ZXIgeW91IG1ha2UgYW55IGNoYW5nZSB0byB0aGUgdGV4dHVyZVxuICAgKlxuICAgKiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIGlzIGNhbiBiZSBxdWl0ZSBleHBlbnNpdmUgdG8gdXBkYXRlIG1pcG1hcHMgZm9yIGEgdGV4dHVyZS4gU28gYnkgZGVmYXVsdCxcbiAgICogV2Ugd2FudCB5b3UsIHRoZSBkZXZlbG9wZXIgdG8gc3BlY2lmeSB3aGVuIHRoaXMgYWN0aW9uIHNob3VsZCBoYXBwZW4uXG4gICAqXG4gICAqIEdlbmVyYWxseSB5b3UgZG9uJ3Qgd2FudCB0byBoYXZlIG1pcG1hcHMgZ2VuZXJhdGVkIG9uIFJlbmRlciB0YXJnZXRzIHRoYXQgYXJlIGNoYW5nZWQgZXZlcnkgZnJhbWUsXG4gICAqL1xuICB1cGRhdGVNaXBtYXBzKCkge1xuICAgIGlmICh0aGlzLmF1dG9HZW5lcmF0ZU1pcG1hcHMgJiYgdGhpcy5taXBMZXZlbENvdW50ID4gMSkge1xuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlTWlwbWFwc1wiLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0IHdyYXBNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUud3JhcE1vZGUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgd3JhcE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlLndyYXBNb2RlO1xuICB9XG4gIHNldCBzY2FsZU1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5zY2FsZU1vZGUgPSB2YWx1ZTtcbiAgfVxuICAvKiogc2V0dGluZyB0aGlzIHdpbGwgc2V0IG1hZ0ZpbHRlcixtaW5GaWx0ZXIgYW5kIG1pcG1hcEZpbHRlciBhbGwgYXQgb25jZSEgICovXG4gIGdldCBzY2FsZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlLnNjYWxlTW9kZTtcbiAgfVxuICAvKipcbiAgICogUmVmcmVzaCBjaGVjayBmb3IgaXNQb3dlck9mVHdvIHRleHR1cmUgYmFzZWQgb24gc2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZnJlc2hQT1QoKSB7XG4gICAgdGhpcy5pc1Bvd2VyT2ZUd28gPSBpc1BvdzIodGhpcy5waXhlbFdpZHRoKSAmJiBpc1BvdzIodGhpcy5waXhlbEhlaWdodCk7XG4gIH1cbiAgc3RhdGljIHRlc3QoX3Jlc291cmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZFwiKTtcbiAgfVxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBUZXh0dXJlU291cmNlLiBvdmVycmlkZSB0aGVzZSB0byBhZGQgeW91ciBvd24gZGVmYXVsdHMgKi9cbl9UZXh0dXJlU291cmNlLmRlZmF1bHRPcHRpb25zID0ge1xuICByZXNvbHV0aW9uOiAxLFxuICBmb3JtYXQ6IFwiYmdyYTh1bm9ybVwiLFxuICBhbHBoYU1vZGU6IFwicHJlbXVsdGlwbHktYWxwaGEtb24tdXBsb2FkXCIsXG4gIGRpbWVuc2lvbnM6IFwiMmRcIixcbiAgbWlwTGV2ZWxDb3VudDogMSxcbiAgYXV0b0dlbmVyYXRlTWlwbWFwczogZmFsc2UsXG4gIHNhbXBsZUNvdW50OiAxLFxuICBhbnRpYWxpYXM6IGZhbHNlLFxuICBhdXRvR2FyYmFnZUNvbGxlY3Q6IGZhbHNlXG59O1xubGV0IFRleHR1cmVTb3VyY2UgPSBfVGV4dHVyZVNvdXJjZTtcblxuZXhwb3J0IHsgVGV4dHVyZVNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZVNvdXJjZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5206\n')},4325:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* unused harmony exports autoDetectSource, resourceToTexture, textureFrom */\n/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4162);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3489);\n/* harmony import */ var _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5206);\n/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9853);\n\n\n\n\n\n"use strict";\nconst sources = [];\n_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .extensions */ .Rw.handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ExtensionType */ .nw.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  return textureSourceFrom(options);\n}\nfunction textureSourceFrom(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.has(resource)) {\n    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.get(resource);\n  }\n  const texture = new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x({ source: textureSourceFrom(opts) });\n  texture.on("destroy", () => {\n    if (_assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.has(resource)) {\n      _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === "string") {\n    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.get(id);\n  } else if (id instanceof _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__/* .TextureSource */ .p) {\n    return new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\n_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x.from = textureFrom;\n_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__/* .TextureSource */ .p.from = textureSourceFrom;\n\n\n//# sourceMappingURL=textureFrom.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMyNS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUN1QjtBQUN4QjtBQUNwQjs7QUFFekM7QUFDQTtBQUNBLDRFQUFVLGNBQWMsK0VBQWE7QUFDckMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLG9CQUFvQixtRUFBSztBQUN6QixXQUFXLG1FQUFLO0FBQ2hCO0FBQ0Esc0JBQXNCLDBEQUFPLEdBQUcsaUNBQWlDO0FBQ2pFO0FBQ0EsUUFBUSxtRUFBSztBQUNiLE1BQU0sbUVBQUs7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUksbUVBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBSztBQUNoQixJQUFJLHVCQUF1Qiw4RUFBYTtBQUN4QyxlQUFlLDBEQUFPLEdBQUcsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQSwwREFBTztBQUNQLDhFQUFhOztBQUUrQztBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3V0aWxzL3RleHR1cmVGcm9tLm1qcz8yZDJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vYXNzZXRzL2NhY2hlL0NhY2hlLm1qcyc7XG5pbXBvcnQgeyBleHRlbnNpb25zLCBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlU291cmNlIH0gZnJvbSAnLi4vc291cmNlcy9UZXh0dXJlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHNvdXJjZXMgPSBbXTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuVGV4dHVyZVNvdXJjZSwgc291cmNlcyk7XG5mdW5jdGlvbiBhdXRvRGV0ZWN0U291cmNlKG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gdGV4dHVyZVNvdXJjZUZyb20ob3B0aW9ucyk7XG59XG5mdW5jdGlvbiB0ZXh0dXJlU291cmNlRnJvbShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaGFzUmVzb3VyY2UgPSBvcHRpb25zICYmIG9wdGlvbnMucmVzb3VyY2U7XG4gIGNvbnN0IHJlcyA9IGhhc1Jlc291cmNlID8gb3B0aW9ucy5yZXNvdXJjZSA6IG9wdGlvbnM7XG4gIGNvbnN0IG9wdHMgPSBoYXNSZXNvdXJjZSA/IG9wdGlvbnMgOiB7IHJlc291cmNlOiBvcHRpb25zIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKFNvdXJjZS50ZXN0KHJlcykpIHtcbiAgICAgIHJldHVybiBuZXcgU291cmNlKG9wdHMpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgc291cmNlIHR5cGUgZm9yIHJlc291cmNlOiAke29wdHMucmVzb3VyY2V9YCk7XG59XG5mdW5jdGlvbiByZXNvdXJjZVRvVGV4dHVyZShvcHRpb25zID0ge30sIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGhhc1Jlc291cmNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc291cmNlO1xuICBjb25zdCByZXNvdXJjZSA9IGhhc1Jlc291cmNlID8gb3B0aW9ucy5yZXNvdXJjZSA6IG9wdGlvbnM7XG4gIGNvbnN0IG9wdHMgPSBoYXNSZXNvdXJjZSA/IG9wdGlvbnMgOiB7IHJlc291cmNlOiBvcHRpb25zIH07XG4gIGlmICghc2tpcENhY2hlICYmIENhY2hlLmhhcyhyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4gQ2FjaGUuZ2V0KHJlc291cmNlKTtcbiAgfVxuICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoeyBzb3VyY2U6IHRleHR1cmVTb3VyY2VGcm9tKG9wdHMpIH0pO1xuICB0ZXh0dXJlLm9uKFwiZGVzdHJveVwiLCAoKSA9PiB7XG4gICAgaWYgKENhY2hlLmhhcyhyZXNvdXJjZSkpIHtcbiAgICAgIENhY2hlLnJlbW92ZShyZXNvdXJjZSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFza2lwQ2FjaGUpIHtcbiAgICBDYWNoZS5zZXQocmVzb3VyY2UsIHRleHR1cmUpO1xuICB9XG4gIHJldHVybiB0ZXh0dXJlO1xufVxuZnVuY3Rpb24gdGV4dHVyZUZyb20oaWQsIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gQ2FjaGUuZ2V0KGlkKTtcbiAgfSBlbHNlIGlmIChpZCBpbnN0YW5jZW9mIFRleHR1cmVTb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoeyBzb3VyY2U6IGlkIH0pO1xuICB9XG4gIHJldHVybiByZXNvdXJjZVRvVGV4dHVyZShpZCwgc2tpcENhY2hlKTtcbn1cblRleHR1cmUuZnJvbSA9IHRleHR1cmVGcm9tO1xuVGV4dHVyZVNvdXJjZS5mcm9tID0gdGV4dHVyZVNvdXJjZUZyb207XG5cbmV4cG9ydCB7IGF1dG9EZXRlY3RTb3VyY2UsIHJlc291cmNlVG9UZXh0dXJlLCB0ZXh0dXJlRnJvbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZUZyb20ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4325\n')},5765:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ RendererType)\n/* harmony export */ });\n\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";\n  RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";\n  RendererType2[RendererType2["BOTH"] = 3] = "BOTH";\n  return RendererType2;\n})(RendererType || {});\n\n\n//# sourceMappingURL=types.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc2NS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFRztBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcz84NzQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIFJlbmRlcmVyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlbmRlcmVyVHlwZTIpID0+IHtcbiAgUmVuZGVyZXJUeXBlMltSZW5kZXJlclR5cGUyW1wiV0VCR0xcIl0gPSAxXSA9IFwiV0VCR0xcIjtcbiAgUmVuZGVyZXJUeXBlMltSZW5kZXJlclR5cGUyW1wiV0VCR1BVXCJdID0gMl0gPSBcIldFQkdQVVwiO1xuICBSZW5kZXJlclR5cGUyW1JlbmRlcmVyVHlwZTJbXCJCT1RIXCJdID0gM10gPSBcIkJPVEhcIjtcbiAgcmV0dXJuIFJlbmRlcmVyVHlwZTI7XG59KShSZW5kZXJlclR5cGUgfHwge30pO1xuXG5leHBvcnQgeyBSZW5kZXJlclR5cGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5765\n')},8400:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  W2: () => (/* binding */ Container),\n  pA: () => (/* binding */ UPDATE_BLEND),\n  wO: () => (/* binding */ UPDATE_COLOR),\n  Jm: () => (/* binding */ UPDATE_VISIBLE)\n});\n\n// UNUSED EXPORTS: UPDATE_TRANSFORM\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/culling/cullingMixin.mjs\n\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\n\n//# sourceMappingURL=cullingMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/const.mjs\nvar misc_const = __webpack_require__(5502);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs\nvar ObservablePoint = __webpack_require__(4973);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/removeItems.mjs\nvar removeItems = __webpack_require__(7040);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs\n\n\n\n"use strict";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        removed.push(child);\n        child.parent = null;\n      }\n      (0,removeItems/* removeItems */.E)(this.children, beginIndex, end);\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.removeChildren(removed);\n      }\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit("childRemoved", removed[i], this, i);\n        removed[i].emit("removed", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error("The supplied Container must be a child of the caller");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "addChildAt: Only Containers will be allowed to add children in v8.0.0");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit("childAdded", child, this, index);\n    child.emit("added", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._didContainerChangeTick++;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  },\n  /**\n   * Reparent the child to this container, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @returns The first child that was reparented.\n   * @memberof scene.Container#\n   */\n  reparentChild(...child) {\n    if (child.length === 1) {\n      return this.reparentChildAt(child[0], this.children.length);\n    }\n    child.forEach((c) => this.reparentChildAt(c, this.children.length));\n    return child[0];\n  },\n  /**\n   * Reparent the child to this container at the specified index, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @param index - The index to reparent the child to\n   * @memberof scene.Container#\n   */\n  reparentChildAt(child, index) {\n    if (child.parent === this) {\n      this.setChildIndex(child, index);\n      return child;\n    }\n    const childMat = child.worldTransform.clone();\n    child.removeFromParent();\n    this.addChildAt(child, index);\n    const newMatrix = this.worldTransform.clone();\n    newMatrix.invert();\n    childMat.prepend(newMatrix);\n    child.setFromMatrix(childMat);\n    return child;\n  }\n};\n\n\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/filters/FilterEffect.mjs\nvar FilterEffect = __webpack_require__(6282);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs\n\n\n\n"use strict";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return PoolGroup/* BigPool */.u.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    PoolGroup/* BigPool */.u.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nExtensions/* extensions */.Rw.handleByList(Extensions/* ExtensionType */.nw.MaskEffect, MaskEffectManager._effectClasses);\n\n\n//# sourceMappingURL=MaskEffectManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs\n\n\n\n"use strict";\nconst effectsMixin = {\n  _maskEffect: null,\n  _filterEffect: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    const effect = this._maskEffect;\n    if (effect?.mask === value)\n      return;\n    if (effect) {\n      this.removeEffect(effect);\n      MaskEffectManager.returnMaskEffect(effect);\n      this._maskEffect = null;\n    }\n    if (value === null || value === void 0)\n      return;\n    this._maskEffect = MaskEffectManager.getMaskEffect(value);\n    this.addEffect(this._maskEffect);\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container\'s width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from \'pixi.js\';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._maskEffect?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    const effect = this._filterEffect || (this._filterEffect = new FilterEffect/* FilterEffect */.U());\n    value = value;\n    const hasFilters = value?.length > 0;\n    const hadFilters = effect.filters?.length > 0;\n    const didChange = hasFilters !== hadFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    effect.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        this.addEffect(effect);\n      } else {\n        this.removeEffect(effect);\n        effect.filters = value ?? null;\n      }\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `\'null\'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filterEffect?.filters;\n  },\n  set filterArea(value) {\n    this._filterEffect || (this._filterEffect = new FilterEffect/* FilterEffect */.U());\n    this._filterEffect.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filterEffect?.filterArea;\n  }\n};\n\n\n//# sourceMappingURL=effectsMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs\n\n\n"use strict";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Container.name property has been removed, use Container.label instead");\n    return this.label;\n  },\n  set name(value) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Container.name property has been removed, use Container.label instead");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\n\n//# sourceMappingURL=findMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(5128);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(3197);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs\n\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const uid = child.uid;\n    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;\n    const index = previousData.index;\n    if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {\n      previousData.data[previousData.index] = uid;\n      previousData.data[previousData.index + 1] = didChange;\n      previousData.didChange = true;\n    }\n    previousData.index = index + 2;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\n\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs\n\n\n\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds/* Bounds */.Y()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didViewChangeTick;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      (0,getLocalBounds/* getLocalBounds */.a)(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return (0,getGlobalBounds/* getGlobalBounds */.qW)(this, skipUpdate, bounds || new Bounds/* Bounds */.Y());\n  }\n};\n\n\n//# sourceMappingURL=measureMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs\n\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and "updateTransform" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\n\n//# sourceMappingURL=onRenderMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs\n\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child\'s zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\n\n//# sourceMappingURL=sortMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs\n\n\n\n\n"use strict";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point/* Point */.E(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = (0,getGlobalBounds/* updateTransformBackwards */.I_)(this, new Matrix/* Matrix */.y());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.apply(position, point);\n    }\n    return this.worldTransform.apply(position, point);\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = (0,getGlobalBounds/* updateTransformBackwards */.I_)(this, new Matrix/* Matrix */.y());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.applyInverse(position, point);\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n};\n\n\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(1854);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs\n\n\n\n"use strict";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = "renderGroup";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix/* Matrix */.y();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet/* InstructionSet */.h();\n    this._onRenderContainers = [];\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender)\n      this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender)\n      this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7)\n      return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined \'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n  destroy() {\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup)\n      return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n}\n\n\n//# sourceMappingURL=RenderGroup.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs\n\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\n\n//# sourceMappingURL=assignWithIgnore.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst defaultSkew = new ObservablePoint/* ObservablePoint */.A(null);\nconst defaultPivot = new ObservablePoint/* ObservablePoint */.A(null);\nconst defaultScale = new ObservablePoint/* ObservablePoint */.A(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends eventemitter3/* default */.Z {\n  constructor(options = {}) {\n    super();\n    /** unique id for this container */\n    this.uid = (0,uid/* uid */.h)("renderable");\n    /** @private */\n    this._updateFlags = 15;\n    // the render group this container owns\n    /** @private */\n    this.renderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    this.parentRenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    this.parentRenderGroupIndex = 0;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix/* Matrix */.y();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix/* Matrix */.y();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = "inherit";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = "normal";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    this._didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    this._didViewChangeTick = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    this.effects = [];\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n   * @deprecated since 8.2.6\n   * @ignore\n   */\n  set _didChangeId(value) {\n    this._didViewChangeTick = value >> 12 & 4095;\n    this._didContainerChangeTick = value & 4095;\n  }\n  get _didChangeId() {\n    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "addChild: Only Containers will be allowed to add children in v8.0.0");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (this.parentRenderGroup) {\n        this.parentRenderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    this.emit("childAdded", child, this, this.children.length - 1);\n    child.emit("added", this);\n    this._didViewChangeTick++;\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this._didViewChangeTick++;\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      } else if (this.parentRenderGroup) {\n        this.parentRenderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit("childRemoved", child, this, index);\n      child.emit("removed", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didContainerChangeTick++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (!!this.renderGroup === value)\n      return;\n    if (value) {\n      this.enableRenderGroup();\n    } else {\n      this.disableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return !!this.renderGroup;\n  }\n  /**\n   * Calling this enables a render group for this container.\n   * This means it will be rendered as a separate set of instructions.\n   * The transform of the container will also be handled on the GPU rather than the CPU.\n   */\n  enableRenderGroup() {\n    if (this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    this.renderGroup = PoolGroup/* BigPool */.u.get(RenderGroup, this);\n    this.groupTransform = Matrix/* Matrix */.y.IDENTITY;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** This will disable the render group for this container. */\n  disableRenderGroup() {\n    if (!this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    PoolGroup/* BigPool */.u.return(this.renderGroup);\n    this.renderGroup = null;\n    this.groupTransform = this.relativeGroupTransform;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.renderGroup && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix/* Matrix */.y());\n    if (this.renderGroup) {\n      this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n    } else if (this.parentRenderGroup) {\n      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n    }\n    return this._worldTransform;\n  }\n  // / ////// transform related stuff\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * misc_const/* RAD_TO_DEG */.jl;\n  }\n  set angle(value) {\n    this.rotation = value * misc_const/* DEG_TO_RAD */.ZX;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent\'s local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint/* ObservablePoint */.A(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    if (typeof value === "object") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, size.width);\n    height !== void 0 && this._setHeight(height, size.height);\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === "number" ? opts.x : this.position.x,\n      typeof opts.y === "number" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === "number" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === "number" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    const localTransformChangeId = this._didContainerChangeTick;\n    if (this._didLocalTransformChangeId === localTransformChangeId)\n      return;\n    this._didLocalTransformChangeId = localTransformChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color/* Color */.I.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    const bgr = this.localColor;\n    return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `\'normal\'` to reset the blend mode.\n   * @default \'normal\'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 2 : 0;\n    if ((this.localDisplayStatus & 2) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 0 : 4;\n    if ((this.localDisplayStatus & 4) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    this.removeFromParent();\n    this.parent = null;\n    this._maskEffect = null;\n    this._filterEffect = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit("destroyed", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === "boolean" ? options : options?.children;\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n    this.renderGroup?.destroy();\n    this.renderGroup = null;\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n\n\n//# sourceMappingURL=Container.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0NBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtDQUFXLENBQUMseUJBQU07QUFDeEI7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUFPLEtBQUssV0FBVztBQUM5QywwQkFBMEIsb0JBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQU07QUFDOUQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLDJCQUEyQiw2QkFBVTtBQUNyQztBQUNBO0FBQ0EsNEJBQTRCLDZCQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixZQUFZOztBQUV1RDtBQUNuRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9jdWxsaW5nL2N1bGxpbmdNaXhpbi5tanM/MGM2YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvY2hpbGRyZW5IZWxwZXJNaXhpbi5tanM/MzJiZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svTWFza0VmZmVjdE1hbmFnZXIubWpzP2Q1Y2IiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL2VmZmVjdHNNaXhpbi5tanM/OGE5MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvZmluZE1peGluLm1qcz8xNjM4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvY2hlY2tDaGlsZHJlbkRpZENoYW5nZS5tanM/ZmI1YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvbWVhc3VyZU1peGluLm1qcz8xOWZlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9vblJlbmRlck1peGluLm1qcz9lMjJmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9zb3J0TWl4aW4ubWpzPzhiNTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL3RvTG9jYWxHbG9iYWxNaXhpbi5tanM/Nzk0MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwLm1qcz9hN2QzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvYXNzaWduV2l0aElnbm9yZS5tanM/ZWI5NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanM/N2MzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGN1bGxpbmdNaXhpbiA9IHtcbiAgY3VsbEFyZWE6IG51bGwsXG4gIGN1bGxhYmxlOiBmYWxzZSxcbiAgY3VsbGFibGVDaGlsZHJlbjogdHJ1ZVxufTtcblxuZXhwb3J0IHsgY3VsbGluZ01peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdWxsaW5nTWl4aW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgcmVtb3ZlSXRlbXMgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL3JlbW92ZUl0ZW1zLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNoaWxkcmVuSGVscGVyTWl4aW4gPSB7XG4gIGFsbG93Q2hpbGRyZW46IHRydWUsXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgY29udGFpbmVyIHRoYXQgYXJlIHdpdGhpbiB0aGUgYmVnaW4gYW5kIGVuZCBpbmRleGVzLlxuICAgKiBAcGFyYW0gYmVnaW5JbmRleCAtIFRoZSBiZWdpbm5pbmcgcG9zaXRpb24uXG4gICAqIEBwYXJhbSBlbmRJbmRleCAtIFRoZSBlbmRpbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJucyAtIExpc3Qgb2YgcmVtb3ZlZCBjaGlsZHJlblxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgcmVtb3ZlQ2hpbGRyZW4oYmVnaW5JbmRleCA9IDAsIGVuZEluZGV4KSB7XG4gICAgY29uc3QgZW5kID0gZW5kSW5kZXggPz8gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgY29uc3QgcmFuZ2UgPSBlbmQgLSBiZWdpbkluZGV4O1xuICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZCkge1xuICAgICAgZm9yIChsZXQgaSA9IGVuZCAtIDE7IGkgPj0gYmVnaW5JbmRleDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGJlZ2luSW5kZXgsIGVuZCk7XG4gICAgICBjb25zdCByZW5kZXJHcm91cCA9IHRoaXMucmVuZGVyR3JvdXAgfHwgdGhpcy5wYXJlbnRSZW5kZXJHcm91cDtcbiAgICAgIGlmIChyZW5kZXJHcm91cCkge1xuICAgICAgICByZW5kZXJHcm91cC5yZW1vdmVDaGlsZHJlbihyZW1vdmVkKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGlsZFJlbW92ZWRcIiwgcmVtb3ZlZFtpXSwgdGhpcywgaSk7XG4gICAgICAgIHJlbW92ZWRbaV0uZW1pdChcInJlbW92ZWRcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJyZW1vdmVDaGlsZHJlbjogbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UuXCIpO1xuICB9LFxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNoaWxkIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxuICAgKiBAcmV0dXJucyBUaGUgY2hpbGQgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHJlbW92ZUNoaWxkQXQoaW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChpbmRleCk7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBhdFxuICAgKiBAcmV0dXJucyAtIFRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGFueS5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldENoaWxkQXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldENoaWxkQXQ6IEluZGV4ICgke2luZGV4fSkgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbiAgfSxcbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGFuIGV4aXN0aW5nIGNoaWxkIGluIHRoZSBjb250YWluZXIgY29udGFpbmVyXG4gICAqIEBwYXJhbSBjaGlsZCAtIFRoZSBjaGlsZCBDb250YWluZXIgaW5zdGFuY2UgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSByZXN1bHRpbmcgaW5kZXggbnVtYmVyIGZvciB0aGUgY2hpbGQgY29udGFpbmVyXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBzZXRDaGlsZEluZGV4KGNoaWxkLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGluZGV4ICR7aW5kZXh9IHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJHt0aGlzLmNoaWxkcmVuLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICB0aGlzLmFkZENoaWxkQXQoY2hpbGQsIGluZGV4KTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IHBvc2l0aW9uIG9mIGEgY2hpbGQgQ29udGFpbmVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSBjaGlsZCAtIFRoZSBDb250YWluZXIgaW5zdGFuY2UgdG8gaWRlbnRpZnlcbiAgICogQHJldHVybnMgLSBUaGUgaW5kZXggcG9zaXRpb24gb2YgdGhlIGNoaWxkIGNvbnRhaW5lciB0byBpZGVudGlmeVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0Q2hpbGRJbmRleChjaGlsZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3VwcGxpZWQgQ29udGFpbmVyIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgY2FsbGVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH0sXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGNvbnRhaW5lciBhdCBhIHNwZWNpZmllZCBpbmRleC4gSWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqIElmIHRoZSBjaGlsZCBpcyBhbHJlYWR5IGluIHRoaXMgY29udGFpbmVyLCBpdCB3aWxsIGJlIG1vdmVkIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7Q29udGFpbmVyfSBjaGlsZCAtIFRoZSBjaGlsZCB0byBhZGQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBhYnNvbHV0ZSBpbmRleCB3aGVyZSB0aGUgY2hpbGQgd2lsbCBiZSBwb3NpdGlvbmVkIGF0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMge0NvbnRhaW5lcn0gVGhlIGNoaWxkIHRoYXQgd2FzIGFkZGVkLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuYWxsb3dDaGlsZHJlbikge1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcImFkZENoaWxkQXQ6IE9ubHkgQ29udGFpbmVycyB3aWxsIGJlIGFsbG93ZWQgdG8gYWRkIGNoaWxkcmVuIGluIHY4LjAuMFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2hpbGR9YWRkQ2hpbGRBdDogVGhlIGluZGV4ICR7aW5kZXh9IHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJHtjaGlsZHJlbi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGNoaWxkLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMgJiYgY3VycmVudEluZGV4ID09PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEluZGV4ICE9PSAtMSkge1xuICAgICAgICBjaGlsZC5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGN1cnJlbnRJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRleCA9PT0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG4gICAgfVxuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgY2hpbGQuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICBjaGlsZC5kaWRWaWV3VXBkYXRlID0gZmFsc2U7XG4gICAgY2hpbGQuX3VwZGF0ZUZsYWdzID0gMTU7XG4gICAgY29uc3QgcmVuZGVyR3JvdXAgPSB0aGlzLnJlbmRlckdyb3VwIHx8IHRoaXMucGFyZW50UmVuZGVyR3JvdXA7XG4gICAgaWYgKHJlbmRlckdyb3VwKSB7XG4gICAgICByZW5kZXJHcm91cC5hZGRDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNvcnRhYmxlQ2hpbGRyZW4pXG4gICAgICB0aGlzLnNvcnREaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFwiY2hpbGRBZGRlZFwiLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0sXG4gIC8qKlxuICAgKiBTd2FwcyB0aGUgcG9zaXRpb24gb2YgMiBDb250YWluZXJzIHdpdGhpbiB0aGlzIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIGNoaWxkIC0gRmlyc3QgY29udGFpbmVyIHRvIHN3YXBcbiAgICogQHBhcmFtIGNoaWxkMiAtIFNlY29uZCBjb250YWluZXIgdG8gc3dhcFxuICAgKi9cbiAgc3dhcENoaWxkcmVuKGNoaWxkLCBjaGlsZDIpIHtcbiAgICBpZiAoY2hpbGQgPT09IGNoaWxkMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleDEgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIGNvbnN0IGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4Ml0gPSBjaGlsZDtcbiAgICBjb25zdCByZW5kZXJHcm91cCA9IHRoaXMucmVuZGVyR3JvdXAgfHwgdGhpcy5wYXJlbnRSZW5kZXJHcm91cDtcbiAgICBpZiAocmVuZGVyR3JvdXApIHtcbiAgICAgIHJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2RpZENvbnRhaW5lckNoYW5nZVRpY2srKztcbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgQ29udGFpbmVyIGZyb20gaXRzIHBhcmVudCBDb250YWluZXIuIElmIHRoZSBDb250YWluZXIgaGFzIG5vIHBhcmVudCwgZG8gbm90aGluZy5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHJlbW92ZUZyb21QYXJlbnQoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9LFxuICAvKipcbiAgICogUmVwYXJlbnQgdGhlIGNoaWxkIHRvIHRoaXMgY29udGFpbmVyLCBrZWVwaW5nIHRoZSBzYW1lIHdvcmxkVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gcmVwYXJlbnRcbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIHJlcGFyZW50ZWQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICByZXBhcmVudENoaWxkKC4uLmNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwYXJlbnRDaGlsZEF0KGNoaWxkWzBdLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIGNoaWxkLmZvckVhY2goKGMpID0+IHRoaXMucmVwYXJlbnRDaGlsZEF0KGMsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSk7XG4gICAgcmV0dXJuIGNoaWxkWzBdO1xuICB9LFxuICAvKipcbiAgICogUmVwYXJlbnQgdGhlIGNoaWxkIHRvIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXgsIGtlZXBpbmcgdGhlIHNhbWUgd29ybGRUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSBjaGlsZCAtIFRoZSBjaGlsZCB0byByZXBhcmVudFxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdG8gcmVwYXJlbnQgdGhlIGNoaWxkIHRvXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICByZXBhcmVudENoaWxkQXQoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy5zZXRDaGlsZEluZGV4KGNoaWxkLCBpbmRleCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkTWF0ID0gY2hpbGQud29ybGRUcmFuc2Zvcm0uY2xvbmUoKTtcbiAgICBjaGlsZC5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgdGhpcy5hZGRDaGlsZEF0KGNoaWxkLCBpbmRleCk7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gdGhpcy53b3JsZFRyYW5zZm9ybS5jbG9uZSgpO1xuICAgIG5ld01hdHJpeC5pbnZlcnQoKTtcbiAgICBjaGlsZE1hdC5wcmVwZW5kKG5ld01hdHJpeCk7XG4gICAgY2hpbGQuc2V0RnJvbU1hdHJpeChjaGlsZE1hdCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG59O1xuXG5leHBvcnQgeyBjaGlsZHJlbkhlbHBlck1peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZHJlbkhlbHBlck1peGluLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE1hc2tFZmZlY3RNYW5hZ2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2VmZmVjdENsYXNzZXMgPSBbXTtcbiAgICB0aGlzLl90ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2VmZmVjdENsYXNzZXMuZm9yRWFjaCgodGVzdCkgPT4ge1xuICAgICAgdGhpcy5hZGQoe1xuICAgICAgICB0ZXN0OiB0ZXN0LnRlc3QsXG4gICAgICAgIG1hc2tDbGFzczogdGVzdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkKHRlc3QpIHtcbiAgICB0aGlzLl90ZXN0cy5wdXNoKHRlc3QpO1xuICB9XG4gIGdldE1hc2tFZmZlY3QoaXRlbSkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3Rlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXN0ID0gdGhpcy5fdGVzdHNbaV07XG4gICAgICBpZiAodGVzdC50ZXN0KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBCaWdQb29sLmdldCh0ZXN0Lm1hc2tDbGFzcywgaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIHJldHVybk1hc2tFZmZlY3QoZWZmZWN0KSB7XG4gICAgQmlnUG9vbC5yZXR1cm4oZWZmZWN0KTtcbiAgfVxufVxuY29uc3QgTWFza0VmZmVjdE1hbmFnZXIgPSBuZXcgTWFza0VmZmVjdE1hbmFnZXJDbGFzcygpO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeUxpc3QoRXh0ZW5zaW9uVHlwZS5NYXNrRWZmZWN0LCBNYXNrRWZmZWN0TWFuYWdlci5fZWZmZWN0Q2xhc3Nlcyk7XG5cbmV4cG9ydCB7IE1hc2tFZmZlY3RNYW5hZ2VyLCBNYXNrRWZmZWN0TWFuYWdlckNsYXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXNrRWZmZWN0TWFuYWdlci5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXJFZmZlY3QgfSBmcm9tICcuLi8uLi8uLi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanMnO1xuaW1wb3J0IHsgTWFza0VmZmVjdE1hbmFnZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvbWFzay9NYXNrRWZmZWN0TWFuYWdlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGVmZmVjdHNNaXhpbiA9IHtcbiAgX21hc2tFZmZlY3Q6IG51bGwsXG4gIF9maWx0ZXJFZmZlY3Q6IG51bGwsXG4gIC8qKlxuICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAdHlwZSB7QXJyYXk8RWZmZWN0Pn1cbiAgICovXG4gIGVmZmVjdHM6IFtdLFxuICAvKipcbiAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICogQHBhcmFtIGVmZmVjdCAtIFRoZSBlZmZlY3QgdG8gYWRkLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAaWdub3JlXG4gICAqL1xuICBhZGRFZmZlY3QoZWZmZWN0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB0aGlzLmVmZmVjdHMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgIGNvbnN0IHJlbmRlckdyb3VwID0gdGhpcy5yZW5kZXJHcm91cCB8fCB0aGlzLnBhcmVudFJlbmRlckdyb3VwO1xuICAgIGlmIChyZW5kZXJHcm91cCkge1xuICAgICAgcmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlSXNTaW1wbGUoKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAqIEBwYXJhbSBlZmZlY3QgLSBUaGUgZWZmZWN0IHRvIHJlbW92ZS5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgcmVtb3ZlRWZmZWN0KGVmZmVjdCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5lZmZlY3RzLmluZGV4T2YoZWZmZWN0KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZWZmZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGlmICh0aGlzLnBhcmVudFJlbmRlckdyb3VwKSB7XG4gICAgICB0aGlzLnBhcmVudFJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUlzU2ltcGxlKCk7XG4gIH0sXG4gIHNldCBtYXNrKHZhbHVlKSB7XG4gICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fbWFza0VmZmVjdDtcbiAgICBpZiAoZWZmZWN0Py5tYXNrID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZWZmZWN0KSB7XG4gICAgICB0aGlzLnJlbW92ZUVmZmVjdChlZmZlY3QpO1xuICAgICAgTWFza0VmZmVjdE1hbmFnZXIucmV0dXJuTWFza0VmZmVjdChlZmZlY3QpO1xuICAgICAgdGhpcy5fbWFza0VmZmVjdCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX21hc2tFZmZlY3QgPSBNYXNrRWZmZWN0TWFuYWdlci5nZXRNYXNrRWZmZWN0KHZhbHVlKTtcbiAgICB0aGlzLmFkZEVmZmVjdCh0aGlzLl9tYXNrRWZmZWN0KTtcbiAgfSxcbiAgLyoqXG4gICAqIFNldHMgYSBtYXNrIGZvciB0aGUgZGlzcGxheU9iamVjdC4gQSBtYXNrIGlzIGFuIG9iamVjdCB0aGF0IGxpbWl0cyB0aGUgdmlzaWJpbGl0eSBvZiBhblxuICAgKiBvYmplY3QgdG8gdGhlIHNoYXBlIG9mIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXQuIEluIFBpeGlKUyBhIHJlZ3VsYXIgbWFzayBtdXN0IGJlIGFcbiAgICoge0BsaW5rIEdyYXBoaWNzfSBvciBhIHtAbGluayBTcHJpdGV9IG9iamVjdC4gVGhpcyBhbGxvd3MgZm9yIG11Y2ggZmFzdGVyIG1hc2tpbmcgaW4gY2FudmFzIGFzIGl0XG4gICAqIHV0aWxpdGllcyBzaGFwZSBjbGlwcGluZy4gRnVydGhlcm1vcmUsIGEgbWFzayBvZiBhbiBvYmplY3QgbXVzdCBiZSBpbiB0aGUgc3VidHJlZSBvZiBpdHMgcGFyZW50LlxuICAgKiBPdGhlcndpc2UsIGBnZXRMb2NhbEJvdW5kc2AgbWF5IGNhbGN1bGF0ZSBpbmNvcnJlY3QgYm91bmRzLCB3aGljaCBtYWtlcyB0aGUgY29udGFpbmVyJ3Mgd2lkdGggYW5kIGhlaWdodCB3cm9uZy5cbiAgICogVG8gcmVtb3ZlIGEgbWFzaywgc2V0IHRoaXMgcHJvcGVydHkgdG8gYG51bGxgLlxuICAgKlxuICAgKiBGb3Igc3ByaXRlIG1hc2sgYm90aCBhbHBoYSBhbmQgcmVkIGNoYW5uZWwgYXJlIHVzZWQuIEJsYWNrIG1hc2sgaXMgdGhlIHNhbWUgYXMgdHJhbnNwYXJlbnQgbWFzay5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgR3JhcGhpY3MsIFNwcml0ZSB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBjb25zdCBncmFwaGljcyA9IG5ldyBHcmFwaGljcygpO1xuICAgKiBncmFwaGljcy5iZWdpbkZpbGwoMHhGRjMzMDApO1xuICAgKiBncmFwaGljcy5kcmF3UmVjdCg1MCwgMjUwLCAxMDAsIDEwMCk7XG4gICAqIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICpcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgICogc3ByaXRlLm1hc2sgPSBncmFwaGljcztcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXNrRWZmZWN0Py5tYXNrO1xuICB9LFxuICBzZXQgZmlsdGVycyh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUpXG4gICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZmlsdGVyRWZmZWN0IHx8ICh0aGlzLl9maWx0ZXJFZmZlY3QgPSBuZXcgRmlsdGVyRWZmZWN0KCkpO1xuICAgIHZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgaGFzRmlsdGVycyA9IHZhbHVlPy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGhhZEZpbHRlcnMgPSBlZmZlY3QuZmlsdGVycz8ubGVuZ3RoID4gMDtcbiAgICBjb25zdCBkaWRDaGFuZ2UgPSBoYXNGaWx0ZXJzICE9PSBoYWRGaWx0ZXJzO1xuICAgIHZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgwKSA6IHZhbHVlO1xuICAgIGVmZmVjdC5maWx0ZXJzID0gT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgaWYgKGhhc0ZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QoZWZmZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRWZmZWN0KGVmZmVjdCk7XG4gICAgICAgIGVmZmVjdC5maWx0ZXJzID0gdmFsdWUgPz8gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWx0ZXJzIGZvciB0aGUgZGlzcGxheU9iamVjdC5cbiAgICogSU1QT1JUQU5UOiBUaGlzIGlzIGEgV2ViR0wgb25seSBmZWF0dXJlIGFuZCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICogVG8gcmVtb3ZlIGZpbHRlcnMgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvIGAnbnVsbCdgLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IGZpbHRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlckVmZmVjdD8uZmlsdGVycztcbiAgfSxcbiAgc2V0IGZpbHRlckFyZWEodmFsdWUpIHtcbiAgICB0aGlzLl9maWx0ZXJFZmZlY3QgfHwgKHRoaXMuX2ZpbHRlckVmZmVjdCA9IG5ldyBGaWx0ZXJFZmZlY3QoKSk7XG4gICAgdGhpcy5fZmlsdGVyRWZmZWN0LmZpbHRlckFyZWEgPSB2YWx1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0by4gVGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pemF0aW9uXG4gICAqIHJhdGhlciB0aGFuIGZpZ3VyaW5nIG91dCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZGlzcGxheU9iamVjdCBlYWNoIGZyYW1lIHlvdSBjYW4gc2V0IHRoaXMgcmVjdGFuZ2xlLlxuICAgKlxuICAgKiBBbHNvIHdvcmtzIGFzIGFuIGludGVyYWN0aW9uIG1hc2suXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXQgZmlsdGVyQXJlYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVyRWZmZWN0Py5maWx0ZXJBcmVhO1xuICB9XG59O1xuXG5leHBvcnQgeyBlZmZlY3RzTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVmZmVjdHNNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGZpbmRNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBsYWJlbCBvZiB0aGUgb2JqZWN0LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9IGxhYmVsXG4gICAqL1xuICBsYWJlbDogbnVsbCxcbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBuYW1lIG9mIHRoZSBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wXG4gICAqIEBzZWUgc2NlbmUuQ29udGFpbmVyI2xhYmVsXG4gICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkNvbnRhaW5lci5uYW1lIHByb3BlcnR5IGhhcyBiZWVuIHJlbW92ZWQsIHVzZSBDb250YWluZXIubGFiZWwgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gdGhpcy5sYWJlbDtcbiAgfSxcbiAgc2V0IG5hbWUodmFsdWUpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQ29udGFpbmVyLm5hbWUgcHJvcGVydHkgaGFzIGJlZW4gcmVtb3ZlZCwgdXNlIENvbnRhaW5lci5sYWJlbCBpbnN0ZWFkXCIpO1xuICAgIHRoaXMubGFiZWwgPSB2YWx1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0Q2hpbGRCeU5hbWVcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBJbnN0YW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59W2RlZXA9ZmFsc2VdIC0gV2hldGhlciB0byBzZWFyY2ggcmVjdXJzaXZlbHlcbiAgICogQHJldHVybnMge0NvbnRhaW5lcn0gVGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgKiBAc2VlIHNjZW5lLkNvbnRhaW5lciNnZXRDaGlsZEJ5TGFiZWxcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldENoaWxkQnlOYW1lKG5hbWUsIGRlZXAgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkQnlMYWJlbChuYW1lLCBkZWVwKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIHRoZSBjb250YWluZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGxhYmVsLlxuICAgKlxuICAgKiBSZWN1cnNpdmUgc2VhcmNoZXMgYXJlIGRvbmUgaW4gYSBwcmUtb3JkZXIgdHJhdmVyc2FsLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IGxhYmVsIC0gSW5zdGFuY2UgbGFiZWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn1bZGVlcD1mYWxzZV0gLSBXaGV0aGVyIHRvIHNlYXJjaCByZWN1cnNpdmVseVxuICAgKiBAcmV0dXJucyB7Q29udGFpbmVyfSBUaGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIGxhYmVsLlxuICAgKi9cbiAgZ2V0Q2hpbGRCeUxhYmVsKGxhYmVsLCBkZWVwID0gZmFsc2UpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC5sYWJlbCA9PT0gbGFiZWwgfHwgbGFiZWwgaW5zdGFuY2VvZiBSZWdFeHAgJiYgbGFiZWwudGVzdChjaGlsZC5sYWJlbCkpXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgZm91bmQgPSBjaGlsZC5nZXRDaGlsZEJ5TGFiZWwobGFiZWwsIHRydWUpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29udGFpbmVyIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBsYWJlbCAtIEluc3RhbmNlIGxhYmVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59W2RlZXA9ZmFsc2VdIC0gV2hldGhlciB0byBzZWFyY2ggcmVjdXJzaXZlbHlcbiAgICogQHBhcmFtIHtDb250YWluZXJbXX0gW291dD1bXV0gLSBUaGUgYXJyYXkgdG8gc3RvcmUgbWF0Y2hpbmcgY2hpbGRyZW4gaW4uXG4gICAqIEByZXR1cm5zIHtDb250YWluZXJbXX0gQW4gYXJyYXkgb2YgY2hpbGRyZW4gd2l0aCB0aGUgc3BlY2lmaWVkIGxhYmVsLlxuICAgKi9cbiAgZ2V0Q2hpbGRyZW5CeUxhYmVsKGxhYmVsLCBkZWVwID0gZmFsc2UsIG91dCA9IFtdKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQubGFiZWwgPT09IGxhYmVsIHx8IGxhYmVsIGluc3RhbmNlb2YgUmVnRXhwICYmIGxhYmVsLnRlc3QoY2hpbGQubGFiZWwpKSB7XG4gICAgICAgIG91dC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRyZW5baV0uZ2V0Q2hpbGRyZW5CeUxhYmVsKGxhYmVsLCB0cnVlLCBvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xuXG5leHBvcnQgeyBmaW5kTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmRNaXhpbi5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UoY29udGFpbmVyLCBwcmV2aW91c0RhdGEpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHVpZCA9IGNoaWxkLnVpZDtcbiAgICBjb25zdCBkaWRDaGFuZ2UgPSAoY2hpbGQuX2RpZFZpZXdDaGFuZ2VUaWNrICYgNjU1MzUpIDw8IDE2IHwgY2hpbGQuX2RpZENvbnRhaW5lckNoYW5nZVRpY2sgJiA2NTUzNTtcbiAgICBjb25zdCBpbmRleCA9IHByZXZpb3VzRGF0YS5pbmRleDtcbiAgICBpZiAocHJldmlvdXNEYXRhLmRhdGFbaW5kZXhdICE9PSB1aWQgfHwgcHJldmlvdXNEYXRhLmRhdGFbaW5kZXggKyAxXSAhPT0gZGlkQ2hhbmdlKSB7XG4gICAgICBwcmV2aW91c0RhdGEuZGF0YVtwcmV2aW91c0RhdGEuaW5kZXhdID0gdWlkO1xuICAgICAgcHJldmlvdXNEYXRhLmRhdGFbcHJldmlvdXNEYXRhLmluZGV4ICsgMV0gPSBkaWRDaGFuZ2U7XG4gICAgICBwcmV2aW91c0RhdGEuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJldmlvdXNEYXRhLmluZGV4ID0gaW5kZXggKyAyO1xuICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UoY2hpbGQsIHByZXZpb3VzRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcmV2aW91c0RhdGEuZGlkQ2hhbmdlO1xufVxuXG5leHBvcnQgeyBjaGVja0NoaWxkcmVuRGlkQ2hhbmdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja0NoaWxkcmVuRGlkQ2hhbmdlLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uL2JvdW5kcy9Cb3VuZHMubWpzJztcbmltcG9ydCB7IGdldEdsb2JhbEJvdW5kcyB9IGZyb20gJy4uL2JvdW5kcy9nZXRHbG9iYWxCb3VuZHMubWpzJztcbmltcG9ydCB7IGdldExvY2FsQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzL2dldExvY2FsQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBjaGVja0NoaWxkcmVuRGlkQ2hhbmdlIH0gZnJvbSAnLi4vdXRpbHMvY2hlY2tDaGlsZHJlbkRpZENoYW5nZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jb25zdCBtZWFzdXJlTWl4aW4gPSB7XG4gIF9sb2NhbEJvdW5kc0NhY2hlSWQ6IC0xLFxuICBfbG9jYWxCb3VuZHNDYWNoZURhdGE6IG51bGwsXG4gIF9zZXRXaWR0aCh2YWx1ZSwgbG9jYWxXaWR0aCkge1xuICAgIGNvbnN0IHNpZ24gPSBNYXRoLnNpZ24odGhpcy5zY2FsZS54KSB8fCAxO1xuICAgIGlmIChsb2NhbFdpZHRoICE9PSAwKSB7XG4gICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIGxvY2FsV2lkdGggKiBzaWduO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnggPSBzaWduO1xuICAgIH1cbiAgfSxcbiAgX3NldEhlaWdodCh2YWx1ZSwgbG9jYWxIZWlnaHQpIHtcbiAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKHRoaXMuc2NhbGUueSkgfHwgMTtcbiAgICBpZiAobG9jYWxIZWlnaHQgIT09IDApIHtcbiAgICAgIHRoaXMuc2NhbGUueSA9IHZhbHVlIC8gbG9jYWxIZWlnaHQgKiBzaWduO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnkgPSBzaWduO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBjb250YWluZXIgYXMgYSBCb3VuZHMgb2JqZWN0LlxuICAgKiBAcmV0dXJucyAtIFRoZSBib3VuZGluZyBhcmVhLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMoKSB7XG4gICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc0NhY2hlRGF0YSkge1xuICAgICAgdGhpcy5fbG9jYWxCb3VuZHNDYWNoZURhdGEgPSB7XG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBpbmRleDogMSxcbiAgICAgICAgZGlkQ2hhbmdlOiBmYWxzZSxcbiAgICAgICAgbG9jYWxCb3VuZHM6IG5ldyBCb3VuZHMoKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxCb3VuZHNDYWNoZURhdGEgPSB0aGlzLl9sb2NhbEJvdW5kc0NhY2hlRGF0YTtcbiAgICBsb2NhbEJvdW5kc0NhY2hlRGF0YS5pbmRleCA9IDE7XG4gICAgbG9jYWxCb3VuZHNDYWNoZURhdGEuZGlkQ2hhbmdlID0gZmFsc2U7XG4gICAgaWYgKGxvY2FsQm91bmRzQ2FjaGVEYXRhLmRhdGFbMF0gIT09IHRoaXMuX2RpZFZpZXdDaGFuZ2VUaWNrKSB7XG4gICAgICBsb2NhbEJvdW5kc0NhY2hlRGF0YS5kaWRDaGFuZ2UgPSB0cnVlO1xuICAgICAgbG9jYWxCb3VuZHNDYWNoZURhdGEuZGF0YVswXSA9IHRoaXMuX2RpZFZpZXdDaGFuZ2VUaWNrO1xuICAgIH1cbiAgICBjaGVja0NoaWxkcmVuRGlkQ2hhbmdlKHRoaXMsIGxvY2FsQm91bmRzQ2FjaGVEYXRhKTtcbiAgICBpZiAobG9jYWxCb3VuZHNDYWNoZURhdGEuZGlkQ2hhbmdlKSB7XG4gICAgICBnZXRMb2NhbEJvdW5kcyh0aGlzLCBsb2NhbEJvdW5kc0NhY2hlRGF0YS5sb2NhbEJvdW5kcywgdGVtcE1hdHJpeCk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbEJvdW5kc0NhY2hlRGF0YS5sb2NhbEJvdW5kcztcbiAgfSxcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlICh3b3JsZCkgYm91bmRzIG9mIHRoZSBkaXNwbGF5IG9iamVjdCBhcyBhIFtSZWN0YW5nbGVde0BsaW5rIFJlY3RhbmdsZX0uXG4gICAqIEBwYXJhbSBza2lwVXBkYXRlIC0gU2V0dGluZyB0byBgdHJ1ZWAgd2lsbCBzdG9wIHRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBzY2VuZSBncmFwaCBmcm9tXG4gICAqICBiZWluZyB1cGRhdGVkLiBUaGlzIG1lYW5zIHRoZSBjYWxjdWxhdGlvbiByZXR1cm5lZCBNQVkgYmUgb3V0IG9mIGRhdGUgQlVUIHdpbGwgZ2l2ZSB5b3UgYVxuICAgKiAgbmljZSBwZXJmb3JtYW5jZSBib29zdC5cbiAgICogQHBhcmFtIGJvdW5kcyAtIE9wdGlvbmFsIGJvdW5kcyB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb24uXG4gICAqIEByZXR1cm5zIC0gVGhlIG1pbmltdW0gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZSBpbiB3b3JsZCBzcGFjZSB0aGF0IGZpdHMgYXJvdW5kIHRoaXMgb2JqZWN0LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0Qm91bmRzKHNraXBVcGRhdGUsIGJvdW5kcykge1xuICAgIHJldHVybiBnZXRHbG9iYWxCb3VuZHModGhpcywgc2tpcFVwZGF0ZSwgYm91bmRzIHx8IG5ldyBCb3VuZHMoKSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IG1lYXN1cmVNaXhpbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVhc3VyZU1peGluLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3Qgb25SZW5kZXJNaXhpbiA9IHtcbiAgX29uUmVuZGVyOiBudWxsLFxuICBzZXQgb25SZW5kZXIoZnVuYykge1xuICAgIGNvbnN0IHJlbmRlckdyb3VwID0gdGhpcy5yZW5kZXJHcm91cCB8fCB0aGlzLnBhcmVudFJlbmRlckdyb3VwO1xuICAgIGlmICghZnVuYykge1xuICAgICAgaWYgKHRoaXMuX29uUmVuZGVyKSB7XG4gICAgICAgIHJlbmRlckdyb3VwPy5yZW1vdmVPblJlbmRlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29uUmVuZGVyID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vblJlbmRlcikge1xuICAgICAgcmVuZGVyR3JvdXA/LmFkZE9uUmVuZGVyKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9vblJlbmRlciA9IGZ1bmM7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGNhbGxiYWNrIGlzIHVzZWQgd2hlbiB0aGUgY29udGFpbmVyIGlzIHJlbmRlcmVkLiBUaGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgYWRkIHlvdXIgY3VzdG9tXG4gICAqIGxvZ2ljIHRoYXQgaXMgbmVlZGVkIHRvIGJlIHJ1biBldmVyeSBmcmFtZS5cbiAgICpcbiAgICogSW4gdjcgbWFueSB1c2VycyB1c2VkIGB1cGRhdGVUcmFuc2Zvcm1gIGZvciB0aGlzLCBob3dldmVyIHRoZSB3YXkgdjggcmVuZGVycyBvYmplY3RzIGlzIGRpZmZlcmVudFxuICAgKiBhbmQgXCJ1cGRhdGVUcmFuc2Zvcm1cIiBpcyBubyBsb25nZXIgY2FsbGVkIGV2ZXJ5IGZyYW1lXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXIoKTtcbiAgICogY29udGFpbmVyLm9uUmVuZGVyID0gKCkgPT4ge1xuICAgKiAgICBjb250YWluZXIucm90YXRpb24gKz0gMC4wMTtcbiAgICogfTtcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBvblJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25SZW5kZXI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IG9uUmVuZGVyTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uUmVuZGVyTWl4aW4ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzb3J0TWl4aW4gPSB7XG4gIF96SW5kZXg6IDAsXG4gIC8qKlxuICAgKiBTaG91bGQgY2hpbGRyZW4gYmUgc29ydGVkIGJ5IHpJbmRleCBhdCB0aGUgbmV4dCByZW5kZXIgY2FsbC5cbiAgICpcbiAgICogV2lsbCBnZXQgYXV0b21hdGljYWxseSBzZXQgdG8gdHJ1ZSBpZiBhIG5ldyBjaGlsZCBpcyBhZGRlZCwgb3IgaWYgYSBjaGlsZCdzIHpJbmRleCBjaGFuZ2VzLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNvcnREaXJ0eTogZmFsc2UsXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGNvbnRhaW5lciB3aWxsIHNvcnQgaXRzIGNoaWxkcmVuIGJ5IGB6SW5kZXhgIHZhbHVlXG4gICAqIHdoZW4gdGhlIG5leHQgcmVuZGVyIGlzIGNhbGxlZCwgb3IgbWFudWFsbHkgaWYgYHNvcnRDaGlsZHJlbigpYCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgYWN0dWFsbHkgY2hhbmdlcyB0aGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCBzbyBzaG91bGQgYmUgdHJlYXRlZFxuICAgKiBhcyBhIGJhc2ljIHNvbHV0aW9uIHRoYXQgaXMgbm90IHBlcmZvcm1hbnQgY29tcGFyZWQgdG8gb3RoZXIgc29sdXRpb25zLFxuICAgKiBzdWNoIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL2xheWVycyBQaXhpSlMgTGF5ZXJzfVxuICAgKlxuICAgKiBBbHNvIGJlIGF3YXJlIG9mIHRoYXQgdGhpcyBtYXkgbm90IHdvcmsgbmljZWx5IHdpdGggdGhlIGBhZGRDaGlsZEF0KClgIGZ1bmN0aW9uLFxuICAgKiBhcyB0aGUgYHpJbmRleGAgc29ydGluZyBtYXkgY2F1c2UgdGhlIGNoaWxkIHRvIGF1dG9tYXRpY2FsbHkgc29ydGVkIHRvIGFub3RoZXIgcG9zaXRpb24uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgc29ydGFibGVDaGlsZHJlbjogZmFsc2UsXG4gIC8qKlxuICAgKiBUaGUgekluZGV4IG9mIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIFNldHRpbmcgdGhpcyB2YWx1ZSwgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgcGFyZW50IHRvIGJlIHNvcnRhYmxlLiBDaGlsZHJlbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHlcbiAgICogc29ydGVkIGJ5IHpJbmRleCB2YWx1ZTsgYSBoaWdoZXIgdmFsdWUgd2lsbCBtZWFuIGl0IHdpbGwgYmUgbW92ZWQgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBhcnJheSxcbiAgICogYW5kIHRodXMgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGRpc3BsYXkgb2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyLlxuICAgKiBAc2VlIHNjZW5lLkNvbnRhaW5lciNzb3J0YWJsZUNoaWxkcmVuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXQgekluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl96SW5kZXg7XG4gIH0sXG4gIHNldCB6SW5kZXgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fekluZGV4ID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl96SW5kZXggPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoT2ZDaGlsZE1vZGlmaWVkKCk7XG4gIH0sXG4gIGRlcHRoT2ZDaGlsZE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc29ydGFibGVDaGlsZHJlbiA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5zb3J0RGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnRSZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5wYXJlbnRSZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNvcnRzIGNoaWxkcmVuIGJ5IHpJbmRleC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNvcnRDaGlsZHJlbigpIHtcbiAgICBpZiAoIXRoaXMuc29ydERpcnR5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZHJlbi5zb3J0KHNvcnRDaGlsZHJlbik7XG4gIH1cbn07XG5mdW5jdGlvbiBzb3J0Q2hpbGRyZW4oYSwgYikge1xuICByZXR1cm4gYS5fekluZGV4IC0gYi5fekluZGV4O1xufVxuXG5leHBvcnQgeyBzb3J0TWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHMgfSBmcm9tICcuLi9ib3VuZHMvZ2V0R2xvYmFsQm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdG9Mb2NhbEdsb2JhbE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBvcHRpb25hbCBwb2ludCB0byB3cml0ZSB0aGUgZ2xvYmFsIHZhbHVlIHRvLlxuICAgKiBAcGFyYW0gc2tpcFVwZGF0ZSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyAtIFRoZSB1cGRhdGVkIHBvaW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0R2xvYmFsUG9zaXRpb24ocG9pbnQgPSBuZXcgUG9pbnQoKSwgc2tpcFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC50b0dsb2JhbCh0aGlzLl9wb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludC54ID0gdGhpcy5fcG9zaXRpb24ueDtcbiAgICAgIHBvaW50LnkgPSB0aGlzLl9wb3NpdGlvbi55O1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH0sXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHBvc2l0aW9uIC0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbS5cbiAgICogQHBhcmFtIHBvaW50IC0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbFxuICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludCkuXG4gICAqIEBwYXJhbSBza2lwVXBkYXRlIC0gU2hvdWxkIHdlIHNraXAgdGhlIHVwZGF0ZSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIC0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICBjb25zdCBnbG9iYWxNYXRyaXggPSB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHModGhpcywgbmV3IE1hdHJpeCgpKTtcbiAgICAgIGdsb2JhbE1hdHJpeC5hcHBlbmQodGhpcy5sb2NhbFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gZ2xvYmFsTWF0cml4LmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gIH0sXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyIHJlbGF0aXZlIHRvIGFub3RoZXIgcG9pbnQuXG4gICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIENvbnRhaW5lciB0byBjYWxjdWxhdGUgdGhlIGdsb2JhbCBwb3NpdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0gcG9pbnQgLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsXG4gICAqICAob3RoZXJ3aXNlIHdpbGwgY3JlYXRlIGEgbmV3IFBvaW50KS5cbiAgICogQHBhcmFtIHNraXBVcGRhdGUgLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJucyAtIEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3RcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHRvTG9jYWwocG9zaXRpb24sIGZyb20sIHBvaW50LCBza2lwVXBkYXRlKSB7XG4gICAgaWYgKGZyb20pIHtcbiAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgIH1cbiAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgIGNvbnN0IGdsb2JhbE1hdHJpeCA9IHVwZGF0ZVRyYW5zZm9ybUJhY2t3YXJkcyh0aGlzLCBuZXcgTWF0cml4KCkpO1xuICAgICAgZ2xvYmFsTWF0cml4LmFwcGVuZCh0aGlzLmxvY2FsVHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiBnbG9iYWxNYXRyaXguYXBwbHlJbnZlcnNlKHBvc2l0aW9uLCBwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xuICB9XG59O1xuXG5leHBvcnQgeyB0b0xvY2FsR2xvYmFsTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvTG9jYWxHbG9iYWxNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBJbnN0cnVjdGlvblNldCB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2luc3RydWN0aW9ucy9JbnN0cnVjdGlvblNldC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFJlbmRlckdyb3VwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZW5kZXJQaXBlSWQgPSBcInJlbmRlckdyb3VwXCI7XG4gICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB0aGlzLmNhbkJ1bmRsZSA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyR3JvdXBQYXJlbnQgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyR3JvdXBDaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy53b3JsZENvbG9yQWxwaGEgPSA0Mjk0OTY3Mjk1O1xuICAgIHRoaXMud29ybGRDb2xvciA9IDE2Nzc3MjE1O1xuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG4gICAgLy8gdGhlc2UgdXBkYXRlcyBhcmUgdHJhbnNmb3JtIGNoYW5nZXMuLlxuICAgIHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudXBkYXRlVGljayA9IDA7XG4gICAgLy8gdGhlc2UgdXBkYXRlIGFyZSByZW5kZXJhYmxlIGNoYW5nZXMuLlxuICAgIHRoaXMuY2hpbGRyZW5SZW5kZXJhYmxlc1RvVXBkYXRlID0geyBsaXN0OiBbXSwgaW5kZXg6IDAgfTtcbiAgICAvLyBvdGhlclxuICAgIHRoaXMuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RydWN0aW9uU2V0ID0gbmV3IEluc3RydWN0aW9uU2V0KCk7XG4gICAgdGhpcy5fb25SZW5kZXJDb250YWluZXJzID0gW107XG4gIH1cbiAgaW5pdChyb290KSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICBpZiAocm9vdC5fb25SZW5kZXIpXG4gICAgICB0aGlzLmFkZE9uUmVuZGVyKHJvb3QpO1xuICAgIHJvb3QuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmVuZGVyR3JvdXBDaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmNoaWxkcmVuVG9VcGRhdGUpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuQXREZXB0aCA9IHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZVtpXTtcbiAgICAgIGNoaWxkcmVuQXREZXB0aC5saXN0LmZpbGwobnVsbCk7XG4gICAgICBjaGlsZHJlbkF0RGVwdGguaW5kZXggPSAwO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuUmVuZGVyYWJsZXNUb1VwZGF0ZS5pbmRleCA9IDA7XG4gICAgdGhpcy5jaGlsZHJlblJlbmRlcmFibGVzVG9VcGRhdGUubGlzdC5maWxsKG51bGwpO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy51cGRhdGVUaWNrID0gMDtcbiAgICB0aGlzLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgdGhpcy5fb25SZW5kZXJDb250YWluZXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5yZW5kZXJHcm91cFBhcmVudCA9IG51bGw7XG4gIH1cbiAgZ2V0IGxvY2FsVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QubG9jYWxUcmFuc2Zvcm07XG4gIH1cbiAgYWRkUmVuZGVyR3JvdXBDaGlsZChyZW5kZXJHcm91cENoaWxkKSB7XG4gICAgaWYgKHJlbmRlckdyb3VwQ2hpbGQucmVuZGVyR3JvdXBQYXJlbnQpIHtcbiAgICAgIHJlbmRlckdyb3VwQ2hpbGQucmVuZGVyR3JvdXBQYXJlbnQuX3JlbW92ZVJlbmRlckdyb3VwQ2hpbGQocmVuZGVyR3JvdXBDaGlsZCk7XG4gICAgfVxuICAgIHJlbmRlckdyb3VwQ2hpbGQucmVuZGVyR3JvdXBQYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMucmVuZGVyR3JvdXBDaGlsZHJlbi5wdXNoKHJlbmRlckdyb3VwQ2hpbGQpO1xuICB9XG4gIF9yZW1vdmVSZW5kZXJHcm91cENoaWxkKHJlbmRlckdyb3VwQ2hpbGQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVuZGVyR3JvdXBDaGlsZHJlbi5pbmRleE9mKHJlbmRlckdyb3VwQ2hpbGQpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnJlbmRlckdyb3VwQ2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmVuZGVyR3JvdXBDaGlsZC5yZW5kZXJHcm91cFBhcmVudCA9IG51bGw7XG4gIH1cbiAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB0aGlzLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgY2hpbGQucGFyZW50UmVuZGVyR3JvdXAgPSB0aGlzO1xuICAgIGNoaWxkLnVwZGF0ZVRpY2sgPSAtMTtcbiAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzLnJvb3QpIHtcbiAgICAgIGNoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aCA9IGNoaWxkLnBhcmVudC5yZWxhdGl2ZVJlbmRlckdyb3VwRGVwdGggKyAxO1xuICAgIH1cbiAgICBjaGlsZC5kaWRDaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMub25DaGlsZFVwZGF0ZShjaGlsZCk7XG4gICAgaWYgKGNoaWxkLnJlbmRlckdyb3VwKSB7XG4gICAgICB0aGlzLmFkZFJlbmRlckdyb3VwQ2hpbGQoY2hpbGQucmVuZGVyR3JvdXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hpbGQuX29uUmVuZGVyKVxuICAgICAgdGhpcy5hZGRPblJlbmRlcihjaGlsZCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZC5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICB0aGlzLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgaWYgKGNoaWxkLl9vblJlbmRlcikge1xuICAgICAgaWYgKCFjaGlsZC5yZW5kZXJHcm91cCkge1xuICAgICAgICB0aGlzLnJlbW92ZU9uUmVuZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGQucGFyZW50UmVuZGVyR3JvdXAgPSBudWxsO1xuICAgIGlmIChjaGlsZC5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5fcmVtb3ZlUmVuZGVyR3JvdXBDaGlsZChjaGlsZC5yZW5kZXJHcm91cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIG9uQ2hpbGRVcGRhdGUoY2hpbGQpIHtcbiAgICBsZXQgY2hpbGRyZW5Ub1VwZGF0ZSA9IHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZVtjaGlsZC5yZWxhdGl2ZVJlbmRlckdyb3VwRGVwdGhdO1xuICAgIGlmICghY2hpbGRyZW5Ub1VwZGF0ZSkge1xuICAgICAgY2hpbGRyZW5Ub1VwZGF0ZSA9IHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZVtjaGlsZC5yZWxhdGl2ZVJlbmRlckdyb3VwRGVwdGhdID0ge1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgbGlzdDogW11cbiAgICAgIH07XG4gICAgfVxuICAgIGNoaWxkcmVuVG9VcGRhdGUubGlzdFtjaGlsZHJlblRvVXBkYXRlLmluZGV4KytdID0gY2hpbGQ7XG4gIH1cbiAgLy8gU0hPVUxEIFRISVMgQkUgSEVSRT9cbiAgdXBkYXRlUmVuZGVyYWJsZShjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLmdsb2JhbERpc3BsYXlTdGF0dXMgPCA3KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnRhaW5lci5kaWRWaWV3VXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0cnVjdGlvblNldC5yZW5kZXJQaXBlc1tjb250YWluZXIucmVuZGVyUGlwZUlkXS51cGRhdGVSZW5kZXJhYmxlKGNvbnRhaW5lcik7XG4gIH1cbiAgb25DaGlsZFZpZXdVcGRhdGUoY2hpbGQpIHtcbiAgICB0aGlzLmNoaWxkcmVuUmVuZGVyYWJsZXNUb1VwZGF0ZS5saXN0W3RoaXMuY2hpbGRyZW5SZW5kZXJhYmxlc1RvVXBkYXRlLmluZGV4KytdID0gY2hpbGQ7XG4gIH1cbiAgZ2V0IGlzUmVuZGVyYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LmxvY2FsRGlzcGxheVN0YXR1cyA9PT0gNyAmJiB0aGlzLndvcmxkQWxwaGEgPiAwO1xuICB9XG4gIC8qKlxuICAgKiBhZGRpbmcgYSBjb250YWluZXIgdG8gdGhlIG9uUmVuZGVyIGxpc3Qgd2lsbCBtYWtlIHN1cmUgdGhlIHVzZXIgZnVuY3Rpb25cbiAgICogcGFzc2VkIGluIHRvIHRoZSB1c2VyIGRlZmluZWQgJ29uUmVuZGVyYCBjYWxsQmFja1xuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gdGhlIGNvbnRhaW5lciB0byBhZGQgdG8gdGhlIG9uUmVuZGVyIGxpc3RcbiAgICovXG4gIGFkZE9uUmVuZGVyKGNvbnRhaW5lcikge1xuICAgIHRoaXMuX29uUmVuZGVyQ29udGFpbmVycy5wdXNoKGNvbnRhaW5lcik7XG4gIH1cbiAgcmVtb3ZlT25SZW5kZXIoY29udGFpbmVyKSB7XG4gICAgdGhpcy5fb25SZW5kZXJDb250YWluZXJzLnNwbGljZSh0aGlzLl9vblJlbmRlckNvbnRhaW5lcnMuaW5kZXhPZihjb250YWluZXIpLCAxKTtcbiAgfVxuICBydW5PblJlbmRlcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX29uUmVuZGVyQ29udGFpbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fb25SZW5kZXJDb250YWluZXJzW2ldLl9vblJlbmRlcigpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyR3JvdXBQYXJlbnQgPSBudWxsO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlblJlbmRlcmFibGVzVG9VcGRhdGUgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJHcm91cENoaWxkcmVuID0gbnVsbDtcbiAgICB0aGlzLl9vblJlbmRlckNvbnRhaW5lcnMgPSBudWxsO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25TZXQgPSBudWxsO1xuICB9XG4gIGdldENoaWxkcmVuKG91dCA9IFtdKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnJvb3QuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZ2V0Q2hpbGRyZW4oY2hpbGRyZW5baV0sIG91dCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgX2dldENoaWxkcmVuKGNvbnRhaW5lciwgb3V0ID0gW10pIHtcbiAgICBvdXQucHVzaChjb250YWluZXIpO1xuICAgIGlmIChjb250YWluZXIucmVuZGVyR3JvdXApXG4gICAgICByZXR1cm4gb3V0O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2dldENoaWxkcmVuKGNoaWxkcmVuW2ldLCBvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5cbmV4cG9ydCB7IFJlbmRlckdyb3VwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJHcm91cC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFzc2lnbldpdGhJZ25vcmUodGFyZ2V0LCBvcHRpb25zLCBpZ25vcmUgPSB7fSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCFpZ25vcmVba2V5XSAmJiBvcHRpb25zW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGFzc2lnbldpdGhJZ25vcmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2lnbldpdGhJZ25vcmUubWpzLm1hcFxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IGN1bGxpbmdNaXhpbiB9IGZyb20gJy4uLy4uL2N1bGxpbmcvY3VsbGluZ01peGluLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBSQURfVE9fREVHLCBERUdfVE9fUkFEIH0gZnJvbSAnLi4vLi4vbWF0aHMvbWlzYy9jb25zdC5tanMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVBvaW50IH0gZnJvbSAnLi4vLi4vbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgY2hpbGRyZW5IZWxwZXJNaXhpbiB9IGZyb20gJy4vY29udGFpbmVyLW1peGlucy9jaGlsZHJlbkhlbHBlck1peGluLm1qcyc7XG5pbXBvcnQgeyBlZmZlY3RzTWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvZWZmZWN0c01peGluLm1qcyc7XG5pbXBvcnQgeyBmaW5kTWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvZmluZE1peGluLm1qcyc7XG5pbXBvcnQgeyBtZWFzdXJlTWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvbWVhc3VyZU1peGluLm1qcyc7XG5pbXBvcnQgeyBvblJlbmRlck1peGluIH0gZnJvbSAnLi9jb250YWluZXItbWl4aW5zL29uUmVuZGVyTWl4aW4ubWpzJztcbmltcG9ydCB7IHNvcnRNaXhpbiB9IGZyb20gJy4vY29udGFpbmVyLW1peGlucy9zb3J0TWl4aW4ubWpzJztcbmltcG9ydCB7IHRvTG9jYWxHbG9iYWxNaXhpbiB9IGZyb20gJy4vY29udGFpbmVyLW1peGlucy90b0xvY2FsR2xvYmFsTWl4aW4ubWpzJztcbmltcG9ydCB7IFJlbmRlckdyb3VwIH0gZnJvbSAnLi9SZW5kZXJHcm91cC5tanMnO1xuaW1wb3J0IHsgYXNzaWduV2l0aElnbm9yZSB9IGZyb20gJy4vdXRpbHMvYXNzaWduV2l0aElnbm9yZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRlZmF1bHRTa2V3ID0gbmV3IE9ic2VydmFibGVQb2ludChudWxsKTtcbmNvbnN0IGRlZmF1bHRQaXZvdCA9IG5ldyBPYnNlcnZhYmxlUG9pbnQobnVsbCk7XG5jb25zdCBkZWZhdWx0U2NhbGUgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KG51bGwsIDEsIDEpO1xuY29uc3QgVVBEQVRFX0NPTE9SID0gMTtcbmNvbnN0IFVQREFURV9CTEVORCA9IDI7XG5jb25zdCBVUERBVEVfVklTSUJMRSA9IDQ7XG5jb25zdCBVUERBVEVfVFJBTlNGT1JNID0gODtcbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIHVuaXF1ZSBpZCBmb3IgdGhpcyBjb250YWluZXIgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcInJlbmRlcmFibGVcIik7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgPSAxNTtcbiAgICAvLyB0aGUgcmVuZGVyIGdyb3VwIHRoaXMgY29udGFpbmVyIG93bnNcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLnJlbmRlckdyb3VwID0gbnVsbDtcbiAgICAvLyB0aGUgcmVuZGVyIGdyb3VwIHRoaXMgY29udGFpbmVyIGJlbG9uZ3MgdG9cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLnBhcmVudFJlbmRlckdyb3VwID0gbnVsbDtcbiAgICAvLyB0aGUgaW5kZXggb2YgdGhlIGNvbnRhaW5lciBpbiB0aGUgcmVuZGVyIGdyb3VwXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5wYXJlbnRSZW5kZXJHcm91cEluZGV4ID0gMDtcbiAgICAvLyBzZXQgdG8gdHJ1ZSBpZiB0aGUgY29udGFpbmVyIGhhcyBjaGFuZ2VkLiBJdCBpcyByZXNldCBvbmNlIHRoZSBjaGFuZ2VzIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgLy8gYnkgdGhlIHRyYW5zZm9ybSBzeXN0ZW1cbiAgICAvLyBpdHMgaGVyZSB0byBzdG9wIGVuc3VyZSB0aGF0IHdoZW4gdGhpbmdzIGNoYW5nZSwgb25seSBvbmUgdXBkYXRlIGdldHMgcmVnaXN0ZXJzIHdpdGggdGhlIHRyYW5zZm9ybSBzeXN0ZW1cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmRpZENoYW5nZSA9IGZhbHNlO1xuICAgIC8vIHNhbWUgYXMgYWJvdmUsIGJ1dCBmb3IgdGhlIHJlbmRlcmFibGVcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmRpZFZpZXdVcGRhdGUgPSBmYWxzZTtcbiAgICAvLyBob3cgZGVlcCBpcyB0aGUgY29udGFpbmVyIHJlbGF0aXZlIHRvIGl0cyByZW5kZXIgZ3JvdXAuLlxuICAgIC8vIHVubGVzcyB0aGUgZWxlbWVudCBpcyB0aGUgcm9vdCByZW5kZXIgZ3JvdXAgLSBpdCB3aWxsIGJlIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnRcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAvKiogVGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QuICovXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIC8vIHVzZWQgaW50ZXJuYWxseSBmb3IgY2hhbmdpbmcgdXAgdGhlIHJlbmRlciBvcmRlci4uIG1haW5seSBmb3IgbWFza3MgYW5kIGZpbHRlcnNcbiAgICAvLyBUT0RPIHNldHRpbmcgdGhpcyBzaG91bGQgY2F1c2UgYSByZWJ1aWxkPz9cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmluY2x1ZGVJbkJ1aWxkID0gdHJ1ZTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLm1lYXN1cmFibGUgPSB0cnVlO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuaXNTaW1wbGUgPSB0cnVlO1xuICAgIC8vIC8gLy8vLy8vLy8vLy8vL1RyYW5zZm9ybSByZWxhdGVkIHByb3BzLy8vLy8vLy8vLy8vLy9cbiAgICAvLyB1c2VkIGJ5IHRoZSB0cmFuc2Zvcm0gc3lzdGVtIHRvIGNoZWNrIGlmIGEgY29udGFpbmVyIG5lZWRzIHRvIGJlIHVwZGF0ZWQgdGhhdCBmcmFtZVxuICAgIC8vIGlmIHRoZSB0aWNrIG1hdGNoZXMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIHN5c3RlbSB0aWNrLCBpdCBpcyBub3QgdXBkYXRlZCBhZ2FpblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZVRpY2sgPSAtMTtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIGxvY2FsIGZhY3RvcnM6IHBvc2l0aW9uLCBzY2FsZSwgb3RoZXIgc3R1ZmYuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5sb2NhbFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXRpdmUgZ3JvdXAgdHJhbnNmb3JtIGlzIGEgdHJhbnNmb3JtIHJlbGF0aXZlIHRvIHRoZSByZW5kZXIgZ3JvdXAgaXQgYmVsb25ncyB0b28uIEl0IHdpbGwgaW5jbHVkZSBhbGwgcGFyZW50XG4gICAgICogdHJhbnNmb3JtcyBhbmQgdXAgdG8gdGhlIHJlbmRlciBncm91cCAodGhpbmsgb2YgaXQgYXMga2luZCBvZiBsaWtlIGEgc3RhZ2UgLSBidXQgdGhlIHN0YWdlIGNhbiBiZSBuZXN0ZWQpLlxuICAgICAqIElmIHRoaXMgY29udGFpbmVyIGlzIGlzIHNlbGYgYSByZW5kZXIgZ3JvdXAgbWF0cml4IHdpbGwgYmUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCByZW5kZXIgZ3JvdXBcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgLyoqXG4gICAgICogVGhlIGdyb3VwIHRyYW5zZm9ybSBpcyBhIHRyYW5zZm9ybSByZWxhdGl2ZSB0byB0aGUgcmVuZGVyIGdyb3VwIGl0IGJlbG9uZ3MgdG9vLlxuICAgICAqIElmIHRoaXMgY29udGFpbmVyIGlzIHJlbmRlciBncm91cCB0aGVuIHRoaXMgd2lsbCBiZSBhbiBpZGVudGl0eSBtYXRyaXguIG90aGVyIHdpc2UgaXRcbiAgICAgKiB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSByZWxhdGl2ZUdyb3VwVHJhbnNmb3JtLlxuICAgICAqIFVzZSB0aGlzIHZhbHVlIHdoZW4gYWN0dWFsbHkgcmVuZGVyaW5nIHRoaW5ncyB0byB0aGUgc2NyZWVuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5ncm91cFRyYW5zZm9ybSA9IHRoaXMucmVsYXRpdmVHcm91cFRyYW5zZm9ybTtcbiAgICAvKiogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQgdmlhIGRlc3Ryb3koKS4gSWYgdHJ1ZSwgaXQgc2hvdWxkIG5vdCBiZSB1c2VkLiAqL1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgLy8gdHJhbnNmb3JtIGRhdGEuLlxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvYmplY3QuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3NjYWxlID0gZGVmYXVsdFNjYWxlO1xuICAgIC8qKlxuICAgICAqIFRoZSBwaXZvdCBwb2ludCBvZiB0aGUgY29udGFpbmVyIHRoYXQgaXQgcm90YXRlcyBhcm91bmQuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3Bpdm90ID0gZGVmYXVsdFBpdm90O1xuICAgIC8qKlxuICAgICAqIFRoZSBza2V3IGFtb3VudCwgb24gdGhlIHggYW5kIHkgYXhpcy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fc2tldyA9IGRlZmF1bHRTa2V3O1xuICAgIC8qKlxuICAgICAqIFRoZSBYLWNvb3JkaW5hdGUgdmFsdWUgb2YgdGhlIG5vcm1hbGl6ZWQgbG9jYWwgWCBheGlzLFxuICAgICAqIHRoZSBmaXJzdCBjb2x1bW4gb2YgdGhlIGxvY2FsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB3aXRob3V0IGEgc2NhbGUuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX2N4ID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgWS1jb29yZGluYXRlIHZhbHVlIG9mIHRoZSBub3JtYWxpemVkIGxvY2FsIFggYXhpcyxcbiAgICAgKiB0aGUgZmlyc3QgY29sdW1uIG9mIHRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggd2l0aG91dCBhIHNjYWxlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9zeCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIFgtY29vcmRpbmF0ZSB2YWx1ZSBvZiB0aGUgbm9ybWFsaXplZCBsb2NhbCBZIGF4aXMsXG4gICAgICogdGhlIHNlY29uZCBjb2x1bW4gb2YgdGhlIGxvY2FsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB3aXRob3V0IGEgc2NhbGUuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX2N5ID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgWS1jb29yZGluYXRlIHZhbHVlIG9mIHRoZSBub3JtYWxpemVkIGxvY2FsIFkgYXhpcyxcbiAgICAgKiB0aGUgc2Vjb25kIGNvbHVtbiBvZiB0aGUgbG9jYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IHdpdGhvdXQgYSBzY2FsZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fc3kgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSByb3RhdGlvbiBhbW91bnQuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3JvdGF0aW9uID0gMDtcbiAgICAvLyAvIENPTE9SIHJlbGF0ZWQgcHJvcHMgLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBjb2xvciBzdG9yZWQgYXMgQUJHUlxuICAgIHRoaXMubG9jYWxDb2xvciA9IDE2Nzc3MjE1O1xuICAgIHRoaXMubG9jYWxBbHBoYSA9IDE7XG4gICAgdGhpcy5ncm91cEFscGhhID0gMTtcbiAgICAvLyBBXG4gICAgdGhpcy5ncm91cENvbG9yID0gMTY3NzcyMTU7XG4gICAgLy8gQkdSXG4gICAgdGhpcy5ncm91cENvbG9yQWxwaGEgPSA0Mjk0OTY3Mjk1O1xuICAgIC8vIEFCR1JcbiAgICAvLyAvIEJMRU5EIHJlbGF0ZWQgcHJvcHMgLy8vLy8vLy8vLy8vLy9cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5sb2NhbEJsZW5kTW9kZSA9IFwiaW5oZXJpdFwiO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwQmxlbmRNb2RlID0gXCJub3JtYWxcIjtcbiAgICAvLyAvIFZJU0lCSUxJVFkgcmVsYXRlZCBwcm9wcyAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIHZpc2liaWxpdHlcbiAgICAvLyAwYjExXG4gICAgLy8gZmlyc3QgYml0IGlzIHZpc2libGUsIHNlY29uZCBiaXQgaXMgcmVuZGVyYWJsZVxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaG9sZHMgdGhyZWUgYml0czogY3VsbGVkLCB2aXNpYmxlLCByZW5kZXJhYmxlXG4gICAgICogdGhlIHRoaXJkIGJpdCByZXByZXNlbnRzIGN1bGxpbmcgKDAgPSBjdWxsZWQsIDEgPSBub3QgY3VsbGVkKSAwYjEwMFxuICAgICAqIHRoZSBzZWNvbmQgYml0IHJlcHJlc2VudHMgdmlzaWJpbGl0eSAoMCA9IG5vdCB2aXNpYmxlLCAxID0gdmlzaWJsZSkgMGIwMTBcbiAgICAgKiB0aGUgZmlyc3QgYml0IHJlcHJlc2VudHMgcmVuZGVyYWJsZSAoMCA9IG5vdCByZW5kZXJhYmxlLCAxID0gcmVuZGVyYWJsZSkgMGIwMDFcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgPSA3O1xuICAgIC8vIDBiMTEgfCAwYjEwIHwgMGIwMSB8IDBiMDBcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5nbG9iYWxEaXNwbGF5U3RhdHVzID0gNztcbiAgICAvKipcbiAgICAgKiBBIHZhbHVlIHRoYXQgaW5jcmVtZW50cyBlYWNoIHRpbWUgdGhlIGNvbnRhaW5lIGlzIG1vZGlmaWVkXG4gICAgICogZWcgY2hpbGRyZW4gYWRkZWQsIHJlbW92ZWQgZXRjXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX2RpZENvbnRhaW5lckNoYW5nZVRpY2sgPSAwO1xuICAgIC8qKlxuICAgICAqIEEgdmFsdWUgdGhhdCBpbmNyZW1lbnRzIGVhY2ggdGltZSB0aGUgY29udGFpbmVyIHZpZXcgaXMgbW9kaWZpZWRcbiAgICAgKiBlZyB0ZXh0dXJlIHN3YXAsIGdlb21ldHJ5IGNoYW5nZSBldGNcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fZGlkVmlld0NoYW5nZVRpY2sgPSAwO1xuICAgIC8qKlxuICAgICAqIHByb3BlcnR5IHRoYXQgdHJhY2tzIGlmIHRoZSBjb250YWluZXIgdHJhbnNmb3JtIGhhcyBjaGFuZ2VkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX2RpZExvY2FsVHJhbnNmb3JtQ2hhbmdlSWQgPSAtMTtcbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICBhc3NpZ25XaXRoSWdub3JlKHRoaXMsIG9wdGlvbnMsIHtcbiAgICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgICAgcGFyZW50OiB0cnVlLFxuICAgICAgZWZmZWN0czogdHJ1ZVxuICAgIH0pO1xuICAgIG9wdGlvbnMuY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLmFkZENoaWxkKGNoaWxkKSk7XG4gICAgb3B0aW9ucy5wYXJlbnQ/LmFkZENoaWxkKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBNaXhlcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZyb20gYSBzb3VyY2Ugb2JqZWN0IHRvIENvbnRhaW5lci5cbiAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2YgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0byBtaXggaW4uXG4gICAqL1xuICBzdGF0aWMgbWl4aW4oc291cmNlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29udGFpbmVyLnByb3RvdHlwZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFdlIG5vdyB1c2UgdGhlIF9kaWRDb250YWluZXJDaGFuZ2VUaWNrIGFuZCBfZGlkVmlld0NoYW5nZVRpY2sgdG8gdHJhY2sgY2hhbmdlc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjIuNlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzZXQgX2RpZENoYW5nZUlkKHZhbHVlKSB7XG4gICAgdGhpcy5fZGlkVmlld0NoYW5nZVRpY2sgPSB2YWx1ZSA+PiAxMiAmIDQwOTU7XG4gICAgdGhpcy5fZGlkQ29udGFpbmVyQ2hhbmdlVGljayA9IHZhbHVlICYgNDA5NTtcbiAgfVxuICBnZXQgX2RpZENoYW5nZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaWRDb250YWluZXJDaGFuZ2VUaWNrICYgNDA5NSB8ICh0aGlzLl9kaWRWaWV3Q2hhbmdlVGljayAmIDQwOTUpIDw8IDEyO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBvciBtb3JlIGNoaWxkcmVuIHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIE11bHRpcGxlIGl0ZW1zIGNhbiBiZSBhZGRlZCBsaWtlIHNvOiBgbXlDb250YWluZXIuYWRkQ2hpbGQodGhpbmdPbmUsIHRoaW5nVHdvLCB0aGluZ1RocmVlKWBcbiAgICogQHBhcmFtIHsuLi5Db250YWluZXJ9IGNoaWxkcmVuIC0gVGhlIENvbnRhaW5lcihzKSB0byBhZGQgdG8gdGhlIGNvbnRhaW5lclxuICAgKiBAcmV0dXJucyB7Q29udGFpbmVyfSAtIFRoZSBmaXJzdCBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAgICovXG4gIGFkZENoaWxkKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKCF0aGlzLmFsbG93Q2hpbGRyZW4pIHtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJhZGRDaGlsZDogT25seSBDb250YWluZXJzIHdpbGwgYmUgYWxsb3dlZCB0byBhZGQgY2hpbGRyZW4gaW4gdjguMC4wXCIpO1xuICAgIH1cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSh0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpLCAxKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnRSZW5kZXJHcm91cCkge1xuICAgICAgICB0aGlzLnBhcmVudFJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgaWYgKHRoaXMuc29ydGFibGVDaGlsZHJlbilcbiAgICAgIHRoaXMuc29ydERpcnR5ID0gdHJ1ZTtcbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIGNoaWxkLmRpZENoYW5nZSA9IHRydWU7XG4gICAgY2hpbGQuZGlkVmlld1VwZGF0ZSA9IGZhbHNlO1xuICAgIGNoaWxkLl91cGRhdGVGbGFncyA9IDE1O1xuICAgIGNvbnN0IHJlbmRlckdyb3VwID0gdGhpcy5yZW5kZXJHcm91cCB8fCB0aGlzLnBhcmVudFJlbmRlckdyb3VwO1xuICAgIGlmIChyZW5kZXJHcm91cCkge1xuICAgICAgcmVuZGVyR3JvdXAuYWRkQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjaGlsZEFkZGVkXCIsIGNoaWxkLCB0aGlzLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICB0aGlzLl9kaWRWaWV3Q2hhbmdlVGljaysrO1xuICAgIGlmIChjaGlsZC5fekluZGV4ICE9PSAwKSB7XG4gICAgICBjaGlsZC5kZXB0aE9mQ2hpbGRNb2RpZmllZCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgb25lIG9yIG1vcmUgY2hpbGRyZW4gZnJvbSB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gey4uLkNvbnRhaW5lcn0gY2hpbGRyZW4gLSBUaGUgQ29udGFpbmVyKHMpIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7Q29udGFpbmVyfSBUaGUgZmlyc3QgY2hpbGQgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUNoaWxkKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLl9kaWRWaWV3Q2hhbmdlVGljaysrO1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgaWYgKHRoaXMucmVuZGVyR3JvdXApIHtcbiAgICAgICAgdGhpcy5yZW5kZXJHcm91cC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50UmVuZGVyR3JvdXApIHtcbiAgICAgICAgdGhpcy5wYXJlbnRSZW5kZXJHcm91cC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgICBjaGlsZC5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIC8qKiBAaWdub3JlICovXG4gIF9vblVwZGF0ZShwb2ludCkge1xuICAgIGlmIChwb2ludCkge1xuICAgICAgaWYgKHBvaW50ID09PSB0aGlzLl9za2V3KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNrZXcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGlkQ29udGFpbmVyQ2hhbmdlVGljaysrO1xuICAgIGlmICh0aGlzLmRpZENoYW5nZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRpZENoYW5nZSA9IHRydWU7XG4gICAgaWYgKHRoaXMucGFyZW50UmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucGFyZW50UmVuZGVyR3JvdXAub25DaGlsZFVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0IGlzUmVuZGVyR3JvdXAodmFsdWUpIHtcbiAgICBpZiAoISF0aGlzLnJlbmRlckdyb3VwID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZW5hYmxlUmVuZGVyR3JvdXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNhYmxlUmVuZGVyR3JvdXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbnRhaW5lciBpcyBhIHJlbmRlciBncm91cC5cbiAgICogVGhpcyBtZWFucyB0aGF0IGl0IHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBzZXBhcmF0ZSBwYXNzLCB3aXRoIGl0cyBvd24gc2V0IG9mIGluc3RydWN0aW9uc1xuICAgKi9cbiAgZ2V0IGlzUmVuZGVyR3JvdXAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5yZW5kZXJHcm91cDtcbiAgfVxuICAvKipcbiAgICogQ2FsbGluZyB0aGlzIGVuYWJsZXMgYSByZW5kZXIgZ3JvdXAgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgKiBUaGlzIG1lYW5zIGl0IHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBzZXBhcmF0ZSBzZXQgb2YgaW5zdHJ1Y3Rpb25zLlxuICAgKiBUaGUgdHJhbnNmb3JtIG9mIHRoZSBjb250YWluZXIgd2lsbCBhbHNvIGJlIGhhbmRsZWQgb24gdGhlIEdQVSByYXRoZXIgdGhhbiB0aGUgQ1BVLlxuICAgKi9cbiAgZW5hYmxlUmVuZGVyR3JvdXAoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcGFyZW50UmVuZGVyR3JvdXAgPSB0aGlzLnBhcmVudFJlbmRlckdyb3VwO1xuICAgIHBhcmVudFJlbmRlckdyb3VwPy5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB0aGlzLnJlbmRlckdyb3VwID0gQmlnUG9vbC5nZXQoUmVuZGVyR3JvdXAsIHRoaXMpO1xuICAgIHRoaXMuZ3JvdXBUcmFuc2Zvcm0gPSBNYXRyaXguSURFTlRJVFk7XG4gICAgcGFyZW50UmVuZGVyR3JvdXA/LmFkZENoaWxkKHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZUlzU2ltcGxlKCk7XG4gIH1cbiAgLyoqIFRoaXMgd2lsbCBkaXNhYmxlIHRoZSByZW5kZXIgZ3JvdXAgZm9yIHRoaXMgY29udGFpbmVyLiAqL1xuICBkaXNhYmxlUmVuZGVyR3JvdXAoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlckdyb3VwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmVudFJlbmRlckdyb3VwID0gdGhpcy5wYXJlbnRSZW5kZXJHcm91cDtcbiAgICBwYXJlbnRSZW5kZXJHcm91cD8ucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgQmlnUG9vbC5yZXR1cm4odGhpcy5yZW5kZXJHcm91cCk7XG4gICAgdGhpcy5yZW5kZXJHcm91cCA9IG51bGw7XG4gICAgdGhpcy5ncm91cFRyYW5zZm9ybSA9IHRoaXMucmVsYXRpdmVHcm91cFRyYW5zZm9ybTtcbiAgICBwYXJlbnRSZW5kZXJHcm91cD8uYWRkQ2hpbGQodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlSXNTaW1wbGUoKTtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICBfdXBkYXRlSXNTaW1wbGUoKSB7XG4gICAgdGhpcy5pc1NpbXBsZSA9ICF0aGlzLnJlbmRlckdyb3VwICYmIHRoaXMuZWZmZWN0cy5sZW5ndGggPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9ycy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgd29ybGRUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5fd29ybGRUcmFuc2Zvcm0gfHwgKHRoaXMuX3dvcmxkVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpKTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5fd29ybGRUcmFuc2Zvcm0uY29weUZyb20odGhpcy5yZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudFJlbmRlckdyb3VwKSB7XG4gICAgICB0aGlzLl93b3JsZFRyYW5zZm9ybS5hcHBlbmRGcm9tKHRoaXMucmVsYXRpdmVHcm91cFRyYW5zZm9ybSwgdGhpcy5wYXJlbnRSZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93b3JsZFRyYW5zZm9ybTtcbiAgfVxuICAvLyAvIC8vLy8vLyB0cmFuc2Zvcm0gcmVsYXRlZCBzdHVmZlxuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICogQW4gYWxpYXMgdG8gcG9zaXRpb24ueFxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uLng7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLl9wb3NpdGlvbi54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyIG9uIHRoZSB5IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAqIEFuIGFsaWFzIHRvIHBvc2l0aW9uLnlcbiAgICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbi55O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy5fcG9zaXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gIH1cbiAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fcG9zaXRpb24uY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgKiAncm90YXRpb24nIGFuZCAnYW5nbGUnIGhhdmUgdGhlIHNhbWUgZWZmZWN0IG9uIGEgZGlzcGxheSBvYmplY3Q7IHJvdGF0aW9uIGlzIGluIHJhZGlhbnMsIGFuZ2xlIGlzIGluIGRlZ3JlZXMuXG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICB0aGlzLl9vblVwZGF0ZSh0aGlzLl9za2V3KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmdsZSBvZiB0aGUgb2JqZWN0IGluIGRlZ3JlZXMuXG4gICAqICdyb3RhdGlvbicgYW5kICdhbmdsZScgaGF2ZSB0aGUgc2FtZSBlZmZlY3Qgb24gYSBkaXNwbGF5IG9iamVjdDsgcm90YXRpb24gaXMgaW4gcmFkaWFucywgYW5nbGUgaXMgaW4gZGVncmVlcy5cbiAgICovXG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGlvbiAqIFJBRF9UT19ERUc7XG4gIH1cbiAgc2V0IGFuZ2xlKHZhbHVlKSB7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHZhbHVlICogREVHX1RPX1JBRDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNlbnRlciBvZiByb3RhdGlvbiwgc2NhbGluZywgYW5kIHNrZXdpbmcgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QgaW4gaXRzIGxvY2FsIHNwYWNlLiBUaGUgYHBvc2l0aW9uYFxuICAgKiBpcyB0aGUgcHJvamVjdGlvbiBvZiBgcGl2b3RgIGluIHRoZSBwYXJlbnQncyBsb2NhbCBzcGFjZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHBpdm90IGlzIHRoZSBvcmlnaW4gKDAsIDApLlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBwaXZvdCgpIHtcbiAgICBpZiAodGhpcy5fcGl2b3QgPT09IGRlZmF1bHRQaXZvdCkge1xuICAgICAgdGhpcy5fcGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGl2b3Q7XG4gIH1cbiAgc2V0IHBpdm90KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3Bpdm90ID09PSBkZWZhdWx0UGl2b3QpIHtcbiAgICAgIHRoaXMuX3Bpdm90ID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdGhpcy5fcGl2b3Quc2V0KHZhbHVlKSA6IHRoaXMuX3Bpdm90LmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNrZXcgZmFjdG9yIGZvciB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKi9cbiAgZ2V0IHNrZXcoKSB7XG4gICAgaWYgKHRoaXMuX3NrZXcgPT09IGRlZmF1bHRTa2V3KSB7XG4gICAgICB0aGlzLl9za2V3ID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NrZXc7XG4gIH1cbiAgc2V0IHNrZXcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc2tldyA9PT0gZGVmYXVsdFNrZXcpIHtcbiAgICAgIHRoaXMuX3NrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDAsIDApO1xuICAgIH1cbiAgICB0aGlzLl9za2V3LmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNjYWxlIGZhY3RvcnMgb2YgdGhpcyBvYmplY3QgYWxvbmcgdGhlIGxvY2FsIGNvb3JkaW5hdGUgYXhlcy5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgc2NhbGUgaXMgKDEsIDEpLlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICBpZiAodGhpcy5fc2NhbGUgPT09IGRlZmF1bHRTY2FsZSkge1xuICAgICAgdGhpcy5fc2NhbGUgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDEsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3NjYWxlID09PSBkZWZhdWx0U2NhbGUpIHtcbiAgICAgIHRoaXMuX3NjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdGhpcy5fc2NhbGUuc2V0KHZhbHVlKSA6IHRoaXMuX3NjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGgpO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIGNvbnN0IGxvY2FsV2lkdGggPSB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgdGhpcy5fc2V0V2lkdGgodmFsdWUsIGxvY2FsV2lkdGgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodCk7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGxvY2FsSGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgICB0aGlzLl9zZXRIZWlnaHQodmFsdWUsIGxvY2FsSGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgYXMgYSBbU2l6ZV17QGxpbmsgU2l6ZX0gb2JqZWN0LlxuICAgKiBUaGlzIGlzIGZhc3RlciB0aGFuIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodCBzZXBhcmF0ZWx5LlxuICAgKiBAcGFyYW0gb3V0IC0gT3B0aW9uYWwgb2JqZWN0IHRvIHN0b3JlIHRoZSBzaXplIGluLlxuICAgKiBAcmV0dXJucyAtIFRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRTaXplKG91dCkge1xuICAgIGlmICghb3V0KSB7XG4gICAgICBvdXQgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuICAgIG91dC53aWR0aCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueCAqIGJvdW5kcy53aWR0aCk7XG4gICAgb3V0LmhlaWdodCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueSAqIGJvdW5kcy5oZWlnaHQpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gc2V0dGluZyB0aGUgd2lkdGggYW5kIGhlaWdodCBzZXBhcmF0ZWx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGlzIGNhbiBiZSBlaXRoZXIgYSBudW1iZXIgb3IgYSBbU2l6ZV17QGxpbmsgU2l6ZX0gb2JqZWN0LlxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byBzZXQuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgd2lkdGhgIGlmIG5vdCBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNldFNpemUodmFsdWUsIGhlaWdodCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaGVpZ2h0ID0gdmFsdWUuaGVpZ2h0ID8/IHZhbHVlLndpZHRoO1xuICAgICAgdmFsdWUgPSB2YWx1ZS53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID8/IChoZWlnaHQgPSB2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlICE9PSB2b2lkIDAgJiYgdGhpcy5fc2V0V2lkdGgodmFsdWUsIHNpemUud2lkdGgpO1xuICAgIGhlaWdodCAhPT0gdm9pZCAwICYmIHRoaXMuX3NldEhlaWdodChoZWlnaHQsIHNpemUuaGVpZ2h0KTtcbiAgfVxuICAvKiogQ2FsbGVkIHdoZW4gdGhlIHNrZXcgb3IgdGhlIHJvdGF0aW9uIGNoYW5nZXMuICovXG4gIF91cGRhdGVTa2V3KCkge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5fcm90YXRpb247XG4gICAgY29uc3Qgc2tldyA9IHRoaXMuX3NrZXc7XG4gICAgdGhpcy5fY3ggPSBNYXRoLmNvcyhyb3RhdGlvbiArIHNrZXcuX3kpO1xuICAgIHRoaXMuX3N4ID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3Ll95KTtcbiAgICB0aGlzLl9jeSA9IC1NYXRoLnNpbihyb3RhdGlvbiAtIHNrZXcuX3gpO1xuICAgIHRoaXMuX3N5ID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3Ll94KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgb2YgdGhlIGNvbnRhaW5lciAoYWNjZXB0cyBwYXJ0aWFsIHZhbHVlcykuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgZm9yIHVwZGF0aW5nIHRoZSB0cmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy55IC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuc2NhbGVYIC0gVGhlIHNjYWxlIGZhY3RvciBvbiB0aGUgeC1heGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zY2FsZVkgLSBUaGUgc2NhbGUgZmFjdG9yIG9uIHRoZSB5LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnJvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBjb250YWluZXIsIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNrZXdYIC0gVGhlIHNrZXcgZmFjdG9yIG9uIHRoZSB4LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNrZXdZIC0gVGhlIHNrZXcgZmFjdG9yIG9uIHRoZSB5LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnBpdm90WCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBpdm90IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5waXZvdFkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBwaXZvdCBwb2ludC5cbiAgICovXG4gIHVwZGF0ZVRyYW5zZm9ybShvcHRzKSB7XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoXG4gICAgICB0eXBlb2Ygb3B0cy54ID09PSBcIm51bWJlclwiID8gb3B0cy54IDogdGhpcy5wb3NpdGlvbi54LFxuICAgICAgdHlwZW9mIG9wdHMueSA9PT0gXCJudW1iZXJcIiA/IG9wdHMueSA6IHRoaXMucG9zaXRpb24ueVxuICAgICk7XG4gICAgdGhpcy5zY2FsZS5zZXQoXG4gICAgICB0eXBlb2Ygb3B0cy5zY2FsZVggPT09IFwibnVtYmVyXCIgPyBvcHRzLnNjYWxlWCB8fCAxIDogdGhpcy5zY2FsZS54LFxuICAgICAgdHlwZW9mIG9wdHMuc2NhbGVZID09PSBcIm51bWJlclwiID8gb3B0cy5zY2FsZVkgfHwgMSA6IHRoaXMuc2NhbGUueVxuICAgICk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHR5cGVvZiBvcHRzLnJvdGF0aW9uID09PSBcIm51bWJlclwiID8gb3B0cy5yb3RhdGlvbiA6IHRoaXMucm90YXRpb247XG4gICAgdGhpcy5za2V3LnNldChcbiAgICAgIHR5cGVvZiBvcHRzLnNrZXdYID09PSBcIm51bWJlclwiID8gb3B0cy5za2V3WCA6IHRoaXMuc2tldy54LFxuICAgICAgdHlwZW9mIG9wdHMuc2tld1kgPT09IFwibnVtYmVyXCIgPyBvcHRzLnNrZXdZIDogdGhpcy5za2V3LnlcbiAgICApO1xuICAgIHRoaXMucGl2b3Quc2V0KFxuICAgICAgdHlwZW9mIG9wdHMucGl2b3RYID09PSBcIm51bWJlclwiID8gb3B0cy5waXZvdFggOiB0aGlzLnBpdm90LngsXG4gICAgICB0eXBlb2Ygb3B0cy5waXZvdFkgPT09IFwibnVtYmVyXCIgPyBvcHRzLnBpdm90WSA6IHRoaXMucGl2b3QueVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHRyYW5zZm9ybSB1c2luZyB0aGUgZ2l2ZW4gbWF0cml4LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byB1c2UgZm9yIHVwZGF0aW5nIHRoZSB0cmFuc2Zvcm0uXG4gICAqL1xuICBzZXRGcm9tTWF0cml4KG1hdHJpeCkge1xuICAgIG1hdHJpeC5kZWNvbXBvc2UodGhpcyk7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIGxvY2FsIHRyYW5zZm9ybS4gKi9cbiAgdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgbG9jYWxUcmFuc2Zvcm1DaGFuZ2VJZCA9IHRoaXMuX2RpZENvbnRhaW5lckNoYW5nZVRpY2s7XG4gICAgaWYgKHRoaXMuX2RpZExvY2FsVHJhbnNmb3JtQ2hhbmdlSWQgPT09IGxvY2FsVHJhbnNmb3JtQ2hhbmdlSWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGlkTG9jYWxUcmFuc2Zvcm1DaGFuZ2VJZCA9IGxvY2FsVHJhbnNmb3JtQ2hhbmdlSWQ7XG4gICAgY29uc3QgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fc2NhbGU7XG4gICAgY29uc3QgcGl2b3QgPSB0aGlzLl9waXZvdDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuICAgIGNvbnN0IHN4ID0gc2NhbGUuX3g7XG4gICAgY29uc3Qgc3kgPSBzY2FsZS5feTtcbiAgICBjb25zdCBweCA9IHBpdm90Ll94O1xuICAgIGNvbnN0IHB5ID0gcGl2b3QuX3k7XG4gICAgbHQuYSA9IHRoaXMuX2N4ICogc3g7XG4gICAgbHQuYiA9IHRoaXMuX3N4ICogc3g7XG4gICAgbHQuYyA9IHRoaXMuX2N5ICogc3k7XG4gICAgbHQuZCA9IHRoaXMuX3N5ICogc3k7XG4gICAgbHQudHggPSBwb3NpdGlvbi5feCAtIChweCAqIGx0LmEgKyBweSAqIGx0LmMpO1xuICAgIGx0LnR5ID0gcG9zaXRpb24uX3kgLSAocHggKiBsdC5iICsgcHkgKiBsdC5kKTtcbiAgfVxuICAvLyAvIC8vLy8vIGNvbG9yIHJlbGF0ZWQgc3R1ZmZcbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLmxvY2FsQWxwaGEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5sb2NhbEFscGhhID0gdmFsdWU7XG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgfD0gVVBEQVRFX0NPTE9SO1xuICAgIHRoaXMuX29uVXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRoZSBvcGFjaXR5IG9mIHRoZSBvYmplY3QuICovXG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbEFscGhhO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgY29uc3QgdGVtcENvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHZhbHVlID8/IDE2Nzc3MjE1KTtcbiAgICBjb25zdCBiZ3IgPSB0ZW1wQ29sb3IudG9CZ3JOdW1iZXIoKTtcbiAgICBpZiAoYmdyID09PSB0aGlzLmxvY2FsQ29sb3IpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5sb2NhbENvbG9yID0gYmdyO1xuICAgIHRoaXMuX3VwZGF0ZUZsYWdzIHw9IFVQREFURV9DT0xPUjtcbiAgICB0aGlzLl9vblVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuXG4gICAqXG4gICAqIEEgdmFsdWUgb2YgMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxuICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgKi9cbiAgZ2V0IHRpbnQoKSB7XG4gICAgY29uc3QgYmdyID0gdGhpcy5sb2NhbENvbG9yO1xuICAgIHJldHVybiAoKGJnciAmIDI1NSkgPDwgMTYpICsgKGJnciAmIDY1MjgwKSArIChiZ3IgPj4gMTYgJiAyNTUpO1xuICB9XG4gIC8vIC8gLy8vLy8vLy8vLy8vLy8vLyBibGVuZCByZWxhdGVkIHN0dWZmXG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5sb2NhbEJsZW5kTW9kZSA9PT0gdmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucGFyZW50UmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucGFyZW50UmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgfD0gVVBEQVRFX0JMRU5EO1xuICAgIHRoaXMubG9jYWxCbGVuZE1vZGUgPSB2YWx1ZTtcbiAgICB0aGlzLl9vblVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIEFwcGx5IGEgdmFsdWUgb2YgYCdub3JtYWwnYCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cbiAgICogQGRlZmF1bHQgJ25vcm1hbCdcbiAgICovXG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxCbGVuZE1vZGU7XG4gIH1cbiAgLy8gLyAvLy8vLy8vLy8gVklTSUJJTElUWSAvIFJFTkRFUkFCTEUgLy8vLy8vLy8vLy8vLy8vLy9cbiAgLyoqIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBvYmplY3QuIElmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24sIGFuZCB0aGUgdHJhbnNmb3JtIHdpbGwgbm90IGJlIHVwZGF0ZWQuICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiAhISh0aGlzLmxvY2FsRGlzcGxheVN0YXR1cyAmIDIpO1xuICB9XG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVOdW1iZXIgPSB2YWx1ZSA/IDIgOiAwO1xuICAgIGlmICgodGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgJiAyKSA9PT0gdmFsdWVOdW1iZXIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucGFyZW50UmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucGFyZW50UmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgfD0gVVBEQVRFX1ZJU0lCTEU7XG4gICAgdGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgXj0gMjtcbiAgICB0aGlzLl9vblVwZGF0ZSgpO1xuICB9XG4gIC8qKiBAaWdub3JlICovXG4gIGdldCBjdWxsZWQoKSB7XG4gICAgcmV0dXJuICEodGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgJiA0KTtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICBzZXQgY3VsbGVkKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVOdW1iZXIgPSB2YWx1ZSA/IDAgOiA0O1xuICAgIGlmICgodGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgJiA0KSA9PT0gdmFsdWVOdW1iZXIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucGFyZW50UmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucGFyZW50UmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgfD0gVVBEQVRFX1ZJU0lCTEU7XG4gICAgdGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgXj0gNDtcbiAgICB0aGlzLl9vblVwZGF0ZSgpO1xuICB9XG4gIC8qKiBDYW4gdGhpcyBvYmplY3QgYmUgcmVuZGVyZWQsIGlmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24gYnV0IHRoZSB0cmFuc2Zvcm0gd2lsbCBzdGlsbCBiZSB1cGRhdGVkLiAqL1xuICBnZXQgcmVuZGVyYWJsZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgJiAxKTtcbiAgfVxuICBzZXQgcmVuZGVyYWJsZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gdmFsdWUgPyAxIDogMDtcbiAgICBpZiAoKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgMSkgPT09IHZhbHVlTnVtYmVyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3VwZGF0ZUZsYWdzIHw9IFVQREFURV9WSVNJQkxFO1xuICAgIHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzIF49IDE7XG4gICAgaWYgKHRoaXMucGFyZW50UmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucGFyZW50UmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fb25VcGRhdGUoKTtcbiAgfVxuICAvKiogV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBzaG91bGQgYmUgcmVuZGVyZWQuICovXG4gIGdldCBpc1JlbmRlcmFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzID09PSA3ICYmIHRoaXMuZ3JvdXBBbHBoYSA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGludGVybmFsIHJlZmVyZW5jZXMgYW5kIGxpc3RlbmVycyBhcyB3ZWxsIGFzIHJlbW92ZXMgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxuICAgKiBEbyBub3QgdXNlIGEgQ29udGFpbmVyIGFmdGVyIGNhbGxpbmcgYGRlc3Ryb3lgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XG4gICAqICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGRyZW4gd2l0aCB0ZXh0dXJlcyBlLmcuIFNwcml0ZXMuIElmIG9wdGlvbnMuY2hpbGRyZW5cbiAgICogaXMgc2V0IHRvIHRydWUgaXQgc2hvdWxkIGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIHRleHR1cmVzIGUuZy4gU3ByaXRlcy5cbiAgICogSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSBpdCBzaG91bGQgZGVzdHJveSB0aGUgdGV4dHVyZSBzb3VyY2Ugb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbnRleHQ9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIGdyYXBoaWNzQ29udGV4dHMgZS5nLiBHcmFwaGljcy5cbiAgICogSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSBpdCBzaG91bGQgZGVzdHJveSB0aGUgY29udGV4dCBvZiB0aGUgY2hpbGQgZ3JhcGhpY3NcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IHRoaXMucmVtb3ZlQ2hpbGRyZW4oMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9tYXNrRWZmZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9maWx0ZXJFZmZlY3QgPSBudWxsO1xuICAgIHRoaXMuZWZmZWN0cyA9IG51bGw7XG4gICAgdGhpcy5fcG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuX3NjYWxlID0gbnVsbDtcbiAgICB0aGlzLl9waXZvdCA9IG51bGw7XG4gICAgdGhpcy5fc2tldyA9IG51bGw7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveWVkXCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgZGVzdHJveUNoaWxkcmVuID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LmNoaWxkcmVuO1xuICAgIGlmIChkZXN0cm95Q2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgb2xkQ2hpbGRyZW5baV0uZGVzdHJveShvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJHcm91cD8uZGVzdHJveSgpO1xuICAgIHRoaXMucmVuZGVyR3JvdXAgPSBudWxsO1xuICB9XG59XG5Db250YWluZXIubWl4aW4oY2hpbGRyZW5IZWxwZXJNaXhpbik7XG5Db250YWluZXIubWl4aW4odG9Mb2NhbEdsb2JhbE1peGluKTtcbkNvbnRhaW5lci5taXhpbihvblJlbmRlck1peGluKTtcbkNvbnRhaW5lci5taXhpbihtZWFzdXJlTWl4aW4pO1xuQ29udGFpbmVyLm1peGluKGVmZmVjdHNNaXhpbik7XG5Db250YWluZXIubWl4aW4oZmluZE1peGluKTtcbkNvbnRhaW5lci5taXhpbihzb3J0TWl4aW4pO1xuQ29udGFpbmVyLm1peGluKGN1bGxpbmdNaXhpbik7XG5cbmV4cG9ydCB7IENvbnRhaW5lciwgVVBEQVRFX0JMRU5ELCBVUERBVEVfQ09MT1IsIFVQREFURV9UUkFOU0ZPUk0sIFVQREFURV9WSVNJQkxFIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8400\n')},535:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Y: () => (/* binding */ Bounds)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3904);\n\n\n\n"use strict";\nconst defaultMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Rectangle */ .A();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */\n  fitBounds(left, right, top, bottom) {\n    if (this.minX < left)\n      this.minX = left;\n    if (this.maxX > right)\n      this.maxX = right;\n    if (this.minY < top)\n      this.minY = top;\n    if (this.maxY > bottom)\n      this.maxY = bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Bounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBEO0FBQ007O0FBRWhFO0FBQ0EsMEJBQTBCLHFFQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkVBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXLE9BQU8sV0FBVyxPQUFPLFdBQVcsT0FBTyxXQUFXLFFBQVEsWUFBWSxTQUFTLFlBQVk7QUFDN0k7QUFDQTs7QUFFa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2JvdW5kcy9Cb3VuZHMubWpzPzY0NzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRlZmF1bHRNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jbGFzcyBCb3VuZHMge1xuICBjb25zdHJ1Y3RvcihtaW5YID0gSW5maW5pdHksIG1pblkgPSBJbmZpbml0eSwgbWF4WCA9IC1JbmZpbml0eSwgbWF4WSA9IC1JbmZpbml0eSkge1xuICAgIC8qKiBAZGVmYXVsdCBJbmZpbml0eSAqL1xuICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgIC8qKiBAZGVmYXVsdCBJbmZpbml0eSAqL1xuICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgIC8qKiBAZGVmYXVsdCAtSW5maW5pdHkgKi9cbiAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgLyoqIEBkZWZhdWx0IC1JbmZpbml0eSAqL1xuICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcbiAgICB0aGlzLm1hdHJpeCA9IGRlZmF1bHRNYXRyaXg7XG4gICAgdGhpcy5taW5YID0gbWluWDtcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGJvdW5kcyBhcmUgZW1wdHkuXG4gICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFk7XG4gIH1cbiAgLyoqIFRoZSBib3VuZGluZyByZWN0YW5nbGUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IHJlY3RhbmdsZSgpIHtcbiAgICBpZiAoIXRoaXMuX3JlY3RhbmdsZSkge1xuICAgICAgdGhpcy5fcmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIH1cbiAgICBjb25zdCByZWN0YW5nbGUgPSB0aGlzLl9yZWN0YW5nbGU7XG4gICAgaWYgKHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFkpIHtcbiAgICAgIHJlY3RhbmdsZS54ID0gMDtcbiAgICAgIHJlY3RhbmdsZS55ID0gMDtcbiAgICAgIHJlY3RhbmdsZS53aWR0aCA9IDA7XG4gICAgICByZWN0YW5nbGUuaGVpZ2h0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdGFuZ2xlLmNvcHlGcm9tQm91bmRzKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICB9XG4gIC8qKiBDbGVhcnMgdGhlIGJvdW5kcyBhbmQgcmVzZXRzLiAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xuICAgIHRoaXMubWF0cml4ID0gZGVmYXVsdE1hdHJpeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYm91bmRzLlxuICAgKiBAcGFyYW0geDAgLSBsZWZ0IFggb2YgZnJhbWVcbiAgICogQHBhcmFtIHkwIC0gdG9wIFkgb2YgZnJhbWVcbiAgICogQHBhcmFtIHgxIC0gcmlnaHQgWCBvZiBmcmFtZVxuICAgKiBAcGFyYW0geTEgLSBib3R0b20gWSBvZiBmcmFtZVxuICAgKi9cbiAgc2V0KHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgdGhpcy5taW5YID0geDA7XG4gICAgdGhpcy5taW5ZID0geTA7XG4gICAgdGhpcy5tYXhYID0geDE7XG4gICAgdGhpcy5tYXhZID0geTE7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgc3ByaXRlIGZyYW1lXG4gICAqIEBwYXJhbSB4MCAtIGxlZnQgWCBvZiBmcmFtZVxuICAgKiBAcGFyYW0geTAgLSB0b3AgWSBvZiBmcmFtZVxuICAgKiBAcGFyYW0geDEgLSByaWdodCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MSAtIGJvdHRvbSBZIG9mIGZyYW1lXG4gICAqIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIGFkZEZyYW1lKHgwLCB5MCwgeDEsIHkxLCBtYXRyaXgpIHtcbiAgICBtYXRyaXggfHwgKG1hdHJpeCA9IHRoaXMubWF0cml4KTtcbiAgICBjb25zdCBhID0gbWF0cml4LmE7XG4gICAgY29uc3QgYiA9IG1hdHJpeC5iO1xuICAgIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgICBjb25zdCBkID0gbWF0cml4LmQ7XG4gICAgY29uc3QgdHggPSBtYXRyaXgudHg7XG4gICAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblg7XG4gICAgbGV0IG1pblkgPSB0aGlzLm1pblk7XG4gICAgbGV0IG1heFggPSB0aGlzLm1heFg7XG4gICAgbGV0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgbGV0IHggPSBhICogeDAgKyBjICogeTAgKyB0eDtcbiAgICBsZXQgeSA9IGIgKiB4MCArIGQgKiB5MCArIHR5O1xuICAgIGlmICh4IDwgbWluWClcbiAgICAgIG1pblggPSB4O1xuICAgIGlmICh5IDwgbWluWSlcbiAgICAgIG1pblkgPSB5O1xuICAgIGlmICh4ID4gbWF4WClcbiAgICAgIG1heFggPSB4O1xuICAgIGlmICh5ID4gbWF4WSlcbiAgICAgIG1heFkgPSB5O1xuICAgIHggPSBhICogeDEgKyBjICogeTAgKyB0eDtcbiAgICB5ID0gYiAqIHgxICsgZCAqIHkwICsgdHk7XG4gICAgaWYgKHggPCBtaW5YKVxuICAgICAgbWluWCA9IHg7XG4gICAgaWYgKHkgPCBtaW5ZKVxuICAgICAgbWluWSA9IHk7XG4gICAgaWYgKHggPiBtYXhYKVxuICAgICAgbWF4WCA9IHg7XG4gICAgaWYgKHkgPiBtYXhZKVxuICAgICAgbWF4WSA9IHk7XG4gICAgeCA9IGEgKiB4MCArIGMgKiB5MSArIHR4O1xuICAgIHkgPSBiICogeDAgKyBkICogeTEgKyB0eTtcbiAgICBpZiAoeCA8IG1pblgpXG4gICAgICBtaW5YID0geDtcbiAgICBpZiAoeSA8IG1pblkpXG4gICAgICBtaW5ZID0geTtcbiAgICBpZiAoeCA+IG1heFgpXG4gICAgICBtYXhYID0geDtcbiAgICBpZiAoeSA+IG1heFkpXG4gICAgICBtYXhZID0geTtcbiAgICB4ID0gYSAqIHgxICsgYyAqIHkxICsgdHg7XG4gICAgeSA9IGIgKiB4MSArIGQgKiB5MSArIHR5O1xuICAgIGlmICh4IDwgbWluWClcbiAgICAgIG1pblggPSB4O1xuICAgIGlmICh5IDwgbWluWSlcbiAgICAgIG1pblkgPSB5O1xuICAgIGlmICh4ID4gbWF4WClcbiAgICAgIG1heFggPSB4O1xuICAgIGlmICh5ID4gbWF4WSlcbiAgICAgIG1heFkgPSB5O1xuICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgdGhpcy5taW5ZID0gbWluWTtcbiAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgIHRoaXMubWF4WSA9IG1heFk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByZWN0YW5nbGUgdG8gdGhlIGJvdW5kcy5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGJlIGFkZGVkLlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBseSB0byB0aGUgYm91bmRzLlxuICAgKi9cbiAgYWRkUmVjdChyZWN0LCBtYXRyaXgpIHtcbiAgICB0aGlzLmFkZEZyYW1lKHJlY3QueCwgcmVjdC55LCByZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnkgKyByZWN0LmhlaWdodCwgbWF0cml4KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvdGhlciB7QGxpbmsgQm91bmRzfS5cbiAgICogQHBhcmFtIGJvdW5kcyAtIFRoZSBCb3VuZHMgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgYWRkQm91bmRzKGJvdW5kcywgbWF0cml4KSB7XG4gICAgdGhpcy5hZGRGcmFtZShib3VuZHMubWluWCwgYm91bmRzLm1pblksIGJvdW5kcy5tYXhYLCBib3VuZHMubWF4WSwgbWF0cml4KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvdGhlciBCb3VuZHMsIG1hc2tlZCB3aXRoIEJvdW5kcy5cbiAgICogQHBhcmFtIG1hc2sgLSBUaGUgQm91bmRzIHRvIGJlIGFkZGVkLlxuICAgKi9cbiAgYWRkQm91bmRzTWFzayhtYXNrKSB7XG4gICAgdGhpcy5taW5YID0gdGhpcy5taW5YID4gbWFzay5taW5YID8gdGhpcy5taW5YIDogbWFzay5taW5YO1xuICAgIHRoaXMubWluWSA9IHRoaXMubWluWSA+IG1hc2subWluWSA/IHRoaXMubWluWSA6IG1hc2subWluWTtcbiAgICB0aGlzLm1heFggPSB0aGlzLm1heFggPCBtYXNrLm1heFggPyB0aGlzLm1heFggOiBtYXNrLm1heFg7XG4gICAgdGhpcy5tYXhZID0gdGhpcy5tYXhZIDwgbWFzay5tYXhZID8gdGhpcy5tYXhZIDogbWFzay5tYXhZO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbXVsdGlwbGllZCB3aXRoIG1hdHJpeC5cbiAgICogQHBhcmFtIG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGJvdW5kcy5cbiAgICovXG4gIGFwcGx5TWF0cml4KG1hdHJpeCkge1xuICAgIGNvbnN0IG1pblggPSB0aGlzLm1pblg7XG4gICAgY29uc3QgbWluWSA9IHRoaXMubWluWTtcbiAgICBjb25zdCBtYXhYID0gdGhpcy5tYXhYO1xuICAgIGNvbnN0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCB0eCwgdHkgfSA9IG1hdHJpeDtcbiAgICBsZXQgeCA9IGEgKiBtaW5YICsgYyAqIG1pblkgKyB0eDtcbiAgICBsZXQgeSA9IGIgKiBtaW5YICsgZCAqIG1pblkgKyB0eTtcbiAgICB0aGlzLm1pblggPSB4O1xuICAgIHRoaXMubWluWSA9IHk7XG4gICAgdGhpcy5tYXhYID0geDtcbiAgICB0aGlzLm1heFkgPSB5O1xuICAgIHggPSBhICogbWF4WCArIGMgKiBtaW5ZICsgdHg7XG4gICAgeSA9IGIgKiBtYXhYICsgZCAqIG1pblkgKyB0eTtcbiAgICB0aGlzLm1pblggPSB4IDwgdGhpcy5taW5YID8geCA6IHRoaXMubWluWDtcbiAgICB0aGlzLm1pblkgPSB5IDwgdGhpcy5taW5ZID8geSA6IHRoaXMubWluWTtcbiAgICB0aGlzLm1heFggPSB4ID4gdGhpcy5tYXhYID8geCA6IHRoaXMubWF4WDtcbiAgICB0aGlzLm1heFkgPSB5ID4gdGhpcy5tYXhZID8geSA6IHRoaXMubWF4WTtcbiAgICB4ID0gYSAqIG1pblggKyBjICogbWF4WSArIHR4O1xuICAgIHkgPSBiICogbWluWCArIGQgKiBtYXhZICsgdHk7XG4gICAgdGhpcy5taW5YID0geCA8IHRoaXMubWluWCA/IHggOiB0aGlzLm1pblg7XG4gICAgdGhpcy5taW5ZID0geSA8IHRoaXMubWluWSA/IHkgOiB0aGlzLm1pblk7XG4gICAgdGhpcy5tYXhYID0geCA+IHRoaXMubWF4WCA/IHggOiB0aGlzLm1heFg7XG4gICAgdGhpcy5tYXhZID0geSA+IHRoaXMubWF4WSA/IHkgOiB0aGlzLm1heFk7XG4gICAgeCA9IGEgKiBtYXhYICsgYyAqIG1heFkgKyB0eDtcbiAgICB5ID0gYiAqIG1heFggKyBkICogbWF4WSArIHR5O1xuICAgIHRoaXMubWluWCA9IHggPCB0aGlzLm1pblggPyB4IDogdGhpcy5taW5YO1xuICAgIHRoaXMubWluWSA9IHkgPCB0aGlzLm1pblkgPyB5IDogdGhpcy5taW5ZO1xuICAgIHRoaXMubWF4WCA9IHggPiB0aGlzLm1heFggPyB4IDogdGhpcy5tYXhYO1xuICAgIHRoaXMubWF4WSA9IHkgPiB0aGlzLm1heFkgPyB5IDogdGhpcy5tYXhZO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBib3VuZHMgb2JqZWN0IHRvIGluY2x1ZGUgdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGJlIGluY2x1ZGVkLlxuICAgKi9cbiAgZml0KHJlY3QpIHtcbiAgICBpZiAodGhpcy5taW5YIDwgcmVjdC5sZWZ0KVxuICAgICAgdGhpcy5taW5YID0gcmVjdC5sZWZ0O1xuICAgIGlmICh0aGlzLm1heFggPiByZWN0LnJpZ2h0KVxuICAgICAgdGhpcy5tYXhYID0gcmVjdC5yaWdodDtcbiAgICBpZiAodGhpcy5taW5ZIDwgcmVjdC50b3ApXG4gICAgICB0aGlzLm1pblkgPSByZWN0LnRvcDtcbiAgICBpZiAodGhpcy5tYXhZID4gcmVjdC5ib3R0b20pXG4gICAgICB0aGlzLm1heFkgPSByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgYm91bmRzIG9iamVjdCB0byBpbmNsdWRlIHRoZSBnaXZlbiBib3VuZHMuXG4gICAqIEBwYXJhbSBsZWZ0IC0gVGhlIGxlZnQgdmFsdWUgb2YgdGhlIGJvdW5kcy5cbiAgICogQHBhcmFtIHJpZ2h0IC0gVGhlIHJpZ2h0IHZhbHVlIG9mIHRoZSBib3VuZHMuXG4gICAqIEBwYXJhbSB0b3AgLSBUaGUgdG9wIHZhbHVlIG9mIHRoZSBib3VuZHMuXG4gICAqIEBwYXJhbSBib3R0b20gLSBUaGUgYm90dG9tIHZhbHVlIG9mIHRoZSBib3VuZHMuXG4gICAqL1xuICBmaXRCb3VuZHMobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tKSB7XG4gICAgaWYgKHRoaXMubWluWCA8IGxlZnQpXG4gICAgICB0aGlzLm1pblggPSBsZWZ0O1xuICAgIGlmICh0aGlzLm1heFggPiByaWdodClcbiAgICAgIHRoaXMubWF4WCA9IHJpZ2h0O1xuICAgIGlmICh0aGlzLm1pblkgPCB0b3ApXG4gICAgICB0aGlzLm1pblkgPSB0b3A7XG4gICAgaWYgKHRoaXMubWF4WSA+IGJvdHRvbSlcbiAgICAgIHRoaXMubWF4WSA9IGJvdHRvbTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUGFkcyBib3VuZHMgb2JqZWN0LCBtYWtpbmcgaXQgZ3JvdyBpbiBhbGwgZGlyZWN0aW9ucy5cbiAgICogSWYgcGFkZGluZ1kgaXMgb21pdHRlZCwgYm90aCBwYWRkaW5nWCBhbmQgcGFkZGluZ1kgd2lsbCBiZSBzZXQgdG8gcGFkZGluZ1guXG4gICAqIEBwYXJhbSBwYWRkaW5nWCAtIFRoZSBob3Jpem9udGFsIHBhZGRpbmcgYW1vdW50LlxuICAgKiBAcGFyYW0gcGFkZGluZ1kgLSBUaGUgdmVydGljYWwgcGFkZGluZyBhbW91bnQuXG4gICAqL1xuICBwYWQocGFkZGluZ1gsIHBhZGRpbmdZID0gcGFkZGluZ1gpIHtcbiAgICB0aGlzLm1pblggLT0gcGFkZGluZ1g7XG4gICAgdGhpcy5tYXhYICs9IHBhZGRpbmdYO1xuICAgIHRoaXMubWluWSAtPSBwYWRkaW5nWTtcbiAgICB0aGlzLm1heFkgKz0gcGFkZGluZ1k7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIENlaWxzIHRoZSBib3VuZHMuICovXG4gIGNlaWwoKSB7XG4gICAgdGhpcy5taW5YID0gTWF0aC5mbG9vcih0aGlzLm1pblgpO1xuICAgIHRoaXMubWluWSA9IE1hdGguZmxvb3IodGhpcy5taW5ZKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLmNlaWwodGhpcy5tYXhYKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLmNlaWwodGhpcy5tYXhZKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogQ2xvbmVzIHRoZSBib3VuZHMuICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRzKHRoaXMubWluWCwgdGhpcy5taW5ZLCB0aGlzLm1heFgsIHRoaXMubWF4WSk7XG4gIH1cbiAgLyoqXG4gICAqIFNjYWxlcyB0aGUgYm91bmRzIGJ5IHRoZSBnaXZlbiB2YWx1ZXNcbiAgICogQHBhcmFtIHggLSBUaGUgWCB2YWx1ZSB0byBzY2FsZSBieS5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSB2YWx1ZSB0byBzY2FsZSBieS5cbiAgICovXG4gIHNjYWxlKHgsIHkgPSB4KSB7XG4gICAgdGhpcy5taW5YICo9IHg7XG4gICAgdGhpcy5taW5ZICo9IHk7XG4gICAgdGhpcy5tYXhYICo9IHg7XG4gICAgdGhpcy5tYXhZICo9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIHRoZSB4IHZhbHVlIG9mIHRoZSBib3VuZHMuICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLm1pblg7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMubWF4WCAtIHRoaXMubWluWDtcbiAgICB0aGlzLm1pblggPSB2YWx1ZTtcbiAgICB0aGlzLm1heFggPSB2YWx1ZSArIHdpZHRoO1xuICB9XG4gIC8qKiB0aGUgeSB2YWx1ZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5ZO1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5tYXhZIC0gdGhpcy5taW5ZO1xuICAgIHRoaXMubWluWSA9IHZhbHVlO1xuICAgIHRoaXMubWF4WSA9IHZhbHVlICsgaGVpZ2h0O1xuICB9XG4gIC8qKiB0aGUgd2lkdGggdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLm1heFggLSB0aGlzLm1pblg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5tYXhYID0gdGhpcy5taW5YICsgdmFsdWU7XG4gIH1cbiAgLyoqIHRoZSBoZWlnaHQgdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhZIC0gdGhpcy5taW5ZO1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLm1heFkgPSB0aGlzLm1pblkgKyB2YWx1ZTtcbiAgfVxuICAvKiogdGhlIGxlZnQgdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWDtcbiAgfVxuICAvKiogdGhlIHJpZ2h0IHZhbHVlIG9mIHRoZSBib3VuZHMuICovXG4gIGdldCByaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhYO1xuICB9XG4gIC8qKiB0aGUgdG9wIHZhbHVlIG9mIHRoZSBib3VuZHMuICovXG4gIGdldCB0b3AoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWTtcbiAgfVxuICAvKiogdGhlIGJvdHRvbSB2YWx1ZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgYm90dG9tKCkge1xuICAgIHJldHVybiB0aGlzLm1heFk7XG4gIH1cbiAgLyoqIElzIHRoZSBib3VuZHMgcG9zaXRpdmUuICovXG4gIGdldCBpc1Bvc2l0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLm1heFggLSB0aGlzLm1pblggPiAwICYmIHRoaXMubWF4WSAtIHRoaXMubWluWSA+IDA7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCArIHRoaXMubWluWSAhPT0gSW5maW5pdHk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgc2NyZWVuIHZlcnRpY2VzIGZyb20gYXJyYXlcbiAgICogQHBhcmFtIHZlcnRleERhdGEgLSBjYWxjdWxhdGVkIHZlcnRpY2VzXG4gICAqIEBwYXJhbSBiZWdpbk9mZnNldCAtIGJlZ2luIG9mZnNldFxuICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gZW5kIG9mZnNldCwgZXhjbHVkZWRcbiAgICogQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgYWRkVmVydGV4RGF0YSh2ZXJ0ZXhEYXRhLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0LCBtYXRyaXgpIHtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWDtcbiAgICBsZXQgbWluWSA9IHRoaXMubWluWTtcbiAgICBsZXQgbWF4WCA9IHRoaXMubWF4WDtcbiAgICBsZXQgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBtYXRyaXggfHwgKG1hdHJpeCA9IHRoaXMubWF0cml4KTtcbiAgICBjb25zdCBhID0gbWF0cml4LmE7XG4gICAgY29uc3QgYiA9IG1hdHJpeC5iO1xuICAgIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgICBjb25zdCBkID0gbWF0cml4LmQ7XG4gICAgY29uc3QgdHggPSBtYXRyaXgudHg7XG4gICAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gICAgZm9yIChsZXQgaSA9IGJlZ2luT2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGxvY2FsWCA9IHZlcnRleERhdGFbaV07XG4gICAgICBjb25zdCBsb2NhbFkgPSB2ZXJ0ZXhEYXRhW2kgKyAxXTtcbiAgICAgIGNvbnN0IHggPSBhICogbG9jYWxYICsgYyAqIGxvY2FsWSArIHR4O1xuICAgICAgY29uc3QgeSA9IGIgKiBsb2NhbFggKyBkICogbG9jYWxZICsgdHk7XG4gICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB9XG4gICAgdGhpcy5taW5YID0gbWluWDtcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIHRoZSBib3VuZHMuXG4gICAqIEBwYXJhbSB4IC0geCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB5IC0geSBjb29yZGluYXRlXG4gICAqL1xuICBjb250YWluc1BvaW50KHgsIHkpIHtcbiAgICBpZiAodGhpcy5taW5YIDw9IHggJiYgdGhpcy5taW5ZIDw9IHkgJiYgdGhpcy5tYXhYID49IHggJiYgdGhpcy5tYXhZID49IHkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbcGl4aS5qczpCb3VuZHMgbWluWD0ke3RoaXMubWluWH0gbWluWT0ke3RoaXMubWluWX0gbWF4WD0ke3RoaXMubWF4WH0gbWF4WT0ke3RoaXMubWF4WX0gd2lkdGg9JHt0aGlzLndpZHRofSBoZWlnaHQ9JHt0aGlzLmhlaWdodH1dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvdW5kcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///535\n')},5128:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I_: () => (/* binding */ updateTransformBackwards),\n/* harmony export */   qW: () => (/* binding */ getGlobalBounds)\n/* harmony export */ });\n/* unused harmony export _getGlobalBounds */\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2692);\n\n\n\n"use strict";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .boundsPool */ .W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.addBounds) {\n      bounds.matrix = worldTransform;\n      target.addBounds(bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y.IDENTITY);\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .boundsPool */ .W.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\n\n//# sourceMappingURL=getGlobalBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBEO0FBQ2U7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtFQUFVO0FBQy9CO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCLHFFQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLElBQUksK0VBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0VBQVU7QUFDL0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0VBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLG1DQUFtQyxxRUFBTTtBQUN6QyxJQUFJLCtFQUFVO0FBQ2Q7QUFDQTtBQUNBLElBQUksK0VBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RTtBQUN2RSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldEdsb2JhbEJvdW5kcy5tanM/YzkxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBtYXRyaXhQb29sLCBib3VuZHNQb29sIH0gZnJvbSAnLi91dGlscy9tYXRyaXhBbmRCb3VuZHNQb29sLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0R2xvYmFsQm91bmRzKHRhcmdldCwgc2tpcFVwZGF0ZVRyYW5zZm9ybSwgYm91bmRzKSB7XG4gIGJvdW5kcy5jbGVhcigpO1xuICBsZXQgcGFyZW50VHJhbnNmb3JtO1xuICBsZXQgcG9vbGVkTWF0cml4O1xuICBpZiAodGFyZ2V0LnBhcmVudCkge1xuICAgIGlmICghc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgcG9vbGVkTWF0cml4ID0gbWF0cml4UG9vbC5nZXQoKS5pZGVudGl0eSgpO1xuICAgICAgcGFyZW50VHJhbnNmb3JtID0gdXBkYXRlVHJhbnNmb3JtQmFja3dhcmRzKHRhcmdldCwgcG9vbGVkTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50VHJhbnNmb3JtID0gdGFyZ2V0LnBhcmVudC53b3JsZFRyYW5zZm9ybTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50VHJhbnNmb3JtID0gTWF0cml4LklERU5USVRZO1xuICB9XG4gIF9nZXRHbG9iYWxCb3VuZHModGFyZ2V0LCBib3VuZHMsIHBhcmVudFRyYW5zZm9ybSwgc2tpcFVwZGF0ZVRyYW5zZm9ybSk7XG4gIGlmIChwb29sZWRNYXRyaXgpIHtcbiAgICBtYXRyaXhQb29sLnJldHVybihwb29sZWRNYXRyaXgpO1xuICB9XG4gIGlmICghYm91bmRzLmlzVmFsaWQpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5mdW5jdGlvbiBfZ2V0R2xvYmFsQm91bmRzKHRhcmdldCwgYm91bmRzLCBwYXJlbnRUcmFuc2Zvcm0sIHNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgaWYgKCF0YXJnZXQudmlzaWJsZSB8fCAhdGFyZ2V0Lm1lYXN1cmFibGUpXG4gICAgcmV0dXJuO1xuICBsZXQgd29ybGRUcmFuc2Zvcm07XG4gIGlmICghc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgIHRhcmdldC51cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgIHdvcmxkVHJhbnNmb3JtID0gbWF0cml4UG9vbC5nZXQoKTtcbiAgICB3b3JsZFRyYW5zZm9ybS5hcHBlbmRGcm9tKHRhcmdldC5sb2NhbFRyYW5zZm9ybSwgcGFyZW50VHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JsZFRyYW5zZm9ybSA9IHRhcmdldC53b3JsZFRyYW5zZm9ybTtcbiAgfVxuICBjb25zdCBwYXJlbnRCb3VuZHMgPSBib3VuZHM7XG4gIGNvbnN0IHByZXNlcnZlQm91bmRzID0gISF0YXJnZXQuZWZmZWN0cy5sZW5ndGg7XG4gIGlmIChwcmVzZXJ2ZUJvdW5kcykge1xuICAgIGJvdW5kcyA9IGJvdW5kc1Bvb2wuZ2V0KCkuY2xlYXIoKTtcbiAgfVxuICBpZiAodGFyZ2V0LmJvdW5kc0FyZWEpIHtcbiAgICBib3VuZHMuYWRkUmVjdCh0YXJnZXQuYm91bmRzQXJlYSwgd29ybGRUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQuYWRkQm91bmRzKSB7XG4gICAgICBib3VuZHMubWF0cml4ID0gd29ybGRUcmFuc2Zvcm07XG4gICAgICB0YXJnZXQuYWRkQm91bmRzKGJvdW5kcyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBfZ2V0R2xvYmFsQm91bmRzKHRhcmdldC5jaGlsZHJlbltpXSwgYm91bmRzLCB3b3JsZFRyYW5zZm9ybSwgc2tpcFVwZGF0ZVRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZXJ2ZUJvdW5kcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldC5lZmZlY3RzW2ldLmFkZEJvdW5kcz8uKGJvdW5kcyk7XG4gICAgfVxuICAgIHBhcmVudEJvdW5kcy5hZGRCb3VuZHMoYm91bmRzLCBNYXRyaXguSURFTlRJVFkpO1xuICAgIGJvdW5kc1Bvb2wucmV0dXJuKGJvdW5kcyk7XG4gIH1cbiAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgbWF0cml4UG9vbC5yZXR1cm4od29ybGRUcmFuc2Zvcm0pO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHModGFyZ2V0LCBwYXJlbnRUcmFuc2Zvcm0pIHtcbiAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgaWYgKHBhcmVudCkge1xuICAgIHVwZGF0ZVRyYW5zZm9ybUJhY2t3YXJkcyhwYXJlbnQsIHBhcmVudFRyYW5zZm9ybSk7XG4gICAgcGFyZW50LnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgcGFyZW50VHJhbnNmb3JtLmFwcGVuZChwYXJlbnQubG9jYWxUcmFuc2Zvcm0pO1xuICB9XG4gIHJldHVybiBwYXJlbnRUcmFuc2Zvcm07XG59XG5cbmV4cG9ydCB7IF9nZXRHbG9iYWxCb3VuZHMsIGdldEdsb2JhbEJvdW5kcywgdXBkYXRlVHJhbnNmb3JtQmFja3dhcmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRHbG9iYWxCb3VuZHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5128\n')},3197:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ getLocalBounds)\n/* harmony export */ });\n/* unused harmony export getParent */\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2692);\n\n\n\n\n"use strict";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .boundsPool */ .W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      target.addBounds(bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y.IDENTITY);\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .boundsPool */ .W.return(bounds);\n  }\n  _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.return(relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn("Item is not inside the root container");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\n\n//# sourceMappingURL=getLocalBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEQ7QUFDSDtBQUNrQjs7QUFFekU7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFFQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtFQUFVO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QiwrRUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxtQ0FBbUMscUVBQU07QUFDekMsSUFBSSwrRUFBVTtBQUNkO0FBQ0EsRUFBRSwrRUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldExvY2FsQm91bmRzLm1qcz8xNWY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IG1hdHJpeFBvb2wsIGJvdW5kc1Bvb2wgfSBmcm9tICcuL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRMb2NhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcywgcmVsYXRpdmVNYXRyaXgpIHtcbiAgYm91bmRzLmNsZWFyKCk7XG4gIHJlbGF0aXZlTWF0cml4IHx8IChyZWxhdGl2ZU1hdHJpeCA9IE1hdHJpeC5JREVOVElUWSk7XG4gIF9nZXRMb2NhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcywgcmVsYXRpdmVNYXRyaXgsIHRhcmdldCwgdHJ1ZSk7XG4gIGlmICghYm91bmRzLmlzVmFsaWQpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5mdW5jdGlvbiBfZ2V0TG9jYWxCb3VuZHModGFyZ2V0LCBib3VuZHMsIHBhcmVudFRyYW5zZm9ybSwgcm9vdENvbnRhaW5lciwgaXNSb290KSB7XG4gIGxldCByZWxhdGl2ZVRyYW5zZm9ybTtcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICBpZiAoIXRhcmdldC52aXNpYmxlIHx8ICF0YXJnZXQubWVhc3VyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICB0YXJnZXQudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICBjb25zdCBsb2NhbFRyYW5zZm9ybSA9IHRhcmdldC5sb2NhbFRyYW5zZm9ybTtcbiAgICByZWxhdGl2ZVRyYW5zZm9ybSA9IG1hdHJpeFBvb2wuZ2V0KCk7XG4gICAgcmVsYXRpdmVUcmFuc2Zvcm0uYXBwZW5kRnJvbShsb2NhbFRyYW5zZm9ybSwgcGFyZW50VHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICByZWxhdGl2ZVRyYW5zZm9ybSA9IG1hdHJpeFBvb2wuZ2V0KCk7XG4gICAgcmVsYXRpdmVUcmFuc2Zvcm0gPSBwYXJlbnRUcmFuc2Zvcm0uY29weVRvKHJlbGF0aXZlVHJhbnNmb3JtKTtcbiAgfVxuICBjb25zdCBwYXJlbnRCb3VuZHMgPSBib3VuZHM7XG4gIGNvbnN0IHByZXNlcnZlQm91bmRzID0gISF0YXJnZXQuZWZmZWN0cy5sZW5ndGg7XG4gIGlmIChwcmVzZXJ2ZUJvdW5kcykge1xuICAgIGJvdW5kcyA9IGJvdW5kc1Bvb2wuZ2V0KCkuY2xlYXIoKTtcbiAgfVxuICBpZiAodGFyZ2V0LmJvdW5kc0FyZWEpIHtcbiAgICBib3VuZHMuYWRkUmVjdCh0YXJnZXQuYm91bmRzQXJlYSwgcmVsYXRpdmVUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQucmVuZGVyUGlwZUlkKSB7XG4gICAgICBib3VuZHMubWF0cml4ID0gcmVsYXRpdmVUcmFuc2Zvcm07XG4gICAgICB0YXJnZXQuYWRkQm91bmRzKGJvdW5kcyk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9nZXRMb2NhbEJvdW5kcyhjaGlsZHJlbltpXSwgYm91bmRzLCByZWxhdGl2ZVRyYW5zZm9ybSwgcm9vdENvbnRhaW5lciwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBpZiAocHJlc2VydmVCb3VuZHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5lZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQuZWZmZWN0c1tpXS5hZGRMb2NhbEJvdW5kcz8uKGJvdW5kcywgcm9vdENvbnRhaW5lcik7XG4gICAgfVxuICAgIHBhcmVudEJvdW5kcy5hZGRCb3VuZHMoYm91bmRzLCBNYXRyaXguSURFTlRJVFkpO1xuICAgIGJvdW5kc1Bvb2wucmV0dXJuKGJvdW5kcyk7XG4gIH1cbiAgbWF0cml4UG9vbC5yZXR1cm4ocmVsYXRpdmVUcmFuc2Zvcm0pO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50KHRhcmdldCwgcm9vdCwgbWF0cml4KSB7XG4gIGNvbnN0IHBhcmVudCA9IHRhcmdldC5wYXJlbnQ7XG4gIGlmICghcGFyZW50KSB7XG4gICAgd2FybihcIkl0ZW0gaXMgbm90IGluc2lkZSB0aGUgcm9vdCBjb250YWluZXJcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJlbnQgIT09IHJvb3QpIHtcbiAgICBnZXRQYXJlbnQocGFyZW50LCByb290LCBtYXRyaXgpO1xuICAgIHBhcmVudC51cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgIG1hdHJpeC5hcHBlbmQocGFyZW50LmxvY2FsVHJhbnNmb3JtKTtcbiAgfVxufVxuXG5leHBvcnQgeyBnZXRMb2NhbEJvdW5kcywgZ2V0UGFyZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRMb2NhbEJvdW5kcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3197\n')},2692:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: () => (/* binding */ matrixPool),\n/* harmony export */   W: () => (/* binding */ boundsPool)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5374);\n/* harmony import */ var _Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(535);\n\n\n\n\n"use strict";\nconst matrixPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y);\nconst boundsPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(_Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Bounds */ .Y);\n\n\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ047QUFDaEI7O0FBRXZDO0FBQ0EsdUJBQXVCLCtEQUFJLENBQUMscUVBQU07QUFDbEMsdUJBQXVCLCtEQUFJLENBQUMsd0RBQU07O0FBRUE7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2JvdW5kcy91dGlscy9tYXRyaXhBbmRCb3VuZHNQb29sLm1qcz8xMDY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IFBvb2wgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9wb29sL1Bvb2wubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uL0JvdW5kcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1hdHJpeFBvb2wgPSBuZXcgUG9vbChNYXRyaXgpO1xuY29uc3QgYm91bmRzUG9vbCA9IG5ldyBQb29sKEJvdW5kcyk7XG5cbmV4cG9ydCB7IGJvdW5kc1Bvb2wsIG1hdHJpeFBvb2wgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdHJpeEFuZEJvdW5kc1Bvb2wubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2692\n')},8859:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  I: () => (/* binding */ BatchableGraphics)\n});\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs\n\nfunction multiplyHexColors(color1, color2) {\n  if (color1 === 16777215 || !color2)\n    return color2;\n  if (color2 === 16777215 || !color1)\n    return color1;\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 * r2 / 255;\n  const g = g1 * g2 / 255;\n  const b = b1 * b2 / 255;\n  return (r << 16) + (g << 8) + b;\n}\n\n\n//# sourceMappingURL=multiplyHexColors.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs\n\n\n"use strict";\nclass BatchableGraphics {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.applyTransform = true;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return "normal";\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometryData.indices;\n    for (let i = 0; i < this.indexSize; i++) {\n      indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const geometry = this.geometryData;\n    const graphics = this.renderable;\n    const positions = geometry.vertices;\n    const uvs = geometry.uvs;\n    const offset = this.vertexOffset * 2;\n    const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n    const rgb = this.color;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    if (this.applyTransform) {\n      const argb = multiplyHexColors(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n      const wt = graphics.groupTransform;\n      const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n      const a = wt.a;\n      const b = wt.b;\n      const c = wt.c;\n      const d = wt.d;\n      const tx = wt.tx;\n      const ty = wt.ty;\n      for (let i = offset; i < vertSize; i += 2) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        float32View[index] = a * x + c * y + tx;\n        float32View[index + 1] = b * x + d * y + ty;\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        index += 6;\n      }\n    } else {\n      const argb = bgr + (this.alpha * 255 << 24);\n      for (let i = offset; i < vertSize; i += 2) {\n        float32View[index] = positions[i];\n        float32View[index + 1] = positions[i + 1];\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureId << 16;\n        index += 6;\n      }\n    }\n  }\n  // TODO rename to vertexSize\n  get vertSize() {\n    return this.vertexSize;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.vertexOffset = this.vertexOffset;\n    gpuBuffer.vertexSize = this.vertexSize;\n    gpuBuffer.color = this.color;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n  }\n  reset() {\n    this.applyTransform = true;\n  }\n}\n\n\n//# sourceMappingURL=BatchableGraphics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg1OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0I7OztBQ25CZ0Y7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9tdWx0aXBseUhleENvbG9ycy5tanM/ZDJhOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0JhdGNoYWJsZUdyYXBoaWNzLm1qcz9hYTNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbXVsdGlwbHlIZXhDb2xvcnMoY29sb3IxLCBjb2xvcjIpIHtcbiAgaWYgKGNvbG9yMSA9PT0gMTY3NzcyMTUgfHwgIWNvbG9yMilcbiAgICByZXR1cm4gY29sb3IyO1xuICBpZiAoY29sb3IyID09PSAxNjc3NzIxNSB8fCAhY29sb3IxKVxuICAgIHJldHVybiBjb2xvcjE7XG4gIGNvbnN0IHIxID0gY29sb3IxID4+IDE2ICYgMjU1O1xuICBjb25zdCBnMSA9IGNvbG9yMSA+PiA4ICYgMjU1O1xuICBjb25zdCBiMSA9IGNvbG9yMSAmIDI1NTtcbiAgY29uc3QgcjIgPSBjb2xvcjIgPj4gMTYgJiAyNTU7XG4gIGNvbnN0IGcyID0gY29sb3IyID4+IDggJiAyNTU7XG4gIGNvbnN0IGIyID0gY29sb3IyICYgMjU1O1xuICBjb25zdCByID0gcjEgKiByMiAvIDI1NTtcbiAgY29uc3QgZyA9IGcxICogZzIgLyAyNTU7XG4gIGNvbnN0IGIgPSBiMSAqIGIyIC8gMjU1O1xuICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiO1xufVxuXG5leHBvcnQgeyBtdWx0aXBseUhleENvbG9ycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbHlIZXhDb2xvcnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgbXVsdGlwbHlIZXhDb2xvcnMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvdXRpbHMvbXVsdGlwbHlIZXhDb2xvcnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCYXRjaGFibGVHcmFwaGljcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlciA9IG51bGw7XG4gICAgdGhpcy5iYXRjaCA9IG51bGw7XG4gICAgdGhpcy5hcHBseVRyYW5zZm9ybSA9IHRydWU7XG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IDA7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICBpZiAodGhpcy5hcHBseVRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyYWJsZS5ncm91cEJsZW5kTW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIFwibm9ybWFsXCI7XG4gIH1cbiAgcGFja0luZGV4KGluZGV4QnVmZmVyLCBpbmRleCwgaW5kaWNlc09mZnNldCkge1xuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLmdlb21ldHJ5RGF0YS5pbmRpY2VzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleFNpemU7IGkrKykge1xuICAgICAgaW5kZXhCdWZmZXJbaW5kZXgrK10gPSBpbmRpY2VzW2kgKyB0aGlzLmluZGV4T2Zmc2V0XSArIGluZGljZXNPZmZzZXQgLSB0aGlzLnZlcnRleE9mZnNldDtcbiAgICB9XG4gIH1cbiAgcGFja0F0dHJpYnV0ZXMoZmxvYXQzMlZpZXcsIHVpbnQzMlZpZXcsIGluZGV4LCB0ZXh0dXJlSWQpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnlEYXRhO1xuICAgIGNvbnN0IGdyYXBoaWNzID0gdGhpcy5yZW5kZXJhYmxlO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgIGNvbnN0IHV2cyA9IGdlb21ldHJ5LnV2cztcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnZlcnRleE9mZnNldCAqIDI7XG4gICAgY29uc3QgdmVydFNpemUgPSAodGhpcy52ZXJ0ZXhPZmZzZXQgKyB0aGlzLnZlcnRleFNpemUpICogMjtcbiAgICBjb25zdCByZ2IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IGJnciA9IHJnYiA+PiAxNiB8IHJnYiAmIDY1MjgwIHwgKHJnYiAmIDI1NSkgPDwgMTY7XG4gICAgaWYgKHRoaXMuYXBwbHlUcmFuc2Zvcm0pIHtcbiAgICAgIGNvbnN0IGFyZ2IgPSBtdWx0aXBseUhleENvbG9ycyhiZ3IsIGdyYXBoaWNzLmdyb3VwQ29sb3IpICsgKHRoaXMuYWxwaGEgKiBncmFwaGljcy5ncm91cEFscGhhICogMjU1IDw8IDI0KTtcbiAgICAgIGNvbnN0IHd0ID0gZ3JhcGhpY3MuZ3JvdXBUcmFuc2Zvcm07XG4gICAgICBjb25zdCB0ZXh0dXJlSWRBbmRSb3VuZCA9IHRleHR1cmVJZCA8PCAxNiB8IHRoaXMucm91bmRQaXhlbHMgJiA2NTUzNTtcbiAgICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgICAgY29uc3QgYiA9IHd0LmI7XG4gICAgICBjb25zdCBjID0gd3QuYztcbiAgICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgICAgY29uc3QgdHggPSB3dC50eDtcbiAgICAgIGNvbnN0IHR5ID0gd3QudHk7XG4gICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdmVydFNpemU7IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gcG9zaXRpb25zW2ldO1xuICAgICAgICBjb25zdCB5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXhdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDJdID0gdXZzW2ldO1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDNdID0gdXZzW2kgKyAxXTtcbiAgICAgICAgdWludDMyVmlld1tpbmRleCArIDRdID0gYXJnYjtcbiAgICAgICAgdWludDMyVmlld1tpbmRleCArIDVdID0gdGV4dHVyZUlkQW5kUm91bmQ7XG4gICAgICAgIGluZGV4ICs9IDY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFyZ2IgPSBiZ3IgKyAodGhpcy5hbHBoYSAqIDI1NSA8PCAyNCk7XG4gICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdmVydFNpemU7IGkgKz0gMikge1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSBwb3NpdGlvbnNbaV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMV0gPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDJdID0gdXZzW2ldO1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleCArIDNdID0gdXZzW2kgKyAxXTtcbiAgICAgICAgdWludDMyVmlld1tpbmRleCArIDRdID0gYXJnYjtcbiAgICAgICAgdWludDMyVmlld1tpbmRleCArIDVdID0gdGV4dHVyZUlkIDw8IDE2O1xuICAgICAgICBpbmRleCArPSA2O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBUT0RPIHJlbmFtZSB0byB2ZXJ0ZXhTaXplXG4gIGdldCB2ZXJ0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXhTaXplO1xuICB9XG4gIGNvcHlUbyhncHVCdWZmZXIpIHtcbiAgICBncHVCdWZmZXIuaW5kZXhPZmZzZXQgPSB0aGlzLmluZGV4T2Zmc2V0O1xuICAgIGdwdUJ1ZmZlci5pbmRleFNpemUgPSB0aGlzLmluZGV4U2l6ZTtcbiAgICBncHVCdWZmZXIudmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0ZXhPZmZzZXQ7XG4gICAgZ3B1QnVmZmVyLnZlcnRleFNpemUgPSB0aGlzLnZlcnRleFNpemU7XG4gICAgZ3B1QnVmZmVyLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBncHVCdWZmZXIuYWxwaGEgPSB0aGlzLmFscGhhO1xuICAgIGdwdUJ1ZmZlci50ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIGdwdUJ1ZmZlci5nZW9tZXRyeURhdGEgPSB0aGlzLmdlb21ldHJ5RGF0YTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmFwcGx5VHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXRjaGFibGVHcmFwaGljcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hhYmxlR3JhcGhpY3MubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8859\n')},6475:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ Graphics)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);\n/* harmony import */ var _view_View_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2906);\n/* harmony import */ var _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6653);\n\n\n\n\n"use strict";\nclass Graphics extends _view_View_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ViewContainer */ .$ {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: "Graphics",\n      ...rest\n    });\n    this.renderPipeId = "graphics";\n    if (!context) {\n      this._context = this._ownedContext = new _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g();\n    } else {\n      this._context = context;\n    }\n    this._context.on("update", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off("update", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on("update", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._didGraphicsUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod("setFillStyle", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod("setStrokeStyle", args);\n  }\n  fill(...args) {\n    return this._callContextMethod("fill", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyle parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod("stroke", args);\n  }\n  texture(...args) {\n    return this._callContextMethod("texture", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod("beginPath", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod("cut", []);\n  }\n  arc(...args) {\n    return this._callContextMethod("arc", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod("arcTo", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod("arcToSvg", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod("bezierCurveTo", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod("closePath", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod("ellipse", args);\n  }\n  circle(...args) {\n    return this._callContextMethod("circle", args);\n  }\n  path(...args) {\n    return this._callContextMethod("path", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod("lineTo", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod("moveTo", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod("quadraticCurveTo", args);\n  }\n  rect(...args) {\n    return this._callContextMethod("rect", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod("roundRect", args);\n  }\n  poly(...args) {\n    return this._callContextMethod("poly", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod("regularPoly", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod("roundPoly", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod("roundShape", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod("filletRect", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod("chamferRect", args);\n  }\n  star(...args) {\n    return this._callContextMethod("star", args);\n  }\n  svg(...args) {\n    return this._callContextMethod("svg", args);\n  }\n  restore(...args) {\n    return this._callContextMethod("restore", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod("save", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod("resetTransform", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod("rotate", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod("scale", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod("setTransform", args);\n  }\n  transform(...args) {\n    return this._callContextMethod("transform", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod("translate", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod("clear", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.width || strokeStyle.color !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.color || strokeStyle.alpha !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawCircle has been renamed to Graphics#circle");\n    return this._callContextMethod("circle", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawEllipse has been renamed to Graphics#ellipse");\n    return this._callContextMethod("ellipse", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawPolygon has been renamed to Graphics#poly");\n    return this._callContextMethod("poly", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawRect has been renamed to Graphics#rect");\n    return this._callContextMethod("rect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");\n    return this._callContextMethod("roundRect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawStar has been renamed to Graphics#star");\n    return this._callContextMethod("star", args);\n  }\n}\n\n\n//# sourceMappingURL=Graphics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ3NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkU7QUFDekI7QUFDSTs7QUFFeEQ7QUFDQSx1QkFBdUIsa0VBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQWU7QUFDMUMsa0JBQWtCO0FBQ2xCO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0MsMEVBQWU7QUFDOUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQSw4QkFBOEIsMEVBQWUsbURBQW1ELDBFQUFlLG1EQUFtRCwwRUFBZTtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLG9GQUFXLENBQUMsMkVBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLG9GQUFXLENBQUMsMkVBQU07QUFDdEI7QUFDQTtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3MubWpzPzdjMWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IFZpZXdDb250YWluZXIgfSBmcm9tICcuLi8uLi92aWV3L1ZpZXcubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzQ29udGV4dCB9IGZyb20gJy4vR3JhcGhpY3NDb250ZXh0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3JhcGhpY3MgZXh0ZW5kcyBWaWV3Q29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEdyYXBoaWNzLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgR3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICBvcHRpb25zID0geyBjb250ZXh0OiBvcHRpb25zIH07XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dCwgcm91bmRQaXhlbHMsIC4uLnJlc3QgfSA9IG9wdGlvbnMgfHwge307XG4gICAgc3VwZXIoe1xuICAgICAgbGFiZWw6IFwiR3JhcGhpY3NcIixcbiAgICAgIC4uLnJlc3RcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclBpcGVJZCA9IFwiZ3JhcGhpY3NcIjtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9vd25lZENvbnRleHQgPSBuZXcgR3JhcGhpY3NDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLmFsbG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gcm91bmRQaXhlbHMgPz8gZmFsc2U7XG4gIH1cbiAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB0aGlzLl9jb250ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbnRleHQub2ZmKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLm9uVmlld1VwZGF0ZSgpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbG9jYWwgYm91bmRzIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7cmVuZGVyaW5nLkJvdW5kc31cbiAgICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuYm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBib3VuZHMgb2YgdGhpcyBvYmplY3QgdG8gdGhlIGJvdW5kcyBvYmplY3QuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBUaGUgb3V0cHV0IGJvdW5kcyBvYmplY3QuXG4gICAqL1xuICBhZGRCb3VuZHMoYm91bmRzKSB7XG4gICAgYm91bmRzLmFkZEJvdW5kcyh0aGlzLl9jb250ZXh0LmJvdW5kcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY29udGFpbnNQb2ludChwb2ludCk7XG4gIH1cbiAgb25WaWV3VXBkYXRlKCkge1xuICAgIHRoaXMuX2RpZFZpZXdDaGFuZ2VUaWNrKys7XG4gICAgdGhpcy5fZGlkR3JhcGhpY3NVcGRhdGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRpZFZpZXdVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRWaWV3VXBkYXRlID0gdHJ1ZTtcbiAgICBjb25zdCByZW5kZXJHcm91cCA9IHRoaXMucmVuZGVyR3JvdXAgfHwgdGhpcy5wYXJlbnRSZW5kZXJHcm91cDtcbiAgICBpZiAocmVuZGVyR3JvdXApIHtcbiAgICAgIHJlbmRlckdyb3VwLm9uQ2hpbGRWaWV3VXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBncmFwaGljcyByZW5kZXJhYmxlIGFuZCBvcHRpb25hbGx5IGl0cyBjb250ZXh0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICpcbiAgICogSWYgdGhlIGNvbnRleHQgd2FzIGNyZWF0ZWQgYnkgdGhpcyBncmFwaGljcyBhbmQgYGRlc3Ryb3koZmFsc2UpYCBvciBgZGVzdHJveSgpYCBpcyBjYWxsZWRcbiAgICogdGhlbiB0aGUgY29udGV4dCB3aWxsIHN0aWxsIGJlIGRlc3Ryb3llZC5cbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gZXhwbGljaXRseSBub3QgZGVzdHJveSB0aGlzIGNvbnRleHQgdGhhdCB0aGlzIGdyYXBoaWNzIGNyZWF0ZWQsXG4gICAqIHRoZW4geW91IHNob3VsZCBwYXNzIGRlc3Ryb3koeyBjb250ZXh0OiBmYWxzZSB9KVxuICAgKlxuICAgKiBJZiB0aGUgY29udGV4dCB3YXMgcGFzc2VkIGluIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjb25zdHJ1Y3RvciB0aGVuIGl0IHdpbGwgbm90IGJlIGRlc3Ryb3llZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIGNvbnRleHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlU291cmNlPWZhbHNlXSAtIFNob3VsZCBkZXN0cm95IHRoZSB0ZXh0dXJlIHNvdXJjZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbnRleHQ9ZmFsc2VdIC0gU2hvdWxkIGRlc3Ryb3kgdGhlIGNvbnRleHRcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9vd25lZENvbnRleHQgJiYgIW9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX293bmVkQ29udGV4dC5kZXN0cm95KG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gdHJ1ZSB8fCBvcHRpb25zPy5jb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX293bmVkQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxuICBfY2FsbENvbnRleHRNZXRob2QobWV0aG9kLCBhcmdzKSB7XG4gICAgdGhpcy5jb250ZXh0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEdyYXBoaWNzQ29udGV4dCBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBmaWxsIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBUaGUgZmlsbCBzdHlsZSBjYW4gYmUgYSBjb2xvciwgZ3JhZGllbnQsXG4gICAqIHBhdHRlcm4sIG9yIGEgbW9yZSBjb21wbGV4IHN0eWxlIGRlZmluZWQgYnkgYSBGaWxsU3R5bGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge0ZpbGxJbnB1dH0gYXJncyAtIFRoZSBmaWxsIHN0eWxlIHRvIGFwcGx5LiBUaGlzIGNhbiBiZSBhIHNpbXBsZSBjb2xvciwgYSBncmFkaWVudCBvclxuICAgKiBwYXR0ZXJuIG9iamVjdCwgb3IgYSBGaWxsU3R5bGUgb3IgQ29udmVydGVkRmlsbFN0eWxlIG9iamVjdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2V0RmlsbFN0eWxlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzZXRGaWxsU3R5bGVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBTaW1pbGFyIHRvIGZpbGwgc3R5bGVzLCBzdHJva2Ugc3R5bGVzIGNhblxuICAgKiBlbmNvbXBhc3MgY29sb3JzLCBncmFkaWVudHMsIHBhdHRlcm5zLCBvciBtb3JlIGRldGFpbGVkIGNvbmZpZ3VyYXRpb25zIHZpYSBhIFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJva2VJbnB1dH0gYXJncyAtIFRoZSBzdHJva2Ugc3R5bGUgdG8gYXBwbHkuIENhbiBiZSBkZWZpbmVkIGFzIGEgY29sb3IsIGEgZ3JhZGllbnQgb3IgcGF0dGVybixcbiAgICogb3IgYSBTdHJva2VTdHlsZSBvciBDb252ZXJ0ZWRTdHJva2VTdHlsZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHNldFN0cm9rZVN0eWxlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzZXRTdHJva2VTdHlsZVwiLCBhcmdzKTtcbiAgfVxuICBmaWxsKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJmaWxsXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBTdHJva2VzIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuIFRoaXMgbWV0aG9kIGNhbiB0YWtlIGFuIG9wdGlvbmFsXG4gICAqIEZpbGxTdHlsZSBwYXJhbWV0ZXIgdG8gZGVmaW5lIHRoZSBzdHJva2UncyBhcHBlYXJhbmNlLCBpbmNsdWRpbmcgaXRzIGNvbG9yLCB3aWR0aCwgYW5kIG90aGVyIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7RmlsbFN0eWxlfSBhcmdzIC0gKE9wdGlvbmFsKSBUaGUgc3Ryb2tlIHN0eWxlIHRvIGFwcGx5LiBDYW4gYmUgZGVmaW5lZCBhcyBhIHNpbXBsZSBjb2xvciBvciBhIG1vcmVcbiAgICogY29tcGxleCBzdHlsZSBvYmplY3QuIElmIG9taXR0ZWQsIHVzZXMgdGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBzdHJva2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInN0cm9rZVwiLCBhcmdzKTtcbiAgfVxuICB0ZXh0dXJlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJ0ZXh0dXJlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgcGF0aC4gQW55IHByZXZpb3VzIHBhdGggYW5kIGl0cyBjb21tYW5kcyBhcmUgZGlzY2FyZGVkIGFuZCBhIG5ldyBwYXRoIGlzXG4gICAqIHN0YXJ0ZWQuIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBiZWZvcmUgYmVnaW5uaW5nIGEgbmV3IHNoYXBlIG9yIHNlcmllcyBvZiBkcmF3aW5nIGNvbW1hbmRzLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBiZWdpblBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYmVnaW5QYXRoXCIsIFtdKTtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIGN1dG91dCB0byB0aGUgbGFzdCBkcmF3biBzaGFwZS4gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBob2xlcyBvciBjb21wbGV4IHNoYXBlcyBieVxuICAgKiBzdWJ0cmFjdGluZyBhIHBhdGggZnJvbSB0aGUgcHJldmlvdXNseSBkcmF3biBwYXRoLiBJZiBhIGhvbGUgaXMgbm90IGNvbXBsZXRlbHkgaW4gYSBzaGFwZSwgaXQgd2lsbFxuICAgKiBmYWlsIHRvIGN1dCBjb3JyZWN0bHkhXG4gICAqL1xuICBjdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY3V0XCIsIFtdKTtcbiAgfVxuICBhcmMoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImFyY1wiLCBhcmdzKTtcbiAgfVxuICBhcmNUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYXJjVG9cIiwgYXJncyk7XG4gIH1cbiAgYXJjVG9TdmcoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImFyY1RvU3ZnXCIsIGFyZ3MpO1xuICB9XG4gIGJlemllckN1cnZlVG8oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImJlemllckN1cnZlVG9cIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY3VycmVudCBwYXRoIGJ5IGRyYXdpbmcgYSBzdHJhaWdodCBsaW5lIGJhY2sgdG8gdGhlIHN0YXJ0LlxuICAgKiBJZiB0aGUgc2hhcGUgaXMgYWxyZWFkeSBjbG9zZWQgb3IgdGhlcmUgYXJlIG5vIHBvaW50cyBpbiB0aGUgcGF0aCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNsb3NlUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJjbG9zZVBhdGhcIiwgW10pO1xuICB9XG4gIGVsbGlwc2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImVsbGlwc2VcIiwgYXJncyk7XG4gIH1cbiAgY2lyY2xlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJjaXJjbGVcIiwgYXJncyk7XG4gIH1cbiAgcGF0aCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicGF0aFwiLCBhcmdzKTtcbiAgfVxuICBsaW5lVG8oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImxpbmVUb1wiLCBhcmdzKTtcbiAgfVxuICBtb3ZlVG8oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcIm1vdmVUb1wiLCBhcmdzKTtcbiAgfVxuICBxdWFkcmF0aWNDdXJ2ZVRvKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJxdWFkcmF0aWNDdXJ2ZVRvXCIsIGFyZ3MpO1xuICB9XG4gIHJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJlY3RcIiwgYXJncyk7XG4gIH1cbiAgcm91bmRSZWN0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyb3VuZFJlY3RcIiwgYXJncyk7XG4gIH1cbiAgcG9seSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicG9seVwiLCBhcmdzKTtcbiAgfVxuICByZWd1bGFyUG9seSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVndWxhclBvbHlcIiwgYXJncyk7XG4gIH1cbiAgcm91bmRQb2x5KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyb3VuZFBvbHlcIiwgYXJncyk7XG4gIH1cbiAgcm91bmRTaGFwZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicm91bmRTaGFwZVwiLCBhcmdzKTtcbiAgfVxuICBmaWxsZXRSZWN0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJmaWxsZXRSZWN0XCIsIGFyZ3MpO1xuICB9XG4gIGNoYW1mZXJSZWN0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJjaGFtZmVyUmVjdFwiLCBhcmdzKTtcbiAgfVxuICBzdGFyKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzdGFyXCIsIGFyZ3MpO1xuICB9XG4gIHN2ZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic3ZnXCIsIGFyZ3MpO1xuICB9XG4gIHJlc3RvcmUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJlc3RvcmVcIiwgYXJncyk7XG4gIH1cbiAgLyoqIFNhdmVzIHRoZSBjdXJyZW50IGdyYXBoaWNzIHN0YXRlLCBpbmNsdWRpbmcgdHJhbnNmb3JtYXRpb25zLCBmaWxsIHN0eWxlcywgYW5kIHN0cm9rZSBzdHlsZXMsIG9udG8gYSBzdGFjay4gKi9cbiAgc2F2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzYXZlXCIsIFtdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQuXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICovXG4gIGdldFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldFRyYW5zZm9ybSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIHRoZSBpZGVudGl0eSBtYXRyaXgsIGVmZmVjdGl2ZWx5IHJlbW92aW5nXG4gICAqIGFueSB0cmFuc2Zvcm1hdGlvbnMgKHJvdGF0aW9uLCBzY2FsaW5nLCB0cmFuc2xhdGlvbikgcHJldmlvdXNseSBhcHBsaWVkLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICByZXNldFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZXNldFRyYW5zZm9ybVwiLCBbXSk7XG4gIH1cbiAgcm90YXRlVHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyb3RhdGVcIiwgYXJncyk7XG4gIH1cbiAgc2NhbGVUcmFuc2Zvcm0oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInNjYWxlXCIsIGFyZ3MpO1xuICB9XG4gIHNldFRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2V0VHJhbnNmb3JtXCIsIGFyZ3MpO1xuICB9XG4gIHRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwidHJhbnNmb3JtXCIsIGFyZ3MpO1xuICB9XG4gIHRyYW5zbGF0ZVRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwidHJhbnNsYXRlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGRyYXdpbmcgY29tbWFuZHMgZnJvbSB0aGUgZ3JhcGhpY3MgY29udGV4dCwgZWZmZWN0aXZlbHkgcmVzZXR0aW5nIGl0LiBUaGlzIGluY2x1ZGVzIGNsZWFyaW5nIHRoZSBwYXRoLFxuICAgKiBhbmQgb3B0aW9uYWxseSByZXNldHRpbmcgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBpZGVudGl0eSBtYXRyaXguXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNsZWFyXCIsIFtdKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZpbGwgc3R5bGUgdG8gdXNlLlxuICAgKiBAdHlwZSB7Q29udmVydGVkRmlsbFN0eWxlfVxuICAgKi9cbiAgZ2V0IGZpbGxTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5maWxsU3R5bGU7XG4gIH1cbiAgc2V0IGZpbGxTdHlsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdHJva2Ugc3R5bGUgdG8gdXNlLlxuICAgKiBAdHlwZSB7Q29udmVydGVkU3Ryb2tlU3R5bGV9XG4gICAqL1xuICBnZXQgc3Ryb2tlU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuc3Ryb2tlU3R5bGU7XG4gIH1cbiAgc2V0IHN0cm9rZVN0eWxlKHZhbHVlKSB7XG4gICAgdGhpcy5fY29udGV4dC5zdHJva2VTdHlsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzIG9iamVjdC5cbiAgICogTm90ZSB0aGF0IG9ubHkgdGhlIGNvbnRleHQgb2YgdGhlIG9iamVjdCBpcyBjbG9uZWQsIG5vdCBpdHMgdHJhbnNmb3JtIChwb3NpdGlvbixzY2FsZSxldGMpXG4gICAqIEBwYXJhbSBkZWVwIC0gV2hldGhlciB0byBjcmVhdGUgYSBkZWVwIGNsb25lIG9mIHRoZSBncmFwaGljcyBvYmplY3QuIElmIGZhbHNlLCB0aGUgY29udGV4dFxuICAgKiB3aWxsIGJlIHNoYXJlZCBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cyAoZGVmYXVsdCBmYWxzZSkuIElmIHRydWUsIHRoZSBjb250ZXh0IHdpbGwgYmVcbiAgICogY2xvbmVkIChyZWNvbW1lbmRlZCBpZiB5b3UgbmVlZCB0byBtb2RpZnkgdGhlIGNvbnRleHQgaW4gYW55IHdheSkuXG4gICAqIEByZXR1cm5zIC0gQSBjbG9uZSBvZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0XG4gICAqL1xuICBjbG9uZShkZWVwID0gZmFsc2UpIHtcbiAgICBpZiAoZGVlcCkge1xuICAgICAgcmV0dXJuIG5ldyBHcmFwaGljcyh0aGlzLl9jb250ZXh0LmNsb25lKCkpO1xuICAgIH1cbiAgICB0aGlzLl9vd25lZENvbnRleHQgPSBudWxsO1xuICAgIGNvbnN0IGNsb25lID0gbmV3IEdyYXBoaWNzKHRoaXMuX2NvbnRleHQpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICAvLyAtLS0tLS0tLSB2NyBkZXByZWNhdGlvbnMgLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHBhcmFtIGNvbG9yXG4gICAqIEBwYXJhbSBhbHBoYVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI3NldFN0cm9rZVN0eWxlfSBpbnN0ZWFkXG4gICAqL1xuICBsaW5lU3R5bGUod2lkdGgsIGNvbG9yLCBhbHBoYSkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNsaW5lU3R5bGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gVXNlIEdyYXBoaWNzI3NldFN0cm9rZVN0eWxlIHRvIHNldCB0aGUgc3Ryb2tlIHN0eWxlLlwiKTtcbiAgICBjb25zdCBzdHJva2VTdHlsZSA9IHt9O1xuICAgIHdpZHRoICYmIChzdHJva2VTdHlsZS53aWR0aCA9IHdpZHRoKTtcbiAgICBjb2xvciAmJiAoc3Ryb2tlU3R5bGUuY29sb3IgPSBjb2xvcik7XG4gICAgYWxwaGEgJiYgKHN0cm9rZVN0eWxlLmFscGhhID0gYWxwaGEpO1xuICAgIHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gY29sb3JcbiAgICogQHBhcmFtIGFscGhhXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3MjZmlsbH0gaW5zdGVhZFxuICAgKi9cbiAgYmVnaW5GaWxsKGNvbG9yLCBhbHBoYSkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNiZWdpbkZpbGwgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gVXNlIEdyYXBoaWNzI2ZpbGwgdG8gZmlsbCB0aGUgc2hhcGUgd2l0aCB0aGUgZGVzaXJlZCBzdHlsZS5cIik7XG4gICAgY29uc3QgZmlsbFN0eWxlID0ge307XG4gICAgY29sb3IgJiYgKGZpbGxTdHlsZS5jb2xvciA9IGNvbG9yKTtcbiAgICBhbHBoYSAmJiAoZmlsbFN0eWxlLmFscGhhID0gYWxwaGEpO1xuICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3MjZmlsbH0gaW5zdGVhZFxuICAgKi9cbiAgZW5kRmlsbCgpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZW5kRmlsbCBpcyBubyBsb25nZXIgbmVlZGVkLiBVc2UgR3JhcGhpY3MjZmlsbCB0byBmaWxsIHRoZSBzaGFwZSB3aXRoIHRoZSBkZXNpcmVkIHN0eWxlLlwiKTtcbiAgICB0aGlzLmNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgIGlmIChzdHJva2VTdHlsZS53aWR0aCAhPT0gR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZS53aWR0aCB8fCBzdHJva2VTdHlsZS5jb2xvciAhPT0gR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZS5jb2xvciB8fCBzdHJva2VTdHlsZS5hbHBoYSAhPT0gR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZS5hbHBoYSkge1xuICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNjaXJjbGV9IGluc3RlYWRcbiAgICovXG4gIGRyYXdDaXJjbGUoLi4uYXJncykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNkcmF3Q2lyY2xlIGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3MjY2lyY2xlXCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNpcmNsZVwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNlbGxpcHNlfSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3RWxsaXBzZSguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdFbGxpcHNlIGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3MjZWxsaXBzZVwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJlbGxpcHNlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI3BvbHl9IGluc3RlYWRcbiAgICovXG4gIGRyYXdQb2x5Z29uKC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd1BvbHlnb24gaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNwb2x5XCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInBvbHlcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3MjcmVjdH0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd1JlY3QoLi4uYXJncykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNkcmF3UmVjdCBoYXMgYmVlbiByZW5hbWVkIHRvIEdyYXBoaWNzI3JlY3RcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVjdFwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNyb3VuZFJlY3R9IGluc3RlYWRcbiAgICovXG4gIGRyYXdSb3VuZGVkUmVjdCguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdSb3VuZGVkUmVjdCBoYXMgYmVlbiByZW5hbWVkIHRvIEdyYXBoaWNzI3JvdW5kUmVjdFwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyb3VuZFJlY3RcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3Mjc3Rhcn0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd1N0YXIoLi4uYXJncykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNkcmF3U3RhciBoYXMgYmVlbiByZW5hbWVkIHRvIEdyYXBoaWNzI3N0YXJcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic3RhclwiLCBhcmdzKTtcbiAgfVxufVxuXG5leHBvcnQgeyBHcmFwaGljcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3MubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6475\n')},6653:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  g: () => (/* binding */ GraphicsContext)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/parse-svg-path/index.js\nvar parse_svg_path = __webpack_require__(1379);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs\n\n\n\n"use strict";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse_svg_path(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case "M":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "m":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "H":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "h":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "V":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "v":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "L":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "l":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "C":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case "c":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case "S":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "s":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "Q":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "q":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "T":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "t":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "A":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "a":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "Z":\n      case "z":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        (0,warn/* warn */.Z)(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== "Z" && type !== "z") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\n\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Circle.mjs\n\n\n"use strict";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'circle\'\n     */\n    this.type = "circle";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=Circle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs\n\n\n"use strict";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'ellipse\'\n     */\n    this.type = "ellipse";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x - this.halfWidth;\n    out.y = this.y - this.halfHeight;\n    out.width = this.halfWidth * 2;\n    out.height = this.halfHeight * 2;\n    return out;\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\n\n//# sourceMappingURL=Ellipse.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs\n\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\n\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs\n\n\n\n"use strict";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'polygon\'\n     */\n    this.type = "polygon";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== "number") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\n\n//# sourceMappingURL=Polygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs\n\n\n"use strict";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'roundedRectangle\'\n     */\n    this.type = "roundedRectangle";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=RoundedRectangle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(4108);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs\n\n\n"use strict";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs\n\n\n"use strict";\nconst buildAdaptiveQuadratic_RECURSION_LIMIT = 8;\nconst buildAdaptiveQuadratic_FLT_EPSILON = 11920929e-14;\nconst buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON = 1;\nconst buildAdaptiveQuadratic_curveAngleToleranceEpsilon = 0.01;\nconst buildAdaptiveQuadratic_mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  buildAdaptiveQuadratic_recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction buildAdaptiveQuadratic_recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > buildAdaptiveQuadratic_RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > buildAdaptiveQuadratic_FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (buildAdaptiveQuadratic_mAngleTolerance < buildAdaptiveQuadratic_curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < buildAdaptiveQuadratic_mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  buildAdaptiveQuadratic_recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  buildAdaptiveQuadratic_recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs\n\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\n\n//# sourceMappingURL=buildArc.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs\n\n\n"use strict";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\n\n//# sourceMappingURL=buildArcTo.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs\n\n\n"use strict";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\n\n//# sourceMappingURL=buildArcToSvg.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs\n\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\n\n//# sourceMappingURL=roundShape.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempRectangle = new Rectangle/* Rectangle */.A();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle/* Rectangle */.A(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\n\n//# sourceMappingURL=ShapePath.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    /** unique id for this graphics path */\n    this.uid = (0,uid/* uid */.h)("graphicsPath");\n    this._dirty = true;\n    if (typeof instructions === "string") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: "addPath", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: "arc", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: "arcTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: "arcToSvg", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: "bezierCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point */.E.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== "bezierCurveTo") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: "closePath", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: "ellipse", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: "lineTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: "moveTo", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: "quadraticCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point */.E.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== "quadraticCurveTo") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: "rect", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: "circle", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: "roundRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: "poly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: "regularPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: "roundPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: "roundShape", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: "filletRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: "chamferRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path\'s geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation\'s effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path\'s appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case "moveTo":\n        case "lineTo":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case "bezierCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case "quadraticCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case "arcToSvg":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case "circle":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case "rect":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case "ellipse":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case "roundRect":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case "addPath":\n          data[0].transform(matrix);\n          break;\n        case "poly":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          (0,warn/* warn */.Z)("unknown transform action", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path\'s current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point\'s position is accurately determined regardless of the path\'s complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point\'s coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point\'s coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === "closePath") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case "moveTo":\n      case "lineTo":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case "quadraticCurveTo":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case "bezierCurveTo":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case "arc":\n      case "arcToSvg":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case "addPath":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\n\n//# sourceMappingURL=GraphicsPath.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs\n\n\n\n"use strict";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === "string") {\n    const div = document.createElement("div");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector("svg");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case "path":\n      d = svg.getAttribute("d");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "circle":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      r = parseFloatAttribute(svg, "r", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "rect":\n      x = parseFloatAttribute(svg, "x", 0);\n      y = parseFloatAttribute(svg, "y", 0);\n      width = parseFloatAttribute(svg, "width", 0);\n      height = parseFloatAttribute(svg, "height", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "ellipse":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "line":\n      x1 = parseFloatAttribute(svg, "x1", 0);\n      y1 = parseFloatAttribute(svg, "y1", 0);\n      x2 = parseFloatAttribute(svg, "x2", 0);\n      y2 = parseFloatAttribute(svg, "y2", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polygon":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polyline":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "g":\n    case "svg":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute("style");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(";");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(":");\n      switch (key) {\n        case "stroke":\n          if (value !== "none") {\n            strokeStyle.color = Color/* Color */.I.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case "stroke-width":\n          strokeStyle.width = Number(value);\n          break;\n        case "fill":\n          if (value !== "none") {\n            useFill = true;\n            fillStyle.color = Color/* Color */.I.shared.setValue(value).toNumber();\n          }\n          break;\n        case "fill-opacity":\n          fillStyle.alpha = Number(value);\n          break;\n        case "stroke-opacity":\n          strokeStyle.alpha = Number(value);\n          break;\n        case "opacity":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute("stroke");\n    if (stroke && stroke !== "none") {\n      useStroke = true;\n      strokeStyle.color = Color/* Color */.I.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);\n    }\n    const fill = svg.getAttribute("fill");\n    if (fill && fill !== "none") {\n      useFill = true;\n      fillStyle.color = Color/* Color */.I.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\n\n//# sourceMappingURL=SVGParser.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs\nvar convertFillInputToFillStyle = __webpack_require__(4915);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tmpPoint = new Point/* Point */.E();\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst _GraphicsContext = class _GraphicsContext extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    /** unique id for this graphics context */\n    this.uid = (0,uid/* uid */.h)("graphicsContext");\n    this.dirty = true;\n    this.batchMode = "auto";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix/* Matrix */.y();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* toFillStyle */.f)(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* toStrokeStyle */.m)(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* toFillStyle */.f)(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* toFillStyle */.f)(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: "texture",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color/* Color */.I.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === "number") {\n        (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = (0,convertFillInputToFillStyle/* toFillStyle */.f)(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: "fill",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point/* Point */.E.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = (0,convertFillInputToFillStyle/* toStrokeStyle */.m)(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: "stroke",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The arc\'s radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc\'s radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === "moveTo") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this._activePath.clear();\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit("update", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === "fill") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === "texture") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === "stroke") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it\'s contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === "fill") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: "butt",\n  /** The line join style to use. */\n  join: "miter",\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\n\n\n//# sourceMappingURL=GraphicsContext.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVEsSUFBSSxPQUFPLFFBQVEsWUFBWSxTQUFTLGFBQWEsU0FBUyxZQUFZO0FBQ2pJO0FBQ0E7O0FBRTRCO0FBQzVCOzs7OztBQzdJcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtREFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RDtBQUN2RDs7O0FDaEk2RDtBQUNFO0FBQ0E7QUFDSTtBQUNjO0FBQ25CO0FBQ2lCO0FBQ007QUFDNUI7QUFDSTtBQUNNO0FBQ1k7O0FBRS9FO0FBQ0EsMEJBQTBCLDBCQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxRQUFRO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxVQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QyxxQkFBcUI7QUFDckIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvc3ZnL1NWR1RvR3JhcGhpY3NQYXRoLm1qcz9lYjUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvQ2lyY2xlLm1qcz9kYWMwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvRWxsaXBzZS5tanM/OGRiMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWF0aHMvbWlzYy9zcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50Lm1qcz82OTZhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvUG9seWdvbi5tanM/M2IxYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWF0aHMvc2hhcGVzL1JvdW5kZWRSZWN0YW5nbGUubWpzP2RiOGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQWRhcHRpdmVCZXppZXIubWpzP2M1N2MiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQWRhcHRpdmVRdWFkcmF0aWMubWpzP2E3OGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjLm1qcz81NjZlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFyY1RvLm1qcz84NjYyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFyY1RvU3ZnLm1qcz9hNjVkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvcGF0aC9yb3VuZFNoYXBlLm1qcz9mOTA3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvcGF0aC9TaGFwZVBhdGgubWpzPzYxOTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9wYXRoL0dyYXBoaWNzUGF0aC5tanM/YjQ0YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3N2Zy9TVkdQYXJzZXIubWpzPzhlNGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc0NvbnRleHQubWpzPzQwYzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcnNlIGZyb20gJ3BhcnNlLXN2Zy1wYXRoJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBTVkdUb0dyYXBoaWNzUGF0aChzdmdQYXRoLCBwYXRoKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gcGFyc2Uoc3ZnUGF0aCk7XG4gIGNvbnN0IHN1YnBhdGhzID0gW107XG4gIGxldCBjdXJyZW50U3ViUGF0aCA9IG51bGw7XG4gIGxldCBsYXN0WCA9IDA7XG4gIGxldCBsYXN0WSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb21tYW5kID0gY29tbWFuZHNbaV07XG4gICAgY29uc3QgdHlwZSA9IGNvbW1hbmRbMF07XG4gICAgY29uc3QgZGF0YSA9IGNvbW1hbmQ7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZID0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5tb3ZlVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibVwiOlxuICAgICAgICBsYXN0WCArPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLm1vdmVUbyhsYXN0WCwgbGFzdFkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVsxXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaFwiOlxuICAgICAgICBsYXN0WCArPSBkYXRhWzFdO1xuICAgICAgICBwYXRoLmxpbmVUbyhsYXN0WCwgbGFzdFkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgIGxhc3RZID0gZGF0YVsxXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidlwiOlxuICAgICAgICBsYXN0WSArPSBkYXRhWzFdO1xuICAgICAgICBwYXRoLmxpbmVUbyhsYXN0WCwgbGFzdFkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVsxXTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLmxpbmVUbyhsYXN0WCwgbGFzdFkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgIGxhc3RYICs9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZICs9IGRhdGFbMl07XG4gICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkNcIjpcbiAgICAgICAgbGFzdFggPSBkYXRhWzVdO1xuICAgICAgICBsYXN0WSA9IGRhdGFbNl07XG4gICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBkYXRhWzFdLFxuICAgICAgICAgIGRhdGFbMl0sXG4gICAgICAgICAgZGF0YVszXSxcbiAgICAgICAgICBkYXRhWzRdLFxuICAgICAgICAgIGxhc3RYLFxuICAgICAgICAgIGxhc3RZXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGxhc3RYICsgZGF0YVsxXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbMl0sXG4gICAgICAgICAgbGFzdFggKyBkYXRhWzNdLFxuICAgICAgICAgIGxhc3RZICsgZGF0YVs0XSxcbiAgICAgICAgICBsYXN0WCArIGRhdGFbNV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzZdXG4gICAgICAgICk7XG4gICAgICAgIGxhc3RYICs9IGRhdGFbNV07XG4gICAgICAgIGxhc3RZICs9IGRhdGFbNl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgbGFzdFggPSBkYXRhWzNdO1xuICAgICAgICBsYXN0WSA9IGRhdGFbNF07XG4gICAgICAgIHBhdGguYmV6aWVyQ3VydmVUb1Nob3J0KFxuICAgICAgICAgIGRhdGFbMV0sXG4gICAgICAgICAgZGF0YVsyXSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgIHBhdGguYmV6aWVyQ3VydmVUb1Nob3J0KFxuICAgICAgICAgIGxhc3RYICsgZGF0YVsxXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbMl0sXG4gICAgICAgICAgbGFzdFggKyBkYXRhWzNdLFxuICAgICAgICAgIGxhc3RZICsgZGF0YVs0XVxuICAgICAgICApO1xuICAgICAgICBsYXN0WCArPSBkYXRhWzNdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzRdO1xuICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgZGF0YVsxXSxcbiAgICAgICAgICBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYLFxuICAgICAgICAgIGxhc3RZXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGxhc3RYICsgZGF0YVsxXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbMl0sXG4gICAgICAgICAgbGFzdFggKyBkYXRhWzNdLFxuICAgICAgICAgIGxhc3RZICsgZGF0YVs0XVxuICAgICAgICApO1xuICAgICAgICBsYXN0WCArPSBkYXRhWzNdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVsxXTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG9TaG9ydChcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgIGxhc3RYICs9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZICs9IGRhdGFbMl07XG4gICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUb1Nob3J0KFxuICAgICAgICAgIGxhc3RYLFxuICAgICAgICAgIGxhc3RZXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgbGFzdFggPSBkYXRhWzZdO1xuICAgICAgICBsYXN0WSA9IGRhdGFbN107XG4gICAgICAgIHBhdGguYXJjVG9TdmcoXG4gICAgICAgICAgZGF0YVsxXSxcbiAgICAgICAgICBkYXRhWzJdLFxuICAgICAgICAgIGRhdGFbM10sXG4gICAgICAgICAgZGF0YVs0XSxcbiAgICAgICAgICBkYXRhWzVdLFxuICAgICAgICAgIGxhc3RYLFxuICAgICAgICAgIGxhc3RZXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgbGFzdFggKz0gZGF0YVs2XTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVs3XTtcbiAgICAgICAgcGF0aC5hcmNUb1N2ZyhcbiAgICAgICAgICBkYXRhWzFdLFxuICAgICAgICAgIGRhdGFbMl0sXG4gICAgICAgICAgZGF0YVszXSxcbiAgICAgICAgICBkYXRhWzRdLFxuICAgICAgICAgIGRhdGFbNV0sXG4gICAgICAgICAgbGFzdFgsXG4gICAgICAgICAgbGFzdFlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiWlwiOlxuICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgaWYgKHN1YnBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50U3ViUGF0aCA9IHN1YnBhdGhzLnBvcCgpO1xuICAgICAgICAgIGlmIChjdXJyZW50U3ViUGF0aCkge1xuICAgICAgICAgICAgbGFzdFggPSBjdXJyZW50U3ViUGF0aC5zdGFydFg7XG4gICAgICAgICAgICBsYXN0WSA9IGN1cnJlbnRTdWJQYXRoLnN0YXJ0WTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdFggPSAwO1xuICAgICAgICAgICAgbGFzdFkgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50U3ViUGF0aCA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2FybihgVW5rbm93biBTVkcgcGF0aCBjb21tYW5kOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIGlmICh0eXBlICE9PSBcIlpcIiAmJiB0eXBlICE9PSBcInpcIikge1xuICAgICAgaWYgKGN1cnJlbnRTdWJQYXRoID09PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRTdWJQYXRoID0geyBzdGFydFg6IGxhc3RYLCBzdGFydFk6IGxhc3RZIH07XG4gICAgICAgIHN1YnBhdGhzLnB1c2goY3VycmVudFN1YlBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuZXhwb3J0IHsgU1ZHVG9HcmFwaGljc1BhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNWR1RvR3JhcGhpY3NQYXRoLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4vUmVjdGFuZ2xlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ2lyY2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAnY2lyY2xlJ1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwiY2lyY2xlXCI7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBDaXJjbGUgaW5zdGFuY2VcbiAgICogQHJldHVybnMgQSBjb3B5IG9mIHRoZSBDaXJjbGVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgY2lyY2xlXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBDaXJjbGVcbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy5yYWRpdXMgPD0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByMiA9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG4gICAgbGV0IGR4ID0gdGhpcy54IC0geDtcbiAgICBsZXQgZHkgPSB0aGlzLnkgLSB5O1xuICAgIGR4ICo9IGR4O1xuICAgIGR5ICo9IGR5O1xuICAgIHJldHVybiBkeCArIGR5IDw9IHIyO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZSBpbmNsdWRpbmcgdGhlIHN0cm9rZS5cbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGxpbmUgdG8gY2hlY2tcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBDaXJjbGVcbiAgICovXG4gIHN0cm9rZUNvbnRhaW5zKHgsIHksIHdpZHRoKSB7XG4gICAgaWYgKHRoaXMucmFkaXVzID09PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGR4ID0gdGhpcy54IC0geDtcbiAgICBjb25zdCBkeSA9IHRoaXMueSAtIHk7XG4gICAgY29uc3QgciA9IHRoaXMucmFkaXVzO1xuICAgIGNvbnN0IHcyID0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICByZXR1cm4gZGlzdGFuY2UgPCByICsgdzIgJiYgZGlzdGFuY2UgPiByIC0gdzI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBjaXJjbGUgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gICAqIEBwYXJhbSBvdXRcbiAgICogQHJldHVybnMgVGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAqL1xuICBnZXRCb3VuZHMob3V0KSB7XG4gICAgb3V0ID0gb3V0IHx8IG5ldyBSZWN0YW5nbGUoKTtcbiAgICBvdXQueCA9IHRoaXMueCAtIHRoaXMucmFkaXVzO1xuICAgIG91dC55ID0gdGhpcy55IC0gdGhpcy5yYWRpdXM7XG4gICAgb3V0LndpZHRoID0gdGhpcy5yYWRpdXMgKiAyO1xuICAgIG91dC5oZWlnaHQgPSB0aGlzLnJhZGl1cyAqIDI7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGFub3RoZXIgY2lyY2xlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gY2lyY2xlIC0gVGhlIGNpcmNsZSB0byBjb3B5IGZyb20uXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgY29weUZyb20oY2lyY2xlKSB7XG4gICAgdGhpcy54ID0gY2lyY2xlLng7XG4gICAgdGhpcy55ID0gY2lyY2xlLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBjaXJjbGUucmFkaXVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhpcyBjaXJjbGUgdG8gYW5vdGhlciBvbmUuXG4gICAqIEBwYXJhbSBjaXJjbGUgLSBUaGUgY2lyY2xlIHRvIGNvcHkgdG8uXG4gICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gcGFyYW1ldGVyLlxuICAgKi9cbiAgY29weVRvKGNpcmNsZSkge1xuICAgIGNpcmNsZS5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gY2lyY2xlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW3BpeGkuanMvbWF0aDpDaXJjbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX0gcmFkaXVzPSR7dGhpcy5yYWRpdXN9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgQ2lyY2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaXJjbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi9SZWN0YW5nbGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBFbGxpcHNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIGhhbGZXaWR0aCAtIFRoZSBoYWxmIHdpZHRoIG9mIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0gaGFsZkhlaWdodCAtIFRoZSBoYWxmIGhlaWdodCBvZiB0aGlzIGVsbGlwc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgaGFsZldpZHRoID0gMCwgaGFsZkhlaWdodCA9IDApIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICogQGRlZmF1bHQgJ2VsbGlwc2UnXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gXCJlbGxpcHNlXCI7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuaGFsZldpZHRoID0gaGFsZldpZHRoO1xuICAgIHRoaXMuaGFsZkhlaWdodCA9IGhhbGZIZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIEVsbGlwc2UgaW5zdGFuY2VcbiAgICogQHJldHVybnMge0VsbGlwc2V9IEEgY29weSBvZiB0aGUgZWxsaXBzZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLmhhbGZXaWR0aCwgdGhpcy5oYWxmSGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgKi9cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGlmICh0aGlzLmhhbGZXaWR0aCA8PSAwIHx8IHRoaXMuaGFsZkhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBub3JteCA9ICh4IC0gdGhpcy54KSAvIHRoaXMuaGFsZldpZHRoO1xuICAgIGxldCBub3JteSA9ICh5IC0gdGhpcy55KSAvIHRoaXMuaGFsZkhlaWdodDtcbiAgICBub3JteCAqPSBub3JteDtcbiAgICBub3JteSAqPSBub3JteTtcbiAgICByZXR1cm4gbm9ybXggKyBub3JteSA8PSAxO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsbGlwc2UgaW5jbHVkaW5nIHN0cm9rZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gICAqL1xuICBzdHJva2VDb250YWlucyh4LCB5LCB3aWR0aCkge1xuICAgIGNvbnN0IHsgaGFsZldpZHRoLCBoYWxmSGVpZ2h0IH0gPSB0aGlzO1xuICAgIGlmIChoYWxmV2lkdGggPD0gMCB8fCBoYWxmSGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaGFsZlN0cm9rZVdpZHRoID0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGlubmVyQSA9IGhhbGZXaWR0aCAtIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCBpbm5lckIgPSBoYWxmSGVpZ2h0IC0gaGFsZlN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IG91dGVyQSA9IGhhbGZXaWR0aCArIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCBvdXRlckIgPSBoYWxmSGVpZ2h0ICsgaGFsZlN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRYID0geCAtIHRoaXMueDtcbiAgICBjb25zdCBub3JtYWxpemVkWSA9IHkgLSB0aGlzLnk7XG4gICAgY29uc3QgaW5uZXJFbGxpcHNlID0gbm9ybWFsaXplZFggKiBub3JtYWxpemVkWCAvIChpbm5lckEgKiBpbm5lckEpICsgbm9ybWFsaXplZFkgKiBub3JtYWxpemVkWSAvIChpbm5lckIgKiBpbm5lckIpO1xuICAgIGNvbnN0IG91dGVyRWxsaXBzZSA9IG5vcm1hbGl6ZWRYICogbm9ybWFsaXplZFggLyAob3V0ZXJBICogb3V0ZXJBKSArIG5vcm1hbGl6ZWRZICogbm9ybWFsaXplZFkgLyAob3V0ZXJCICogb3V0ZXJCKTtcbiAgICByZXR1cm4gaW5uZXJFbGxpcHNlID4gMSAmJiBvdXRlckVsbGlwc2UgPD0gMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGVsbGlwc2UgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gICAqIEBwYXJhbSBvdXRcbiAgICogQHJldHVybnMgVGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAqL1xuICBnZXRCb3VuZHMob3V0KSB7XG4gICAgb3V0ID0gb3V0IHx8IG5ldyBSZWN0YW5nbGUoKTtcbiAgICBvdXQueCA9IHRoaXMueCAtIHRoaXMuaGFsZldpZHRoO1xuICAgIG91dC55ID0gdGhpcy55IC0gdGhpcy5oYWxmSGVpZ2h0O1xuICAgIG91dC53aWR0aCA9IHRoaXMuaGFsZldpZHRoICogMjtcbiAgICBvdXQuaGVpZ2h0ID0gdGhpcy5oYWxmSGVpZ2h0ICogMjtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYW5vdGhlciBlbGxpcHNlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gZWxsaXBzZSAtIFRoZSBlbGxpcHNlIHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjb3B5RnJvbShlbGxpcHNlKSB7XG4gICAgdGhpcy54ID0gZWxsaXBzZS54O1xuICAgIHRoaXMueSA9IGVsbGlwc2UueTtcbiAgICB0aGlzLmhhbGZXaWR0aCA9IGVsbGlwc2UuaGFsZldpZHRoO1xuICAgIHRoaXMuaGFsZkhlaWdodCA9IGVsbGlwc2UuaGFsZkhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgZWxsaXBzZSB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIGVsbGlwc2UgLSBUaGUgZWxsaXBzZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhlbGxpcHNlKSB7XG4gICAgZWxsaXBzZS5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gZWxsaXBzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6RWxsaXBzZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSBoYWxmV2lkdGg9JHt0aGlzLmhhbGZXaWR0aH0gaGFsZkhlaWdodD0ke3RoaXMuaGFsZkhlaWdodH1dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBFbGxpcHNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBhID0geCAtIHgxO1xuICBjb25zdCBiID0geSAtIHkxO1xuICBjb25zdCBjID0geDIgLSB4MTtcbiAgY29uc3QgZCA9IHkyIC0geTE7XG4gIGNvbnN0IGRvdCA9IGEgKiBjICsgYiAqIGQ7XG4gIGNvbnN0IGxlblNxID0gYyAqIGMgKyBkICogZDtcbiAgbGV0IHBhcmFtID0gLTE7XG4gIGlmIChsZW5TcSAhPT0gMCkge1xuICAgIHBhcmFtID0gZG90IC8gbGVuU3E7XG4gIH1cbiAgbGV0IHh4O1xuICBsZXQgeXk7XG4gIGlmIChwYXJhbSA8IDApIHtcbiAgICB4eCA9IHgxO1xuICAgIHl5ID0geTE7XG4gIH0gZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgeHggPSB4MjtcbiAgICB5eSA9IHkyO1xuICB9IGVsc2Uge1xuICAgIHh4ID0geDEgKyBwYXJhbSAqIGM7XG4gICAgeXkgPSB5MSArIHBhcmFtICogZDtcbiAgfVxuICBjb25zdCBkeCA9IHggLSB4eDtcbiAgY29uc3QgZHkgPSB5IC0geXk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZXhwb3J0IHsgc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50IH0gZnJvbSAnLi4vbWlzYy9zcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFBvbHlnb24ge1xuICAvKipcbiAgICogQHBhcmFtIHBvaW50cyAtIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9mIFBvaW50c1xuICAgKiAgdGhhdCBmb3JtIHRoZSBwb2x5Z29uLCBhIGZsYXQgYXJyYXkgb2YgbnVtYmVycyB0aGF0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgW3gseSwgeCx5LCAuLi5dLCBvclxuICAgKiAgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGFsbCB0aGUgcG9pbnRzIG9mIHRoZSBwb2x5Z29uIGUuZy5cbiAgICogIGBuZXcgUG9seWdvbihuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIC4uLilgLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmUgZmxhdFxuICAgKiAgeCx5IHZhbHVlcyBlLmcuIGBuZXcgUG9seWdvbih4LHksIHgseSwgeCx5LCAuLi4pYCB3aGVyZSBgeGAgYW5kIGB5YCBhcmUgTnVtYmVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLnBvaW50cykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAncG9seWdvbidcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInBvbHlnb25cIjtcbiAgICBsZXQgZmxhdCA9IEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSA/IHBvaW50c1swXSA6IHBvaW50cztcbiAgICBpZiAodHlwZW9mIGZsYXRbMF0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGZsYXQubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBwLnB1c2goZmxhdFtpXS54LCBmbGF0W2ldLnkpO1xuICAgICAgfVxuICAgICAgZmxhdCA9IHA7XG4gICAgfVxuICAgIHRoaXMucG9pbnRzID0gZmxhdDtcbiAgICB0aGlzLmNsb3NlUGF0aCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIC0gQSBjb3B5IG9mIHRoZSBwb2x5Z29uLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMuc2xpY2UoKTtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICBwb2x5Z29uLmNsb3NlUGF0aCA9IHRoaXMuY2xvc2VQYXRoO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvbi5cbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgIGNvbnN0IHhpID0gdGhpcy5wb2ludHNbaSAqIDJdO1xuICAgICAgY29uc3QgeWkgPSB0aGlzLnBvaW50c1tpICogMiArIDFdO1xuICAgICAgY29uc3QgeGogPSB0aGlzLnBvaW50c1tqICogMl07XG4gICAgICBjb25zdCB5aiA9IHRoaXMucG9pbnRzW2ogKiAyICsgMV07XG4gICAgICBjb25zdCBpbnRlcnNlY3QgPSB5aSA+IHkgIT09IHlqID4geSAmJiB4IDwgKHhqIC0geGkpICogKCh5IC0geWkpIC8gKHlqIC0geWkpKSArIHhpO1xuICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24gaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHN0cm9rZVdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvblxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgc3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaGFsZlN0cm9rZVdpZHRoU3FyZCA9IGhhbGZTdHJva2VXaWR0aCAqIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCB7IHBvaW50cyB9ID0gdGhpcztcbiAgICBjb25zdCBpdGVyYXRpb25MZW5ndGggPSBwb2ludHMubGVuZ3RoIC0gKHRoaXMuY2xvc2VQYXRoID8gMCA6IDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uTGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHgxID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgeTEgPSBwb2ludHNbaSArIDFdO1xuICAgICAgY29uc3QgeDIgPSBwb2ludHNbKGkgKyAyKSAlIHBvaW50cy5sZW5ndGhdO1xuICAgICAgY29uc3QgeTIgPSBwb2ludHNbKGkgKyAzKSAlIHBvaW50cy5sZW5ndGhdO1xuICAgICAgY29uc3QgZGlzdGFuY2VTcXJkID0gc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICBpZiAoZGlzdGFuY2VTcXJkIDw9IGhhbGZTdHJva2VXaWR0aFNxcmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIHBvbHlnb24gYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gICAqIEBwYXJhbSBvdXQgLSBvcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgKiBAcmV0dXJucyBUaGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICovXG4gIGdldEJvdW5kcyhvdXQpIHtcbiAgICBvdXQgPSBvdXQgfHwgbmV3IFJlY3RhbmdsZSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGxldCBtaW5YID0gSW5maW5pdHk7XG4gICAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1pblkgPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICBjb25zdCB5ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIH1cbiAgICBvdXQueCA9IG1pblg7XG4gICAgb3V0LndpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgb3V0LnkgPSBtaW5ZO1xuICAgIG91dC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYW5vdGhlciBwb2x5Z29uIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcG9seWdvbiAtIFRoZSBwb2x5Z29uIHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjb3B5RnJvbShwb2x5Z29uKSB7XG4gICAgdGhpcy5wb2ludHMgPSBwb2x5Z29uLnBvaW50cy5zbGljZSgpO1xuICAgIHRoaXMuY2xvc2VQYXRoID0gcG9seWdvbi5jbG9zZVBhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHBvbHlnb24gdG8gYW5vdGhlciBvbmUuXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHBvbHlnb24gdG8gY29weSB0by5cbiAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBjb3B5VG8ocG9seWdvbikge1xuICAgIHBvbHlnb24uY29weUZyb20odGhpcyk7XG4gICAgcmV0dXJuIHBvbHlnb247XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbcGl4aS5qcy9tYXRoOlBvbHlnb25jbG9zZVN0cm9rZT0ke3RoaXMuY2xvc2VQYXRofXBvaW50cz0ke3RoaXMucG9pbnRzLnJlZHVjZSgocG9pbnRzRGVzYywgY3VycmVudFBvaW50KSA9PiBgJHtwb2ludHNEZXNjfSwgJHtjdXJyZW50UG9pbnR9YCwgXCJcIil9XWA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGFzdFgoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDJdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhc3QgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGxhc3RZKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMl07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDFdO1xuICB9XG59XG5cbmV4cG9ydCB7IFBvbHlnb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvbHlnb24ubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi9SZWN0YW5nbGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc0Nvcm5lcldpdGhpblN0cm9rZSA9IChwWCwgcFksIGNvcm5lclgsIGNvcm5lclksIHJhZGl1cywgaGFsZlN0cm9rZVdpZHRoKSA9PiB7XG4gIGNvbnN0IGR4ID0gcFggLSBjb3JuZXJYO1xuICBjb25zdCBkeSA9IHBZIC0gY29ybmVyWTtcbiAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICByZXR1cm4gZGlzdGFuY2UgPj0gcmFkaXVzIC0gaGFsZlN0cm9rZVdpZHRoICYmIGRpc3RhbmNlIDw9IHJhZGl1cyArIGhhbGZTdHJva2VXaWR0aDtcbn07XG5jbGFzcyBSb3VuZGVkUmVjdGFuZ2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGlzIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSByYWRpdXMgLSBDb250cm9scyB0aGUgcmFkaXVzIG9mIHRoZSByb3VuZGVkIGNvcm5lcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwLCByYWRpdXMgPSAyMCkge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAncm91bmRlZFJlY3RhbmdsZSdcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInJvdW5kZWRSZWN0YW5nbGVcIjtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gICAqIEBwYXJhbSBvdXQgLSBvcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgKiBAcmV0dXJucyBUaGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICovXG4gIGdldEJvdW5kcyhvdXQpIHtcbiAgICBvdXQgPSBvdXQgfHwgbmV3IFJlY3RhbmdsZSgpO1xuICAgIG91dC54ID0gdGhpcy54O1xuICAgIG91dC55ID0gdGhpcy55O1xuICAgIG91dC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgb3V0LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyAtIEEgY29weSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJvdW5kZWRSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIHJlY3RhbmdsZSB0byB0aGlzIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKHJlY3RhbmdsZSkge1xuICAgIHRoaXMueCA9IHJlY3RhbmdsZS54O1xuICAgIHRoaXMueSA9IHJlY3RhbmdsZS55O1xuICAgIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSByZWN0YW5nbGUuaGVpZ2h0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhpcyByZWN0YW5nbGUgdG8gYW5vdGhlciBvbmUuXG4gICAqIEBwYXJhbSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgdG8uXG4gICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gcGFyYW1ldGVyLlxuICAgKi9cbiAgY29weVRvKHJlY3RhbmdsZSkge1xuICAgIHJlY3RhbmdsZS5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgUm91bmRlZCBSZWN0YW5nbGUuXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGgpIHtcbiAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmFkaXVzLCBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyKSk7XG4gICAgICAgIGlmICh5ID49IHRoaXMueSArIHJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gcmFkaXVzIHx8IHggPj0gdGhpcy54ICsgcmFkaXVzICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAtIHJhZGl1cykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkeCA9IHggLSAodGhpcy54ICsgcmFkaXVzKTtcbiAgICAgICAgbGV0IGR5ID0geSAtICh0aGlzLnkgKyByYWRpdXMpO1xuICAgICAgICBjb25zdCByYWRpdXMyID0gcmFkaXVzICogcmFkaXVzO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gcmFkaXVzKTtcbiAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyByZWN0YW5nbGUgaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSBwWCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHBZIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gc3Ryb2tlV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGxpbmUgdG8gY2hlY2tcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyByZWN0YW5nbGVcbiAgICovXG4gIHN0cm9rZUNvbnRhaW5zKHBYLCBwWSwgc3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyB9ID0gdGhpcztcbiAgICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaW5uZXJYID0geCArIHJhZGl1cztcbiAgICBjb25zdCBpbm5lclkgPSB5ICsgcmFkaXVzO1xuICAgIGNvbnN0IGlubmVyV2lkdGggPSB3aWR0aCAtIHJhZGl1cyAqIDI7XG4gICAgY29uc3QgaW5uZXJIZWlnaHQgPSBoZWlnaHQgLSByYWRpdXMgKiAyO1xuICAgIGNvbnN0IHJpZ2h0Qm91bmQgPSB4ICsgd2lkdGg7XG4gICAgY29uc3QgYm90dG9tQm91bmQgPSB5ICsgaGVpZ2h0O1xuICAgIGlmICgocFggPj0geCAtIGhhbGZTdHJva2VXaWR0aCAmJiBwWCA8PSB4ICsgaGFsZlN0cm9rZVdpZHRoIHx8IHBYID49IHJpZ2h0Qm91bmQgLSBoYWxmU3Ryb2tlV2lkdGggJiYgcFggPD0gcmlnaHRCb3VuZCArIGhhbGZTdHJva2VXaWR0aCkgJiYgcFkgPj0gaW5uZXJZICYmIHBZIDw9IGlubmVyWSArIGlubmVySGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKChwWSA+PSB5IC0gaGFsZlN0cm9rZVdpZHRoICYmIHBZIDw9IHkgKyBoYWxmU3Ryb2tlV2lkdGggfHwgcFkgPj0gYm90dG9tQm91bmQgLSBoYWxmU3Ryb2tlV2lkdGggJiYgcFkgPD0gYm90dG9tQm91bmQgKyBoYWxmU3Ryb2tlV2lkdGgpICYmIHBYID49IGlubmVyWCAmJiBwWCA8PSBpbm5lclggKyBpbm5lcldpZHRoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIFRvcC1sZWZ0XG4gICAgICBwWCA8IGlubmVyWCAmJiBwWSA8IGlubmVyWSAmJiBpc0Nvcm5lcldpdGhpblN0cm9rZShwWCwgcFksIGlubmVyWCwgaW5uZXJZLCByYWRpdXMsIGhhbGZTdHJva2VXaWR0aCkgfHwgcFggPiByaWdodEJvdW5kIC0gcmFkaXVzICYmIHBZIDwgaW5uZXJZICYmIGlzQ29ybmVyV2l0aGluU3Ryb2tlKHBYLCBwWSwgcmlnaHRCb3VuZCAtIHJhZGl1cywgaW5uZXJZLCByYWRpdXMsIGhhbGZTdHJva2VXaWR0aCkgfHwgcFggPiByaWdodEJvdW5kIC0gcmFkaXVzICYmIHBZID4gYm90dG9tQm91bmQgLSByYWRpdXMgJiYgaXNDb3JuZXJXaXRoaW5TdHJva2UocFgsIHBZLCByaWdodEJvdW5kIC0gcmFkaXVzLCBib3R0b21Cb3VuZCAtIHJhZGl1cywgcmFkaXVzLCBoYWxmU3Ryb2tlV2lkdGgpIHx8IHBYIDwgaW5uZXJYICYmIHBZID4gYm90dG9tQm91bmQgLSByYWRpdXMgJiYgaXNDb3JuZXJXaXRoaW5TdHJva2UocFgsIHBZLCBpbm5lclgsIGJvdHRvbUJvdW5kIC0gcmFkaXVzLCByYWRpdXMsIGhhbGZTdHJva2VXaWR0aClcbiAgICApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW3BpeGkuanMvbWF0aDpSb3VuZGVkUmVjdGFuZ2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9d2lkdGg9JHt0aGlzLndpZHRofSBoZWlnaHQ9JHt0aGlzLmhlaWdodH0gcmFkaXVzPSR7dGhpcy5yYWRpdXN9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgUm91bmRlZFJlY3RhbmdsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um91bmRlZFJlY3RhbmdsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfSBmcm9tICcuLi9HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSA4O1xuY29uc3QgRkxUX0VQU0lMT04gPSAxMTkyMDkyOWUtMTQ7XG5jb25zdCBQQVRIX0RJU1RBTkNFX0VQU0lMT04gPSAxO1xuY29uc3QgY3VydmVBbmdsZVRvbGVyYW5jZUVwc2lsb24gPSAwLjAxO1xuY29uc3QgbUFuZ2xlVG9sZXJhbmNlID0gMDtcbmNvbnN0IG1DdXNwTGltaXQgPSAwO1xuZnVuY3Rpb24gYnVpbGRBZGFwdGl2ZUJlemllcihwb2ludHMsIHNYLCBzWSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgZVgsIGVZLCBzbW9vdGhuZXNzKSB7XG4gIGNvbnN0IHNjYWxlID0gMTtcbiAgY29uc3Qgc21vb3RoaW5nID0gTWF0aC5taW4oXG4gICAgMC45OSxcbiAgICAvLyBhIHZhbHVlIG9mIDEuMCBhY3R1YWxseSBpbnZlcnRzIHNtb290aGluZywgc28gd2UgY2FwIGl0IGF0IDAuOTlcbiAgICBNYXRoLm1heCgwLCBzbW9vdGhuZXNzID8/IEdyYXBoaWNzQ29udGV4dFN5c3RlbS5kZWZhdWx0T3B0aW9ucy5iZXppZXJTbW9vdGhuZXNzKVxuICApO1xuICBsZXQgZGlzdGFuY2VUb2xlcmFuY2UgPSAoUEFUSF9ESVNUQU5DRV9FUFNJTE9OIC0gc21vb3RoaW5nKSAvIHNjYWxlO1xuICBkaXN0YW5jZVRvbGVyYW5jZSAqPSBkaXN0YW5jZVRvbGVyYW5jZTtcbiAgYmVnaW4oc1gsIHNZLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBlWCwgZVksIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UpO1xuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gYmVnaW4oc1gsIHNZLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBlWCwgZVksIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UpIHtcbiAgcmVjdXJzaXZlKHNYLCBzWSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgZVgsIGVZLCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlLCAwKTtcbiAgcG9pbnRzLnB1c2goZVgsIGVZKTtcbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsKSB7XG4gIGlmIChsZXZlbCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwaSA9IE1hdGguUEk7XG4gIGNvbnN0IHgxMiA9ICh4MSArIHgyKSAvIDI7XG4gIGNvbnN0IHkxMiA9ICh5MSArIHkyKSAvIDI7XG4gIGNvbnN0IHgyMyA9ICh4MiArIHgzKSAvIDI7XG4gIGNvbnN0IHkyMyA9ICh5MiArIHkzKSAvIDI7XG4gIGNvbnN0IHgzNCA9ICh4MyArIHg0KSAvIDI7XG4gIGNvbnN0IHkzNCA9ICh5MyArIHk0KSAvIDI7XG4gIGNvbnN0IHgxMjMgPSAoeDEyICsgeDIzKSAvIDI7XG4gIGNvbnN0IHkxMjMgPSAoeTEyICsgeTIzKSAvIDI7XG4gIGNvbnN0IHgyMzQgPSAoeDIzICsgeDM0KSAvIDI7XG4gIGNvbnN0IHkyMzQgPSAoeTIzICsgeTM0KSAvIDI7XG4gIGNvbnN0IHgxMjM0ID0gKHgxMjMgKyB4MjM0KSAvIDI7XG4gIGNvbnN0IHkxMjM0ID0gKHkxMjMgKyB5MjM0KSAvIDI7XG4gIGlmIChsZXZlbCA+IDApIHtcbiAgICBsZXQgZHggPSB4NCAtIHgxO1xuICAgIGxldCBkeSA9IHk0IC0geTE7XG4gICAgY29uc3QgZDIgPSBNYXRoLmFicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KTtcbiAgICBjb25zdCBkMyA9IE1hdGguYWJzKCh4MyAtIHg0KSAqIGR5IC0gKHkzIC0geTQpICogZHgpO1xuICAgIGxldCBkYTE7XG4gICAgbGV0IGRhMjtcbiAgICBpZiAoZDIgPiBGTFRfRVBTSUxPTiAmJiBkMyA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICBpZiAoKGQyICsgZDMpICogKGQyICsgZDMpIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgICAgICBpZiAobUFuZ2xlVG9sZXJhbmNlIDwgY3VydmVBbmdsZVRvbGVyYW5jZUVwc2lsb24pIHtcbiAgICAgICAgICBwb2ludHMucHVzaCh4MTIzNCwgeTEyMzQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhMjMgPSBNYXRoLmF0YW4yKHkzIC0geTIsIHgzIC0geDIpO1xuICAgICAgICBkYTEgPSBNYXRoLmFicyhhMjMgLSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpKTtcbiAgICAgICAgZGEyID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAtIGEyMyk7XG4gICAgICAgIGlmIChkYTEgPj0gcGkpXG4gICAgICAgICAgZGExID0gMiAqIHBpIC0gZGExO1xuICAgICAgICBpZiAoZGEyID49IHBpKVxuICAgICAgICAgIGRhMiA9IDIgKiBwaSAtIGRhMjtcbiAgICAgICAgaWYgKGRhMSArIGRhMiA8IG1BbmdsZVRvbGVyYW5jZSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgxMjM0LCB5MTIzNCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtQ3VzcExpbWl0ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGRhMSA+IG1DdXNwTGltaXQpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgyLCB5Mik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYTIgPiBtQ3VzcExpbWl0KSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh4MywgeTMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZDIgPiBGTFRfRVBTSUxPTikge1xuICAgICAgaWYgKGQyICogZDIgPD0gZGlzdGFuY2VUb2xlcmFuY2UgKiAoZHggKiBkeCArIGR5ICogZHkpKSB7XG4gICAgICAgIGlmIChtQW5nbGVUb2xlcmFuY2UgPCBjdXJ2ZUFuZ2xlVG9sZXJhbmNlRXBzaWxvbikge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgxMjM0LCB5MTIzNCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhMSA9IE1hdGguYWJzKE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4MikgLSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpKTtcbiAgICAgICAgaWYgKGRhMSA+PSBwaSlcbiAgICAgICAgICBkYTEgPSAyICogcGkgLSBkYTE7XG4gICAgICAgIGlmIChkYTEgPCBtQW5nbGVUb2xlcmFuY2UpIHtcbiAgICAgICAgICBwb2ludHMucHVzaCh4MiwgeTIpO1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgzLCB5Myk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtQ3VzcExpbWl0ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGRhMSA+IG1DdXNwTGltaXQpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgyLCB5Mik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkMyA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICBpZiAoZDMgKiBkMyA8PSBkaXN0YW5jZVRvbGVyYW5jZSAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICAgICAgaWYgKG1BbmdsZVRvbGVyYW5jZSA8IGN1cnZlQW5nbGVUb2xlcmFuY2VFcHNpbG9uKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDEyMzQsIHkxMjM0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGExID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAtIE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4MikpO1xuICAgICAgICBpZiAoZGExID49IHBpKVxuICAgICAgICAgIGRhMSA9IDIgKiBwaSAtIGRhMTtcbiAgICAgICAgaWYgKGRhMSA8IG1BbmdsZVRvbGVyYW5jZSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgyLCB5Mik7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDMsIHkzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1DdXNwTGltaXQgIT09IDApIHtcbiAgICAgICAgICBpZiAoZGExID4gbUN1c3BMaW1pdCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeDMsIHkzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHggPSB4MTIzNCAtICh4MSArIHg0KSAvIDI7XG4gICAgICBkeSA9IHkxMjM0IC0gKHkxICsgeTQpIC8gMjtcbiAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICAgICAgICBwb2ludHMucHVzaCh4MTIzNCwgeTEyMzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlY3Vyc2l2ZSh4MSwgeTEsIHgxMiwgeTEyLCB4MTIzLCB5MTIzLCB4MTIzNCwgeTEyMzQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSk7XG4gIHJlY3Vyc2l2ZSh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSk7XG59XG5cbmV4cG9ydCB7IGJ1aWxkQWRhcHRpdmVCZXppZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQWRhcHRpdmVCZXppZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgR3JhcGhpY3NDb250ZXh0U3lzdGVtIH0gZnJvbSAnLi4vR3JhcGhpY3NDb250ZXh0U3lzdGVtLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gODtcbmNvbnN0IEZMVF9FUFNJTE9OID0gMTE5MjA5MjllLTE0O1xuY29uc3QgUEFUSF9ESVNUQU5DRV9FUFNJTE9OID0gMTtcbmNvbnN0IGN1cnZlQW5nbGVUb2xlcmFuY2VFcHNpbG9uID0gMC4wMTtcbmNvbnN0IG1BbmdsZVRvbGVyYW5jZSA9IDA7XG5mdW5jdGlvbiBidWlsZEFkYXB0aXZlUXVhZHJhdGljKHBvaW50cywgc1gsIHNZLCBjcDF4LCBjcDF5LCBlWCwgZVksIHNtb290aG5lc3MpIHtcbiAgY29uc3Qgc2NhbGUgPSAxO1xuICBjb25zdCBzbW9vdGhpbmcgPSBNYXRoLm1pbihcbiAgICAwLjk5LFxuICAgIC8vIGEgdmFsdWUgb2YgMS4wIGFjdHVhbGx5IGludmVydHMgc21vb3RoaW5nLCBzbyB3ZSBjYXAgaXQgYXQgMC45OVxuICAgIE1hdGgubWF4KDAsIHNtb290aG5lc3MgPz8gR3JhcGhpY3NDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLmJlemllclNtb290aG5lc3MpXG4gICk7XG4gIGxldCBkaXN0YW5jZVRvbGVyYW5jZSA9IChQQVRIX0RJU1RBTkNFX0VQU0lMT04gLSBzbW9vdGhpbmcpIC8gc2NhbGU7XG4gIGRpc3RhbmNlVG9sZXJhbmNlICo9IGRpc3RhbmNlVG9sZXJhbmNlO1xuICBiZWdpbihzWCwgc1ksIGNwMXgsIGNwMXksIGVYLCBlWSwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBiZWdpbihzWCwgc1ksIGNwMXgsIGNwMXksIGVYLCBlWSwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICByZWN1cnNpdmUocG9pbnRzLCBzWCwgc1ksIGNwMXgsIGNwMXksIGVYLCBlWSwgZGlzdGFuY2VUb2xlcmFuY2UsIDApO1xuICBwb2ludHMucHVzaChlWCwgZVkpO1xufVxuZnVuY3Rpb24gcmVjdXJzaXZlKHBvaW50cywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsKSB7XG4gIGlmIChsZXZlbCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwaSA9IE1hdGguUEk7XG4gIGNvbnN0IHgxMiA9ICh4MSArIHgyKSAvIDI7XG4gIGNvbnN0IHkxMiA9ICh5MSArIHkyKSAvIDI7XG4gIGNvbnN0IHgyMyA9ICh4MiArIHgzKSAvIDI7XG4gIGNvbnN0IHkyMyA9ICh5MiArIHkzKSAvIDI7XG4gIGNvbnN0IHgxMjMgPSAoeDEyICsgeDIzKSAvIDI7XG4gIGNvbnN0IHkxMjMgPSAoeTEyICsgeTIzKSAvIDI7XG4gIGxldCBkeCA9IHgzIC0geDE7XG4gIGxldCBkeSA9IHkzIC0geTE7XG4gIGNvbnN0IGQgPSBNYXRoLmFicygoeDIgLSB4MykgKiBkeSAtICh5MiAtIHkzKSAqIGR4KTtcbiAgaWYgKGQgPiBGTFRfRVBTSUxPTikge1xuICAgIGlmIChkICogZCA8PSBkaXN0YW5jZVRvbGVyYW5jZSAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICAgIGlmIChtQW5nbGVUb2xlcmFuY2UgPCBjdXJ2ZUFuZ2xlVG9sZXJhbmNlRXBzaWxvbikge1xuICAgICAgICBwb2ludHMucHVzaCh4MTIzLCB5MTIzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRhID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKSAtIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkpO1xuICAgICAgaWYgKGRhID49IHBpKVxuICAgICAgICBkYSA9IDIgKiBwaSAtIGRhO1xuICAgICAgaWYgKGRhIDwgbUFuZ2xlVG9sZXJhbmNlKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHgxMjMsIHkxMjMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGR4ID0geDEyMyAtICh4MSArIHgzKSAvIDI7XG4gICAgZHkgPSB5MTIzIC0gKHkxICsgeTMpIC8gMjtcbiAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gZGlzdGFuY2VUb2xlcmFuY2UpIHtcbiAgICAgIHBvaW50cy5wdXNoKHgxMjMsIHkxMjMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZWN1cnNpdmUocG9pbnRzLCB4MSwgeTEsIHgxMiwgeTEyLCB4MTIzLCB5MTIzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwgKyAxKTtcbiAgcmVjdXJzaXZlKHBvaW50cywgeDEyMywgeTEyMywgeDIzLCB5MjMsIHgzLCB5MywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSk7XG59XG5cbmV4cG9ydCB7IGJ1aWxkQWRhcHRpdmVRdWFkcmF0aWMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQWRhcHRpdmVRdWFkcmF0aWMubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBidWlsZEFyYyhwb2ludHMsIHgsIHksIHJhZGl1cywgc3RhcnQsIGVuZCwgY2xvY2t3aXNlLCBzdGVwcykge1xuICBsZXQgZGlzdCA9IE1hdGguYWJzKHN0YXJ0IC0gZW5kKTtcbiAgaWYgKCFjbG9ja3dpc2UgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICBkaXN0ID0gMiAqIE1hdGguUEkgLSBkaXN0O1xuICB9IGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBlbmQgPiBzdGFydCkge1xuICAgIGRpc3QgPSAyICogTWF0aC5QSSAtIGRpc3Q7XG4gIH1cbiAgc3RlcHMgPSBzdGVwcyB8fCBNYXRoLm1heCg2LCBNYXRoLmZsb29yKDYgKiBNYXRoLnBvdyhyYWRpdXMsIDEgLyAzKSAqIChkaXN0IC8gTWF0aC5QSSkpKTtcbiAgc3RlcHMgPSBNYXRoLm1heChzdGVwcywgMyk7XG4gIGxldCBmID0gZGlzdCAvIHN0ZXBzO1xuICBsZXQgdCA9IHN0YXJ0O1xuICBmICo9IGNsb2Nrd2lzZSA/IC0xIDogMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwcyArIDE7IGkrKykge1xuICAgIGNvbnN0IGNzID0gTWF0aC5jb3ModCk7XG4gICAgY29uc3Qgc24gPSBNYXRoLnNpbih0KTtcbiAgICBjb25zdCBueCA9IHggKyBjcyAqIHJhZGl1cztcbiAgICBjb25zdCBueSA9IHkgKyBzbiAqIHJhZGl1cztcbiAgICBwb2ludHMucHVzaChueCwgbnkpO1xuICAgIHQgKz0gZjtcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZEFyYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRBcmMubWpzLm1hcFxuIiwiaW1wb3J0IHsgYnVpbGRBcmMgfSBmcm9tICcuL2J1aWxkQXJjLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYnVpbGRBcmNUbyhwb2ludHMsIHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgY29uc3QgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGExID0gZnJvbVkgLSB5MTtcbiAgY29uc3QgYjEgPSBmcm9tWCAtIHgxO1xuICBjb25zdCBhMiA9IHkyIC0geTE7XG4gIGNvbnN0IGIyID0geDIgLSB4MTtcbiAgY29uc3QgbW0gPSBNYXRoLmFicyhhMSAqIGIyIC0gYjEgKiBhMik7XG4gIGlmIChtbSA8IDFlLTggfHwgcmFkaXVzID09PSAwKSB7XG4gICAgaWYgKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gIT09IHgxIHx8IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gIT09IHkxKSB7XG4gICAgICBwb2ludHMucHVzaCh4MSwgeTEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGQgPSBhMSAqIGExICsgYjEgKiBiMTtcbiAgY29uc3QgY2MgPSBhMiAqIGEyICsgYjIgKiBiMjtcbiAgY29uc3QgdHQgPSBhMSAqIGEyICsgYjEgKiBiMjtcbiAgY29uc3QgazEgPSByYWRpdXMgKiBNYXRoLnNxcnQoZGQpIC8gbW07XG4gIGNvbnN0IGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tO1xuICBjb25zdCBqMSA9IGsxICogdHQgLyBkZDtcbiAgY29uc3QgajIgPSBrMiAqIHR0IC8gY2M7XG4gIGNvbnN0IGN4ID0gazEgKiBiMiArIGsyICogYjE7XG4gIGNvbnN0IGN5ID0gazEgKiBhMiArIGsyICogYTE7XG4gIGNvbnN0IHB4ID0gYjEgKiAoazIgKyBqMSk7XG4gIGNvbnN0IHB5ID0gYTEgKiAoazIgKyBqMSk7XG4gIGNvbnN0IHF4ID0gYjIgKiAoazEgKyBqMik7XG4gIGNvbnN0IHF5ID0gYTIgKiAoazEgKyBqMik7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpO1xuICBjb25zdCBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG4gIGJ1aWxkQXJjKFxuICAgIHBvaW50cyxcbiAgICBjeCArIHgxLFxuICAgIGN5ICsgeTEsXG4gICAgcmFkaXVzLFxuICAgIHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUsXG4gICAgYjEgKiBhMiA+IGIyICogYTFcbiAgKTtcbn1cblxuZXhwb3J0IHsgYnVpbGRBcmNUbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRBcmNUby5tanMubWFwXG4iLCJpbXBvcnQgeyBidWlsZEFkYXB0aXZlQmV6aWVyIH0gZnJvbSAnLi9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgVEFVID0gTWF0aC5QSSAqIDI7XG5jb25zdCBvdXQgPSB7XG4gIGNlbnRlclg6IDAsXG4gIGNlbnRlclk6IDAsXG4gIGFuZzE6IDAsXG4gIGFuZzI6IDBcbn07XG5jb25zdCBtYXBUb0VsbGlwc2UgPSAoeyB4LCB5IH0sIHJ4LCByeSwgY29zUGhpLCBzaW5QaGksIGNlbnRlclgsIGNlbnRlclksIG91dDIpID0+IHtcbiAgeCAqPSByeDtcbiAgeSAqPSByeTtcbiAgY29uc3QgeHAgPSBjb3NQaGkgKiB4IC0gc2luUGhpICogeTtcbiAgY29uc3QgeXAgPSBzaW5QaGkgKiB4ICsgY29zUGhpICogeTtcbiAgb3V0Mi54ID0geHAgKyBjZW50ZXJYO1xuICBvdXQyLnkgPSB5cCArIGNlbnRlclk7XG4gIHJldHVybiBvdXQyO1xufTtcbmZ1bmN0aW9uIGFwcHJveFVuaXRBcmMoYW5nMSwgYW5nMikge1xuICBjb25zdCBhMSA9IGFuZzIgPT09IC0xLjU3MDc5NjMyNjc5NDg5NjYgPyAtMC41NTE5MTUwMjQ0OTQgOiA0IC8gMyAqIE1hdGgudGFuKGFuZzIgLyA0KTtcbiAgY29uc3QgYSA9IGFuZzIgPT09IDEuNTcwNzk2MzI2Nzk0ODk2NiA/IDAuNTUxOTE1MDI0NDk0IDogYTE7XG4gIGNvbnN0IHgxID0gTWF0aC5jb3MoYW5nMSk7XG4gIGNvbnN0IHkxID0gTWF0aC5zaW4oYW5nMSk7XG4gIGNvbnN0IHgyID0gTWF0aC5jb3MoYW5nMSArIGFuZzIpO1xuICBjb25zdCB5MiA9IE1hdGguc2luKGFuZzEgKyBhbmcyKTtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB4OiB4MSAtIHkxICogYSxcbiAgICAgIHk6IHkxICsgeDEgKiBhXG4gICAgfSxcbiAgICB7XG4gICAgICB4OiB4MiArIHkyICogYSxcbiAgICAgIHk6IHkyIC0geDIgKiBhXG4gICAgfSxcbiAgICB7XG4gICAgICB4OiB4MixcbiAgICAgIHk6IHkyXG4gICAgfVxuICBdO1xufVxuY29uc3QgdmVjdG9yQW5nbGUgPSAodXgsIHV5LCB2eCwgdnkpID0+IHtcbiAgY29uc3Qgc2lnbiA9IHV4ICogdnkgLSB1eSAqIHZ4IDwgMCA/IC0xIDogMTtcbiAgbGV0IGRvdCA9IHV4ICogdnggKyB1eSAqIHZ5O1xuICBpZiAoZG90ID4gMSkge1xuICAgIGRvdCA9IDE7XG4gIH1cbiAgaWYgKGRvdCA8IC0xKSB7XG4gICAgZG90ID0gLTE7XG4gIH1cbiAgcmV0dXJuIHNpZ24gKiBNYXRoLmFjb3MoZG90KTtcbn07XG5jb25zdCBnZXRBcmNDZW50ZXIgPSAocHgsIHB5LCBjeCwgY3ksIHJ4LCByeSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHNpblBoaSwgY29zUGhpLCBweHAsIHB5cCwgb3V0MikgPT4ge1xuICBjb25zdCByeFNxID0gTWF0aC5wb3cocngsIDIpO1xuICBjb25zdCByeVNxID0gTWF0aC5wb3cocnksIDIpO1xuICBjb25zdCBweHBTcSA9IE1hdGgucG93KHB4cCwgMik7XG4gIGNvbnN0IHB5cFNxID0gTWF0aC5wb3cocHlwLCAyKTtcbiAgbGV0IHJhZGljYW50ID0gcnhTcSAqIHJ5U3EgLSByeFNxICogcHlwU3EgLSByeVNxICogcHhwU3E7XG4gIGlmIChyYWRpY2FudCA8IDApIHtcbiAgICByYWRpY2FudCA9IDA7XG4gIH1cbiAgcmFkaWNhbnQgLz0gcnhTcSAqIHB5cFNxICsgcnlTcSAqIHB4cFNxO1xuICByYWRpY2FudCA9IE1hdGguc3FydChyYWRpY2FudCkgKiAobGFyZ2VBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpO1xuICBjb25zdCBjZW50ZXJYcCA9IHJhZGljYW50ICogcnggLyByeSAqIHB5cDtcbiAgY29uc3QgY2VudGVyWXAgPSByYWRpY2FudCAqIC1yeSAvIHJ4ICogcHhwO1xuICBjb25zdCBjZW50ZXJYID0gY29zUGhpICogY2VudGVyWHAgLSBzaW5QaGkgKiBjZW50ZXJZcCArIChweCArIGN4KSAvIDI7XG4gIGNvbnN0IGNlbnRlclkgPSBzaW5QaGkgKiBjZW50ZXJYcCArIGNvc1BoaSAqIGNlbnRlcllwICsgKHB5ICsgY3kpIC8gMjtcbiAgY29uc3QgdngxID0gKHB4cCAtIGNlbnRlclhwKSAvIHJ4O1xuICBjb25zdCB2eTEgPSAocHlwIC0gY2VudGVyWXApIC8gcnk7XG4gIGNvbnN0IHZ4MiA9ICgtcHhwIC0gY2VudGVyWHApIC8gcng7XG4gIGNvbnN0IHZ5MiA9ICgtcHlwIC0gY2VudGVyWXApIC8gcnk7XG4gIGNvbnN0IGFuZzEgPSB2ZWN0b3JBbmdsZSgxLCAwLCB2eDEsIHZ5MSk7XG4gIGxldCBhbmcyID0gdmVjdG9yQW5nbGUodngxLCB2eTEsIHZ4MiwgdnkyKTtcbiAgaWYgKHN3ZWVwRmxhZyA9PT0gMCAmJiBhbmcyID4gMCkge1xuICAgIGFuZzIgLT0gVEFVO1xuICB9XG4gIGlmIChzd2VlcEZsYWcgPT09IDEgJiYgYW5nMiA8IDApIHtcbiAgICBhbmcyICs9IFRBVTtcbiAgfVxuICBvdXQyLmNlbnRlclggPSBjZW50ZXJYO1xuICBvdXQyLmNlbnRlclkgPSBjZW50ZXJZO1xuICBvdXQyLmFuZzEgPSBhbmcxO1xuICBvdXQyLmFuZzIgPSBhbmcyO1xufTtcbmZ1bmN0aW9uIGJ1aWxkQXJjVG9TdmcocG9pbnRzLCBweCwgcHksIGN4LCBjeSwgcngsIHJ5LCB4QXhpc1JvdGF0aW9uID0gMCwgbGFyZ2VBcmNGbGFnID0gMCwgc3dlZXBGbGFnID0gMCkge1xuICBpZiAocnggPT09IDAgfHwgcnkgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2luUGhpID0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvbiAqIFRBVSAvIDM2MCk7XG4gIGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHhBeGlzUm90YXRpb24gKiBUQVUgLyAzNjApO1xuICBjb25zdCBweHAgPSBjb3NQaGkgKiAocHggLSBjeCkgLyAyICsgc2luUGhpICogKHB5IC0gY3kpIC8gMjtcbiAgY29uc3QgcHlwID0gLXNpblBoaSAqIChweCAtIGN4KSAvIDIgKyBjb3NQaGkgKiAocHkgLSBjeSkgLyAyO1xuICBpZiAocHhwID09PSAwICYmIHB5cCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgcnkgPSBNYXRoLmFicyhyeSk7XG4gIGNvbnN0IGxhbWJkYSA9IE1hdGgucG93KHB4cCwgMikgLyBNYXRoLnBvdyhyeCwgMikgKyBNYXRoLnBvdyhweXAsIDIpIC8gTWF0aC5wb3cocnksIDIpO1xuICBpZiAobGFtYmRhID4gMSkge1xuICAgIHJ4ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICB9XG4gIGdldEFyY0NlbnRlcihcbiAgICBweCxcbiAgICBweSxcbiAgICBjeCxcbiAgICBjeSxcbiAgICByeCxcbiAgICByeSxcbiAgICBsYXJnZUFyY0ZsYWcsXG4gICAgc3dlZXBGbGFnLFxuICAgIHNpblBoaSxcbiAgICBjb3NQaGksXG4gICAgcHhwLFxuICAgIHB5cCxcbiAgICBvdXRcbiAgKTtcbiAgbGV0IHsgYW5nMSwgYW5nMiB9ID0gb3V0O1xuICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclkgfSA9IG91dDtcbiAgbGV0IHJhdGlvID0gTWF0aC5hYnMoYW5nMikgLyAoVEFVIC8gNCk7XG4gIGlmIChNYXRoLmFicygxIC0gcmF0aW8pIDwgMWUtNykge1xuICAgIHJhdGlvID0gMTtcbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IE1hdGgubWF4KE1hdGguY2VpbChyYXRpbyksIDEpO1xuICBhbmcyIC89IHNlZ21lbnRzO1xuICBsZXQgbGFzdFggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICBsZXQgbGFzdFkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBvdXRDdXJ2ZVBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgIGNvbnN0IGN1cnZlID0gYXBwcm94VW5pdEFyYyhhbmcxLCBhbmcyKTtcbiAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gbWFwVG9FbGxpcHNlKGN1cnZlWzBdLCByeCwgcnksIGNvc1BoaSwgc2luUGhpLCBjZW50ZXJYLCBjZW50ZXJZLCBvdXRDdXJ2ZVBvaW50KTtcbiAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gbWFwVG9FbGxpcHNlKGN1cnZlWzFdLCByeCwgcnksIGNvc1BoaSwgc2luUGhpLCBjZW50ZXJYLCBjZW50ZXJZLCBvdXRDdXJ2ZVBvaW50KTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFRvRWxsaXBzZShjdXJ2ZVsyXSwgcngsIHJ5LCBjb3NQaGksIHNpblBoaSwgY2VudGVyWCwgY2VudGVyWSwgb3V0Q3VydmVQb2ludCk7XG4gICAgYnVpbGRBZGFwdGl2ZUJlemllcihcbiAgICAgIHBvaW50cyxcbiAgICAgIGxhc3RYLFxuICAgICAgbGFzdFksXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIHgsXG4gICAgICB5XG4gICAgKTtcbiAgICBsYXN0WCA9IHg7XG4gICAgbGFzdFkgPSB5O1xuICAgIGFuZzEgKz0gYW5nMjtcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZEFyY1RvU3ZnIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZEFyY1RvU3ZnLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcm91bmRlZFNoYXBlQXJjKGcsIHBvaW50cywgcmFkaXVzKSB7XG4gIGNvbnN0IHZlY0Zyb20gPSAocCwgcHApID0+IHtcbiAgICBjb25zdCB4ID0gcHAueCAtIHAueDtcbiAgICBjb25zdCB5ID0gcHAueSAtIHAueTtcbiAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgY29uc3QgbnggPSB4IC8gbGVuO1xuICAgIGNvbnN0IG55ID0geSAvIGxlbjtcbiAgICByZXR1cm4geyBsZW4sIG54LCBueSB9O1xuICB9O1xuICBjb25zdCBzaGFycENvcm5lciA9IChpLCBwKSA9PiB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGcubW92ZVRvKHAueCwgcC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZy5saW5lVG8ocC54LCBwLnkpO1xuICAgIH1cbiAgfTtcbiAgbGV0IHAxID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwMiA9IHBvaW50c1tpICUgcG9pbnRzLmxlbmd0aF07XG4gICAgY29uc3QgcFJhZGl1cyA9IHAyLnJhZGl1cyA/PyByYWRpdXM7XG4gICAgaWYgKHBSYWRpdXMgPD0gMCkge1xuICAgICAgc2hhcnBDb3JuZXIoaSwgcDIpO1xuICAgICAgcDEgPSBwMjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwMyA9IHBvaW50c1soaSArIDEpICUgcG9pbnRzLmxlbmd0aF07XG4gICAgY29uc3QgdjEgPSB2ZWNGcm9tKHAyLCBwMSk7XG4gICAgY29uc3QgdjIgPSB2ZWNGcm9tKHAyLCBwMyk7XG4gICAgaWYgKHYxLmxlbiA8IDFlLTQgfHwgdjIubGVuIDwgMWUtNCkge1xuICAgICAgc2hhcnBDb3JuZXIoaSwgcDIpO1xuICAgICAgcDEgPSBwMjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgYW5nbGUgPSBNYXRoLmFzaW4odjEubnggKiB2Mi5ueSAtIHYxLm55ICogdjIubngpO1xuICAgIGxldCByYWREaXJlY3Rpb24gPSAxO1xuICAgIGxldCBkcmF3RGlyZWN0aW9uID0gZmFsc2U7XG4gICAgaWYgKHYxLm54ICogdjIubnggLSB2MS5ueSAqIC12Mi5ueSA8IDApIHtcbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSBNYXRoLlBJICsgYW5nbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmdsZSA9IE1hdGguUEkgLSBhbmdsZTtcbiAgICAgICAgcmFkRGlyZWN0aW9uID0gLTE7XG4gICAgICAgIGRyYXdEaXJlY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYW5nbGUgPiAwKSB7XG4gICAgICByYWREaXJlY3Rpb24gPSAtMTtcbiAgICAgIGRyYXdEaXJlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDI7XG4gICAgbGV0IGNSYWRpdXM7XG4gICAgbGV0IGxlbk91dCA9IE1hdGguYWJzKFxuICAgICAgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIHBSYWRpdXMgLyBNYXRoLnNpbihoYWxmQW5nbGUpXG4gICAgKTtcbiAgICBpZiAobGVuT3V0ID4gTWF0aC5taW4odjEubGVuIC8gMiwgdjIubGVuIC8gMikpIHtcbiAgICAgIGxlbk91dCA9IE1hdGgubWluKHYxLmxlbiAvIDIsIHYyLmxlbiAvIDIpO1xuICAgICAgY1JhZGl1cyA9IE1hdGguYWJzKGxlbk91dCAqIE1hdGguc2luKGhhbGZBbmdsZSkgLyBNYXRoLmNvcyhoYWxmQW5nbGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1JhZGl1cyA9IHBSYWRpdXM7XG4gICAgfVxuICAgIGNvbnN0IGNYID0gcDIueCArIHYyLm54ICogbGVuT3V0ICsgLXYyLm55ICogY1JhZGl1cyAqIHJhZERpcmVjdGlvbjtcbiAgICBjb25zdCBjWSA9IHAyLnkgKyB2Mi5ueSAqIGxlbk91dCArIHYyLm54ICogY1JhZGl1cyAqIHJhZERpcmVjdGlvbjtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gTWF0aC5hdGFuMih2MS5ueSwgdjEubngpICsgTWF0aC5QSSAvIDIgKiByYWREaXJlY3Rpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBNYXRoLmF0YW4yKHYyLm55LCB2Mi5ueCkgLSBNYXRoLlBJIC8gMiAqIHJhZERpcmVjdGlvbjtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZy5tb3ZlVG8oXG4gICAgICAgIGNYICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiBjUmFkaXVzLFxuICAgICAgICBjWSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogY1JhZGl1c1xuICAgICAgKTtcbiAgICB9XG4gICAgZy5hcmMoY1gsIGNZLCBjUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZHJhd0RpcmVjdGlvbik7XG4gICAgcDEgPSBwMjtcbiAgfVxufVxuZnVuY3Rpb24gcm91bmRlZFNoYXBlUXVhZHJhdGljQ3VydmUoZywgcG9pbnRzLCByYWRpdXMsIHNtb290aG5lc3MpIHtcbiAgY29uc3QgZGlzdGFuY2UgPSAocDEsIHAyKSA9PiBNYXRoLnNxcnQoKHAxLnggLSBwMi54KSAqKiAyICsgKHAxLnkgLSBwMi55KSAqKiAyKTtcbiAgY29uc3QgcG9pbnRMZXJwID0gKHAxLCBwMiwgdCkgPT4gKHtcbiAgICB4OiBwMS54ICsgKHAyLnggLSBwMS54KSAqIHQsXG4gICAgeTogcDEueSArIChwMi55IC0gcDEueSkgKiB0XG4gIH0pO1xuICBjb25zdCBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgY29uc3QgdGhpc1BvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBudW1Qb2ludHNdO1xuICAgIGNvbnN0IHBSYWRpdXMgPSB0aGlzUG9pbnQucmFkaXVzID8/IHJhZGl1cztcbiAgICBpZiAocFJhZGl1cyA8PSAwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBnLm1vdmVUbyh0aGlzUG9pbnQueCwgdGhpc1BvaW50LnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZy5saW5lVG8odGhpc1BvaW50LngsIHRoaXNQb2ludC55KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbaV07XG4gICAgY29uc3QgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMikgJSBudW1Qb2ludHNdO1xuICAgIGNvbnN0IGxhc3RFZGdlTGVuZ3RoID0gZGlzdGFuY2UobGFzdFBvaW50LCB0aGlzUG9pbnQpO1xuICAgIGxldCBzdGFydDtcbiAgICBpZiAobGFzdEVkZ2VMZW5ndGggPCAxZS00KSB7XG4gICAgICBzdGFydCA9IHRoaXNQb2ludDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdE9mZnNldERpc3RhbmNlID0gTWF0aC5taW4obGFzdEVkZ2VMZW5ndGggLyAyLCBwUmFkaXVzKTtcbiAgICAgIHN0YXJ0ID0gcG9pbnRMZXJwKFxuICAgICAgICB0aGlzUG9pbnQsXG4gICAgICAgIGxhc3RQb2ludCxcbiAgICAgICAgbGFzdE9mZnNldERpc3RhbmNlIC8gbGFzdEVkZ2VMZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRFZGdlTGVuZ3RoID0gZGlzdGFuY2UobmV4dFBvaW50LCB0aGlzUG9pbnQpO1xuICAgIGxldCBlbmQ7XG4gICAgaWYgKG5leHRFZGdlTGVuZ3RoIDwgMWUtNCkge1xuICAgICAgZW5kID0gdGhpc1BvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXh0T2Zmc2V0RGlzdGFuY2UgPSBNYXRoLm1pbihuZXh0RWRnZUxlbmd0aCAvIDIsIHBSYWRpdXMpO1xuICAgICAgZW5kID0gcG9pbnRMZXJwKFxuICAgICAgICB0aGlzUG9pbnQsXG4gICAgICAgIG5leHRQb2ludCxcbiAgICAgICAgbmV4dE9mZnNldERpc3RhbmNlIC8gbmV4dEVkZ2VMZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBnLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZy5saW5lVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgfVxuICAgIGcucXVhZHJhdGljQ3VydmVUbyh0aGlzUG9pbnQueCwgdGhpc1BvaW50LnksIGVuZC54LCBlbmQueSwgc21vb3RobmVzcyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgcm91bmRlZFNoYXBlQXJjLCByb3VuZGVkU2hhcGVRdWFkcmF0aWNDdXJ2ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91bmRTaGFwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBDaXJjbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvQ2lyY2xlLm1qcyc7XG5pbXBvcnQgeyBFbGxpcHNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL0VsbGlwc2UubWpzJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvUG9seWdvbi5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgUm91bmRlZFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRBZGFwdGl2ZUJlemllciB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRBZGFwdGl2ZUJlemllci5tanMnO1xuaW1wb3J0IHsgYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYyB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYy5tanMnO1xuaW1wb3J0IHsgYnVpbGRBcmMgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQXJjLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFyY1RvIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZEFyY1RvLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFyY1RvU3ZnIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZEFyY1RvU3ZnLm1qcyc7XG5pbXBvcnQgeyByb3VuZGVkU2hhcGVRdWFkcmF0aWNDdXJ2ZSwgcm91bmRlZFNoYXBlQXJjIH0gZnJvbSAnLi9yb3VuZFNoYXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoKTtcbmNsYXNzIFNoYXBlUGF0aCB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoaWNzUGF0aDJEKSB7XG4gICAgLyoqIFRoZSBsaXN0IG9mIHNoYXBlIHByaW1pdGl2ZXMgdGhhdCBtYWtlIHVwIHRoZSBwYXRoLiAqL1xuICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzID0gW107XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgICB0aGlzLl9ncmFwaGljc1BhdGgyRCA9IGdyYXBoaWNzUGF0aDJEO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgYSBuZXcgc3ViLXBhdGguIEFueSBzdWJzZXF1ZW50IGRyYXdpbmcgY29tbWFuZHMgYXJlIGNvbnNpZGVyZWQgcGFydCBvZiB0aGlzIHBhdGguXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBmb3IgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgZm9yIHRoZSBzdGFydGluZyBwb2ludC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBtb3ZlVG8oeCwgeSkge1xuICAgIHRoaXMuc3RhcnRQb2x5KHgsIHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgY3VycmVudCBwb2ludCB0byBhIG5ldyBwb2ludCB3aXRoIGEgc3RyYWlnaHQgbGluZS4gVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb2ludCB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb2ludCB0byBjb25uZWN0IHRvLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cztcbiAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgY29uc3QgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChmcm9tWCAhPT0geCB8fCBmcm9tWSAhPT0geSkge1xuICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFyYyB0byB0aGUgcGF0aC4gVGhlIGFyYyBpcyBjZW50ZXJlZCBhdCAoeCwgeSlcbiAgICogIHBvc2l0aW9uIHdpdGggcmFkaXVzIGByYWRpdXNgIHN0YXJ0aW5nIGF0IGBzdGFydEFuZ2xlYCBhbmQgZW5kaW5nIGF0IGBlbmRBbmdsZWAuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgY2VudGVyLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGNlbnRlci5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyYy5cbiAgICogQHBhcmFtIHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnRpbmcgYW5nbGUgb2YgdGhlIGFyYywgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSBvZiB0aGUgYXJjLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0gY291bnRlcmNsb2Nrd2lzZSAtIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBhcmMgc2hvdWxkIGJlIGRyYXduIGluIHRoZSBhbnRpY2xvY2t3aXNlIGRpcmVjdGlvbi4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlcmNsb2Nrd2lzZSkge1xuICAgIHRoaXMuX2Vuc3VyZVBvbHkoZmFsc2UpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cztcbiAgICBidWlsZEFyYyhwb2ludHMsIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJjbG9ja3dpc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFyYyB0byB0aGUgcGF0aCB3aXRoIHRoZSBhcmMgdGFuZ2VudCB0byB0aGUgbGluZSBqb2luaW5nIHR3byBzcGVjaWZpZWQgcG9pbnRzLlxuICAgKiBUaGUgYXJjIHJhZGl1cyBpcyBzcGVjaWZpZWQgYnkgYHJhZGl1c2AuXG4gICAqIEBwYXJhbSB4MSAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0geTEgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICogQHBhcmFtIHgyIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgKiBAcGFyYW0geTIgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBhcmMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIHRoaXMuX2Vuc3VyZVBvbHkoKTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jdXJyZW50UG9seS5wb2ludHM7XG4gICAgYnVpbGRBcmNUbyhwb2ludHMsIHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIFNWRy1zdHlsZSBhcmMgdG8gdGhlIHBhdGgsIGFsbG93aW5nIGZvciBlbGxpcHRpY2FsIGFyY3MgYmFzZWQgb24gdGhlIFNWRyBzcGVjLlxuICAgKiBAcGFyYW0gcnggLSBUaGUgeC1yYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSByeSAtIFRoZSB5LXJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHhBeGlzUm90YXRpb24gLSBUaGUgcm90YXRpb24gb2YgdGhlIGVsbGlwc2UncyB4LWF4aXMgcmVsYXRpdmVcbiAgICogdG8gdGhlIHgtYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0sIGluIGRlZ3JlZXMuXG4gICAqIEBwYXJhbSBsYXJnZUFyY0ZsYWcgLSBEZXRlcm1pbmVzIGlmIHRoZSBhcmMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBsZXNzIHRoYW4gMTgwIGRlZ3JlZXMuXG4gICAqIEBwYXJhbSBzd2VlcEZsYWcgLSBEZXRlcm1pbmVzIGlmIHRoZSBhcmMgc2hvdWxkIGJlIHN3ZXB0IGluIGEgcG9zaXRpdmUgYW5nbGUgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBlbmQgcG9pbnQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYXJjVG9TdmcocngsIHJ5LCB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cztcbiAgICBidWlsZEFyY1RvU3ZnKFxuICAgICAgcG9pbnRzLFxuICAgICAgdGhpcy5fY3VycmVudFBvbHkubGFzdFgsXG4gICAgICB0aGlzLl9jdXJyZW50UG9seS5sYXN0WSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcngsXG4gICAgICByeSxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICBsYXJnZUFyY0ZsYWcsXG4gICAgICBzd2VlcEZsYWdcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgY3ViaWMgQmV6aWVyIGN1cnZlIHRvIHRoZSBwYXRoLlxuICAgKiBJdCByZXF1aXJlcyB0aHJlZSBwb2ludHM6IHRoZSBmaXJzdCB0d28gYXJlIGNvbnRyb2wgcG9pbnRzIGFuZCB0aGUgdGhpcmQgb25lIGlzIHRoZSBlbmQgcG9pbnQuXG4gICAqIFRoZSBzdGFydGluZyBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0gY3AxeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDF5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMnggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMnkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gc21vb3RobmVzcyAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBhZGp1c3QgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSwgc21vb3RobmVzcykge1xuICAgIHRoaXMuX2Vuc3VyZVBvbHkoKTtcbiAgICBjb25zdCBjdXJyZW50UG9seSA9IHRoaXMuX2N1cnJlbnRQb2x5O1xuICAgIGJ1aWxkQWRhcHRpdmVCZXppZXIoXG4gICAgICB0aGlzLl9jdXJyZW50UG9seS5wb2ludHMsXG4gICAgICBjdXJyZW50UG9seS5sYXN0WCxcbiAgICAgIGN1cnJlbnRQb2x5Lmxhc3RZLFxuICAgICAgY3AxeCxcbiAgICAgIGNwMXksXG4gICAgICBjcDJ4LFxuICAgICAgY3AyeSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgc21vb3RobmVzc1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBxdWFkcmF0aWMgY3VydmUgdG8gdGhlIHBhdGguIEl0IHJlcXVpcmVzIHR3byBwb2ludHM6IHRoZSBjb250cm9sIHBvaW50IGFuZCB0aGUgZW5kIHBvaW50LlxuICAgKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgdGhlIGxhc3QgcG9pbnQgaW4gdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHBhcmFtIGNwMXggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AxeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aGluZyAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBhZGp1c3QgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHF1YWRyYXRpY0N1cnZlVG8oY3AxeCwgY3AxeSwgeCwgeSwgc21vb3RoaW5nKSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seSgpO1xuICAgIGNvbnN0IGN1cnJlbnRQb2x5ID0gdGhpcy5fY3VycmVudFBvbHk7XG4gICAgYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYyhcbiAgICAgIHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cyxcbiAgICAgIGN1cnJlbnRQb2x5Lmxhc3RYLFxuICAgICAgY3VycmVudFBvbHkubGFzdFksXG4gICAgICBjcDF4LFxuICAgICAgY3AxeSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgc21vb3RoaW5nXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgZHJhd2luZyBhIHN0cmFpZ2h0IGxpbmUgYmFjayB0byB0aGUgc3RhcnQuXG4gICAqIElmIHRoZSBzaGFwZSBpcyBhbHJlYWR5IGNsb3NlZCBvciB0aGVyZSBhcmUgbm8gcG9pbnRzIGluIHRoZSBwYXRoLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuZW5kUG9seSh0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbm90aGVyIHBhdGggdG8gdGhlIGN1cnJlbnQgcGF0aC4gVGhpcyBtZXRob2QgYWxsb3dzIGZvciB0aGUgY29tYmluYXRpb24gb2YgbXVsdGlwbGUgcGF0aHMgaW50byBvbmUuXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIGBHcmFwaGljc1BhdGhgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBhdGggdG8gYWRkLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHBhdGggYmVmb3JlIGFkZGluZyBpdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGRQYXRoKHBhdGgsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZW5kUG9seSgpO1xuICAgIGlmICh0cmFuc2Zvcm0gJiYgIXRyYW5zZm9ybS5pc0lkZW50aXR5KCkpIHtcbiAgICAgIHBhdGggPSBwYXRoLmNsb25lKHRydWUpO1xuICAgICAgcGF0aC50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBwYXRoLmluc3RydWN0aW9uc1tpXTtcbiAgICAgIHRoaXNbaW5zdHJ1Y3Rpb24uYWN0aW9uXSguLi5pbnN0cnVjdGlvbi5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmFsaXplcyB0aGUgZHJhd2luZyBvZiB0aGUgY3VycmVudCBwYXRoLiBPcHRpb25hbGx5LCBpdCBjYW4gY2xvc2UgdGhlIHBhdGguXG4gICAqIEBwYXJhbSBjbG9zZVBhdGggLSBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNsb3NlIHRoZSBwYXRoIGFmdGVyIGZpbmlzaGluZy4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICovXG4gIGZpbmlzaChjbG9zZVBhdGggPSBmYWxzZSkge1xuICAgIHRoaXMuZW5kUG9seShjbG9zZVBhdGgpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyByZWN0YW5nbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSByZWN0YW5nbGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVjdCh4LCB5LCB3LCBoLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgUmVjdGFuZ2xlKHgsIHksIHcsIGgpLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGNpcmNsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyBjaXJjbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGNpcmNsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjaXJjbGUoeCwgeSwgcmFkaXVzLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgQ2lyY2xlKHgsIHksIHJhZGl1cyksIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcG9seWdvbiBzaGFwZS4gVGhpcyBtZXRob2QgYWxsb3dzIGZvciB0aGUgY3JlYXRpb24gb2YgY29tcGxleCBwb2x5Z29ucyBieSBzcGVjaWZ5aW5nIGEgc2VxdWVuY2Ugb2YgcG9pbnRzLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgbnVtYmVycywgb3Igb3IgYW4gYXJyYXkgb2YgUG9pbnREYXRhIG9iamVjdHMgZWcgW3t4LHl9LCB7eCx5fSwge3gseX1dXG4gICAqIHJlcHJlc2VudGluZyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbidzIHZlcnRpY2VzLCBpbiBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIGNsb3NlIC0gQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byBjbG9zZSB0aGUgcG9seWdvbiBwYXRoLiBUcnVlIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBwb2x5KHBvaW50cywgY2xvc2UsIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbihwb2ludHMpO1xuICAgIHBvbHlnb24uY2xvc2VQYXRoID0gY2xvc2U7XG4gICAgdGhpcy5kcmF3U2hhcGUocG9seWdvbiwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSByZWd1bGFyIHBvbHlnb24gd2l0aCBhIHNwZWNpZmllZCBudW1iZXIgb2Ygc2lkZXMuIEFsbCBzaWRlcyBhbmQgYW5nbGVzIGFyZSBlcXVhbC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY3Vtc2NyaWJlZCBjaXJjbGUgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSBzaWRlcyAtIFRoZSBudW1iZXIgb2Ygc2lkZXMgb2YgdGhlIHBvbHlnb24uIE11c3QgYmUgMyBvciBtb3JlLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gYW5nbGUgb2YgdGhlIHBvbHlnb24sIGluIHJhZGlhbnMuIFplcm8gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlZ3VsYXJQb2x5KHgsIHksIHJhZGl1cywgc2lkZXMsIHJvdGF0aW9uID0gMCwgdHJhbnNmb3JtKSB7XG4gICAgc2lkZXMgPSBNYXRoLm1heChzaWRlcyB8IDAsIDMpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSAtMSAqIE1hdGguUEkgLyAyICsgcm90YXRpb247XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLlBJICogMiAvIHNpZGVzO1xuICAgIGNvbnN0IHBvbHlnb24gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGFuZ2xlID0gaSAqIGRlbHRhICsgc3RhcnRBbmdsZTtcbiAgICAgIHBvbHlnb24ucHVzaChcbiAgICAgICAgeCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wb2x5KHBvbHlnb24sIHRydWUsIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcG9seWdvbiB3aXRoIHJvdW5kZWQgY29ybmVycy5cbiAgICogU2ltaWxhciB0byBgcmVndWxhclBvbHlgIGJ1dCB3aXRoIHRoZSBhYmlsaXR5IHRvIHJvdW5kIHRoZSBjb3JuZXJzIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjdW1zY3JpYmVkIGNpcmNsZSBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHNpZGVzIC0gVGhlIG51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gTXVzdCBiZSAzIG9yIG1vcmUuXG4gICAqIEBwYXJhbSBjb3JuZXIgLSBUaGUgcmFkaXVzIG9mIHRoZSByb3VuZGluZyBvZiB0aGUgY29ybmVycy5cbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIGFuZ2xlIG9mIHRoZSBwb2x5Z29uLCBpbiByYWRpYW5zLiBaZXJvIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgcm91bmRpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcm91bmRQb2x5KHgsIHksIHJhZGl1cywgc2lkZXMsIGNvcm5lciwgcm90YXRpb24gPSAwLCBzbW9vdGhuZXNzKSB7XG4gICAgc2lkZXMgPSBNYXRoLm1heChzaWRlcyB8IDAsIDMpO1xuICAgIGlmIChjb3JuZXIgPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVndWxhclBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgcm90YXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBzaWRlTGVuZ3RoID0gcmFkaXVzICogTWF0aC5zaW4oTWF0aC5QSSAvIHNpZGVzKSAtIDFlLTM7XG4gICAgY29ybmVyID0gTWF0aC5taW4oY29ybmVyLCBzaWRlTGVuZ3RoKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gLTEgKiBNYXRoLlBJIC8gMiArIHJvdGF0aW9uO1xuICAgIGNvbnN0IGRlbHRhID0gTWF0aC5QSSAqIDIgLyBzaWRlcztcbiAgICBjb25zdCBpbnRlcm5hbEFuZ2xlID0gKHNpZGVzIC0gMikgKiBNYXRoLlBJIC8gc2lkZXMgLyAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgY29uc3QgYW5nbGUgPSBpICogZGVsdGEgKyBzdGFydEFuZ2xlO1xuICAgICAgY29uc3QgeDAgPSB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgY29uc3QgeTAgPSB5ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgY29uc3QgYTEgPSBhbmdsZSArIE1hdGguUEkgKyBpbnRlcm5hbEFuZ2xlO1xuICAgICAgY29uc3QgYTIgPSBhbmdsZSAtIE1hdGguUEkgLSBpbnRlcm5hbEFuZ2xlO1xuICAgICAgY29uc3QgeDEgPSB4MCArIGNvcm5lciAqIE1hdGguY29zKGExKTtcbiAgICAgIGNvbnN0IHkxID0geTAgKyBjb3JuZXIgKiBNYXRoLnNpbihhMSk7XG4gICAgICBjb25zdCB4MyA9IHgwICsgY29ybmVyICogTWF0aC5jb3MoYTIpO1xuICAgICAgY29uc3QgeTMgPSB5MCArIGNvcm5lciAqIE1hdGguc2luKGEyKTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKHgxLCB5MSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpbmVUbyh4MSwgeTEpO1xuICAgICAgfVxuICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHgwLCB5MCwgeDMsIHkzLCBzbW9vdGhuZXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgc2hhcGUgd2l0aCByb3VuZGVkIGNvcm5lcnMuIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY3VzdG9tIHJhZGl1cyBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIHNoYXBlLlxuICAgKiBPcHRpb25hbGx5LCBjb3JuZXJzIGNhbiBiZSByb3VuZGVkIHVzaW5nIGEgcXVhZHJhdGljIGN1cnZlIGluc3RlYWQgb2YgYW4gYXJjLCBwcm92aWRpbmcgYSBkaWZmZXJlbnQgYWVzdGhldGljLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgYFJvdW5kZWRQb2ludGAgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIHRoZSBzaGFwZSB0byBkcmF3LlxuICAgKiBBIG1pbmltdW0gb2YgMyBwb2ludHMgaXMgcmVxdWlyZWQuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgZGVmYXVsdCByYWRpdXMgZm9yIHRoZSBjb3JuZXJzLlxuICAgKiBUaGlzIHJhZGl1cyBpcyBhcHBsaWVkIHRvIGFsbCBjb3JuZXJzIHVubGVzcyBvdmVycmlkZGVuIGluIGBwb2ludHNgLlxuICAgKiBAcGFyYW0gdXNlUXVhZHJhdGljIC0gSWYgc2V0IHRvIHRydWUsIHJvdW5kZWQgY29ybmVycyBhcmUgZHJhd24gdXNpbmcgYSBxdWFkcmF0aWNDdXJ2ZVxuICAgKiAgbWV0aG9kIGluc3RlYWQgb2YgYW4gYXJjIG1ldGhvZC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gU3BlY2lmaWVzIHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZSB3aGVuIGB1c2VRdWFkcmF0aWNgIGlzIHRydWUuXG4gICAqIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgY3VydmUgc21vb3RoZXIuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcm91bmRTaGFwZShwb2ludHMsIHJhZGl1cywgdXNlUXVhZHJhdGljID0gZmFsc2UsIHNtb290aG5lc3MpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodXNlUXVhZHJhdGljKSB7XG4gICAgICByb3VuZGVkU2hhcGVRdWFkcmF0aWNDdXJ2ZSh0aGlzLCBwb2ludHMsIHJhZGl1cywgc21vb3RobmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kZWRTaGFwZUFyYyh0aGlzLCBwb2ludHMsIHJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlUGF0aCgpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3IFJlY3RhbmdsZSB3aXRoIGZpbGxldCBjb3JuZXJzLiBUaGlzIGlzIG11Y2ggbGlrZSByb3VuZGVkIHJlY3RhbmdsZVxuICAgKiBob3dldmVyIGl0IHN1cHBvcnQgbmVnYXRpdmUgbnVtYmVycyBhcyB3ZWxsIGZvciB0aGUgY29ybmVyIHJhZGl1cy5cbiAgICogQHBhcmFtIHggLSBVcHBlciBsZWZ0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB5IC0gVXBwZXIgcmlnaHQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgcmVjdFxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHJlY3RcbiAgICogQHBhcmFtIGZpbGxldCAtIGFjY2VwdCBuZWdhdGl2ZSBvciBwb3NpdGl2ZSB2YWx1ZXNcbiAgICovXG4gIGZpbGxldFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgZmlsbGV0KSB7XG4gICAgaWYgKGZpbGxldCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgbWF4RmlsbGV0ID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyO1xuICAgIGNvbnN0IGluc2V0ID0gTWF0aC5taW4obWF4RmlsbGV0LCBNYXRoLm1heCgtbWF4RmlsbGV0LCBmaWxsZXQpKTtcbiAgICBjb25zdCByaWdodCA9IHggKyB3aWR0aDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgaGVpZ2h0O1xuICAgIGNvbnN0IGRpciA9IGluc2V0IDwgMCA/IC1pbnNldCA6IDA7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKGluc2V0KTtcbiAgICByZXR1cm4gdGhpcy5tb3ZlVG8oeCwgeSArIHNpemUpLmFyY1RvKHggKyBkaXIsIHkgKyBkaXIsIHggKyBzaXplLCB5LCBzaXplKS5saW5lVG8ocmlnaHQgLSBzaXplLCB5KS5hcmNUbyhyaWdodCAtIGRpciwgeSArIGRpciwgcmlnaHQsIHkgKyBzaXplLCBzaXplKS5saW5lVG8ocmlnaHQsIGJvdHRvbSAtIHNpemUpLmFyY1RvKHJpZ2h0IC0gZGlyLCBib3R0b20gLSBkaXIsIHggKyB3aWR0aCAtIHNpemUsIGJvdHRvbSwgc2l6ZSkubGluZVRvKHggKyBzaXplLCBib3R0b20pLmFyY1RvKHggKyBkaXIsIGJvdHRvbSAtIGRpciwgeCwgYm90dG9tIC0gc2l6ZSwgc2l6ZSkuY2xvc2VQYXRoKCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXcgUmVjdGFuZ2xlIHdpdGggY2hhbWZlciBjb3JuZXJzLiBUaGVzZSBhcmUgYW5nbGVkIGNvcm5lcnMuXG4gICAqIEBwYXJhbSB4IC0gVXBwZXIgbGVmdCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0geSAtIFVwcGVyIHJpZ2h0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHJlY3RcbiAgICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiByZWN0XG4gICAqIEBwYXJhbSBjaGFtZmVyIC0gbm9uLXplcm8gcmVhbCBudW1iZXIsIHNpemUgb2YgY29ybmVyIGN1dG91dFxuICAgKiBAcGFyYW0gdHJhbnNmb3JtXG4gICAqL1xuICBjaGFtZmVyUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjaGFtZmVyLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoY2hhbWZlciA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBpbnNldCA9IE1hdGgubWluKGNoYW1mZXIsIE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMik7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgd2lkdGg7XG4gICAgY29uc3QgYm90dG9tID0geSArIGhlaWdodDtcbiAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICB4ICsgaW5zZXQsXG4gICAgICB5LFxuICAgICAgcmlnaHQgLSBpbnNldCxcbiAgICAgIHksXG4gICAgICByaWdodCxcbiAgICAgIHkgKyBpbnNldCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tIC0gaW5zZXQsXG4gICAgICByaWdodCAtIGluc2V0LFxuICAgICAgYm90dG9tLFxuICAgICAgeCArIGluc2V0LFxuICAgICAgYm90dG9tLFxuICAgICAgeCxcbiAgICAgIGJvdHRvbSAtIGluc2V0LFxuICAgICAgeCxcbiAgICAgIHkgKyBpbnNldFxuICAgIF07XG4gICAgZm9yIChsZXQgaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDI7IGkgLT0gMikge1xuICAgICAgaWYgKHBvaW50c1tpXSA9PT0gcG9pbnRzW2kgLSAyXSAmJiBwb2ludHNbaSAtIDFdID09PSBwb2ludHNbaSAtIDNdKSB7XG4gICAgICAgIHBvaW50cy5zcGxpY2UoaSAtIDEsIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb2x5KHBvaW50cywgdHJ1ZSwgdHJhbnNmb3JtKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYW4gZWxsaXBzZSBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIGFuZCB3aXRoIHRoZSBnaXZlbiB4IGFuZCB5IHJhZGlpLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgYWxsb3dpbmcgZm9yIHJvdGF0aW9uLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJhZGl1c1ggLSBUaGUgaG9yaXpvbnRhbCByYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSByYWRpdXNZIC0gVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBlbGxpcHNlLiBUaGlzIGNhbiBpbmNsdWRlIHJvdGF0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBlbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1ksIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBFbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1kpLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycy5cbiAgICogVGhlIGNvcm5lciByYWRpdXMgY2FuIGJlIHNwZWNpZmllZCB0byBkZXRlcm1pbmUgaG93IHJvdW5kZWQgdGhlIGNvcm5lcnMgc2hvdWxkIGJlLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgd2hpY2ggYWxsb3dzIGZvciByb3RhdGlvbiwgc2NhbGluZywgYW5kIHRyYW5zbGF0aW9uIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlJ3MgY29ybmVycy4gSWYgbm90IHNwZWNpZmllZCwgY29ybmVycyB3aWxsIGJlIHNoYXJwLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaXVzLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgUm91bmRlZFJlY3RhbmdsZSh4LCB5LCB3LCBoLCByYWRpdXMpLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGdpdmVuIHNoYXBlIG9uIHRoZSBjYW52YXMuXG4gICAqIFRoaXMgaXMgYSBnZW5lcmljIG1ldGhvZCB0aGF0IGNhbiBkcmF3IGFueSB0eXBlIG9mIHNoYXBlIHNwZWNpZmllZCBieSB0aGUgYFNoYXBlUHJpbWl0aXZlYCBwYXJhbWV0ZXIuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBjYW4gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUsIGFsbG93aW5nIGZvciBjb21wbGV4IHRyYW5zZm9ybWF0aW9ucy5cbiAgICogQHBhcmFtIHNoYXBlIC0gVGhlIHNoYXBlIHRvIGRyYXcsIGRlZmluZWQgYXMgYSBgU2hhcGVQcmltaXRpdmVgIG9iamVjdC5cbiAgICogQHBhcmFtIG1hdHJpeCAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIGZvciB0cmFuc2Zvcm1pbmcgdGhlIHNoYXBlLiBUaGlzIGNhbiBpbmNsdWRlIHJvdGF0aW9ucyxcbiAgICogc2NhbGluZywgYW5kIHRyYW5zbGF0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBkcmF3U2hhcGUoc2hhcGUsIG1hdHJpeCkge1xuICAgIHRoaXMuZW5kUG9seSgpO1xuICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzLnB1c2goeyBzaGFwZSwgdHJhbnNmb3JtOiBtYXRyaXggfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyBhIG5ldyBwb2x5Z29uIHBhdGggZnJvbSB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIHBvaW50LlxuICAgKiBUaGlzIG1ldGhvZCBpbml0aWFsaXplcyBhIG5ldyBwb2x5Z29uIG9yIGVuZHMgdGhlIGN1cnJlbnQgb25lIGlmIGl0IGV4aXN0cy5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbmV3IHBvbHlnb24uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIG5ldyBwb2x5Z29uLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHN0YXJ0UG9seSh4LCB5KSB7XG4gICAgbGV0IGN1cnJlbnRQb2x5ID0gdGhpcy5fY3VycmVudFBvbHk7XG4gICAgaWYgKGN1cnJlbnRQb2x5KSB7XG4gICAgICB0aGlzLmVuZFBvbHkoKTtcbiAgICB9XG4gICAgY3VycmVudFBvbHkgPSBuZXcgUG9seWdvbigpO1xuICAgIGN1cnJlbnRQb2x5LnBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHRoaXMuX2N1cnJlbnRQb2x5ID0gY3VycmVudFBvbHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEVuZHMgdGhlIGN1cnJlbnQgcG9seWdvbiBwYXRoLiBJZiBgY2xvc2VQYXRoYCBpcyBzZXQgdG8gdHJ1ZSxcbiAgICogdGhlIHBhdGggaXMgY2xvc2VkIGJ5IGNvbm5lY3RpbmcgdGhlIGxhc3QgcG9pbnQgdG8gdGhlIGZpcnN0IG9uZS5cbiAgICogVGhpcyBtZXRob2QgZmluYWxpemVzIHRoZSBjdXJyZW50IHBvbHlnb24gYW5kIHByZXBhcmVzIGl0IGZvciBkcmF3aW5nIG9yIGFkZGluZyB0byB0aGUgc2hhcGUgcHJpbWl0aXZlcy5cbiAgICogQHBhcmFtIGNsb3NlUGF0aCAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHBvbHlnb24gYnkgY29ubmVjdGluZyB0aGUgbGFzdCBwb2ludFxuICAgKiAgYmFjayB0byB0aGUgc3RhcnRpbmcgcG9pbnQuIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgZW5kUG9seShjbG9zZVBhdGggPSBmYWxzZSkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fY3VycmVudFBvbHk7XG4gICAgaWYgKHNoYXBlICYmIHNoYXBlLnBvaW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBzaGFwZS5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgICB0aGlzLnNoYXBlUHJpbWl0aXZlcy5wdXNoKHsgc2hhcGUgfSk7XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRQb2x5ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfZW5zdXJlUG9seShzdGFydCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5fY3VycmVudFBvbHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBuZXcgUG9seWdvbigpO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgY29uc3QgbGFzdFNoYXBlID0gdGhpcy5zaGFwZVByaW1pdGl2ZXNbdGhpcy5zaGFwZVByaW1pdGl2ZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdFNoYXBlKSB7XG4gICAgICAgIGxldCBseCA9IGxhc3RTaGFwZS5zaGFwZS54O1xuICAgICAgICBsZXQgbHkgPSBsYXN0U2hhcGUuc2hhcGUueTtcbiAgICAgICAgaWYgKGxhc3RTaGFwZS50cmFuc2Zvcm0gJiYgIWxhc3RTaGFwZS50cmFuc2Zvcm0uaXNJZGVudGl0eSgpKSB7XG4gICAgICAgICAgY29uc3QgdCA9IGxhc3RTaGFwZS50cmFuc2Zvcm07XG4gICAgICAgICAgY29uc3QgdGVtcFggPSBseDtcbiAgICAgICAgICBseCA9IHQuYSAqIGx4ICsgdC5jICogbHkgKyB0LnR4O1xuICAgICAgICAgIGx5ID0gdC5iICogdGVtcFggKyB0LmQgKiBseSArIHQudHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudFBvbHkucG9pbnRzLnB1c2gobHgsIGx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cy5wdXNoKDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQnVpbGRzIHRoZSBwYXRoLiAqL1xuICBidWlsZFBhdGgoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuX2dyYXBoaWNzUGF0aDJEO1xuICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gcGF0aC5pbnN0cnVjdGlvbnNbaV07XG4gICAgICB0aGlzW2luc3RydWN0aW9uLmFjdGlvbl0oLi4uaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKCk7XG4gIH1cbiAgLyoqIEdldHMgdGhlIGJvdW5kcyBvZiB0aGUgcGF0aC4gKi9cbiAgZ2V0IGJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCk7XG4gICAgY29uc3Qgc2hhcGVQcmltaXRpdmVzID0gdGhpcy5zaGFwZVByaW1pdGl2ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZVByaW1pdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYXBlUHJpbWl0aXZlID0gc2hhcGVQcmltaXRpdmVzW2ldO1xuICAgICAgY29uc3QgYm91bmRzUmVjdCA9IHNoYXBlUHJpbWl0aXZlLnNoYXBlLmdldEJvdW5kcyh0ZW1wUmVjdGFuZ2xlKTtcbiAgICAgIGlmIChzaGFwZVByaW1pdGl2ZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgYm91bmRzLmFkZFJlY3QoYm91bmRzUmVjdCwgc2hhcGVQcmltaXRpdmUudHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy5hZGRSZWN0KGJvdW5kc1JlY3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG59XG5cbmV4cG9ydCB7IFNoYXBlUGF0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhcGVQYXRoLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBTVkdUb0dyYXBoaWNzUGF0aCB9IGZyb20gJy4uL3N2Zy9TVkdUb0dyYXBoaWNzUGF0aC5tanMnO1xuaW1wb3J0IHsgU2hhcGVQYXRoIH0gZnJvbSAnLi9TaGFwZVBhdGgubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcmFwaGljc1BhdGgge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGBHcmFwaGljc1BhdGhgIGluc3RhbmNlIG9wdGlvbmFsbHkgZnJvbSBhbiBTVkcgcGF0aCBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgYFBhdGhJbnN0cnVjdGlvbmAuXG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvbnMgLSBBbiBTVkcgcGF0aCBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgYFBhdGhJbnN0cnVjdGlvbmAgb2JqZWN0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluc3RydWN0aW9ucykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgLyoqIHVuaXF1ZSBpZCBmb3IgdGhpcyBncmFwaGljcyBwYXRoICovXG4gICAgdGhpcy51aWQgPSB1aWQoXCJncmFwaGljc1BhdGhcIik7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBTVkdUb0dyYXBoaWNzUGF0aChpbnN0cnVjdGlvbnMsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucz8uc2xpY2UoKSA/PyBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgaW50ZXJuYWwgc2hhcGUgcGF0aCwgZW5zdXJpbmcgaXQgaXMgdXAtdG8tZGF0ZSB3aXRoIHRoZSBjdXJyZW50IGluc3RydWN0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGBTaGFwZVBhdGhgIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGBHcmFwaGljc1BhdGhgLlxuICAgKi9cbiAgZ2V0IHNoYXBlUGF0aCgpIHtcbiAgICBpZiAoIXRoaXMuX3NoYXBlUGF0aCkge1xuICAgICAgdGhpcy5fc2hhcGVQYXRoID0gbmV3IFNoYXBlUGF0aCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5fc2hhcGVQYXRoLmJ1aWxkUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcGVQYXRoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgYEdyYXBoaWNzUGF0aGAgdG8gdGhpcyBwYXRoLCBvcHRpb25hbGx5IGFwcGx5aW5nIGEgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIGBHcmFwaGljc1BhdGhgIHRvIGFkZC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSBhZGRlZCBwYXRoLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZFBhdGgocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgcGF0aCA9IHBhdGguY2xvbmUoKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImFkZFBhdGhcIiwgZGF0YTogW3BhdGgsIHRyYW5zZm9ybV0gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFyYyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJhcmNcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXJjVG8oLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYXJjVG9cIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXJjVG9TdmcoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYXJjVG9TdmdcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmV6aWVyQ3VydmVUbyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJiZXppZXJDdXJ2ZVRvXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgY3ViaWMgQmV6aWVyIGN1cnZlIHRvIHRoZSBwYXRoLlxuICAgKiBJdCByZXF1aXJlcyB0d28gcG9pbnRzOiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgYW5kIHRoZSBlbmQgcG9pbnQuIFRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSBjcDJ4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDJ5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvU2hvcnQoY3AyeCwgY3AyeSwgeCwgeSwgc21vb3RobmVzcykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmdldExhc3RQb2ludChQb2ludC5zaGFyZWQpO1xuICAgIGxldCBjcDF4ID0gMDtcbiAgICBsZXQgY3AxeSA9IDA7XG4gICAgaWYgKCFsYXN0IHx8IGxhc3QuYWN0aW9uICE9PSBcImJlemllckN1cnZlVG9cIikge1xuICAgICAgY3AxeCA9IGxhc3RQb2ludC54O1xuICAgICAgY3AxeSA9IGxhc3RQb2ludC55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjcDF4ID0gbGFzdC5kYXRhWzJdO1xuICAgICAgY3AxeSA9IGxhc3QuZGF0YVszXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRYID0gbGFzdFBvaW50Lng7XG4gICAgICBjb25zdCBjdXJyZW50WSA9IGxhc3RQb2ludC55O1xuICAgICAgY3AxeCA9IGN1cnJlbnRYICsgKGN1cnJlbnRYIC0gY3AxeCk7XG4gICAgICBjcDF5ID0gY3VycmVudFkgKyAoY3VycmVudFkgLSBjcDF5KTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJiZXppZXJDdXJ2ZVRvXCIsIGRhdGE6IFtjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5LCBzbW9vdGhuZXNzXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY3VycmVudCBwYXRoIGJ5IGRyYXdpbmcgYSBzdHJhaWdodCBsaW5lIGJhY2sgdG8gdGhlIHN0YXJ0LlxuICAgKiBJZiB0aGUgc2hhcGUgaXMgYWxyZWFkeSBjbG9zZWQgb3IgdGhlcmUgYXJlIG5vIHBvaW50cyBpbiB0aGUgcGF0aCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImNsb3NlUGF0aFwiLCBkYXRhOiBbXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZWxsaXBzZSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJlbGxpcHNlXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpbmVUbyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJsaW5lVG9cIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbW92ZVRvKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcIm1vdmVUb1wiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHF1YWRyYXRpY0N1cnZlVG8oLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicXVhZHJhdGljQ3VydmVUb1wiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgcGF0aC4gSXQgdXNlcyB0aGUgcHJldmlvdXMgcG9pbnQgYXMgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvU2hvcnQoeCwgeSwgc21vb3RobmVzcykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmdldExhc3RQb2ludChQb2ludC5zaGFyZWQpO1xuICAgIGxldCBjcHgxID0gMDtcbiAgICBsZXQgY3B5MSA9IDA7XG4gICAgaWYgKCFsYXN0IHx8IGxhc3QuYWN0aW9uICE9PSBcInF1YWRyYXRpY0N1cnZlVG9cIikge1xuICAgICAgY3B4MSA9IGxhc3RQb2ludC54O1xuICAgICAgY3B5MSA9IGxhc3RQb2ludC55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjcHgxID0gbGFzdC5kYXRhWzBdO1xuICAgICAgY3B5MSA9IGxhc3QuZGF0YVsxXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRYID0gbGFzdFBvaW50Lng7XG4gICAgICBjb25zdCBjdXJyZW50WSA9IGxhc3RQb2ludC55O1xuICAgICAgY3B4MSA9IGN1cnJlbnRYICsgKGN1cnJlbnRYIC0gY3B4MSk7XG4gICAgICBjcHkxID0gY3VycmVudFkgKyAoY3VycmVudFkgLSBjcHkxKTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJxdWFkcmF0aWNDdXJ2ZVRvXCIsIGRhdGE6IFtjcHgxLCBjcHkxLCB4LCB5LCBzbW9vdGhuZXNzXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IHJlY3RhbmdsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWN0KHgsIHksIHcsIGgsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicmVjdFwiLCBkYXRhOiBbeCwgeSwgdywgaCwgdHJhbnNmb3JtXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgY2lyY2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IGNpcmNsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgY2lyY2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiY2lyY2xlXCIsIGRhdGE6IFt4LCB5LCByYWRpdXMsIHRyYW5zZm9ybV0gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kUmVjdCguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFJlY3RcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcG9seSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJwb2x5XCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZ3VsYXJQb2x5KC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcInJlZ3VsYXJQb2x5XCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kUG9seSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFBvbHlcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm91bmRTaGFwZSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFNoYXBlXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpbGxldFJlY3QoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiZmlsbGV0UmVjdFwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjaGFtZmVyUmVjdCguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJjaGFtZmVyUmVjdFwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzdGFyIHNoYXBlIGNlbnRlcmVkIGF0IGEgc3BlY2lmaWVkIGxvY2F0aW9uLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvblxuICAgKiAgb2Ygc3RhcnMgd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBwb2ludHMsIG91dGVyIHJhZGl1cywgb3B0aW9uYWwgaW5uZXIgcmFkaXVzLCBhbmQgcm90YXRpb24uXG4gICAqIFRoZSBzdGFyIGlzIGRyYXduIGFzIGEgY2xvc2VkIHBvbHlnb24gd2l0aCBhbHRlcm5hdGluZyBvdXRlciBhbmQgaW5uZXIgdmVydGljZXMgdG8gY3JlYXRlIHRoZSBzdGFyJ3MgcG9pbnRzLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCB0byBzY2FsZSwgcm90YXRlLCBvciB0cmFuc2xhdGUgdGhlIHN0YXIgYXMgbmVlZGVkLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgbnVtYmVyIG9mIHBvaW50cyBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIgKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgb3V0ZXIgcG9pbnRzKS5cbiAgICogQHBhcmFtIGlubmVyUmFkaXVzIC0gT3B0aW9uYWwuIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIHN0YXJcbiAgICogKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgaW5uZXIgcG9pbnRzIGJldHdlZW4gdGhlIG91dGVyIHBvaW50cykuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gaGFsZiBvZiB0aGUgYHJhZGl1c2AuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIE9wdGlvbmFsLiBUaGUgcm90YXRpb24gb2YgdGhlIHN0YXIgaW4gcmFkaWFucywgd2hlcmUgMCBpcyBhbGlnbmVkIHdpdGggdGhlIHktYXhpcy5cbiAgICogRGVmYXVsdHMgdG8gMCwgbWVhbmluZyBvbmUgcG9pbnQgaXMgZGlyZWN0bHkgdXB3YXJkLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHN0YXIuXG4gICAqIFRoaXMgY2FuIGluY2x1ZGUgcm90YXRpb25zLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZyBmdXJ0aGVyIGRyYXdpbmcgY29tbWFuZHMuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBzdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cywgcm90YXRpb24sIHRyYW5zZm9ybSkge1xuICAgIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgcmFkaXVzIC8gMjtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gLTEgKiBNYXRoLlBJIC8gMiArIHJvdGF0aW9uO1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cyAqIDI7XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLlBJICogMiAvIGxlbjtcbiAgICBjb25zdCBwb2x5Z29uID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgciA9IGkgJSAyID8gaW5uZXJSYWRpdXMgOiByYWRpdXM7XG4gICAgICBjb25zdCBhbmdsZSA9IGkgKiBkZWx0YSArIHN0YXJ0QW5nbGU7XG4gICAgICBwb2x5Z29uLnB1c2goXG4gICAgICAgIHggKyByICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5ICsgciAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wb2x5KHBvbHlnb24sIHRydWUsIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGBHcmFwaGljc1BhdGhgIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2xvbmluZy5cbiAgICogQSBzaGFsbG93IGNsb25lIGNvcGllcyB0aGUgcmVmZXJlbmNlIG9mIHRoZSBpbnN0cnVjdGlvbnMgYXJyYXksIHdoaWxlIGEgZGVlcCBjbG9uZSBjcmVhdGVzIGEgbmV3IGFycmF5IGFuZFxuICAgKiBjb3BpZXMgZWFjaCBpbnN0cnVjdGlvbiBpbmRpdmlkdWFsbHksIGVuc3VyaW5nIHRoYXQgbW9kaWZpY2F0aW9ucyB0byB0aGUgaW5zdHJ1Y3Rpb25zIG9mIHRoZSBjbG9uZWQgYEdyYXBoaWNzUGF0aGBcbiAgICogZG8gbm90IGFmZmVjdCB0aGUgb3JpZ2luYWwgYEdyYXBoaWNzUGF0aGAgYW5kIHZpY2UgdmVyc2EuXG4gICAqIEBwYXJhbSBkZWVwIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjbG9uZSBzaG91bGQgYmUgZGVlcC5cbiAgICogQHJldHVybnMgQSBuZXcgYEdyYXBoaWNzUGF0aGAgaW5zdGFuY2UgdGhhdCBpcyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgKi9cbiAgY2xvbmUoZGVlcCA9IGZhbHNlKSB7XG4gICAgY29uc3QgbmV3R3JhcGhpY3NQYXRoMkQgPSBuZXcgR3JhcGhpY3NQYXRoKCk7XG4gICAgaWYgKCFkZWVwKSB7XG4gICAgICBuZXdHcmFwaGljc1BhdGgyRC5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaV07XG4gICAgICAgIG5ld0dyYXBoaWNzUGF0aDJELmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBpbnN0cnVjdGlvbi5hY3Rpb24sIGRhdGE6IGluc3RydWN0aW9uLmRhdGEuc2xpY2UoKSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0dyYXBoaWNzUGF0aDJEO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIGFsbCBkcmF3aW5nIGluc3RydWN0aW9ucyB3aXRoaW4gdGhlIGBHcmFwaGljc1BhdGhgLlxuICAgKiBUaGlzIG1ldGhvZCBlbmFibGVzIHRoZSBtb2RpZmljYXRpb24gb2YgdGhlIHBhdGgncyBnZW9tZXRyeSBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gICAqIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCwgd2hpY2ggY2FuIGluY2x1ZGUgdHJhbnNsYXRpb25zLCByb3RhdGlvbnMsIHNjYWxpbmcsIGFuZCBza2V3aW5nLlxuICAgKlxuICAgKiBFYWNoIGRyYXdpbmcgaW5zdHJ1Y3Rpb24gaW4gdGhlIHBhdGggaXMgdXBkYXRlZCB0byByZWZsZWN0IHRoZSB0cmFuc2Zvcm1hdGlvbixcbiAgICogZW5zdXJpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGF0aCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIGFwcGxpZWQgbWF0cml4LlxuICAgKlxuICAgKiBOb3RlOiBUaGUgdHJhbnNmb3JtYXRpb24gaXMgYXBwbGllZCBkaXJlY3RseSB0byB0aGUgY29vcmRpbmF0ZXMgYW5kIGNvbnRyb2wgcG9pbnRzIG9mIHRoZSBkcmF3aW5nIGluc3RydWN0aW9ucyxcbiAgICogbm90IHRvIHRoZSBwYXRoIGFzIGEgd2hvbGUuIFRoaXMgbWVhbnMgdGhlIHRyYW5zZm9ybWF0aW9uJ3MgZWZmZWN0cyBhcmUgYmFrZWQgaW50byB0aGUgaW5kaXZpZHVhbCBpbnN0cnVjdGlvbnMsXG4gICAqIGFsbG93aW5nIGZvciBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBwYXRoJ3MgYXBwZWFyYW5jZS5cbiAgICogQHBhcmFtIG1hdHJpeCAtIEEgYE1hdHJpeGAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nIGZ1cnRoZXIgb3BlcmF0aW9ucy5cbiAgICovXG4gIHRyYW5zZm9ybShtYXRyaXgpIHtcbiAgICBpZiAobWF0cml4LmlzSWRlbnRpdHkoKSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjcHgxID0gMDtcbiAgICBsZXQgY3B5MSA9IDA7XG4gICAgbGV0IGNweDIgPSAwO1xuICAgIGxldCBjcHkyID0gMDtcbiAgICBsZXQgcnggPSAwO1xuICAgIGxldCByeSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgc3dpdGNoIChpbnN0cnVjdGlvbi5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcIm1vdmVUb1wiOlxuICAgICAgICBjYXNlIFwibGluZVRvXCI6XG4gICAgICAgICAgeCA9IGRhdGFbMF07XG4gICAgICAgICAgeSA9IGRhdGFbMV07XG4gICAgICAgICAgZGF0YVswXSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgICAgICBkYXRhWzFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmV6aWVyQ3VydmVUb1wiOlxuICAgICAgICAgIGNweDEgPSBkYXRhWzBdO1xuICAgICAgICAgIGNweTEgPSBkYXRhWzFdO1xuICAgICAgICAgIGNweDIgPSBkYXRhWzJdO1xuICAgICAgICAgIGNweTIgPSBkYXRhWzNdO1xuICAgICAgICAgIHggPSBkYXRhWzRdO1xuICAgICAgICAgIHkgPSBkYXRhWzVdO1xuICAgICAgICAgIGRhdGFbMF0gPSBhICogY3B4MSArIGMgKiBjcHkxICsgdHg7XG4gICAgICAgICAgZGF0YVsxXSA9IGIgKiBjcHgxICsgZCAqIGNweTEgKyB0eTtcbiAgICAgICAgICBkYXRhWzJdID0gYSAqIGNweDIgKyBjICogY3B5MiArIHR4O1xuICAgICAgICAgIGRhdGFbM10gPSBiICogY3B4MiArIGQgKiBjcHkyICsgdHk7XG4gICAgICAgICAgZGF0YVs0XSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgICAgICBkYXRhWzVdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicXVhZHJhdGljQ3VydmVUb1wiOlxuICAgICAgICAgIGNweDEgPSBkYXRhWzBdO1xuICAgICAgICAgIGNweTEgPSBkYXRhWzFdO1xuICAgICAgICAgIHggPSBkYXRhWzJdO1xuICAgICAgICAgIHkgPSBkYXRhWzNdO1xuICAgICAgICAgIGRhdGFbMF0gPSBhICogY3B4MSArIGMgKiBjcHkxICsgdHg7XG4gICAgICAgICAgZGF0YVsxXSA9IGIgKiBjcHgxICsgZCAqIGNweTEgKyB0eTtcbiAgICAgICAgICBkYXRhWzJdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgICAgICAgIGRhdGFbM10gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcmNUb1N2Z1wiOlxuICAgICAgICAgIHggPSBkYXRhWzVdO1xuICAgICAgICAgIHkgPSBkYXRhWzZdO1xuICAgICAgICAgIHJ4ID0gZGF0YVswXTtcbiAgICAgICAgICByeSA9IGRhdGFbMV07XG4gICAgICAgICAgZGF0YVswXSA9IGEgKiByeCArIGMgKiByeTtcbiAgICAgICAgICBkYXRhWzFdID0gYiAqIHJ4ICsgZCAqIHJ5O1xuICAgICAgICAgIGRhdGFbNV0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICAgICAgZGF0YVs2XSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgIGRhdGFbNF0gPSBhZGp1c3RUcmFuc2Zvcm0oZGF0YVszXSwgbWF0cml4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlY3RcIjpcbiAgICAgICAgICBkYXRhWzRdID0gYWRqdXN0VHJhbnNmb3JtKGRhdGFbNF0sIG1hdHJpeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgZGF0YVs4XSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzhdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicm91bmRSZWN0XCI6XG4gICAgICAgICAgZGF0YVs1XSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzVdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWRkUGF0aFwiOlxuICAgICAgICAgIGRhdGFbMF0udHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb2x5XCI6XG4gICAgICAgICAgZGF0YVsyXSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzJdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdhcm4oXCJ1bmtub3duIHRyYW5zZm9ybSBhY3Rpb25cIiwgaW5zdHJ1Y3Rpb24uYWN0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhcGVQYXRoLmJvdW5kcztcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsYXN0IHBvaW50IGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBpbnN0cnVjdGlvbnMgaW4gdGhlIGBHcmFwaGljc1BhdGhgLlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIG9wZXJhdGlvbnMgdGhhdCBkZXBlbmQgb24gdGhlIHBhdGgncyBjdXJyZW50IGVuZHBvaW50LFxuICAgKiBzdWNoIGFzIGNvbm5lY3Rpbmcgc3Vic2VxdWVudCBzaGFwZXMgb3IgcGF0aHMuIEl0IHN1cHBvcnRzIHZhcmlvdXMgZHJhd2luZyBpbnN0cnVjdGlvbnMsXG4gICAqIGVuc3VyaW5nIHRoZSBsYXN0IHBvaW50J3MgcG9zaXRpb24gaXMgYWNjdXJhdGVseSBkZXRlcm1pbmVkIHJlZ2FyZGxlc3Mgb2YgdGhlIHBhdGgncyBjb21wbGV4aXR5LlxuICAgKlxuICAgKiBJZiB0aGUgbGFzdCBpbnN0cnVjdGlvbiBpcyBhIGBjbG9zZVBhdGhgLCB0aGUgbWV0aG9kIGl0ZXJhdGVzIGJhY2t3YXJkIHRocm91Z2ggdGhlIGluc3RydWN0aW9uc1xuICAgKiAgdW50aWwgaXQgZmluZHMgYW4gYWN0aW9uYWJsZSBpbnN0cnVjdGlvbiB0aGF0IGRlZmluZXMgYSBwb2ludCAoZS5nLiwgYG1vdmVUb2AsIGBsaW5lVG9gLFxuICAgKiBgcXVhZHJhdGljQ3VydmVUb2AsIGV0Yy4pLiBGb3IgY29tcG91bmQgcGF0aHMgYWRkZWQgdmlhIGBhZGRQYXRoYCwgaXQgcmVjdXJzaXZlbHkgcmV0cmlldmVzXG4gICAqIHRoZSBsYXN0IHBvaW50IGZyb20gdGhlIG5lc3RlZCBwYXRoLlxuICAgKiBAcGFyYW0gb3V0IC0gQSBgUG9pbnRgIG9iamVjdCB3aGVyZSB0aGUgbGFzdCBwb2ludCdzIGNvb3JkaW5hdGVzIHdpbGwgYmUgc3RvcmVkLlxuICAgKiBUaGlzIG9iamVjdCBpcyBtb2RpZmllZCBkaXJlY3RseSB0byBjb250YWluIHRoZSByZXN1bHQuXG4gICAqIEByZXR1cm5zIFRoZSBgUG9pbnRgIG9iamVjdCBjb250YWluaW5nIHRoZSBsYXN0IHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRMYXN0UG9pbnQob3V0KSB7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMTtcbiAgICBsZXQgbGFzdEluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaW5kZXhdO1xuICAgIGlmICghbGFzdEluc3RydWN0aW9uKSB7XG4gICAgICBvdXQueCA9IDA7XG4gICAgICBvdXQueSA9IDA7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB3aGlsZSAobGFzdEluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJjbG9zZVBhdGhcIikge1xuICAgICAgaW5kZXgtLTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgb3V0LnggPSAwO1xuICAgICAgICBvdXQueSA9IDA7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgICBsYXN0SW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpbmRleF07XG4gICAgfVxuICAgIHN3aXRjaCAobGFzdEluc3RydWN0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBcIm1vdmVUb1wiOlxuICAgICAgY2FzZSBcImxpbmVUb1wiOlxuICAgICAgICBvdXQueCA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhWzBdO1xuICAgICAgICBvdXQueSA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJxdWFkcmF0aWNDdXJ2ZVRvXCI6XG4gICAgICAgIG91dC54ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbMl07XG4gICAgICAgIG91dC55ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbM107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJlemllckN1cnZlVG9cIjpcbiAgICAgICAgb3V0LnggPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs0XTtcbiAgICAgICAgb3V0LnkgPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs1XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXJjXCI6XG4gICAgICBjYXNlIFwiYXJjVG9TdmdcIjpcbiAgICAgICAgb3V0LnggPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs1XTtcbiAgICAgICAgb3V0LnkgPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs2XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWRkUGF0aFwiOlxuICAgICAgICBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVswXS5nZXRMYXN0UG9pbnQob3V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFRyYW5zZm9ybShjdXJyZW50TWF0cml4LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKGN1cnJlbnRNYXRyaXgpIHtcbiAgICByZXR1cm4gY3VycmVudE1hdHJpeC5wcmVwZW5kKHRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybS5jbG9uZSgpO1xufVxuXG5leHBvcnQgeyBHcmFwaGljc1BhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzUGF0aC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc1BhdGggfSBmcm9tICcuLi9wYXRoL0dyYXBoaWNzUGF0aC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIFNWR1BhcnNlcihzdmcsIGdyYXBoaWNzQ29udGV4dCkge1xuICBpZiAodHlwZW9mIHN2ZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmlubmVySFRNTCA9IHN2Zy50cmltKCk7XG4gICAgc3ZnID0gZGl2LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIik7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICBjb250ZXh0OiBncmFwaGljc0NvbnRleHQsXG4gICAgcGF0aDogbmV3IEdyYXBoaWNzUGF0aCgpXG4gIH07XG4gIHJlbmRlckNoaWxkcmVuKHN2Zywgc2Vzc2lvbiwgbnVsbCwgbnVsbCk7XG4gIHJldHVybiBncmFwaGljc0NvbnRleHQ7XG59XG5mdW5jdGlvbiByZW5kZXJDaGlsZHJlbihzdmcsIHNlc3Npb24sIGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBzdmcuY2hpbGRyZW47XG4gIGNvbnN0IHsgZmlsbFN0eWxlOiBmMSwgc3Ryb2tlU3R5bGU6IHMxIH0gPSBwYXJzZVN0eWxlKHN2Zyk7XG4gIGlmIChmMSAmJiBmaWxsU3R5bGUpIHtcbiAgICBmaWxsU3R5bGUgPSB7IC4uLmZpbGxTdHlsZSwgLi4uZjEgfTtcbiAgfSBlbHNlIGlmIChmMSkge1xuICAgIGZpbGxTdHlsZSA9IGYxO1xuICB9XG4gIGlmIChzMSAmJiBzdHJva2VTdHlsZSkge1xuICAgIHN0cm9rZVN0eWxlID0geyAuLi5zdHJva2VTdHlsZSwgLi4uczEgfTtcbiAgfSBlbHNlIGlmIChzMSkge1xuICAgIHN0cm9rZVN0eWxlID0gczE7XG4gIH1cbiAgc2Vzc2lvbi5jb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gIGxldCB4O1xuICBsZXQgeTtcbiAgbGV0IHgxO1xuICBsZXQgeTE7XG4gIGxldCB4MjtcbiAgbGV0IHkyO1xuICBsZXQgY3g7XG4gIGxldCBjeTtcbiAgbGV0IHI7XG4gIGxldCByeDtcbiAgbGV0IHJ5O1xuICBsZXQgcG9pbnRzO1xuICBsZXQgcG9pbnRzU3RyaW5nO1xuICBsZXQgZDtcbiAgbGV0IGdyYXBoaWNzUGF0aDtcbiAgbGV0IHdpZHRoO1xuICBsZXQgaGVpZ2h0O1xuICBzd2l0Y2ggKHN2Zy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcInBhdGhcIjpcbiAgICAgIGQgPSBzdmcuZ2V0QXR0cmlidXRlKFwiZFwiKTtcbiAgICAgIGdyYXBoaWNzUGF0aCA9IG5ldyBHcmFwaGljc1BhdGgoZCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQucGF0aChncmFwaGljc1BhdGgpO1xuICAgICAgaWYgKGZpbGxTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgY3ggPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJjeFwiLCAwKTtcbiAgICAgIGN5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiY3lcIiwgMCk7XG4gICAgICByID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiclwiLCAwKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5lbGxpcHNlKGN4LCBjeSwgciwgcik7XG4gICAgICBpZiAoZmlsbFN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuZmlsbCgpO1xuICAgICAgaWYgKHN0cm9rZVN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgeCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInhcIiwgMCk7XG4gICAgICB5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwieVwiLCAwKTtcbiAgICAgIHdpZHRoID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwid2lkdGhcIiwgMCk7XG4gICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJoZWlnaHRcIiwgMCk7XG4gICAgICByeCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInJ4XCIsIDApO1xuICAgICAgcnkgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJyeVwiLCAwKTtcbiAgICAgIGlmIChyeCB8fCByeSkge1xuICAgICAgICBzZXNzaW9uLmNvbnRleHQucm91bmRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJ4IHx8IHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlc3Npb24uY29udGV4dC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgIGN4ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiY3hcIiwgMCk7XG4gICAgICBjeSA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcImN5XCIsIDApO1xuICAgICAgcnggPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJyeFwiLCAwKTtcbiAgICAgIHJ5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwicnlcIiwgMCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQuZWxsaXBzZShjeCwgY3ksIHJ4LCByeSk7XG4gICAgICBpZiAoZmlsbFN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuZmlsbCgpO1xuICAgICAgaWYgKHN0cm9rZVN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibGluZVwiOlxuICAgICAgeDEgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJ4MVwiLCAwKTtcbiAgICAgIHkxID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwieTFcIiwgMCk7XG4gICAgICB4MiA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcIngyXCIsIDApO1xuICAgICAgeTIgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJ5MlwiLCAwKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICAgIHBvaW50c1N0cmluZyA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIik7XG4gICAgICBwb2ludHMgPSBwb2ludHNTdHJpbmcubWF0Y2goL1xcZCsvZykubWFwKChuKSA9PiBwYXJzZUludChuLCAxMCkpO1xuICAgICAgc2Vzc2lvbi5jb250ZXh0LnBvbHkocG9pbnRzLCB0cnVlKTtcbiAgICAgIGlmIChmaWxsU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5maWxsKCk7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwb2x5bGluZVwiOlxuICAgICAgcG9pbnRzU3RyaW5nID0gc3ZnLmdldEF0dHJpYnV0ZShcInBvaW50c1wiKTtcbiAgICAgIHBvaW50cyA9IHBvaW50c1N0cmluZy5tYXRjaCgvXFxkKy9nKS5tYXAoKG4pID0+IHBhcnNlSW50KG4sIDEwKSk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQucG9seShwb2ludHMsIGZhbHNlKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwic3ZnXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zb2xlLmluZm8oYFtTVkcgcGFyc2VyXSA8JHtzdmcubm9kZU5hbWV9PiBlbGVtZW50cyB1bnN1cHBvcnRlZGApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICByZW5kZXJDaGlsZHJlbihjaGlsZHJlbltpXSwgc2Vzc2lvbiwgZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBpZCwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IHZhbHVlID0gc3ZnLmdldEF0dHJpYnV0ZShpZCk7XG4gIHJldHVybiB2YWx1ZSA/IE51bWJlcih2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZVN0eWxlKHN2Zykge1xuICBjb25zdCBzdHlsZSA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgY29uc3Qgc3Ryb2tlU3R5bGUgPSB7fTtcbiAgY29uc3QgZmlsbFN0eWxlID0ge307XG4gIGxldCB1c2VGaWxsID0gZmFsc2U7XG4gIGxldCB1c2VTdHJva2UgPSBmYWxzZTtcbiAgaWYgKHN0eWxlKSB7XG4gICAgY29uc3Qgc3R5bGVQYXJ0cyA9IHN0eWxlLnNwbGl0KFwiO1wiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0eWxlUGFydCA9IHN0eWxlUGFydHNbaV07XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBzdHlsZVBhcnQuc3BsaXQoXCI6XCIpO1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcInN0cm9rZVwiOlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHZhbHVlKS50b051bWJlcigpO1xuICAgICAgICAgICAgdXNlU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJva2Utd2lkdGhcIjpcbiAgICAgICAgICBzdHJva2VTdHlsZS53aWR0aCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaWxsXCI6XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgdXNlRmlsbCA9IHRydWU7XG4gICAgICAgICAgICBmaWxsU3R5bGUuY29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmlsbC1vcGFjaXR5XCI6XG4gICAgICAgICAgZmlsbFN0eWxlLmFscGhhID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cm9rZS1vcGFjaXR5XCI6XG4gICAgICAgICAgc3Ryb2tlU3R5bGUuYWxwaGEgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib3BhY2l0eVwiOlxuICAgICAgICAgIGZpbGxTdHlsZS5hbHBoYSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgc3Ryb2tlU3R5bGUuYWxwaGEgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdHJva2UgPSBzdmcuZ2V0QXR0cmlidXRlKFwic3Ryb2tlXCIpO1xuICAgIGlmIChzdHJva2UgJiYgc3Ryb2tlICE9PSBcIm5vbmVcIikge1xuICAgICAgdXNlU3Ryb2tlID0gdHJ1ZTtcbiAgICAgIHN0cm9rZVN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0cm9rZSkudG9OdW1iZXIoKTtcbiAgICAgIHN0cm9rZVN0eWxlLndpZHRoID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwic3Ryb2tlLXdpZHRoXCIsIDEpO1xuICAgIH1cbiAgICBjb25zdCBmaWxsID0gc3ZnLmdldEF0dHJpYnV0ZShcImZpbGxcIik7XG4gICAgaWYgKGZpbGwgJiYgZmlsbCAhPT0gXCJub25lXCIpIHtcbiAgICAgIHVzZUZpbGwgPSB0cnVlO1xuICAgICAgZmlsbFN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGZpbGwpLnRvTnVtYmVyKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3Ryb2tlU3R5bGU6IHVzZVN0cm9rZSA/IHN0cm9rZVN0eWxlIDogbnVsbCxcbiAgICBmaWxsU3R5bGU6IHVzZUZpbGwgPyBmaWxsU3R5bGUgOiBudWxsXG4gIH07XG59XG5cbmV4cG9ydCB7IFNWR1BhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1ZHUGFyc2VyLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc1BhdGggfSBmcm9tICcuL3BhdGgvR3JhcGhpY3NQYXRoLm1qcyc7XG5pbXBvcnQgeyBTVkdQYXJzZXIgfSBmcm9tICcuL3N2Zy9TVkdQYXJzZXIubWpzJztcbmltcG9ydCB7IHRvRmlsbFN0eWxlLCB0b1N0cm9rZVN0eWxlIH0gZnJvbSAnLi91dGlscy9jb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0bXBQb2ludCA9IG5ldyBQb2ludCgpO1xuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbmNvbnN0IF9HcmFwaGljc0NvbnRleHQgPSBjbGFzcyBfR3JhcGhpY3NDb250ZXh0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKiogdW5pcXVlIGlkIGZvciB0aGlzIGdyYXBoaWNzIGNvbnRleHQgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcImdyYXBoaWNzQ29udGV4dFwiKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmJhdGNoTW9kZSA9IFwiYXV0b1wiO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgdGhpcy5fYWN0aXZlUGF0aCA9IG5ldyBHcmFwaGljc1BhdGgoKTtcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5fZmlsbFN0eWxlID0geyAuLi5fR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRGaWxsU3R5bGUgfTtcbiAgICB0aGlzLl9zdHJva2VTdHlsZSA9IHsgLi4uX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUgfTtcbiAgICB0aGlzLl9zdGF0ZVN0YWNrID0gW107XG4gICAgdGhpcy5fdGljayA9IDA7XG4gICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcygpO1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljc0NvbnRleHQgb2JqZWN0IHRoYXQgaXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLCBjb3B5aW5nIGFsbCBwcm9wZXJ0aWVzLFxuICAgKiBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZHJhd2luZyBzdGF0ZSwgdHJhbnNmb3JtYXRpb25zLCBzdHlsZXMsIGFuZCBpbnN0cnVjdGlvbnMuXG4gICAqIEByZXR1cm5zIEEgbmV3IEdyYXBoaWNzQ29udGV4dCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYW5kIHN0YXRlIGFzIHRoaXMgb25lLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgX0dyYXBoaWNzQ29udGV4dCgpO1xuICAgIGNsb25lLmJhdGNoTW9kZSA9IHRoaXMuYmF0Y2hNb2RlO1xuICAgIGNsb25lLmluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG4gICAgY2xvbmUuX2FjdGl2ZVBhdGggPSB0aGlzLl9hY3RpdmVQYXRoLmNsb25lKCk7XG4gICAgY2xvbmUuX3RyYW5zZm9ybSA9IHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpO1xuICAgIGNsb25lLl9maWxsU3R5bGUgPSB7IC4uLnRoaXMuX2ZpbGxTdHlsZSB9O1xuICAgIGNsb25lLl9zdHJva2VTdHlsZSA9IHsgLi4udGhpcy5fc3Ryb2tlU3R5bGUgfTtcbiAgICBjbG9uZS5fc3RhdGVTdGFjayA9IHRoaXMuX3N0YXRlU3RhY2suc2xpY2UoKTtcbiAgICBjbG9uZS5fYm91bmRzID0gdGhpcy5fYm91bmRzLmNsb25lKCk7XG4gICAgY2xvbmUuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGZpbGwgc3R5bGUgb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQuIFRoaXMgY2FuIGJlIGEgY29sb3IsIGdyYWRpZW50LCBwYXR0ZXJuLCBvciBhIG1vcmUgY29tcGxleCBzdHlsZSBkZWZpbmVkIGJ5IGEgRmlsbFN0eWxlIG9iamVjdC5cbiAgICovXG4gIGdldCBmaWxsU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxTdHlsZTtcbiAgfVxuICBzZXQgZmlsbFN0eWxlKHZhbHVlKSB7XG4gICAgdGhpcy5fZmlsbFN0eWxlID0gdG9GaWxsU3R5bGUodmFsdWUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gU2ltaWxhciB0byBmaWxsIHN0eWxlcywgc3Ryb2tlIHN0eWxlcyBjYW4gZW5jb21wYXNzIGNvbG9ycywgZ3JhZGllbnRzLCBwYXR0ZXJucywgb3IgbW9yZSBkZXRhaWxlZCBjb25maWd1cmF0aW9ucyB2aWEgYSBTdHJva2VTdHlsZSBvYmplY3QuXG4gICAqL1xuICBnZXQgc3Ryb2tlU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cm9rZVN0eWxlO1xuICB9XG4gIHNldCBzdHJva2VTdHlsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3N0cm9rZVN0eWxlID0gdG9TdHJva2VTdHlsZSh2YWx1ZSwgX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGZpbGwgc3R5bGUgb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQuIFRoZSBmaWxsIHN0eWxlIGNhbiBiZSBhIGNvbG9yLCBncmFkaWVudCxcbiAgICogcGF0dGVybiwgb3IgYSBtb3JlIGNvbXBsZXggc3R5bGUgZGVmaW5lZCBieSBhIEZpbGxTdHlsZSBvYmplY3QuXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBmaWxsIHN0eWxlIHRvIGFwcGx5LiBUaGlzIGNhbiBiZSBhIHNpbXBsZSBjb2xvciwgYSBncmFkaWVudCBvciBwYXR0ZXJuIG9iamVjdCxcbiAgICogICAgICAgICAgICAgICAgb3IgYSBGaWxsU3R5bGUgb3IgQ29udmVydGVkRmlsbFN0eWxlIG9iamVjdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2V0RmlsbFN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5fZmlsbFN0eWxlID0gdG9GaWxsU3R5bGUoc3R5bGUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBTaW1pbGFyIHRvIGZpbGwgc3R5bGVzLCBzdHJva2Ugc3R5bGVzIGNhblxuICAgKiBlbmNvbXBhc3MgY29sb3JzLCBncmFkaWVudHMsIHBhdHRlcm5zLCBvciBtb3JlIGRldGFpbGVkIGNvbmZpZ3VyYXRpb25zIHZpYSBhIFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBjb2xvciwgYSBncmFkaWVudCBvciBwYXR0ZXJuLFxuICAgKiAgICAgICAgICAgICAgICBvciBhIFN0cm9rZVN0eWxlIG9yIENvbnZlcnRlZFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2V0U3Ryb2tlU3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLl9zdHJva2VTdHlsZSA9IHRvRmlsbFN0eWxlKHN0eWxlLCBfR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGV4dHVyZSh0ZXh0dXJlLCB0aW50LCBkeCwgZHksIGR3LCBkaCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uOiBcInRleHR1cmVcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaW1hZ2U6IHRleHR1cmUsXG4gICAgICAgIGR4OiBkeCB8fCAwLFxuICAgICAgICBkeTogZHkgfHwgMCxcbiAgICAgICAgZHc6IGR3IHx8IHRleHR1cmUuZnJhbWUud2lkdGgsXG4gICAgICAgIGRoOiBkaCB8fCB0ZXh0dXJlLmZyYW1lLmhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSxcbiAgICAgICAgYWxwaGE6IHRoaXMuX2ZpbGxTdHlsZS5hbHBoYSxcbiAgICAgICAgc3R5bGU6IHRpbnQgPyBDb2xvci5zaGFyZWQuc2V0VmFsdWUodGludCkudG9OdW1iZXIoKSA6IDE2Nzc3MjE1XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vblVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgcGF0aC4gQW55IHByZXZpb3VzIHBhdGggYW5kIGl0cyBjb21tYW5kcyBhcmUgZGlzY2FyZGVkIGFuZCBhIG5ldyBwYXRoIGlzXG4gICAqIHN0YXJ0ZWQuIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBiZWZvcmUgYmVnaW5uaW5nIGEgbmV3IHNoYXBlIG9yIHNlcmllcyBvZiBkcmF3aW5nIGNvbW1hbmRzLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBiZWdpblBhdGgoKSB7XG4gICAgdGhpcy5fYWN0aXZlUGF0aCA9IG5ldyBHcmFwaGljc1BhdGgoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmaWxsKHN0eWxlLCBhbHBoYSkge1xuICAgIGxldCBwYXRoO1xuICAgIGNvbnN0IGxhc3RJbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW3RoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0aGlzLl90aWNrID09PSAwICYmIGxhc3RJbnN0cnVjdGlvbiAmJiBsYXN0SW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBwYXRoID0gbGFzdEluc3RydWN0aW9uLmRhdGEucGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMuX2FjdGl2ZVBhdGguY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHN0eWxlICE9IG51bGwpIHtcbiAgICAgIGlmIChhbHBoYSAhPT0gdm9pZCAwICYmIHR5cGVvZiBzdHlsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3NDb250ZXh0LmZpbGwoY29sb3IsIGFscGhhKSBpcyBkZXByZWNhdGVkLCB1c2UgR3JhcGhpY3NDb250ZXh0LmZpbGwoeyBjb2xvciwgYWxwaGEgfSkgaW5zdGVhZFwiKTtcbiAgICAgICAgc3R5bGUgPSB7IGNvbG9yOiBzdHlsZSwgYWxwaGEgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpbGxTdHlsZSA9IHRvRmlsbFN0eWxlKHN0eWxlLCBfR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRGaWxsU3R5bGUpO1xuICAgIH1cbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgIGFjdGlvbjogXCJmaWxsXCIsXG4gICAgICAvLyBUT0RPIGNvcHkgZmlsbCBzdHlsZSFcbiAgICAgIGRhdGE6IHsgc3R5bGU6IHRoaXMuZmlsbFN0eWxlLCBwYXRoIH1cbiAgICB9KTtcbiAgICB0aGlzLm9uVXBkYXRlKCk7XG4gICAgdGhpcy5faW5pdE5leHRQYXRoTG9jYXRpb24oKTtcbiAgICB0aGlzLl90aWNrID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdE5leHRQYXRoTG9jYXRpb24oKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLl9hY3RpdmVQYXRoLmdldExhc3RQb2ludChQb2ludC5zaGFyZWQpO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguY2xlYXIoKTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLm1vdmVUbyh4LCB5KTtcbiAgfVxuICAvKipcbiAgICogU3Ryb2tlcyB0aGUgY3VycmVudCBwYXRoIHdpdGggdGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlLiBUaGlzIG1ldGhvZCBjYW4gdGFrZSBhbiBvcHRpb25hbFxuICAgKiBGaWxsSW5wdXQgcGFyYW1ldGVyIHRvIGRlZmluZSB0aGUgc3Ryb2tlJ3MgYXBwZWFyYW5jZSwgaW5jbHVkaW5nIGl0cyBjb2xvciwgd2lkdGgsIGFuZCBvdGhlciBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gc3R5bGUgLSAoT3B0aW9uYWwpIFRoZSBzdHJva2Ugc3R5bGUgdG8gYXBwbHkuIENhbiBiZSBkZWZpbmVkIGFzIGEgc2ltcGxlIGNvbG9yIG9yIGEgbW9yZSBjb21wbGV4IHN0eWxlIG9iamVjdC4gSWYgb21pdHRlZCwgdXNlcyB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHN0cm9rZShzdHlsZSkge1xuICAgIGxldCBwYXRoO1xuICAgIGNvbnN0IGxhc3RJbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW3RoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0aGlzLl90aWNrID09PSAwICYmIGxhc3RJbnN0cnVjdGlvbiAmJiBsYXN0SW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcImZpbGxcIikge1xuICAgICAgcGF0aCA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhLnBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSB0aGlzLl9hY3RpdmVQYXRoLmNsb25lKCk7XG4gICAgfVxuICAgIGlmICghcGF0aClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmIChzdHlsZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9zdHJva2VTdHlsZSA9IHRvU3Ryb2tlU3R5bGUoc3R5bGUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICBhY3Rpb246IFwic3Ryb2tlXCIsXG4gICAgICAvLyBUT0RPIGNvcHkgZmlsbCBzdHlsZSFcbiAgICAgIGRhdGE6IHsgc3R5bGU6IHRoaXMuc3Ryb2tlU3R5bGUsIHBhdGggfVxuICAgIH0pO1xuICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICB0aGlzLl9pbml0TmV4dFBhdGhMb2NhdGlvbigpO1xuICAgIHRoaXMuX3RpY2sgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgY3V0b3V0IHRvIHRoZSBsYXN0IGRyYXduIHNoYXBlLiBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGhvbGVzIG9yIGNvbXBsZXggc2hhcGVzIGJ5XG4gICAqIHN1YnRyYWN0aW5nIGEgcGF0aCBmcm9tIHRoZSBwcmV2aW91c2x5IGRyYXduIHBhdGguIElmIGEgaG9sZSBpcyBub3QgY29tcGxldGVseSBpbiBhIHNoYXBlLCBpdCB3aWxsXG4gICAqIGZhaWwgdG8gY3V0IGNvcnJlY3RseSFcbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgY3V0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBjb25zdCBsYXN0SW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggLSAxIC0gaV07XG4gICAgICBjb25zdCBob2xlUGF0aCA9IHRoaXMuX2FjdGl2ZVBhdGguY2xvbmUoKTtcbiAgICAgIGlmIChsYXN0SW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaWYgKGxhc3RJbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwic3Ryb2tlXCIgfHwgbGFzdEluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICBpZiAobGFzdEluc3RydWN0aW9uLmRhdGEuaG9sZSkge1xuICAgICAgICAgICAgbGFzdEluc3RydWN0aW9uLmRhdGEuaG9sZS5hZGRQYXRoKGhvbGVQYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdEluc3RydWN0aW9uLmRhdGEuaG9sZSA9IGhvbGVQYXRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2luaXROZXh0UGF0aExvY2F0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBjdXJyZW50IHBhdGgsIHdoaWNoIGlzIGNlbnRlcmVkIGF0ICh4LCB5KSB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzLFxuICAgKiBzdGFydGluZyBhbmQgZW5kaW5nIGFuZ2xlcywgYW5kIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBjZW50ZXIuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgY2VudGVyLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIGFyYydzIHJhZGl1cy5cbiAgICogQHBhcmFtIHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSBlbmRBbmdsZSAtIFRoZSBlbmRpbmcgYW5nbGUsIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSBjb3VudGVyY2xvY2t3aXNlIC0gKE9wdGlvbmFsKSBTcGVjaWZpZXMgd2hldGhlciB0aGUgYXJjIGlzIGRyYXduIGNvdW50ZXJjbG9ja3dpc2UgKHRydWUpIG9yIGNsb2Nrd2lzZSAoZmFsc2UpLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgYXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJjbG9ja3dpc2UpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmFyYyhcbiAgICAgIHQuYSAqIHggKyB0LmMgKiB5ICsgdC50eCxcbiAgICAgIHQuYiAqIHggKyB0LmQgKiB5ICsgdC50eSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSxcbiAgICAgIGNvdW50ZXJjbG9ja3dpc2VcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFyYyB0byB0aGUgY3VycmVudCBwYXRoIHdpdGggdGhlIGdpdmVuIGNvbnRyb2wgcG9pbnRzIGFuZCByYWRpdXMsIGNvbm5lY3RlZCB0byB0aGUgcHJldmlvdXMgcG9pbnRcbiAgICogYnkgYSBzdHJhaWdodCBsaW5lIGlmIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtIHgxIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHkxIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHgyIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB5MiAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIGFyYydzIHJhZGl1cy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguYXJjVG8oXG4gICAgICB0LmEgKiB4MSArIHQuYyAqIHkxICsgdC50eCxcbiAgICAgIHQuYiAqIHgxICsgdC5kICogeTEgKyB0LnR5LFxuICAgICAgdC5hICogeDIgKyB0LmMgKiB5MiArIHQudHgsXG4gICAgICB0LmIgKiB4MiArIHQuZCAqIHkyICsgdC50eSxcbiAgICAgIHJhZGl1c1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gU1ZHLXN0eWxlIGFyYyB0byB0aGUgcGF0aCwgYWxsb3dpbmcgZm9yIGVsbGlwdGljYWwgYXJjcyBiYXNlZCBvbiB0aGUgU1ZHIHNwZWMuXG4gICAqIEBwYXJhbSByeCAtIFRoZSB4LXJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJ5IC0gVGhlIHktcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0geEF4aXNSb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBvZiB0aGUgZWxsaXBzZSdzIHgtYXhpcyByZWxhdGl2ZVxuICAgKiB0byB0aGUgeC1heGlzIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSwgaW4gZGVncmVlcy5cbiAgICogQHBhcmFtIGxhcmdlQXJjRmxhZyAtIERldGVybWluZXMgaWYgdGhlIGFyYyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGxlc3MgdGhhbiAxODAgZGVncmVlcy5cbiAgICogQHBhcmFtIHN3ZWVwRmxhZyAtIERldGVybWluZXMgaWYgdGhlIGFyYyBzaG91bGQgYmUgc3dlcHQgaW4gYSBwb3NpdGl2ZSBhbmdsZSBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGVuZCBwb2ludC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhcmNUb1N2ZyhyeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5hcmNUb1N2ZyhcbiAgICAgIHJ4LFxuICAgICAgcnksXG4gICAgICB4QXhpc1JvdGF0aW9uLFxuICAgICAgLy8gc2hvdWxkIHdlIHJvdGF0ZSB0aGlzIHdpdGggdHJhbnNmb3JtPz9cbiAgICAgIGxhcmdlQXJjRmxhZyxcbiAgICAgIHN3ZWVwRmxhZyxcbiAgICAgIHQuYSAqIHggKyB0LmMgKiB5ICsgdC50eCxcbiAgICAgIHQuYiAqIHggKyB0LmQgKiB5ICsgdC50eVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjdWJpYyBCZXppZXIgY3VydmUgdG8gdGhlIHBhdGguXG4gICAqIEl0IHJlcXVpcmVzIHRocmVlIHBvaW50czogdGhlIGZpcnN0IHR3byBhcmUgY29udHJvbCBwb2ludHMgYW5kIHRoZSB0aGlyZCBvbmUgaXMgdGhlIGVuZCBwb2ludC5cbiAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSBjcDF4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMXkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AyeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AyeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5LCBzbW9vdGhuZXNzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgdC5hICogY3AxeCArIHQuYyAqIGNwMXkgKyB0LnR4LFxuICAgICAgdC5iICogY3AxeCArIHQuZCAqIGNwMXkgKyB0LnR5LFxuICAgICAgdC5hICogY3AyeCArIHQuYyAqIGNwMnkgKyB0LnR4LFxuICAgICAgdC5iICogY3AyeCArIHQuZCAqIGNwMnkgKyB0LnR5LFxuICAgICAgdC5hICogeCArIHQuYyAqIHkgKyB0LnR4LFxuICAgICAgdC5iICogeCArIHQuZCAqIHkgKyB0LnR5LFxuICAgICAgc21vb3RobmVzc1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY3VycmVudCBwYXRoIGJ5IGRyYXdpbmcgYSBzdHJhaWdodCBsaW5lIGJhY2sgdG8gdGhlIHN0YXJ0LlxuICAgKiBJZiB0aGUgc2hhcGUgaXMgYWxyZWFkeSBjbG9zZWQgb3IgdGhlcmUgYXJlIG5vIHBvaW50cyBpbiB0aGUgcGF0aCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aD8uY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGFuIGVsbGlwc2UgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBhbmQgd2l0aCB0aGUgZ2l2ZW4geCBhbmQgeSByYWRpaS5cbiAgICogQW4gb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gY2FuIGJlIGFwcGxpZWQsIGFsbG93aW5nIGZvciByb3RhdGlvbiwgc2NhbGluZywgYW5kIHRyYW5zbGF0aW9uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSByYWRpdXNYIC0gVGhlIGhvcml6b250YWwgcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0gcmFkaXVzWSAtIFRoZSB2ZXJ0aWNhbCByYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgZWxsaXBzZSh4LCB5LCByYWRpdXNYLCByYWRpdXNZKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguZWxsaXBzZSh4LCB5LCByYWRpdXNYLCByYWRpdXNZLCB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgY2lyY2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IGNpcmNsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgY2lyY2xlKHgsIHksIHJhZGl1cykge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmNpcmNsZSh4LCB5LCByYWRpdXMsIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbm90aGVyIGBHcmFwaGljc1BhdGhgIHRvIHRoaXMgcGF0aCwgb3B0aW9uYWxseSBhcHBseWluZyBhIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBgR3JhcGhpY3NQYXRoYCB0byBhZGQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcGF0aChwYXRoKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguYWRkUGF0aChwYXRoLCB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBjdXJyZW50IHBvaW50IHRvIGEgbmV3IHBvaW50IHdpdGggYSBzdHJhaWdodCBsaW5lLiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvaW50IHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvaW50IHRvIGNvbm5lY3QgdG8uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmxpbmVUbyhcbiAgICAgIHQuYSAqIHggKyB0LmMgKiB5ICsgdC50eCxcbiAgICAgIHQuYiAqIHggKyB0LmQgKiB5ICsgdC50eVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciBhIG5ldyBzdWItcGF0aC4gQW55IHN1YnNlcXVlbnQgZHJhd2luZyBjb21tYW5kcyBhcmUgY29uc2lkZXJlZCBwYXJ0IG9mIHRoaXMgcGF0aC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIGZvciB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBmb3IgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gdGhpcy5fYWN0aXZlUGF0aC5pbnN0cnVjdGlvbnM7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRYID0gdC5hICogeCArIHQuYyAqIHkgKyB0LnR4O1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkWSA9IHQuYiAqIHggKyB0LmQgKiB5ICsgdC50eTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSAmJiBpbnN0cnVjdGlvbnNbMF0uYWN0aW9uID09PSBcIm1vdmVUb1wiKSB7XG4gICAgICBpbnN0cnVjdGlvbnNbMF0uZGF0YVswXSA9IHRyYW5zZm9ybWVkWDtcbiAgICAgIGluc3RydWN0aW9uc1swXS5kYXRhWzFdID0gdHJhbnNmb3JtZWRZO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVBhdGgubW92ZVRvKFxuICAgICAgdHJhbnNmb3JtZWRYLFxuICAgICAgdHJhbnNmb3JtZWRZXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgcGF0aC4gSXQgcmVxdWlyZXMgdHdvIHBvaW50czogdGhlIGNvbnRyb2wgcG9pbnQgYW5kIHRoZSBlbmQgcG9pbnQuXG4gICAqIFRoZSBzdGFydGluZyBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0gY3B4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNweSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvKGNweCwgY3B5LCB4LCB5LCBzbW9vdGhuZXNzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgdC5hICogY3B4ICsgdC5jICogY3B5ICsgdC50eCxcbiAgICAgIHQuYiAqIGNweCArIHQuZCAqIGNweSArIHQudHksXG4gICAgICB0LmEgKiB4ICsgdC5jICogeSArIHQudHgsXG4gICAgICB0LmIgKiB4ICsgdC5kICogeSArIHQudHksXG4gICAgICBzbW9vdGhuZXNzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSByZWN0YW5nbGUgc2hhcGUuIFRoaXMgbWV0aG9kIGFkZHMgYSBuZXcgcmVjdGFuZ2xlIHBhdGggdG8gdGhlIGN1cnJlbnQgZHJhd2luZy5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgucmVjdCh4LCB5LCB3LCBoLCB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzLlxuICAgKiBUaGUgY29ybmVyIHJhZGl1cyBjYW4gYmUgc3BlY2lmaWVkIHRvIGRldGVybWluZSBob3cgcm91bmRlZCB0aGUgY29ybmVycyBzaG91bGQgYmUuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBhcHBsaWVkLCB3aGljaCBhbGxvd3MgZm9yIHJvdGF0aW9uLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb24gb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSByZWN0YW5nbGUncyBjb3JuZXJzLiBJZiBub3Qgc3BlY2lmaWVkLCBjb3JuZXJzIHdpbGwgYmUgc2hhcnAuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcm91bmRSZWN0KHgsIHksIHcsIGgsIHJhZGl1cykge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnJvdW5kUmVjdCh4LCB5LCB3LCBoLCByYWRpdXMsIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBwb2x5Z29uIHNoYXBlIGJ5IHNwZWNpZnlpbmcgYSBzZXF1ZW5jZSBvZiBwb2ludHMuIFRoaXMgbWV0aG9kIGFsbG93cyBmb3IgdGhlIGNyZWF0aW9uIG9mIGNvbXBsZXggcG9seWdvbnMsXG4gICAqIHdoaWNoIGNhbiBiZSBib3RoIG9wZW4gYW5kIGNsb3NlZC4gQW4gb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gY2FuIGJlIGFwcGxpZWQsIGVuYWJsaW5nIHRoZSBwb2x5Z29uIHRvIGJlIHNjYWxlZCxcbiAgICogcm90YXRlZCwgb3IgdHJhbnNsYXRlZCBhcyBuZWVkZWQuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBhbiBhcnJheSBvZiBQb2ludERhdGEgb2JqZWN0cyBlZyBbe3gseX0sIHt4LHl9LCB7eCx5fV1cbiAgICogcmVwcmVzZW50aW5nIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzLCBvZiB0aGUgcG9seWdvbidzIHZlcnRpY2VzLCBpbiBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIGNsb3NlIC0gQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byBjbG9zZSB0aGUgcG9seWdvbiBwYXRoLiBUcnVlIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBwb2x5KHBvaW50cywgY2xvc2UpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5wb2x5KHBvaW50cywgY2xvc2UsIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSByZWd1bGFyIHBvbHlnb24gd2l0aCBhIHNwZWNpZmllZCBudW1iZXIgb2Ygc2lkZXMuIEFsbCBzaWRlcyBhbmQgYW5nbGVzIGFyZSBlcXVhbC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY3Vtc2NyaWJlZCBjaXJjbGUgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSBzaWRlcyAtIFRoZSBudW1iZXIgb2Ygc2lkZXMgb2YgdGhlIHBvbHlnb24uIE11c3QgYmUgMyBvciBtb3JlLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gYW5nbGUgb2YgdGhlIHBvbHlnb24sIGluIHJhZGlhbnMuIFplcm8gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlZ3VsYXJQb2x5KHgsIHksIHJhZGl1cywgc2lkZXMsIHJvdGF0aW9uID0gMCwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgucmVndWxhclBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgcm90YXRpb24sIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcG9seWdvbiB3aXRoIHJvdW5kZWQgY29ybmVycy5cbiAgICogU2ltaWxhciB0byBgcmVndWxhclBvbHlgIGJ1dCB3aXRoIHRoZSBhYmlsaXR5IHRvIHJvdW5kIHRoZSBjb3JuZXJzIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjdW1zY3JpYmVkIGNpcmNsZSBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHNpZGVzIC0gVGhlIG51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gTXVzdCBiZSAzIG9yIG1vcmUuXG4gICAqIEBwYXJhbSBjb3JuZXIgLSBUaGUgcmFkaXVzIG9mIHRoZSByb3VuZGluZyBvZiB0aGUgY29ybmVycy5cbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIGFuZ2xlIG9mIHRoZSBwb2x5Z29uLCBpbiByYWRpYW5zLiBaZXJvIGJ5IGRlZmF1bHQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcm91bmRQb2x5KHgsIHksIHJhZGl1cywgc2lkZXMsIGNvcm5lciwgcm90YXRpb24pIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5yb3VuZFBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgY29ybmVyLCByb3RhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgc2hhcGUgd2l0aCByb3VuZGVkIGNvcm5lcnMuIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY3VzdG9tIHJhZGl1cyBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIHNoYXBlLlxuICAgKiBPcHRpb25hbGx5LCBjb3JuZXJzIGNhbiBiZSByb3VuZGVkIHVzaW5nIGEgcXVhZHJhdGljIGN1cnZlIGluc3RlYWQgb2YgYW4gYXJjLCBwcm92aWRpbmcgYSBkaWZmZXJlbnQgYWVzdGhldGljLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgYFJvdW5kZWRQb2ludGAgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIHRoZSBzaGFwZSB0byBkcmF3LlxuICAgKiBBIG1pbmltdW0gb2YgMyBwb2ludHMgaXMgcmVxdWlyZWQuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgZGVmYXVsdCByYWRpdXMgZm9yIHRoZSBjb3JuZXJzLlxuICAgKiBUaGlzIHJhZGl1cyBpcyBhcHBsaWVkIHRvIGFsbCBjb3JuZXJzIHVubGVzcyBvdmVycmlkZGVuIGluIGBwb2ludHNgLlxuICAgKiBAcGFyYW0gdXNlUXVhZHJhdGljIC0gSWYgc2V0IHRvIHRydWUsIHJvdW5kZWQgY29ybmVycyBhcmUgZHJhd24gdXNpbmcgYSBxdWFkcmF0aWNDdXJ2ZVxuICAgKiAgbWV0aG9kIGluc3RlYWQgb2YgYW4gYXJjIG1ldGhvZC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gU3BlY2lmaWVzIHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZSB3aGVuIGB1c2VRdWFkcmF0aWNgIGlzIHRydWUuXG4gICAqIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgY3VydmUgc21vb3RoZXIuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcm91bmRTaGFwZShwb2ludHMsIHJhZGl1cywgdXNlUXVhZHJhdGljLCBzbW9vdGhuZXNzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgucm91bmRTaGFwZShwb2ludHMsIHJhZGl1cywgdXNlUXVhZHJhdGljLCBzbW9vdGhuZXNzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhdyBSZWN0YW5nbGUgd2l0aCBmaWxsZXQgY29ybmVycy4gVGhpcyBpcyBtdWNoIGxpa2Ugcm91bmRlZCByZWN0YW5nbGVcbiAgICogaG93ZXZlciBpdCBzdXBwb3J0IG5lZ2F0aXZlIG51bWJlcnMgYXMgd2VsbCBmb3IgdGhlIGNvcm5lciByYWRpdXMuXG4gICAqIEBwYXJhbSB4IC0gVXBwZXIgbGVmdCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0geSAtIFVwcGVyIHJpZ2h0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHJlY3RcbiAgICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiByZWN0XG4gICAqIEBwYXJhbSBmaWxsZXQgLSBhY2NlcHQgbmVnYXRpdmUgb3IgcG9zaXRpdmUgdmFsdWVzXG4gICAqL1xuICBmaWxsZXRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGZpbGxldCkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmZpbGxldFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgZmlsbGV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhdyBSZWN0YW5nbGUgd2l0aCBjaGFtZmVyIGNvcm5lcnMuIFRoZXNlIGFyZSBhbmdsZWQgY29ybmVycy5cbiAgICogQHBhcmFtIHggLSBVcHBlciBsZWZ0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB5IC0gVXBwZXIgcmlnaHQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgcmVjdFxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHJlY3RcbiAgICogQHBhcmFtIGNoYW1mZXIgLSBub24temVybyByZWFsIG51bWJlciwgc2l6ZSBvZiBjb3JuZXIgY3V0b3V0XG4gICAqIEBwYXJhbSB0cmFuc2Zvcm1cbiAgICovXG4gIGNoYW1mZXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGNoYW1mZXIsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmNoYW1mZXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGNoYW1mZXIsIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgc3RhciBzaGFwZSBjZW50ZXJlZCBhdCBhIHNwZWNpZmllZCBsb2NhdGlvbi4gVGhpcyBtZXRob2QgYWxsb3dzIGZvciB0aGUgY3JlYXRpb25cbiAgICogIG9mIHN0YXJzIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgcG9pbnRzLCBvdXRlciByYWRpdXMsIG9wdGlvbmFsIGlubmVyIHJhZGl1cywgYW5kIHJvdGF0aW9uLlxuICAgKiBUaGUgc3RhciBpcyBkcmF3biBhcyBhIGNsb3NlZCBwb2x5Z29uIHdpdGggYWx0ZXJuYXRpbmcgb3V0ZXIgYW5kIGlubmVyIHZlcnRpY2VzIHRvIGNyZWF0ZSB0aGUgc3RhcidzIHBvaW50cy5cbiAgICogQW4gb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gY2FuIGJlIGFwcGxpZWQgdG8gc2NhbGUsIHJvdGF0ZSwgb3IgdHJhbnNsYXRlIHRoZSBzdGFyIGFzIG5lZWRlZC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBzdGFyLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gVGhlIG51bWJlciBvZiBwb2ludHMgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzdGFyIChkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgdG8gdGhlIG91dGVyIHBvaW50cykuXG4gICAqIEBwYXJhbSBpbm5lclJhZGl1cyAtIE9wdGlvbmFsLiBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBzdGFyXG4gICAqIChkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgdG8gdGhlIGlubmVyIHBvaW50cyBiZXR3ZWVuIHRoZSBvdXRlciBwb2ludHMpLlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGhhbGYgb2YgdGhlIGByYWRpdXNgLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBPcHRpb25hbC4gVGhlIHJvdGF0aW9uIG9mIHRoZSBzdGFyIGluIHJhZGlhbnMsIHdoZXJlIDAgaXMgYWxpZ25lZCB3aXRoIHRoZSB5LWF4aXMuXG4gICAqIERlZmF1bHRzIHRvIDAsIG1lYW5pbmcgb25lIHBvaW50IGlzIGRpcmVjdGx5IHVwd2FyZC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcgZnVydGhlciBkcmF3aW5nIGNvbW1hbmRzLlxuICAgKi9cbiAgc3Rhcih4LCB5LCBwb2ludHMsIHJhZGl1cywgaW5uZXJSYWRpdXMgPSAwLCByb3RhdGlvbiA9IDApIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5zdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cywgcm90YXRpb24sIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuZCByZW5kZXJzIGFuIFNWRyBzdHJpbmcgaW50byB0aGUgZ3JhcGhpY3MgY29udGV4dC4gVGhpcyBhbGxvd3MgZm9yIGNvbXBsZXggc2hhcGVzIGFuZCBwYXRoc1xuICAgKiBkZWZpbmVkIGluIFNWRyBmb3JtYXQgdG8gYmUgZHJhd24gd2l0aGluIHRoZSBncmFwaGljcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gc3ZnIC0gVGhlIFNWRyBzdHJpbmcgdG8gYmUgcGFyc2VkIGFuZCByZW5kZXJlZC5cbiAgICovXG4gIHN2ZyhzdmcpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgU1ZHUGFyc2VyKHN2ZywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBtb3N0IHJlY2VudGx5IHNhdmVkIGdyYXBoaWNzIHN0YXRlIGJ5IHBvcHBpbmcgdGhlIHRvcCBvZiB0aGUgZ3JhcGhpY3Mgc3RhdGUgc3RhY2suXG4gICAqIFRoaXMgaW5jbHVkZXMgdHJhbnNmb3JtYXRpb25zLCBmaWxsIHN0eWxlcywgYW5kIHN0cm9rZSBzdHlsZXMuXG4gICAqL1xuICByZXN0b3JlKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHN0YXRlLnRyYW5zZm9ybTtcbiAgICAgIHRoaXMuX2ZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICAgIHRoaXMuX3N0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBTYXZlcyB0aGUgY3VycmVudCBncmFwaGljcyBzdGF0ZSwgaW5jbHVkaW5nIHRyYW5zZm9ybWF0aW9ucywgZmlsbCBzdHlsZXMsIGFuZCBzdHJva2Ugc3R5bGVzLCBvbnRvIGEgc3RhY2suICovXG4gIHNhdmUoKSB7XG4gICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKHtcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5fdHJhbnNmb3JtLmNsb25lKCksXG4gICAgICBmaWxsU3R5bGU6IHsgLi4udGhpcy5fZmlsbFN0eWxlIH0sXG4gICAgICBzdHJva2VTdHlsZTogeyAuLi50aGlzLl9zdHJva2VTdHlsZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBncmFwaGljcyBjb250ZXh0LlxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqL1xuICBnZXRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byB0aGUgaWRlbnRpdHkgbWF0cml4LCBlZmZlY3RpdmVseSByZW1vdmluZyBhbnkgdHJhbnNmb3JtYXRpb25zIChyb3RhdGlvbiwgc2NhbGluZywgdHJhbnNsYXRpb24pIHByZXZpb3VzbHkgYXBwbGllZC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgcmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgZ3JhcGhpY3MgY29udGV4dCBhcm91bmQgdGhlIGN1cnJlbnQgb3JpZ2luLlxuICAgKiBAcGFyYW0gYW5nbGUgLSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFucy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtLnJvdGF0ZShhbmdsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBzY2FsaW5nIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBncmFwaGljcyBjb250ZXh0LCBzY2FsaW5nIGRyYXdpbmdzIGJ5IHggaG9yaXpvbnRhbGx5IGFuZCBieSB5IHZlcnRpY2FsbHkuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHNjYWxlIGZhY3RvciBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB5IC0gKE9wdGlvbmFsKSBUaGUgc2NhbGUgZmFjdG9yIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB4IHZhbHVlIGlzIHVzZWQgZm9yIGJvdGggZGlyZWN0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2NhbGUoeCwgeSA9IHgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0uc2NhbGUoeCwgeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGR4LCBkeSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0uc2V0KGEuYSwgYS5iLCBhLmMsIGEuZCwgYS50eCwgYS50eSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNmb3JtLnNldChhLCBiLCBjLCBkLCBkeCwgZHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRyYW5zZm9ybShhLCBiLCBjLCBkLCBkeCwgZHkpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtLmFwcGVuZChhKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0ZW1wTWF0cml4LnNldChhLCBiLCBjLCBkLCBkeCwgZHkpO1xuICAgIHRoaXMuX3RyYW5zZm9ybS5hcHBlbmQodGVtcE1hdHJpeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSB0cmFuc2xhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgZ3JhcGhpY3MgY29udGV4dCwgbW92aW5nIHRoZSBvcmlnaW4gYnkgdGhlIHNwZWNpZmllZCBhbW91bnRzLlxuICAgKiBAcGFyYW0geCAtIFRoZSBhbW91bnQgdG8gdHJhbnNsYXRlIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHkgLSAoT3B0aW9uYWwpIFRoZSBhbW91bnQgdG8gdHJhbnNsYXRlIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB4IHZhbHVlIGlzIHVzZWQgZm9yIGJvdGggZGlyZWN0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgdHJhbnNsYXRlKHgsIHkgPSB4KSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBkcmF3aW5nIGNvbW1hbmRzIGZyb20gdGhlIGdyYXBoaWNzIGNvbnRleHQsIGVmZmVjdGl2ZWx5IHJlc2V0dGluZyBpdC4gVGhpcyBpbmNsdWRlcyBjbGVhcmluZyB0aGUgcGF0aCxcbiAgICogYW5kIG9wdGlvbmFsbHkgcmVzZXR0aW5nIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgaWRlbnRpdHkgbWF0cml4LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmNsZWFyKCk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgdGhpcy5vblVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzLCAxNik7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICB9XG4gIC8qKiBUaGUgYm91bmRzIG9mIHRoZSBncmFwaGljIHNoYXBlLiAqL1xuICBnZXQgYm91bmRzKCkge1xuICAgIGlmICghdGhpcy5fYm91bmRzRGlydHkpXG4gICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcbiAgICBib3VuZHMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgY29uc3QgYWN0aW9uID0gaW5zdHJ1Y3Rpb24uYWN0aW9uO1xuICAgICAgaWYgKGFjdGlvbiA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGluc3RydWN0aW9uLmRhdGE7XG4gICAgICAgIGJvdW5kcy5hZGRCb3VuZHMoZGF0YS5wYXRoLmJvdW5kcyk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJ0ZXh0dXJlXCIpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGluc3RydWN0aW9uLmRhdGE7XG4gICAgICAgIGJvdW5kcy5hZGRGcmFtZShkYXRhLmR4LCBkYXRhLmR5LCBkYXRhLmR4ICsgZGF0YS5kdywgZGF0YS5keSArIGRhdGEuZGgsIGRhdGEudHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb24gPT09IFwic3Ryb2tlXCIpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGluc3RydWN0aW9uLmRhdGE7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBkYXRhLnN0eWxlLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgX2JvdW5kcyA9IGRhdGEucGF0aC5ib3VuZHM7XG4gICAgICAgIGJvdW5kcy5hZGRGcmFtZShcbiAgICAgICAgICBfYm91bmRzLm1pblggLSBwYWRkaW5nLFxuICAgICAgICAgIF9ib3VuZHMubWluWSAtIHBhZGRpbmcsXG4gICAgICAgICAgX2JvdW5kcy5tYXhYICsgcGFkZGluZyxcbiAgICAgICAgICBfYm91bmRzLm1heFkgKyBwYWRkaW5nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiBhIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHBvaW50IC0gUG9pbnQgdG8gY2hlY2sgaWYgaXQncyBjb250YWluZWQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gZ2VvbWV0cnkuXG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgaWYgKCF0aGlzLmJvdW5kcy5jb250YWluc1BvaW50KHBvaW50LngsIHBvaW50LnkpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgIGxldCBoYXNIaXQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGsrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNba107XG4gICAgICBjb25zdCBkYXRhID0gaW5zdHJ1Y3Rpb24uZGF0YTtcbiAgICAgIGNvbnN0IHBhdGggPSBkYXRhLnBhdGg7XG4gICAgICBpZiAoIWluc3RydWN0aW9uLmFjdGlvbiB8fCAhcGF0aClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBzdHlsZSA9IGRhdGEuc3R5bGU7XG4gICAgICBjb25zdCBzaGFwZXMgPSBwYXRoLnNoYXBlUGF0aC5zaGFwZVByaW1pdGl2ZXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHNoYXBlc1tpXS5zaGFwZTtcbiAgICAgICAgaWYgKCFzdHlsZSB8fCAhc2hhcGUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHNoYXBlc1tpXS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUG9pbnQgPSB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0bXBQb2ludCkgOiBwb2ludDtcbiAgICAgICAgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICBoYXNIaXQgPSBzaGFwZS5jb250YWlucyh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzSGl0ID0gc2hhcGUuc3Ryb2tlQ29udGFpbnModHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnksIHN0eWxlLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob2xlcyA9IGRhdGEuaG9sZTtcbiAgICAgICAgaWYgKGhvbGVzKSB7XG4gICAgICAgICAgY29uc3QgaG9sZVNoYXBlcyA9IGhvbGVzLnNoYXBlUGF0aD8uc2hhcGVQcmltaXRpdmVzO1xuICAgICAgICAgIGlmIChob2xlU2hhcGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhvbGVTaGFwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKGhvbGVTaGFwZXNbal0uc2hhcGUuY29udGFpbnModHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgaGFzSGl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0hpdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNIaXQ7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljc0RhdGEgb2JqZWN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgZmlsbC9zdHJva2Ugc3R5bGU/XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZVNvdXJjZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBzb3VyY2Ugb2YgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlP1xuICAgKi9cbiAgZGVzdHJveShvcHRpb25zID0gZmFsc2UpIHtcbiAgICB0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgZGVzdHJveVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8udGV4dHVyZTtcbiAgICBpZiAoZGVzdHJveVRleHR1cmUpIHtcbiAgICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlU291cmNlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmVTb3VyY2U7XG4gICAgICBpZiAodGhpcy5fZmlsbFN0eWxlLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fZmlsbFN0eWxlLnRleHR1cmUuZGVzdHJveShkZXN0cm95VGV4dHVyZVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3Ryb2tlU3R5bGUudGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9zdHJva2VTdHlsZS50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9maWxsU3R5bGUgPSBudWxsO1xuICAgIHRoaXMuX3N0cm9rZVN0eWxlID0gbnVsbDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlUGF0aCA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0ZVN0YWNrID0gbnVsbDtcbiAgICB0aGlzLmN1c3RvbVNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gbnVsbDtcbiAgfVxufTtcbi8qKiBUaGUgZGVmYXVsdCBmaWxsIHN0eWxlIHRvIHVzZSB3aGVuIG5vbmUgaXMgcHJvdmlkZWQuICovXG5fR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRGaWxsU3R5bGUgPSB7XG4gIC8qKiBUaGUgY29sb3IgdG8gdXNlIGZvciB0aGUgZmlsbC4gKi9cbiAgY29sb3I6IDE2Nzc3MjE1LFxuICAvKiogVGhlIGFscGhhIHZhbHVlIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIGFscGhhOiAxLFxuICAvKiogVGhlIHRleHR1cmUgdG8gdXNlIGZvciB0aGUgZmlsbC4gKi9cbiAgdGV4dHVyZTogVGV4dHVyZS5XSElURSxcbiAgLyoqIFRoZSBtYXRyaXggdG8gYXBwbHkuICovXG4gIG1hdHJpeDogbnVsbCxcbiAgLyoqIFRoZSBmaWxsIHBhdHRlcm4gdG8gdXNlLiAqL1xuICBmaWxsOiBudWxsXG59O1xuLyoqIFRoZSBkZWZhdWx0IHN0cm9rZSBzdHlsZSB0byB1c2Ugd2hlbiBub25lIGlzIHByb3ZpZGVkLiAqL1xuX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUgPSB7XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZS4gKi9cbiAgd2lkdGg6IDEsXG4gIC8qKiBUaGUgY29sb3IgdG8gdXNlIGZvciB0aGUgc3Ryb2tlLiAqL1xuICBjb2xvcjogMTY3NzcyMTUsXG4gIC8qKiBUaGUgYWxwaGEgdmFsdWUgdG8gdXNlIGZvciB0aGUgc3Ryb2tlLiAqL1xuICBhbHBoYTogMSxcbiAgLyoqIFRoZSBhbGlnbm1lbnQgb2YgdGhlIHN0cm9rZS4gKi9cbiAgYWxpZ25tZW50OiAwLjUsXG4gIC8qKiBUaGUgbWl0ZXIgbGltaXQgdG8gdXNlLiAqL1xuICBtaXRlckxpbWl0OiAxMCxcbiAgLyoqIFRoZSBsaW5lIGNhcCBzdHlsZSB0byB1c2UuICovXG4gIGNhcDogXCJidXR0XCIsXG4gIC8qKiBUaGUgbGluZSBqb2luIHN0eWxlIHRvIHVzZS4gKi9cbiAgam9pbjogXCJtaXRlclwiLFxuICAvKiogVGhlIHRleHR1cmUgdG8gdXNlIGZvciB0aGUgZmlsbC4gKi9cbiAgdGV4dHVyZTogVGV4dHVyZS5XSElURSxcbiAgLyoqIFRoZSBtYXRyaXggdG8gYXBwbHkuICovXG4gIG1hdHJpeDogbnVsbCxcbiAgLyoqIFRoZSBmaWxsIHBhdHRlcm4gdG8gdXNlLiAqL1xuICBmaWxsOiBudWxsXG59O1xubGV0IEdyYXBoaWNzQ29udGV4dCA9IF9HcmFwaGljc0NvbnRleHQ7XG5cbmV4cG9ydCB7IEdyYXBoaWNzQ29udGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NDb250ZXh0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6653\n')},4108:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  hJ: () => (/* binding */ GraphicsContextSystem)\n});\n\n// UNUSED EXPORTS: GpuGraphicsContext, GraphicsContextRenderData\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs\nvar getTextureBatchBindGroup = __webpack_require__(3018);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs + 2 modules\nvar Batcher = __webpack_require__(4683);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs\nvar BatchGeometry = __webpack_require__(37);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(1854);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs\n\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=buildUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs\n\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset = offset || 0;\n  stride = stride || 2;\n  size = size || vertices.length / stride - offset;\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\n\n//# sourceMappingURL=transformVertices.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs + 1 modules\nvar BatchableGraphics = __webpack_require__(8859);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs\n\n\n"use strict";\nconst buildCircle = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.ShapeBuilder,\n    name: "circle"\n  },\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === "circle") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === "ellipse") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\nconst buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };\nconst buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };\n\n\n//# sourceMappingURL=buildCircle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs\n\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs\n\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\n\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs\n\n\n\n\n"use strict";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point/* Point */.E(points[0], points[1]);\n  const lastPoint = new Point/* Point */.E(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === "round") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === "round") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === "round") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\n\n//# sourceMappingURL=buildLine.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs\n\n\n"use strict";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\n\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs\n\n\n\n"use strict";\nconst emptyArray = [];\nconst buildPolygon = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.ShapeBuilder,\n    name: "polygon"\n  },\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\n\n//# sourceMappingURL=buildPolygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs\n\n\n"use strict";\nconst buildRectangle = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.ShapeBuilder,\n    name: "rectangle"\n  },\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs\n\n\n"use strict";\nconst buildTriangle = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.ShapeBuilder,\n    name: "triangle"\n  },\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildTriangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst shapeBuilders = {};\nExtensions/* extensions */.Rw.handleByMap(Extensions/* ExtensionType */.nw.ShapeBuilder, shapeBuilders);\nExtensions/* extensions */.Rw.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\nconst tempRect = new Rectangle/* Rectangle */.A();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === "texture") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === "fill" || instruction.action === "stroke") {\n      const isStroke = instruction.action === "stroke";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.vertexOffset = vertOffset;\n  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.color = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn("[Pixi Graphics] only the last shape have be cut out");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture/* Texture */.x.WHITE) {\n      const textureMatrix = style.matrix;\n      if (textureMatrix) {\n        if (matrix) {\n          textureMatrix.append(matrix.clone().invert());\n        }\n        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n      }\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\n\n//# sourceMappingURL=buildContextBatches.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batcher = new Batcher/* Batcher */.m();\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.geometry = new BatchGeometry/* BatchGeometry */.J();\n    this.instructions = new InstructionSet/* InstructionSet */.h();\n  }\n  init() {\n    this.instructions.reset();\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === "no-batch") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === "auto") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const graphicsData = PoolGroup/* BigPool */.u.get(GraphicsContextRenderData);\n    const { batches, geometryData, batcher } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = graphicsData.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.Q)(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on("destroy", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off("destroy", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        PoolGroup/* BigPool */.u.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        PoolGroup/* BigPool */.u.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "graphicsContext"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\n\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQUs7QUFDOUIsd0JBQXdCLGtCQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNB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Y2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvYnVpbGRVdnMubWpzP2NiNDQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL3RyYW5zZm9ybVZlcnRpY2VzLm1qcz82NGYwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZENpcmNsZS5tanM/Zjk5OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2NvbnN0Lm1qcz83NzNlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvZ2V0T3JpZW50YXRpb25PZlBvaW50cy5tanM/MmU0ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRMaW5lLm1qcz9iMTVhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvdHJpYW5ndWxhdGVXaXRoSG9sZXMubWpzPzg5ZWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkUG9seWdvbi5tanM/YmEzOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRSZWN0YW5nbGUubWpzP2E2YjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkVHJpYW5nbGUubWpzP2QxMjIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy9idWlsZENvbnRleHRCYXRjaGVzLm1qcz9jMWNkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0U3lzdGVtLm1qcz9hNWI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYnVpbGRVdnModmVydGljZXMsIHZlcnRpY2VzU3RyaWRlLCB2ZXJ0aWNlc09mZnNldCwgdXZzLCB1dnNPZmZzZXQsIHV2c1N0cmlkZSwgc2l6ZSwgbWF0cml4ID0gbnVsbCkge1xuICBsZXQgaW5kZXggPSAwO1xuICB2ZXJ0aWNlc09mZnNldCAqPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgdXZzT2Zmc2V0ICo9IHV2c1N0cmlkZTtcbiAgY29uc3QgYSA9IG1hdHJpeC5hO1xuICBjb25zdCBiID0gbWF0cml4LmI7XG4gIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgY29uc3QgZCA9IG1hdHJpeC5kO1xuICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gIHdoaWxlIChpbmRleCA8IHNpemUpIHtcbiAgICBjb25zdCB4ID0gdmVydGljZXNbdmVydGljZXNPZmZzZXRdO1xuICAgIGNvbnN0IHkgPSB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIDFdO1xuICAgIHV2c1t1dnNPZmZzZXRdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIHV2c1t1dnNPZmZzZXQgKyAxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICB1dnNPZmZzZXQgKz0gdXZzU3RyaWRlO1xuICAgIHZlcnRpY2VzT2Zmc2V0ICs9IHZlcnRpY2VzU3RyaWRlO1xuICAgIGluZGV4Kys7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkU2ltcGxlVXZzKHV2cywgdXZzT2Zmc2V0LCB1dnNTdHJpZGUsIHNpemUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgdXZzT2Zmc2V0ICo9IHV2c1N0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgIHV2c1t1dnNPZmZzZXRdID0gMDtcbiAgICB1dnNbdXZzT2Zmc2V0ICsgMV0gPSAwO1xuICAgIHV2c09mZnNldCArPSB1dnNTdHJpZGU7XG4gICAgaW5kZXgrKztcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZFNpbXBsZVV2cywgYnVpbGRVdnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkVXZzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdHJhbnNmb3JtVmVydGljZXModmVydGljZXMsIG0sIG9mZnNldCwgc3RyaWRlLCBzaXplKSB7XG4gIGNvbnN0IGEgPSBtLmE7XG4gIGNvbnN0IGIgPSBtLmI7XG4gIGNvbnN0IGMgPSBtLmM7XG4gIGNvbnN0IGQgPSBtLmQ7XG4gIGNvbnN0IHR4ID0gbS50eDtcbiAgY29uc3QgdHkgPSBtLnR5O1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgc3RyaWRlID0gc3RyaWRlIHx8IDI7XG4gIHNpemUgPSBzaXplIHx8IHZlcnRpY2VzLmxlbmd0aCAvIHN0cmlkZSAtIG9mZnNldDtcbiAgbGV0IGluZGV4ID0gb2Zmc2V0ICogc3RyaWRlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpbmRleF07XG4gICAgY29uc3QgeSA9IHZlcnRpY2VzW2luZGV4ICsgMV07XG4gICAgdmVydGljZXNbaW5kZXhdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgaW5kZXggKz0gc3RyaWRlO1xuICB9XG59XG5cbmV4cG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1WZXJ0aWNlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgYnVpbGRDaXJjbGUgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuU2hhcGVCdWlsZGVyLFxuICAgIG5hbWU6IFwiY2lyY2xlXCJcbiAgfSxcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGxldCBkeDtcbiAgICBsZXQgZHk7XG4gICAgbGV0IHJ4O1xuICAgIGxldCByeTtcbiAgICBpZiAoc2hhcGUudHlwZSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgY29uc3QgY2lyY2xlID0gc2hhcGU7XG4gICAgICB4ID0gY2lyY2xlLng7XG4gICAgICB5ID0gY2lyY2xlLnk7XG4gICAgICByeCA9IHJ5ID0gY2lyY2xlLnJhZGl1cztcbiAgICAgIGR4ID0gZHkgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2hhcGUudHlwZSA9PT0gXCJlbGxpcHNlXCIpIHtcbiAgICAgIGNvbnN0IGVsbGlwc2UgPSBzaGFwZTtcbiAgICAgIHggPSBlbGxpcHNlLng7XG4gICAgICB5ID0gZWxsaXBzZS55O1xuICAgICAgcnggPSBlbGxpcHNlLmhhbGZXaWR0aDtcbiAgICAgIHJ5ID0gZWxsaXBzZS5oYWxmSGVpZ2h0O1xuICAgICAgZHggPSBkeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdW5kZWRSZWN0ID0gc2hhcGU7XG4gICAgICBjb25zdCBoYWxmV2lkdGggPSByb3VuZGVkUmVjdC53aWR0aCAvIDI7XG4gICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gcm91bmRlZFJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIHggPSByb3VuZGVkUmVjdC54ICsgaGFsZldpZHRoO1xuICAgICAgeSA9IHJvdW5kZWRSZWN0LnkgKyBoYWxmSGVpZ2h0O1xuICAgICAgcnggPSByeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJvdW5kZWRSZWN0LnJhZGl1cywgTWF0aC5taW4oaGFsZldpZHRoLCBoYWxmSGVpZ2h0KSkpO1xuICAgICAgZHggPSBoYWxmV2lkdGggLSByeDtcbiAgICAgIGR5ID0gaGFsZkhlaWdodCAtIHJ5O1xuICAgIH1cbiAgICBpZiAoIShyeCA+PSAwICYmIHJ5ID49IDAgJiYgZHggPj0gMCAmJiBkeSA+PSAwKSkge1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgY29uc3QgbiA9IE1hdGguY2VpbCgyLjMgKiBNYXRoLnNxcnQocnggKyByeSkpO1xuICAgIGNvbnN0IG0gPSBuICogOCArIChkeCA/IDQgOiAwKSArIChkeSA/IDQgOiAwKTtcbiAgICBpZiAobSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHBvaW50c1swXSA9IHBvaW50c1s2XSA9IHggKyBkeDtcbiAgICAgIHBvaW50c1sxXSA9IHBvaW50c1szXSA9IHkgKyBkeTtcbiAgICAgIHBvaW50c1syXSA9IHBvaW50c1s0XSA9IHggLSBkeDtcbiAgICAgIHBvaW50c1s1XSA9IHBvaW50c1s3XSA9IHkgLSBkeTtcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIGxldCBqMSA9IDA7XG4gICAgbGV0IGoyID0gbiAqIDQgKyAoZHggPyAyIDogMCkgKyAyO1xuICAgIGxldCBqMyA9IGoyO1xuICAgIGxldCBqNCA9IG07XG4gICAgbGV0IHgwID0gZHggKyByeDtcbiAgICBsZXQgeTAgPSBkeTtcbiAgICBsZXQgeDEgPSB4ICsgeDA7XG4gICAgbGV0IHgyID0geCAtIHgwO1xuICAgIGxldCB5MSA9IHkgKyB5MDtcbiAgICBwb2ludHNbajErK10gPSB4MTtcbiAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICBwb2ludHNbLS1qMl0gPSB5MTtcbiAgICBwb2ludHNbLS1qMl0gPSB4MjtcbiAgICBpZiAoZHkpIHtcbiAgICAgIGNvbnN0IHkyMiA9IHkgLSB5MDtcbiAgICAgIHBvaW50c1tqMysrXSA9IHgyO1xuICAgICAgcG9pbnRzW2ozKytdID0geTIyO1xuICAgICAgcG9pbnRzWy0tajRdID0geTIyO1xuICAgICAgcG9pbnRzWy0tajRdID0geDE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5QSSAvIDIgKiAoaSAvIG4pO1xuICAgICAgY29uc3QgeDAyID0gZHggKyBNYXRoLmNvcyhhKSAqIHJ4O1xuICAgICAgY29uc3QgeTAyID0gZHkgKyBNYXRoLnNpbihhKSAqIHJ5O1xuICAgICAgY29uc3QgeDEyID0geCArIHgwMjtcbiAgICAgIGNvbnN0IHgyMiA9IHggLSB4MDI7XG4gICAgICBjb25zdCB5MTIgPSB5ICsgeTAyO1xuICAgICAgY29uc3QgeTIyID0geSAtIHkwMjtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHgxMjtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHkxMjtcbiAgICAgIHBvaW50c1stLWoyXSA9IHkxMjtcbiAgICAgIHBvaW50c1stLWoyXSA9IHgyMjtcbiAgICAgIHBvaW50c1tqMysrXSA9IHgyMjtcbiAgICAgIHBvaW50c1tqMysrXSA9IHkyMjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHkyMjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHgxMjtcbiAgICB9XG4gICAgeDAgPSBkeDtcbiAgICB5MCA9IGR5ICsgcnk7XG4gICAgeDEgPSB4ICsgeDA7XG4gICAgeDIgPSB4IC0geDA7XG4gICAgeTEgPSB5ICsgeTA7XG4gICAgY29uc3QgeTIgPSB5IC0geTA7XG4gICAgcG9pbnRzW2oxKytdID0geDE7XG4gICAgcG9pbnRzW2oxKytdID0geTE7XG4gICAgcG9pbnRzWy0tajRdID0geTI7XG4gICAgcG9pbnRzWy0tajRdID0geDE7XG4gICAgaWYgKGR4KSB7XG4gICAgICBwb2ludHNbajErK10gPSB4MjtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHkxO1xuICAgICAgcG9pbnRzWy0tajRdID0geTI7XG4gICAgICBwb2ludHNbLS1qNF0gPSB4MjtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgdHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNlbnRlclggPSAwO1xuICAgIGxldCBjZW50ZXJZID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY2VudGVyWCArPSBwb2ludHNbaV07XG4gICAgICBjZW50ZXJZICs9IHBvaW50c1tpICsgMV07XG4gICAgfVxuICAgIGNlbnRlclggLz0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgY2VudGVyWSAvPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICBsZXQgY291bnQgPSB2ZXJ0aWNlc09mZnNldDtcbiAgICB2ZXJ0aWNlc1tjb3VudCAqIHZlcnRpY2VzU3RyaWRlXSA9IGNlbnRlclg7XG4gICAgdmVydGljZXNbY291bnQgKiB2ZXJ0aWNlc1N0cmlkZSArIDFdID0gY2VudGVyWTtcbiAgICBjb25zdCBjZW50ZXJJbmRleCA9IGNvdW50Kys7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZlcnRpY2VzW2NvdW50ICogdmVydGljZXNTdHJpZGVdID0gcG9pbnRzW2ldO1xuICAgICAgdmVydGljZXNbY291bnQgKiB2ZXJ0aWNlc1N0cmlkZSArIDFdID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSBjb3VudDtcbiAgICAgICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gY2VudGVySW5kZXg7XG4gICAgICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNvdW50IC0gMTtcbiAgICAgIH1cbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNlbnRlckluZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSBjZW50ZXJJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSBjb3VudCAtIDE7XG4gIH1cbn07XG5jb25zdCBidWlsZEVsbGlwc2UgPSB7IC4uLmJ1aWxkQ2lyY2xlLCBleHRlbnNpb246IHsgLi4uYnVpbGRDaXJjbGUuZXh0ZW5zaW9uLCBuYW1lOiBcImVsbGlwc2VcIiB9IH07XG5jb25zdCBidWlsZFJvdW5kZWRSZWN0YW5nbGUgPSB7IC4uLmJ1aWxkQ2lyY2xlLCBleHRlbnNpb246IHsgLi4uYnVpbGRDaXJjbGUuZXh0ZW5zaW9uLCBuYW1lOiBcInJvdW5kZWRSZWN0YW5nbGVcIiB9IH07XG5cbmV4cG9ydCB7IGJ1aWxkQ2lyY2xlLCBidWlsZEVsbGlwc2UsIGJ1aWxkUm91bmRlZFJlY3RhbmdsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDaXJjbGUubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjbG9zZVBvaW50RXBzID0gMWUtNDtcbmNvbnN0IGN1cnZlRXBzID0gMWUtNDtcblxuZXhwb3J0IHsgY2xvc2VQb2ludEVwcywgY3VydmVFcHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0T3JpZW50YXRpb25PZlBvaW50cyhwb2ludHMpIHtcbiAgY29uc3QgbSA9IHBvaW50cy5sZW5ndGg7XG4gIGlmIChtIDwgNikge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGxldCBhcmVhID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIHgxID0gcG9pbnRzW20gLSAyXSwgeTEgPSBwb2ludHNbbSAtIDFdOyBpIDwgbTsgaSArPSAyKSB7XG4gICAgY29uc3QgeDIgPSBwb2ludHNbaV07XG4gICAgY29uc3QgeTIgPSBwb2ludHNbaSArIDFdO1xuICAgIGFyZWEgKz0gKHgyIC0geDEpICogKHkyICsgeTEpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICBpZiAoYXJlYSA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCB7IGdldE9yaWVudGF0aW9uT2ZQb2ludHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE9yaWVudGF0aW9uT2ZQb2ludHMubWpzLm1hcFxuIiwiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgY2xvc2VQb2ludEVwcywgY3VydmVFcHMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuaW1wb3J0IHsgZ2V0T3JpZW50YXRpb25PZlBvaW50cyB9IGZyb20gJy4uL3V0aWxzL2dldE9yaWVudGF0aW9uT2ZQb2ludHMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBzcXVhcmUoeCwgeSwgbngsIG55LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIGNsb2Nrd2lzZSwgdmVydHMpIHtcbiAgY29uc3QgaXggPSB4IC0gbnggKiBpbm5lcldlaWdodDtcbiAgY29uc3QgaXkgPSB5IC0gbnkgKiBpbm5lcldlaWdodDtcbiAgY29uc3Qgb3ggPSB4ICsgbnggKiBvdXRlcldlaWdodDtcbiAgY29uc3Qgb3kgPSB5ICsgbnkgKiBvdXRlcldlaWdodDtcbiAgbGV0IGV4eDtcbiAgbGV0IGV5eTtcbiAgaWYgKGNsb2Nrd2lzZSkge1xuICAgIGV4eCA9IG55O1xuICAgIGV5eSA9IC1ueDtcbiAgfSBlbHNlIHtcbiAgICBleHggPSAtbnk7XG4gICAgZXl5ID0gbng7XG4gIH1cbiAgY29uc3QgZWl4ID0gaXggKyBleHg7XG4gIGNvbnN0IGVpeSA9IGl5ICsgZXl5O1xuICBjb25zdCBlb3ggPSBveCArIGV4eDtcbiAgY29uc3QgZW95ID0gb3kgKyBleXk7XG4gIHZlcnRzLnB1c2goZWl4LCBlaXkpO1xuICB2ZXJ0cy5wdXNoKGVveCwgZW95KTtcbiAgcmV0dXJuIDI7XG59XG5mdW5jdGlvbiByb3VuZChjeCwgY3ksIHN4LCBzeSwgZXgsIGV5LCB2ZXJ0cywgY2xvY2t3aXNlKSB7XG4gIGNvbnN0IGN4MnAweCA9IHN4IC0gY3g7XG4gIGNvbnN0IGN5MnAweSA9IHN5IC0gY3k7XG4gIGxldCBhbmdsZTAgPSBNYXRoLmF0YW4yKGN4MnAweCwgY3kycDB5KTtcbiAgbGV0IGFuZ2xlMSA9IE1hdGguYXRhbjIoZXggLSBjeCwgZXkgLSBjeSk7XG4gIGlmIChjbG9ja3dpc2UgJiYgYW5nbGUwIDwgYW5nbGUxKSB7XG4gICAgYW5nbGUwICs9IE1hdGguUEkgKiAyO1xuICB9IGVsc2UgaWYgKCFjbG9ja3dpc2UgJiYgYW5nbGUwID4gYW5nbGUxKSB7XG4gICAgYW5nbGUxICs9IE1hdGguUEkgKiAyO1xuICB9XG4gIGxldCBzdGFydEFuZ2xlID0gYW5nbGUwO1xuICBjb25zdCBhbmdsZURpZmYgPSBhbmdsZTEgLSBhbmdsZTA7XG4gIGNvbnN0IGFic0FuZ2xlRGlmZiA9IE1hdGguYWJzKGFuZ2xlRGlmZik7XG4gIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydChjeDJwMHggKiBjeDJwMHggKyBjeTJwMHkgKiBjeTJwMHkpO1xuICBjb25zdCBzZWdDb3VudCA9ICgxNSAqIGFic0FuZ2xlRGlmZiAqIE1hdGguc3FydChyYWRpdXMpIC8gTWF0aC5QSSA+PiAwKSArIDE7XG4gIGNvbnN0IGFuZ2xlSW5jID0gYW5nbGVEaWZmIC8gc2VnQ291bnQ7XG4gIHN0YXJ0QW5nbGUgKz0gYW5nbGVJbmM7XG4gIGlmIChjbG9ja3dpc2UpIHtcbiAgICB2ZXJ0cy5wdXNoKGN4LCBjeSk7XG4gICAgdmVydHMucHVzaChzeCwgc3kpO1xuICAgIGZvciAobGV0IGkgPSAxLCBhbmdsZSA9IHN0YXJ0QW5nbGU7IGkgPCBzZWdDb3VudDsgaSsrLCBhbmdsZSArPSBhbmdsZUluYykge1xuICAgICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgY3ggKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgIGN5ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzXG4gICAgICApO1xuICAgIH1cbiAgICB2ZXJ0cy5wdXNoKGN4LCBjeSk7XG4gICAgdmVydHMucHVzaChleCwgZXkpO1xuICB9IGVsc2Uge1xuICAgIHZlcnRzLnB1c2goc3gsIHN5KTtcbiAgICB2ZXJ0cy5wdXNoKGN4LCBjeSk7XG4gICAgZm9yIChsZXQgaSA9IDEsIGFuZ2xlID0gc3RhcnRBbmdsZTsgaSA8IHNlZ0NvdW50OyBpKyssIGFuZ2xlICs9IGFuZ2xlSW5jKSB7XG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICBjeCArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgICAgY3kgKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXNcbiAgICAgICk7XG4gICAgICB2ZXJ0cy5wdXNoKGN4LCBjeSk7XG4gICAgfVxuICAgIHZlcnRzLnB1c2goZXgsIGV5KTtcbiAgICB2ZXJ0cy5wdXNoKGN4LCBjeSk7XG4gIH1cbiAgcmV0dXJuIHNlZ0NvdW50ICogMjtcbn1cbmZ1bmN0aW9uIGJ1aWxkTGluZShwb2ludHMsIGxpbmVTdHlsZSwgZmxpcEFsaWdubWVudCwgY2xvc2VkLCB2ZXJ0aWNlcywgX3ZlcnRpY2VzU3RyaWRlLCBfdmVydGljZXNPZmZzZXQsIGluZGljZXMsIF9pbmRpY2VzT2Zmc2V0KSB7XG4gIGNvbnN0IGVwcyA9IGNsb3NlUG9pbnRFcHM7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gbGluZVN0eWxlO1xuICBsZXQgYWxpZ25tZW50ID0gc3R5bGUuYWxpZ25tZW50O1xuICBpZiAobGluZVN0eWxlLmFsaWdubWVudCAhPT0gMC41KSB7XG4gICAgbGV0IG9yaWVudGF0aW9uID0gZ2V0T3JpZW50YXRpb25PZlBvaW50cyhwb2ludHMpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KVxuICAgICAgb3JpZW50YXRpb24gKj0gLTE7XG4gICAgYWxpZ25tZW50ID0gKGFsaWdubWVudCAtIDAuNSkgKiBvcmllbnRhdGlvbiArIDAuNTtcbiAgfVxuICBjb25zdCBmaXJzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgY29uc3QgbGFzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICBjb25zdCBjbG9zZWRTaGFwZSA9IGNsb3NlZDtcbiAgY29uc3QgY2xvc2VkUGF0aCA9IE1hdGguYWJzKGZpcnN0UG9pbnQueCAtIGxhc3RQb2ludC54KSA8IGVwcyAmJiBNYXRoLmFicyhmaXJzdFBvaW50LnkgLSBsYXN0UG9pbnQueSkgPCBlcHM7XG4gIGlmIChjbG9zZWRTaGFwZSkge1xuICAgIHBvaW50cyA9IHBvaW50cy5zbGljZSgpO1xuICAgIGlmIChjbG9zZWRQYXRoKSB7XG4gICAgICBwb2ludHMucG9wKCk7XG4gICAgICBwb2ludHMucG9wKCk7XG4gICAgICBsYXN0UG9pbnQuc2V0KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgICBjb25zdCBtaWRQb2ludFggPSAoZmlyc3RQb2ludC54ICsgbGFzdFBvaW50LngpICogMC41O1xuICAgIGNvbnN0IG1pZFBvaW50WSA9IChsYXN0UG9pbnQueSArIGZpcnN0UG9pbnQueSkgKiAwLjU7XG4gICAgcG9pbnRzLnVuc2hpZnQobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgIHBvaW50cy5wdXNoKG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgfVxuICBjb25zdCB2ZXJ0cyA9IHZlcnRpY2VzO1xuICBjb25zdCBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgbGV0IGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBpbmRleFN0YXJ0ID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgY29uc3Qgd2lkdGggPSBzdHlsZS53aWR0aCAvIDI7XG4gIGNvbnN0IHdpZHRoU3F1YXJlZCA9IHdpZHRoICogd2lkdGg7XG4gIGNvbnN0IG1pdGVyTGltaXRTcXVhcmVkID0gc3R5bGUubWl0ZXJMaW1pdCAqIHN0eWxlLm1pdGVyTGltaXQ7XG4gIGxldCB4MCA9IHBvaW50c1swXTtcbiAgbGV0IHkwID0gcG9pbnRzWzFdO1xuICBsZXQgeDEgPSBwb2ludHNbMl07XG4gIGxldCB5MSA9IHBvaW50c1szXTtcbiAgbGV0IHgyID0gMDtcbiAgbGV0IHkyID0gMDtcbiAgbGV0IHBlcnBYID0gLSh5MCAtIHkxKTtcbiAgbGV0IHBlcnBZID0geDAgLSB4MTtcbiAgbGV0IHBlcnAxeCA9IDA7XG4gIGxldCBwZXJwMXkgPSAwO1xuICBsZXQgZGlzdCA9IE1hdGguc3FydChwZXJwWCAqIHBlcnBYICsgcGVycFkgKiBwZXJwWSk7XG4gIHBlcnBYIC89IGRpc3Q7XG4gIHBlcnBZIC89IGRpc3Q7XG4gIHBlcnBYICo9IHdpZHRoO1xuICBwZXJwWSAqPSB3aWR0aDtcbiAgY29uc3QgcmF0aW8gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IGlubmVyV2VpZ2h0ID0gKDEgLSByYXRpbykgKiAyO1xuICBjb25zdCBvdXRlcldlaWdodCA9IHJhdGlvICogMjtcbiAgaWYgKCFjbG9zZWRTaGFwZSkge1xuICAgIGlmIChzdHlsZS5jYXAgPT09IFwicm91bmRcIikge1xuICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgeDAgLSBwZXJwWCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICAgICAgeTAgLSBwZXJwWSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICAgICAgeDAgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MCAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgIHgwICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICAgICAgeTAgKyBwZXJwWSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB2ZXJ0cyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKSArIDI7XG4gICAgfSBlbHNlIGlmIChzdHlsZS5jYXAgPT09IFwic3F1YXJlXCIpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gc3F1YXJlKHgwLCB5MCwgcGVycFgsIHBlcnBZLCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIHRydWUsIHZlcnRzKTtcbiAgICB9XG4gIH1cbiAgdmVydHMucHVzaChcbiAgICB4MCAtIHBlcnBYICogaW5uZXJXZWlnaHQsXG4gICAgeTAgLSBwZXJwWSAqIGlubmVyV2VpZ2h0XG4gICk7XG4gIHZlcnRzLnB1c2goXG4gICAgeDAgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LFxuICAgIHkwICsgcGVycFkgKiBvdXRlcldlaWdodFxuICApO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgIHgwID0gcG9pbnRzWyhpIC0gMSkgKiAyXTtcbiAgICB5MCA9IHBvaW50c1soaSAtIDEpICogMiArIDFdO1xuICAgIHgxID0gcG9pbnRzW2kgKiAyXTtcbiAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgIHgyID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIHBlcnBYID0gLSh5MCAtIHkxKTtcbiAgICBwZXJwWSA9IHgwIC0geDE7XG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJwWCAqIHBlcnBYICsgcGVycFkgKiBwZXJwWSk7XG4gICAgcGVycFggLz0gZGlzdDtcbiAgICBwZXJwWSAvPSBkaXN0O1xuICAgIHBlcnBYICo9IHdpZHRoO1xuICAgIHBlcnBZICo9IHdpZHRoO1xuICAgIHBlcnAxeCA9IC0oeTEgLSB5Mik7XG4gICAgcGVycDF5ID0geDEgLSB4MjtcbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAxeCAqIHBlcnAxeCArIHBlcnAxeSAqIHBlcnAxeSk7XG4gICAgcGVycDF4IC89IGRpc3Q7XG4gICAgcGVycDF5IC89IGRpc3Q7XG4gICAgcGVycDF4ICo9IHdpZHRoO1xuICAgIHBlcnAxeSAqPSB3aWR0aDtcbiAgICBjb25zdCBkeDAgPSB4MSAtIHgwO1xuICAgIGNvbnN0IGR5MCA9IHkwIC0geTE7XG4gICAgY29uc3QgZHgxID0geDEgLSB4MjtcbiAgICBjb25zdCBkeTEgPSB5MiAtIHkxO1xuICAgIGNvbnN0IGRvdCA9IGR4MCAqIGR4MSArIGR5MCAqIGR5MTtcbiAgICBjb25zdCBjcm9zcyA9IGR5MCAqIGR4MSAtIGR5MSAqIGR4MDtcbiAgICBjb25zdCBjbG9ja3dpc2UgPSBjcm9zcyA8IDA7XG4gICAgaWYgKE1hdGguYWJzKGNyb3NzKSA8IDFlLTMgKiBNYXRoLmFicyhkb3QpKSB7XG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICB4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsXG4gICAgICAgIHkxIC0gcGVycFkgKiBpbm5lcldlaWdodFxuICAgICAgKTtcbiAgICAgIHZlcnRzLnB1c2goXG4gICAgICAgIHgxICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICAgICAgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0XG4gICAgICApO1xuICAgICAgaWYgKGRvdCA+PSAwKSB7XG4gICAgICAgIGlmIChzdHlsZS5qb2luID09PSBcInJvdW5kXCIpIHtcbiAgICAgICAgICBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIHgxIC0gcGVycFggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycFkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgdmVydHMsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICkgKyA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICAgIHgxIC0gcGVycDF4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgeTEgLSBwZXJwMXkgKiBvdXRlcldlaWdodFxuICAgICAgICApO1xuICAgICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICAgIHgxICsgcGVycDF4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgeTEgKyBwZXJwMXkgKiBpbm5lcldlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGMxID0gKC1wZXJwWCArIHgwKSAqICgtcGVycFkgKyB5MSkgLSAoLXBlcnBYICsgeDEpICogKC1wZXJwWSArIHkwKTtcbiAgICBjb25zdCBjMiA9ICgtcGVycDF4ICsgeDIpICogKC1wZXJwMXkgKyB5MSkgLSAoLXBlcnAxeCArIHgxKSAqICgtcGVycDF5ICsgeTIpO1xuICAgIGNvbnN0IHB4ID0gKGR4MCAqIGMyIC0gZHgxICogYzEpIC8gY3Jvc3M7XG4gICAgY29uc3QgcHkgPSAoZHkxICogYzEgLSBkeTAgKiBjMikgLyBjcm9zcztcbiAgICBjb25zdCBwRGlzdCA9IChweCAtIHgxKSAqIChweCAtIHgxKSArIChweSAtIHkxKSAqIChweSAtIHkxKTtcbiAgICBjb25zdCBpbXggPSB4MSArIChweCAtIHgxKSAqIGlubmVyV2VpZ2h0O1xuICAgIGNvbnN0IGlteSA9IHkxICsgKHB5IC0geTEpICogaW5uZXJXZWlnaHQ7XG4gICAgY29uc3Qgb214ID0geDEgLSAocHggLSB4MSkgKiBvdXRlcldlaWdodDtcbiAgICBjb25zdCBvbXkgPSB5MSAtIChweSAtIHkxKSAqIG91dGVyV2VpZ2h0O1xuICAgIGNvbnN0IHNtYWxsZXJJbnNpZGVTZWdtZW50U3EgPSBNYXRoLm1pbihkeDAgKiBkeDAgKyBkeTAgKiBkeTAsIGR4MSAqIGR4MSArIGR5MSAqIGR5MSk7XG4gICAgY29uc3QgaW5zaWRlV2VpZ2h0ID0gY2xvY2t3aXNlID8gaW5uZXJXZWlnaHQgOiBvdXRlcldlaWdodDtcbiAgICBjb25zdCBzbWFsbGVySW5zaWRlRGlhZ29uYWxTcSA9IHNtYWxsZXJJbnNpZGVTZWdtZW50U3EgKyBpbnNpZGVXZWlnaHQgKiBpbnNpZGVXZWlnaHQgKiB3aWR0aFNxdWFyZWQ7XG4gICAgY29uc3QgaW5zaWRlTWl0ZXJPayA9IHBEaXN0IDw9IHNtYWxsZXJJbnNpZGVEaWFnb25hbFNxO1xuICAgIGlmIChpbnNpZGVNaXRlck9rKSB7XG4gICAgICBpZiAoc3R5bGUuam9pbiA9PT0gXCJiZXZlbFwiIHx8IHBEaXN0IC8gd2lkdGhTcXVhcmVkID4gbWl0ZXJMaW1pdFNxdWFyZWQpIHtcbiAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycFkgKiBpbm5lcldlaWdodCk7XG4gICAgICAgICAgdmVydHMucHVzaChvbXgsIG9teSk7XG4gICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlLmpvaW4gPT09IFwicm91bmRcIikge1xuICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgdmVydHMucHVzaChpbXgsIGlteSk7XG4gICAgICAgICAgdmVydHMucHVzaCh4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycFkgKiBvdXRlcldlaWdodCk7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICkgKyA0O1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycFkgKiBpbm5lcldlaWdodCk7XG4gICAgICAgICAgdmVydHMucHVzaChvbXgsIG9teSk7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApICsgNDtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQpO1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgdmVydHMucHVzaChvbXgsIG9teSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICAgICAgdmVydHMucHVzaCh4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycFkgKiBvdXRlcldlaWdodCk7XG4gICAgICBpZiAoc3R5bGUuam9pbiA9PT0gXCJyb3VuZFwiKSB7XG4gICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIHgxICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHkxICsgcGVycFkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgdmVydHMsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKSArIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApICsgMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHlsZS5qb2luID09PSBcIm1pdGVyXCIgJiYgcERpc3QgLyB3aWR0aFNxdWFyZWQgPD0gbWl0ZXJMaW1pdFNxdWFyZWQpIHtcbiAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXkpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICAgIH1cbiAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCk7XG4gICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgIH1cbiAgfVxuICB4MCA9IHBvaW50c1sobGVuZ3RoIC0gMikgKiAyXTtcbiAgeTAgPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMiArIDFdO1xuICB4MSA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyXTtcbiAgeTEgPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMiArIDFdO1xuICBwZXJwWCA9IC0oeTAgLSB5MSk7XG4gIHBlcnBZID0geDAgLSB4MTtcbiAgZGlzdCA9IE1hdGguc3FydChwZXJwWCAqIHBlcnBYICsgcGVycFkgKiBwZXJwWSk7XG4gIHBlcnBYIC89IGRpc3Q7XG4gIHBlcnBZIC89IGRpc3Q7XG4gIHBlcnBYICo9IHdpZHRoO1xuICBwZXJwWSAqPSB3aWR0aDtcbiAgdmVydHMucHVzaCh4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycFkgKiBpbm5lcldlaWdodCk7XG4gIHZlcnRzLnB1c2goeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQpO1xuICBpZiAoIWNsb3NlZFNoYXBlKSB7XG4gICAgaWYgKHN0eWxlLmNhcCA9PT0gXCJyb3VuZFwiKSB7XG4gICAgICBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgICAgICB4MSAtIHBlcnBYICogKGlubmVyV2VpZ2h0IC0gb3V0ZXJXZWlnaHQpICogMC41LFxuICAgICAgICB5MSAtIHBlcnBZICogKGlubmVyV2VpZ2h0IC0gb3V0ZXJXZWlnaHQpICogMC41LFxuICAgICAgICB4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsXG4gICAgICAgIHkxIC0gcGVycFkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQsXG4gICAgICAgIHZlcnRzLFxuICAgICAgICBmYWxzZVxuICAgICAgKSArIDI7XG4gICAgfSBlbHNlIGlmIChzdHlsZS5jYXAgPT09IFwic3F1YXJlXCIpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gc3F1YXJlKHgxLCB5MSwgcGVycFgsIHBlcnBZLCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIGZhbHNlLCB2ZXJ0cyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGVwczIgPSBjdXJ2ZUVwcyAqIGN1cnZlRXBzO1xuICBmb3IgKGxldCBpID0gaW5kZXhTdGFydDsgaSA8IGluZGV4Q291bnQgKyBpbmRleFN0YXJ0IC0gMjsgKytpKSB7XG4gICAgeDAgPSB2ZXJ0c1tpICogMl07XG4gICAgeTAgPSB2ZXJ0c1tpICogMiArIDFdO1xuICAgIHgxID0gdmVydHNbKGkgKyAxKSAqIDJdO1xuICAgIHkxID0gdmVydHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB4MiA9IHZlcnRzWyhpICsgMikgKiAyXTtcbiAgICB5MiA9IHZlcnRzWyhpICsgMikgKiAyICsgMV07XG4gICAgaWYgKE1hdGguYWJzKHgwICogKHkxIC0geTIpICsgeDEgKiAoeTIgLSB5MCkgKyB4MiAqICh5MCAtIHkxKSkgPCBlcHMyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5kaWNlcy5wdXNoKGksIGkgKyAxLCBpICsgMik7XG4gIH1cbn1cblxuZXhwb3J0IHsgYnVpbGRMaW5lIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZExpbmUubWpzLm1hcFxuIiwiaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHRyaWFuZ3VsYXRlV2l0aEhvbGVzKHBvaW50cywgaG9sZXMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgY29uc3QgdHJpYW5nbGVzID0gZWFyY3V0KHBvaW50cywgaG9sZXMsIDIpO1xuICBpZiAoIXRyaWFuZ2xlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IHRyaWFuZ2xlc1tpXSArIHZlcnRpY2VzT2Zmc2V0O1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IHRyaWFuZ2xlc1tpICsgMV0gKyB2ZXJ0aWNlc09mZnNldDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB0cmlhbmdsZXNbaSArIDJdICsgdmVydGljZXNPZmZzZXQ7XG4gIH1cbiAgbGV0IGluZGV4ID0gdmVydGljZXNPZmZzZXQgKiB2ZXJ0aWNlc1N0cmlkZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2ZXJ0aWNlc1tpbmRleF0gPSBwb2ludHNbaV07XG4gICAgdmVydGljZXNbaW5kZXggKyAxXSA9IHBvaW50c1tpICsgMV07XG4gICAgaW5kZXggKz0gdmVydGljZXNTdHJpZGU7XG4gIH1cbn1cblxuZXhwb3J0IHsgdHJpYW5ndWxhdGVXaXRoSG9sZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaWFuZ3VsYXRlV2l0aEhvbGVzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHRyaWFuZ3VsYXRlV2l0aEhvbGVzIH0gZnJvbSAnLi4vdXRpbHMvdHJpYW5ndWxhdGVXaXRoSG9sZXMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5jb25zdCBidWlsZFBvbHlnb24gPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuU2hhcGVCdWlsZGVyLFxuICAgIG5hbWU6IFwicG9seWdvblwiXG4gIH0sXG4gIGJ1aWxkKHNoYXBlLCBwb2ludHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9pbnRzW2ldID0gc2hhcGUucG9pbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICB0cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgICB0cmlhbmd1bGF0ZVdpdGhIb2xlcyhwb2ludHMsIGVtcHR5QXJyYXksIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpO1xuICB9XG59O1xuXG5leHBvcnQgeyBidWlsZFBvbHlnb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUG9seWdvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgYnVpbGRSZWN0YW5nbGUgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuU2hhcGVCdWlsZGVyLFxuICAgIG5hbWU6IFwicmVjdGFuZ2xlXCJcbiAgfSxcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIGNvbnN0IHJlY3REYXRhID0gc2hhcGU7XG4gICAgY29uc3QgeCA9IHJlY3REYXRhLng7XG4gICAgY29uc3QgeSA9IHJlY3REYXRhLnk7XG4gICAgY29uc3Qgd2lkdGggPSByZWN0RGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG4gICAgaWYgKCEod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMCkpIHtcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHBvaW50c1swXSA9IHg7XG4gICAgcG9pbnRzWzFdID0geTtcbiAgICBwb2ludHNbMl0gPSB4ICsgd2lkdGg7XG4gICAgcG9pbnRzWzNdID0geTtcbiAgICBwb2ludHNbNF0gPSB4ICsgd2lkdGg7XG4gICAgcG9pbnRzWzVdID0geSArIGhlaWdodDtcbiAgICBwb2ludHNbNl0gPSB4O1xuICAgIHBvaW50c1s3XSA9IHkgKyBoZWlnaHQ7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgdHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB2ZXJ0aWNlc09mZnNldCAqPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1swXTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbMV07XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudF0gPSBwb2ludHNbMl07XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudCArIDFdID0gcG9pbnRzWzNdO1xuICAgIGNvdW50ICs9IHZlcnRpY2VzU3RyaWRlO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnRdID0gcG9pbnRzWzZdO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnQgKyAxXSA9IHBvaW50c1s3XTtcbiAgICBjb3VudCArPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1s0XTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbNV07XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgY29uc3QgdmVydGljZXNJbmRleCA9IHZlcnRpY2VzT2Zmc2V0IC8gdmVydGljZXNTdHJpZGU7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMjtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMztcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMjtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRSZWN0YW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBidWlsZFRyaWFuZ2xlID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLlNoYXBlQnVpbGRlcixcbiAgICBuYW1lOiBcInRyaWFuZ2xlXCJcbiAgfSxcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIHBvaW50c1swXSA9IHNoYXBlLng7XG4gICAgcG9pbnRzWzFdID0gc2hhcGUueTtcbiAgICBwb2ludHNbMl0gPSBzaGFwZS54MjtcbiAgICBwb2ludHNbM10gPSBzaGFwZS55MjtcbiAgICBwb2ludHNbNF0gPSBzaGFwZS54MztcbiAgICBwb2ludHNbNV0gPSBzaGFwZS55MztcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICB0cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHZlcnRpY2VzT2Zmc2V0ICo9IHZlcnRpY2VzU3RyaWRlO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnRdID0gcG9pbnRzWzBdO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnQgKyAxXSA9IHBvaW50c1sxXTtcbiAgICBjb3VudCArPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1syXTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbM107XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudF0gPSBwb2ludHNbNF07XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudCArIDFdID0gcG9pbnRzWzVdO1xuICAgIGNvbnN0IHZlcnRpY2VzSW5kZXggPSB2ZXJ0aWNlc09mZnNldCAvIHZlcnRpY2VzU3RyaWRlO1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IHZlcnRpY2VzSW5kZXg7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleCArIDE7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleCArIDI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJ1aWxkVHJpYW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkVHJpYW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucywgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRVdnMsIGJ1aWxkU2ltcGxlVXZzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvYnVpbGRVdnMubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvdHJhbnNmb3JtVmVydGljZXMubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlR3JhcGhpY3MgfSBmcm9tICcuLi9CYXRjaGFibGVHcmFwaGljcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRDaXJjbGUsIGJ1aWxkRWxsaXBzZSwgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZENpcmNsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRMaW5lIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZExpbmUubWpzJztcbmltcG9ydCB7IGJ1aWxkUG9seWdvbiB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRQb2x5Z29uLm1qcyc7XG5pbXBvcnQgeyBidWlsZFJlY3RhbmdsZSB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRSZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IGJ1aWxkVHJpYW5nbGUgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkVHJpYW5nbGUubWpzJztcbmltcG9ydCB7IHRyaWFuZ3VsYXRlV2l0aEhvbGVzIH0gZnJvbSAnLi90cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHNoYXBlQnVpbGRlcnMgPSB7fTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlNYXAoRXh0ZW5zaW9uVHlwZS5TaGFwZUJ1aWxkZXIsIHNoYXBlQnVpbGRlcnMpO1xuZXh0ZW5zaW9ucy5hZGQoYnVpbGRSZWN0YW5nbGUsIGJ1aWxkUG9seWdvbiwgYnVpbGRUcmlhbmdsZSwgYnVpbGRDaXJjbGUsIGJ1aWxkRWxsaXBzZSwgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlKTtcbmNvbnN0IHRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuZnVuY3Rpb24gYnVpbGRDb250ZXh0QmF0Y2hlcyhjb250ZXh0LCBncHVDb250ZXh0KSB7XG4gIGNvbnN0IHsgZ2VvbWV0cnlEYXRhLCBiYXRjaGVzIH0gPSBncHVDb250ZXh0O1xuICBiYXRjaGVzLmxlbmd0aCA9IDA7XG4gIGdlb21ldHJ5RGF0YS5pbmRpY2VzLmxlbmd0aCA9IDA7XG4gIGdlb21ldHJ5RGF0YS52ZXJ0aWNlcy5sZW5ndGggPSAwO1xuICBnZW9tZXRyeURhdGEudXZzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGV4dC5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGNvbnRleHQuaW5zdHJ1Y3Rpb25zW2ldO1xuICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwidGV4dHVyZVwiKSB7XG4gICAgICBhZGRUZXh0dXJlVG9HZW9tZXRyeURhdGEoaW5zdHJ1Y3Rpb24uZGF0YSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJmaWxsXCIgfHwgaW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBjb25zdCBpc1N0cm9rZSA9IGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJzdHJva2VcIjtcbiAgICAgIGNvbnN0IHNoYXBlUGF0aCA9IGluc3RydWN0aW9uLmRhdGEucGF0aC5zaGFwZVBhdGg7XG4gICAgICBjb25zdCBzdHlsZSA9IGluc3RydWN0aW9uLmRhdGEuc3R5bGU7XG4gICAgICBjb25zdCBob2xlID0gaW5zdHJ1Y3Rpb24uZGF0YS5ob2xlO1xuICAgICAgaWYgKGlzU3Ryb2tlICYmIGhvbGUpIHtcbiAgICAgICAgYWRkU2hhcGVQYXRoVG9HZW9tZXRyeURhdGEoaG9sZS5zaGFwZVBhdGgsIHN0eWxlLCBudWxsLCB0cnVlLCBiYXRjaGVzLCBnZW9tZXRyeURhdGEpO1xuICAgICAgfVxuICAgICAgYWRkU2hhcGVQYXRoVG9HZW9tZXRyeURhdGEoc2hhcGVQYXRoLCBzdHlsZSwgaG9sZSwgaXNTdHJva2UsIGJhdGNoZXMsIGdlb21ldHJ5RGF0YSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUZXh0dXJlVG9HZW9tZXRyeURhdGEoZGF0YSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKSB7XG4gIGNvbnN0IHsgdmVydGljZXMsIHV2cywgaW5kaWNlcyB9ID0gZ2VvbWV0cnlEYXRhO1xuICBjb25zdCBpbmRleE9mZnNldCA9IGluZGljZXMubGVuZ3RoO1xuICBjb25zdCB2ZXJ0T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMjtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IGJ1aWxkID0gc2hhcGVCdWlsZGVycy5yZWN0YW5nbGU7XG4gIGNvbnN0IHJlY3QgPSB0ZW1wUmVjdDtcbiAgY29uc3QgdGV4dHVyZSA9IGRhdGEuaW1hZ2U7XG4gIHJlY3QueCA9IGRhdGEuZHg7XG4gIHJlY3QueSA9IGRhdGEuZHk7XG4gIHJlY3Qud2lkdGggPSBkYXRhLmR3O1xuICByZWN0LmhlaWdodCA9IGRhdGEuZGg7XG4gIGNvbnN0IG1hdHJpeCA9IGRhdGEudHJhbnNmb3JtO1xuICBidWlsZC5idWlsZChyZWN0LCBwb2ludHMpO1xuICBpZiAobWF0cml4KSB7XG4gICAgdHJhbnNmb3JtVmVydGljZXMocG9pbnRzLCBtYXRyaXgpO1xuICB9XG4gIGJ1aWxkLnRyaWFuZ3VsYXRlKHBvaW50cywgdmVydGljZXMsIDIsIHZlcnRPZmZzZXQsIGluZGljZXMsIGluZGV4T2Zmc2V0KTtcbiAgY29uc3QgdGV4dHVyZVV2cyA9IHRleHR1cmUudXZzO1xuICB1dnMucHVzaChcbiAgICB0ZXh0dXJlVXZzLngwLFxuICAgIHRleHR1cmVVdnMueTAsXG4gICAgdGV4dHVyZVV2cy54MSxcbiAgICB0ZXh0dXJlVXZzLnkxLFxuICAgIHRleHR1cmVVdnMueDMsXG4gICAgdGV4dHVyZVV2cy55MyxcbiAgICB0ZXh0dXJlVXZzLngyLFxuICAgIHRleHR1cmVVdnMueTJcbiAgKTtcbiAgY29uc3QgZ3JhcGhpY3NCYXRjaCA9IEJpZ1Bvb2wuZ2V0KEJhdGNoYWJsZUdyYXBoaWNzKTtcbiAgZ3JhcGhpY3NCYXRjaC5pbmRleE9mZnNldCA9IGluZGV4T2Zmc2V0O1xuICBncmFwaGljc0JhdGNoLmluZGV4U2l6ZSA9IGluZGljZXMubGVuZ3RoIC0gaW5kZXhPZmZzZXQ7XG4gIGdyYXBoaWNzQmF0Y2gudmVydGV4T2Zmc2V0ID0gdmVydE9mZnNldDtcbiAgZ3JhcGhpY3NCYXRjaC52ZXJ0ZXhTaXplID0gdmVydGljZXMubGVuZ3RoIC8gMiAtIHZlcnRPZmZzZXQ7XG4gIGdyYXBoaWNzQmF0Y2guY29sb3IgPSBkYXRhLnN0eWxlO1xuICBncmFwaGljc0JhdGNoLmFscGhhID0gZGF0YS5hbHBoYTtcbiAgZ3JhcGhpY3NCYXRjaC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgZ3JhcGhpY3NCYXRjaC5nZW9tZXRyeURhdGEgPSBnZW9tZXRyeURhdGE7XG4gIGJhdGNoZXMucHVzaChncmFwaGljc0JhdGNoKTtcbn1cbmZ1bmN0aW9uIGFkZFNoYXBlUGF0aFRvR2VvbWV0cnlEYXRhKHNoYXBlUGF0aCwgc3R5bGUsIGhvbGUsIGlzU3Ryb2tlLCBiYXRjaGVzLCBnZW9tZXRyeURhdGEpIHtcbiAgY29uc3QgeyB2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzIH0gPSBnZW9tZXRyeURhdGE7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHNoYXBlUGF0aC5zaGFwZVByaW1pdGl2ZXMubGVuZ3RoIC0gMTtcbiAgc2hhcGVQYXRoLnNoYXBlUHJpbWl0aXZlcy5mb3JFYWNoKCh7IHNoYXBlLCB0cmFuc2Zvcm06IG1hdHJpeCB9LCBpKSA9PiB7XG4gICAgY29uc3QgaW5kZXhPZmZzZXQgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBjb25zdCBidWlsZCA9IHNoYXBlQnVpbGRlcnNbc2hhcGUudHlwZV07XG4gICAgYnVpbGQuYnVpbGQoc2hhcGUsIHBvaW50cyk7XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdHJhbnNmb3JtVmVydGljZXMocG9pbnRzLCBtYXRyaXgpO1xuICAgIH1cbiAgICBpZiAoIWlzU3Ryb2tlKSB7XG4gICAgICBpZiAoaG9sZSAmJiBsYXN0SW5kZXggPT09IGkpIHtcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltQaXhpIEdyYXBoaWNzXSBvbmx5IHRoZSBsYXN0IHNoYXBlIGhhdmUgYmUgY3V0IG91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob2xlSW5kaWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBvdGhlclBvaW50cyA9IHBvaW50cy5zbGljZSgpO1xuICAgICAgICBjb25zdCBob2xlQXJyYXlzID0gZ2V0SG9sZUFycmF5cyhob2xlLnNoYXBlUGF0aCk7XG4gICAgICAgIGhvbGVBcnJheXMuZm9yRWFjaCgoaG9sZVBvaW50cykgPT4ge1xuICAgICAgICAgIGhvbGVJbmRpY2VzLnB1c2gob3RoZXJQb2ludHMubGVuZ3RoIC8gMik7XG4gICAgICAgICAgb3RoZXJQb2ludHMucHVzaCguLi5ob2xlUG9pbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyaWFuZ3VsYXRlV2l0aEhvbGVzKG90aGVyUG9pbnRzLCBob2xlSW5kaWNlcywgdmVydGljZXMsIDIsIHZlcnRPZmZzZXQsIGluZGljZXMsIGluZGV4T2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1aWxkLnRyaWFuZ3VsYXRlKHBvaW50cywgdmVydGljZXMsIDIsIHZlcnRPZmZzZXQsIGluZGljZXMsIGluZGV4T2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2xvc2UgPSBzaGFwZS5jbG9zZVBhdGggPz8gdHJ1ZTtcbiAgICAgIGNvbnN0IGxpbmVTdHlsZSA9IHN0eWxlO1xuICAgICAgYnVpbGRMaW5lKHBvaW50cywgbGluZVN0eWxlLCBmYWxzZSwgY2xvc2UsIHZlcnRpY2VzLCAyLCB2ZXJ0T2Zmc2V0LCBpbmRpY2VzLCBpbmRleE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IHV2c09mZnNldCA9IHV2cy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IHRleHR1cmUgPSBzdHlsZS50ZXh0dXJlO1xuICAgIGlmICh0ZXh0dXJlICE9PSBUZXh0dXJlLldISVRFKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlTWF0cml4ID0gc3R5bGUubWF0cml4O1xuICAgICAgaWYgKHRleHR1cmVNYXRyaXgpIHtcbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgIHRleHR1cmVNYXRyaXguYXBwZW5kKG1hdHJpeC5jbG9uZSgpLmludmVydCgpKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZFV2cyh2ZXJ0aWNlcywgMiwgdmVydE9mZnNldCwgdXZzLCB1dnNPZmZzZXQsIDIsIHZlcnRpY2VzLmxlbmd0aCAvIDIgLSB2ZXJ0T2Zmc2V0LCB0ZXh0dXJlTWF0cml4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnVpbGRTaW1wbGVVdnModXZzLCB1dnNPZmZzZXQsIDIsIHZlcnRpY2VzLmxlbmd0aCAvIDIgLSB2ZXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZ3JhcGhpY3NCYXRjaCA9IEJpZ1Bvb2wuZ2V0KEJhdGNoYWJsZUdyYXBoaWNzKTtcbiAgICBncmFwaGljc0JhdGNoLmluZGV4T2Zmc2V0ID0gaW5kZXhPZmZzZXQ7XG4gICAgZ3JhcGhpY3NCYXRjaC5pbmRleFNpemUgPSBpbmRpY2VzLmxlbmd0aCAtIGluZGV4T2Zmc2V0O1xuICAgIGdyYXBoaWNzQmF0Y2gudmVydGV4T2Zmc2V0ID0gdmVydE9mZnNldDtcbiAgICBncmFwaGljc0JhdGNoLnZlcnRleFNpemUgPSB2ZXJ0aWNlcy5sZW5ndGggLyAyIC0gdmVydE9mZnNldDtcbiAgICBncmFwaGljc0JhdGNoLmNvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgZ3JhcGhpY3NCYXRjaC5hbHBoYSA9IHN0eWxlLmFscGhhO1xuICAgIGdyYXBoaWNzQmF0Y2gudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgZ3JhcGhpY3NCYXRjaC5nZW9tZXRyeURhdGEgPSBnZW9tZXRyeURhdGE7XG4gICAgYmF0Y2hlcy5wdXNoKGdyYXBoaWNzQmF0Y2gpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEhvbGVBcnJheXMoc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGhvbGVQcmltaXRpdmVzID0gc2hhcGUuc2hhcGVQcmltaXRpdmVzO1xuICBjb25zdCBob2xlQXJyYXlzID0gW107XG4gIGZvciAobGV0IGsgPSAwOyBrIDwgaG9sZVByaW1pdGl2ZXMubGVuZ3RoOyBrKyspIHtcbiAgICBjb25zdCBob2xlUHJpbWl0aXZlID0gaG9sZVByaW1pdGl2ZXNba10uc2hhcGU7XG4gICAgY29uc3QgaG9sZVBvaW50cyA9IFtdO1xuICAgIGNvbnN0IGhvbGVCdWlsZGVyID0gc2hhcGVCdWlsZGVyc1tob2xlUHJpbWl0aXZlLnR5cGVdO1xuICAgIGhvbGVCdWlsZGVyLmJ1aWxkKGhvbGVQcmltaXRpdmUsIGhvbGVQb2ludHMpO1xuICAgIGhvbGVBcnJheXMucHVzaChob2xlUG9pbnRzKTtcbiAgfVxuICByZXR1cm4gaG9sZUFycmF5cztcbn1cblxuZXhwb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcywgc2hhcGVCdWlsZGVycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDb250ZXh0QmF0Y2hlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBnZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvZ2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXIubWpzJztcbmltcG9ydCB7IEJhdGNoR2VvbWV0cnkgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hHZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgSW5zdHJ1Y3Rpb25TZXQgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9pbnN0cnVjdGlvbnMvSW5zdHJ1Y3Rpb25TZXQubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9IGZyb20gJy4vdXRpbHMvYnVpbGRDb250ZXh0QmF0Y2hlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdUdyYXBoaWNzQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlciA9IG5ldyBCYXRjaGVyKCk7XG4gICAgdGhpcy5iYXRjaGVzID0gW107XG4gICAgdGhpcy5nZW9tZXRyeURhdGEgPSB7XG4gICAgICB2ZXJ0aWNlczogW10sXG4gICAgICB1dnM6IFtdLFxuICAgICAgaW5kaWNlczogW11cbiAgICB9O1xuICB9XG59XG5jbGFzcyBHcmFwaGljc0NvbnRleHRSZW5kZXJEYXRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBCYXRjaEdlb21ldHJ5KCk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBuZXcgSW5zdHJ1Y3Rpb25TZXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnJlc2V0KCk7XG4gIH1cbn1cbmNvbnN0IF9HcmFwaGljc0NvbnRleHRTeXN0ZW0gPSBjbGFzcyBfR3JhcGhpY3NDb250ZXh0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gdGhlIHJvb3QgY29udGV4dCBiYXRjaGVzLCB1c2VkIHRvIGVpdGhlciBtYWtlIGEgYmF0Y2ggb3IgZ2VvbWV0cnlcbiAgICAvLyBhbGwgZ3JhcGhpY3MgdXNlIHRoaXMgYXMgYSBiYXNlXG4gICAgdGhpcy5fZ3B1Q29udGV4dEhhc2ggPSB7fTtcbiAgICAvLyB1c2VkIGZvciBub24tYmF0Y2hhYmxlIGdyYXBoaWNzXG4gICAgdGhpcy5fZ3JhcGhpY3NEYXRhQ29udGV4dEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAvKipcbiAgICogUnVubmVyIGluaXQgY2FsbGVkLCB1cGRhdGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgKiBAaWdub3JlXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICBfR3JhcGhpY3NDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLmJlemllclNtb290aG5lc3MgPSBvcHRpb25zPy5iZXppZXJTbW9vdGhuZXNzID8/IF9HcmFwaGljc0NvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMuYmV6aWVyU21vb3RobmVzcztcbiAgfVxuICBnZXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNzRGF0YUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSB8fCB0aGlzLl9pbml0Q29udGV4dFJlbmRlckRhdGEoY29udGV4dCk7XG4gIH1cbiAgLy8gQ29udGV4dCBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuICB1cGRhdGVHcHVDb250ZXh0KGNvbnRleHQpIHtcbiAgICBsZXQgZ3B1Q29udGV4dCA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSB8fCB0aGlzLl9pbml0Q29udGV4dChjb250ZXh0KTtcbiAgICBpZiAoY29udGV4dC5kaXJ0eSkge1xuICAgICAgaWYgKGdwdUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY2xlYW5HcmFwaGljc0NvbnRleHREYXRhKGNvbnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3B1Q29udGV4dCA9IHRoaXMuX2luaXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgYnVpbGRDb250ZXh0QmF0Y2hlcyhjb250ZXh0LCBncHVDb250ZXh0KTtcbiAgICAgIGNvbnN0IGJhdGNoTW9kZSA9IGNvbnRleHQuYmF0Y2hNb2RlO1xuICAgICAgaWYgKGNvbnRleHQuY3VzdG9tU2hhZGVyIHx8IGJhdGNoTW9kZSA9PT0gXCJuby1iYXRjaFwiKSB7XG4gICAgICAgIGdwdUNvbnRleHQuaXNCYXRjaGFibGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoYmF0Y2hNb2RlID09PSBcImF1dG9cIikge1xuICAgICAgICBncHVDb250ZXh0LmlzQmF0Y2hhYmxlID0gZ3B1Q29udGV4dC5nZW9tZXRyeURhdGEudmVydGljZXMubGVuZ3RoIDwgNDAwO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZ3B1Q29udGV4dDtcbiAgfVxuICBnZXRHcHVDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdIHx8IHRoaXMuX2luaXRDb250ZXh0KGNvbnRleHQpO1xuICB9XG4gIF9pbml0Q29udGV4dFJlbmRlckRhdGEoY29udGV4dCkge1xuICAgIGNvbnN0IGdyYXBoaWNzRGF0YSA9IEJpZ1Bvb2wuZ2V0KEdyYXBoaWNzQ29udGV4dFJlbmRlckRhdGEpO1xuICAgIGNvbnN0IHsgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhLCBiYXRjaGVyIH0gPSB0aGlzLl9ncHVDb250ZXh0SGFzaFtjb250ZXh0LnVpZF07XG4gICAgY29uc3QgdmVydGV4U2l6ZSA9IGdlb21ldHJ5RGF0YS52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgY29uc3QgaW5kZXhTaXplID0gZ2VvbWV0cnlEYXRhLmluZGljZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYmF0Y2hlc1tpXS5hcHBseVRyYW5zZm9ybSA9IGZhbHNlO1xuICAgIH1cbiAgICBiYXRjaGVyLmVuc3VyZUF0dHJpYnV0ZUJ1ZmZlcih2ZXJ0ZXhTaXplKTtcbiAgICBiYXRjaGVyLmVuc3VyZUluZGV4QnVmZmVyKGluZGV4U2l6ZSk7XG4gICAgYmF0Y2hlci5iZWdpbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2ldO1xuICAgICAgYmF0Y2hlci5hZGQoYmF0Y2gpO1xuICAgIH1cbiAgICBiYXRjaGVyLmZpbmlzaChncmFwaGljc0RhdGEuaW5zdHJ1Y3Rpb25zKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IGdyYXBoaWNzRGF0YS5nZW9tZXRyeTtcbiAgICBnZW9tZXRyeS5pbmRleEJ1ZmZlci5zZXREYXRhV2l0aFNpemUoYmF0Y2hlci5pbmRleEJ1ZmZlciwgYmF0Y2hlci5pbmRleFNpemUsIHRydWUpO1xuICAgIGdlb21ldHJ5LmJ1ZmZlcnNbMF0uc2V0RGF0YVdpdGhTaXplKGJhdGNoZXIuYXR0cmlidXRlQnVmZmVyLmZsb2F0MzJWaWV3LCBiYXRjaGVyLmF0dHJpYnV0ZVNpemUsIHRydWUpO1xuICAgIGNvbnN0IGRyYXdCYXRjaGVzID0gYmF0Y2hlci5iYXRjaGVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJhd0JhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gZHJhd0JhdGNoZXNbaV07XG4gICAgICBiYXRjaC5iaW5kR3JvdXAgPSBnZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAoYmF0Y2gudGV4dHVyZXMudGV4dHVyZXMsIGJhdGNoLnRleHR1cmVzLmNvdW50KTtcbiAgICB9XG4gICAgdGhpcy5fZ3JhcGhpY3NEYXRhQ29udGV4dEhhc2hbY29udGV4dC51aWRdID0gZ3JhcGhpY3NEYXRhO1xuICAgIHJldHVybiBncmFwaGljc0RhdGE7XG4gIH1cbiAgX2luaXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gbmV3IEdwdUdyYXBoaWNzQ29udGV4dCgpO1xuICAgIGdwdUNvbnRleHQuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdID0gZ3B1Q29udGV4dDtcbiAgICBjb250ZXh0Lm9uKFwiZGVzdHJveVwiLCB0aGlzLm9uR3JhcGhpY3NDb250ZXh0RGVzdHJveSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXTtcbiAgfVxuICBvbkdyYXBoaWNzQ29udGV4dERlc3Ryb3koY29udGV4dCkge1xuICAgIHRoaXMuX2NsZWFuR3JhcGhpY3NDb250ZXh0RGF0YShjb250ZXh0KTtcbiAgICBjb250ZXh0Lm9mZihcImRlc3Ryb3lcIiwgdGhpcy5vbkdyYXBoaWNzQ29udGV4dERlc3Ryb3ksIHRoaXMpO1xuICAgIHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSA9IG51bGw7XG4gIH1cbiAgX2NsZWFuR3JhcGhpY3NDb250ZXh0RGF0YShjb250ZXh0KSB7XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXTtcbiAgICBpZiAoIWdwdUNvbnRleHQuaXNCYXRjaGFibGUpIHtcbiAgICAgIGlmICh0aGlzLl9ncmFwaGljc0RhdGFDb250ZXh0SGFzaFtjb250ZXh0LnVpZF0pIHtcbiAgICAgICAgQmlnUG9vbC5yZXR1cm4odGhpcy5nZXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSk7XG4gICAgICAgIHRoaXMuX2dyYXBoaWNzRGF0YUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChncHVDb250ZXh0LmJhdGNoZXMpIHtcbiAgICAgIGdwdUNvbnRleHQuYmF0Y2hlcy5mb3JFYWNoKChiYXRjaCkgPT4ge1xuICAgICAgICBCaWdQb29sLnJldHVybihiYXRjaCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ3B1Q29udGV4dEhhc2gpIHtcbiAgICAgIGlmICh0aGlzLl9ncHVDb250ZXh0SGFzaFtpXSkge1xuICAgICAgICB0aGlzLm9uR3JhcGhpY3NDb250ZXh0RGVzdHJveSh0aGlzLl9ncHVDb250ZXh0SGFzaFtpXS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vKiogQGlnbm9yZSAqL1xuX0dyYXBoaWNzQ29udGV4dFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiZ3JhcGhpY3NDb250ZXh0XCJcbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIEdyYXBoaWNzQ29udGV4dFN5c3RlbS4gKi9cbl9HcmFwaGljc0NvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBBIHZhbHVlIGZyb20gMCB0byAxIHRoYXQgY29udHJvbHMgdGhlIHNtb290aG5lc3Mgb2YgYmV6aWVyIGN1cnZlcyAodGhlIGhpZ2hlciB0aGUgc21vb3RoZXIpXG4gICAqIEBkZWZhdWx0IDAuNVxuICAgKi9cbiAgYmV6aWVyU21vb3RobmVzczogMC41XG59O1xubGV0IEdyYXBoaWNzQ29udGV4dFN5c3RlbSA9IF9HcmFwaGljc0NvbnRleHRTeXN0ZW07XG5cbmV4cG9ydCB7IEdwdUdyYXBoaWNzQ29udGV4dCwgR3JhcGhpY3NDb250ZXh0UmVuZGVyRGF0YSwgR3JhcGhpY3NDb250ZXh0U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4108\n')},557:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ FillGradient)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8409);\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3646);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9160);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9853);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n\n\n\n\n\n"use strict";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    /** unique id for this fill gradient */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillGradient");\n    this.type = "linear";\n    this.gradientStops = [];\n    this._styleKey = null;\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(color).toHexa() });\n    this._styleKey = null;\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext("2d");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture */ .x({\n      source: new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__/* .ImageSource */ .c({\n        resource: canvas,\n        addressModeU: "clamp-to-edge",\n        addressModeV: "repeat"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__/* .Matrix */ .y();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey) {\n      return this._styleKey;\n    }\n    const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join("-");\n    const texture = this.texture.uid;\n    const transform = this.transform.toArray().join("-");\n    return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\n\n//# sourceMappingURL=FillGradient.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRDtBQUNhO0FBQ0o7QUFDd0M7QUFDaEI7QUFDaEM7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZSw0REFBSyxrQ0FBa0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsbUJBQW1CLHlFQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZGQUFPO0FBQzlCLGtCQUFrQiw2R0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLFlBQVksaUJBQWlCO0FBQzdCLGtCQUFrQixxRUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsWUFBWSxHQUFHLFdBQVc7QUFDaEY7QUFDQTtBQUNBLDRCQUE0QixTQUFTLEdBQUcsTUFBTSxHQUFHLFFBQVEsR0FBRyxVQUFVLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyxRQUFRLEdBQUcsUUFBUTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcz9kNTg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBJbWFnZVNvdXJjZSB9IGZyb20gJy4uLy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9JbWFnZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfRmlsbEdyYWRpZW50ID0gY2xhc3MgX0ZpbGxHcmFkaWVudCB7XG4gIGNvbnN0cnVjdG9yKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgLyoqIHVuaXF1ZSBpZCBmb3IgdGhpcyBmaWxsIGdyYWRpZW50ICovXG4gICAgdGhpcy51aWQgPSB1aWQoXCJmaWxsR3JhZGllbnRcIik7XG4gICAgdGhpcy50eXBlID0gXCJsaW5lYXJcIjtcbiAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSBbXTtcbiAgICB0aGlzLl9zdHlsZUtleSA9IG51bGw7XG4gICAgdGhpcy54MCA9IHgwO1xuICAgIHRoaXMueTAgPSB5MDtcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICB9XG4gIGFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKSB7XG4gICAgdGhpcy5ncmFkaWVudFN0b3BzLnB1c2goeyBvZmZzZXQsIGNvbG9yOiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvSGV4YSgpIH0pO1xuICAgIHRoaXMuX3N0eWxlS2V5ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvLyBUT0RPIG1vdmUgdG8gdGhlIHN5c3RlbSFcbiAgYnVpbGRMaW5lYXJHcmFkaWVudCgpIHtcbiAgICBjb25zdCBkZWZhdWx0U2l6ZSA9IF9GaWxsR3JhZGllbnQuZGVmYXVsdFRleHR1cmVTaXplO1xuICAgIGNvbnN0IHsgZ3JhZGllbnRTdG9wcyB9ID0gdGhpcztcbiAgICBjb25zdCBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGRlZmF1bHRTaXplO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZWZhdWx0U2l6ZTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIF9GaWxsR3JhZGllbnQuZGVmYXVsdFRleHR1cmVTaXplLCAxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYWRpZW50U3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0b3AgPSBncmFkaWVudFN0b3BzW2ldO1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3Aub2Zmc2V0LCBzdG9wLmNvbG9yKTtcbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBkZWZhdWx0U2l6ZSwgZGVmYXVsdFNpemUpO1xuICAgIHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcbiAgICAgIHNvdXJjZTogbmV3IEltYWdlU291cmNlKHtcbiAgICAgICAgcmVzb3VyY2U6IGNhbnZhcyxcbiAgICAgICAgYWRkcmVzc01vZGVVOiBcImNsYW1wLXRvLWVkZ2VcIixcbiAgICAgICAgYWRkcmVzc01vZGVWOiBcInJlcGVhdFwiXG4gICAgICB9KVxuICAgIH0pO1xuICAgIGNvbnN0IHsgeDAsIHkwLCB4MSwgeTEgfSA9IHRoaXM7XG4gICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoKTtcbiAgICBjb25zdCBkeCA9IHgxIC0geDA7XG4gICAgY29uc3QgZHkgPSB5MSAtIHkwO1xuICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgIG0udHJhbnNsYXRlKC14MCwgLXkwKTtcbiAgICBtLnNjYWxlKDEgLyBkZWZhdWx0U2l6ZSwgMSAvIGRlZmF1bHRTaXplKTtcbiAgICBtLnJvdGF0ZSgtYW5nbGUpO1xuICAgIG0uc2NhbGUoMjU2IC8gZGlzdCwgMSk7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBtO1xuICAgIHRoaXMuX3N0eWxlS2V5ID0gbnVsbDtcbiAgfVxuICBnZXQgc3R5bGVLZXkoKSB7XG4gICAgaWYgKHRoaXMuX3N0eWxlS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVLZXk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3BzID0gdGhpcy5ncmFkaWVudFN0b3BzLm1hcCgoc3RvcCkgPT4gYCR7c3RvcC5vZmZzZXR9LSR7c3RvcC5jb2xvcn1gKS5qb2luKFwiLVwiKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlLnVpZDtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS50b0FycmF5KCkuam9pbihcIi1cIik7XG4gICAgcmV0dXJuIGBmaWxsLWdyYWRpZW50LSR7dGhpcy51aWR9LSR7c3RvcHN9LSR7dGV4dHVyZX0tJHt0cmFuc2Zvcm19LSR7dGhpcy54MH0tJHt0aGlzLnkwfS0ke3RoaXMueDF9LSR7dGhpcy55MX1gO1xuICB9XG59O1xuX0ZpbGxHcmFkaWVudC5kZWZhdWx0VGV4dHVyZVNpemUgPSAyNTY7XG5sZXQgRmlsbEdyYWRpZW50ID0gX0ZpbGxHcmFkaWVudDtcblxuZXhwb3J0IHsgRmlsbEdyYWRpZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxsR3JhZGllbnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///557\n')},1261:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ FillPattern)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n\n"use strict";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: "repeat",\n    addressModeV: "repeat"\n  },\n  "repeat-x": {\n    addressModeU: "repeat",\n    addressModeV: "clamp-to-edge"\n  },\n  "repeat-y": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "repeat"\n  },\n  "no-repeat": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "clamp-to-edge"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    /** unique id for this fill pattern */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillPattern");\n    this.transform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y();\n    this._styleKey = null;\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey)\n      return this._styleKey;\n    this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;\n    return this._styleKey;\n  }\n}\n\n\n//# sourceMappingURL=FillPattern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RDtBQUNSOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQUc7QUFDbEIseUJBQXlCLHFFQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTLEdBQUcsaUJBQWlCLEdBQUcsbUNBQW1DO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbFBhdHRlcm4ubWpzPzhmNzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCByZXBldGl0aW9uTWFwID0ge1xuICByZXBlYXQ6IHtcbiAgICBhZGRyZXNzTW9kZVU6IFwicmVwZWF0XCIsXG4gICAgYWRkcmVzc01vZGVWOiBcInJlcGVhdFwiXG4gIH0sXG4gIFwicmVwZWF0LXhcIjoge1xuICAgIGFkZHJlc3NNb2RlVTogXCJyZXBlYXRcIixcbiAgICBhZGRyZXNzTW9kZVY6IFwiY2xhbXAtdG8tZWRnZVwiXG4gIH0sXG4gIFwicmVwZWF0LXlcIjoge1xuICAgIGFkZHJlc3NNb2RlVTogXCJjbGFtcC10by1lZGdlXCIsXG4gICAgYWRkcmVzc01vZGVWOiBcInJlcGVhdFwiXG4gIH0sXG4gIFwibm8tcmVwZWF0XCI6IHtcbiAgICBhZGRyZXNzTW9kZVU6IFwiY2xhbXAtdG8tZWRnZVwiLFxuICAgIGFkZHJlc3NNb2RlVjogXCJjbGFtcC10by1lZGdlXCJcbiAgfVxufTtcbmNsYXNzIEZpbGxQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgcmVwZXRpdGlvbikge1xuICAgIC8qKiB1bmlxdWUgaWQgZm9yIHRoaXMgZmlsbCBwYXR0ZXJuICovXG4gICAgdGhpcy51aWQgPSB1aWQoXCJmaWxsUGF0dGVyblwiKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLl9zdHlsZUtleSA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZShcbiAgICAgIDEgLyB0ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgMSAvIHRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgICBpZiAocmVwZXRpdGlvbikge1xuICAgICAgdGV4dHVyZS5zb3VyY2Uuc3R5bGUuYWRkcmVzc01vZGVVID0gcmVwZXRpdGlvbk1hcFtyZXBldGl0aW9uXS5hZGRyZXNzTW9kZVU7XG4gICAgICB0ZXh0dXJlLnNvdXJjZS5zdHlsZS5hZGRyZXNzTW9kZVYgPSByZXBldGl0aW9uTWFwW3JlcGV0aXRpb25dLmFkZHJlc3NNb2RlVjtcbiAgICB9XG4gIH1cbiAgc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgdGhpcy50cmFuc2Zvcm0uY29weUZyb20odHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKTtcbiAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZShcbiAgICAgIDEgLyB0ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgMSAvIHRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgICB0aGlzLl9zdHlsZUtleSA9IG51bGw7XG4gIH1cbiAgZ2V0IHN0eWxlS2V5KCkge1xuICAgIGlmICh0aGlzLl9zdHlsZUtleSlcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZUtleTtcbiAgICB0aGlzLl9zdHlsZUtleSA9IGBmaWxsLXBhdHRlcm4tJHt0aGlzLnVpZH0tJHt0aGlzLnRleHR1cmUudWlkfS0ke3RoaXMudHJhbnNmb3JtLnRvQXJyYXkoKS5qb2luKFwiLVwiKX1gO1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUtleTtcbiAgfVxufVxuXG5leHBvcnQgeyBGaWxsUGF0dGVybiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsbFBhdHRlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1261\n')},4915:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ toFillStyle),\n/* harmony export */   m: () => (/* binding */ toStrokeStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8409);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9853);\n/* harmony import */ var _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(557);\n/* harmony import */ var _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1261);\n\n\n\n\n\n\n"use strict";\nfunction isColorLike(value) {\n  return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.isColorLike(value);\n}\nfunction isFillPattern(value) {\n  return value instanceof _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_1__/* .FillPattern */ .h;\n}\nfunction isFillGradient(value) {\n  return value instanceof _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_2__/* .FillGradient */ .f;\n}\nfunction handleColorLike(fill, value, defaultStyle) {\n  const temp = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.shared.setValue(value ?? 0);\n  fill.color = temp.toNumber();\n  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n  fill.texture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture */ .x.WHITE;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillPattern(fill, value, defaultStyle) {\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillGradient(fill, value, defaultStyle) {\n  value.buildLinearGradient();\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillObject(value, defaultStyle) {\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture */ .x.WHITE) {\n      const m = style.matrix?.invert() || new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__/* .Matrix */ .y();\n      m.translate(style.texture.frame.x, style.texture.frame.y);\n      m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === "clamp-to-edge") {\n      sourceStyle.addressMode = "repeat";\n      sourceStyle.update();\n    }\n  }\n  const color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\nfunction toFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  const fill = {};\n  const objectStyle = value;\n  if (isColorLike(value)) {\n    return handleColorLike(fill, value, defaultStyle);\n  } else if (isFillPattern(value)) {\n    return handleFillPattern(fill, value, defaultStyle);\n  } else if (isFillGradient(value)) {\n    return handleFillGradient(fill, value, defaultStyle);\n  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {\n    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {\n    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n  }\n  return handleFillObject(objectStyle, defaultStyle);\n}\nfunction toStrokeStyle(value, defaultStyle) {\n  const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;\n  const fill = toFillStyle(value, rest);\n  if (!fill) {\n    return null;\n  }\n  return {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    ...fill\n  };\n}\n\n\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkxNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFDUztBQUN3QjtBQUM3QjtBQUNGOztBQUV0RDtBQUNBO0FBQ0EsU0FBUyw0REFBSztBQUNkO0FBQ0E7QUFDQSwwQkFBMEIsdUVBQVc7QUFDckM7QUFDQTtBQUNBLDBCQUEwQix5RUFBWTtBQUN0QztBQUNBO0FBQ0EsZUFBZSw0REFBSztBQUNwQjtBQUNBO0FBQ0EsaUJBQWlCLDZGQUFPO0FBQ3hCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLDBCQUEwQiw2RkFBTztBQUNqQyw4Q0FBOEMscUVBQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbURBQW1EO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzQztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcz9kZmVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEZpbGxHcmFkaWVudCB9IGZyb20gJy4uL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcyc7XG5pbXBvcnQgeyBGaWxsUGF0dGVybiB9IGZyb20gJy4uL2ZpbGwvRmlsbFBhdHRlcm4ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc0NvbG9yTGlrZSh2YWx1ZSkge1xuICByZXR1cm4gQ29sb3IuaXNDb2xvckxpa2UodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNGaWxsUGF0dGVybih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBGaWxsUGF0dGVybjtcbn1cbmZ1bmN0aW9uIGlzRmlsbEdyYWRpZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEZpbGxHcmFkaWVudDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbG9yTGlrZShmaWxsLCB2YWx1ZSwgZGVmYXVsdFN0eWxlKSB7XG4gIGNvbnN0IHRlbXAgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUgPz8gMCk7XG4gIGZpbGwuY29sb3IgPSB0ZW1wLnRvTnVtYmVyKCk7XG4gIGZpbGwuYWxwaGEgPSB0ZW1wLmFscGhhID09PSAxID8gZGVmYXVsdFN0eWxlLmFscGhhIDogdGVtcC5hbHBoYTtcbiAgZmlsbC50ZXh0dXJlID0gVGV4dHVyZS5XSElURTtcbiAgcmV0dXJuIHsgLi4uZGVmYXVsdFN0eWxlLCAuLi5maWxsIH07XG59XG5mdW5jdGlvbiBoYW5kbGVGaWxsUGF0dGVybihmaWxsLCB2YWx1ZSwgZGVmYXVsdFN0eWxlKSB7XG4gIGZpbGwuZmlsbCA9IHZhbHVlO1xuICBmaWxsLmNvbG9yID0gMTY3NzcyMTU7XG4gIGZpbGwudGV4dHVyZSA9IHZhbHVlLnRleHR1cmU7XG4gIGZpbGwubWF0cml4ID0gdmFsdWUudHJhbnNmb3JtO1xuICByZXR1cm4geyAuLi5kZWZhdWx0U3R5bGUsIC4uLmZpbGwgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZpbGxHcmFkaWVudChmaWxsLCB2YWx1ZSwgZGVmYXVsdFN0eWxlKSB7XG4gIHZhbHVlLmJ1aWxkTGluZWFyR3JhZGllbnQoKTtcbiAgZmlsbC5maWxsID0gdmFsdWU7XG4gIGZpbGwuY29sb3IgPSAxNjc3NzIxNTtcbiAgZmlsbC50ZXh0dXJlID0gdmFsdWUudGV4dHVyZTtcbiAgZmlsbC5tYXRyaXggPSB2YWx1ZS50cmFuc2Zvcm07XG4gIHJldHVybiB7IC4uLmRlZmF1bHRTdHlsZSwgLi4uZmlsbCB9O1xufVxuZnVuY3Rpb24gaGFuZGxlRmlsbE9iamVjdCh2YWx1ZSwgZGVmYXVsdFN0eWxlKSB7XG4gIGNvbnN0IHN0eWxlID0geyAuLi5kZWZhdWx0U3R5bGUsIC4uLnZhbHVlIH07XG4gIGlmIChzdHlsZS50ZXh0dXJlKSB7XG4gICAgaWYgKHN0eWxlLnRleHR1cmUgIT09IFRleHR1cmUuV0hJVEUpIHtcbiAgICAgIGNvbnN0IG0gPSBzdHlsZS5tYXRyaXg/LmludmVydCgpIHx8IG5ldyBNYXRyaXgoKTtcbiAgICAgIG0udHJhbnNsYXRlKHN0eWxlLnRleHR1cmUuZnJhbWUueCwgc3R5bGUudGV4dHVyZS5mcmFtZS55KTtcbiAgICAgIG0uc2NhbGUoMSAvIHN0eWxlLnRleHR1cmUuc291cmNlLndpZHRoLCAxIC8gc3R5bGUudGV4dHVyZS5zb3VyY2UuaGVpZ2h0KTtcbiAgICAgIHN0eWxlLm1hdHJpeCA9IG07XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVN0eWxlID0gc3R5bGUudGV4dHVyZS5zb3VyY2Uuc3R5bGU7XG4gICAgaWYgKHNvdXJjZVN0eWxlLmFkZHJlc3NNb2RlID09PSBcImNsYW1wLXRvLWVkZ2VcIikge1xuICAgICAgc291cmNlU3R5bGUuYWRkcmVzc01vZGUgPSBcInJlcGVhdFwiO1xuICAgICAgc291cmNlU3R5bGUudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0eWxlLmNvbG9yKTtcbiAgc3R5bGUuYWxwaGEgKj0gY29sb3IuYWxwaGE7XG4gIHN0eWxlLmNvbG9yID0gY29sb3IudG9OdW1iZXIoKTtcbiAgc3R5bGUubWF0cml4ID0gc3R5bGUubWF0cml4ID8gc3R5bGUubWF0cml4LmNsb25lKCkgOiBudWxsO1xuICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiB0b0ZpbGxTdHlsZSh2YWx1ZSwgZGVmYXVsdFN0eWxlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZmlsbCA9IHt9O1xuICBjb25zdCBvYmplY3RTdHlsZSA9IHZhbHVlO1xuICBpZiAoaXNDb2xvckxpa2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIGhhbmRsZUNvbG9yTGlrZShmaWxsLCB2YWx1ZSwgZGVmYXVsdFN0eWxlKTtcbiAgfSBlbHNlIGlmIChpc0ZpbGxQYXR0ZXJuKHZhbHVlKSkge1xuICAgIHJldHVybiBoYW5kbGVGaWxsUGF0dGVybihmaWxsLCB2YWx1ZSwgZGVmYXVsdFN0eWxlKTtcbiAgfSBlbHNlIGlmIChpc0ZpbGxHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaGFuZGxlRmlsbEdyYWRpZW50KGZpbGwsIHZhbHVlLCBkZWZhdWx0U3R5bGUpO1xuICB9IGVsc2UgaWYgKG9iamVjdFN0eWxlLmZpbGwgJiYgaXNGaWxsUGF0dGVybihvYmplY3RTdHlsZS5maWxsKSkge1xuICAgIHJldHVybiBoYW5kbGVGaWxsUGF0dGVybihvYmplY3RTdHlsZSwgb2JqZWN0U3R5bGUuZmlsbCwgZGVmYXVsdFN0eWxlKTtcbiAgfSBlbHNlIGlmIChvYmplY3RTdHlsZS5maWxsICYmIGlzRmlsbEdyYWRpZW50KG9iamVjdFN0eWxlLmZpbGwpKSB7XG4gICAgcmV0dXJuIGhhbmRsZUZpbGxHcmFkaWVudChvYmplY3RTdHlsZSwgb2JqZWN0U3R5bGUuZmlsbCwgZGVmYXVsdFN0eWxlKTtcbiAgfVxuICByZXR1cm4gaGFuZGxlRmlsbE9iamVjdChvYmplY3RTdHlsZSwgZGVmYXVsdFN0eWxlKTtcbn1cbmZ1bmN0aW9uIHRvU3Ryb2tlU3R5bGUodmFsdWUsIGRlZmF1bHRTdHlsZSkge1xuICBjb25zdCB7IHdpZHRoLCBhbGlnbm1lbnQsIG1pdGVyTGltaXQsIGNhcCwgam9pbiwgLi4ucmVzdCB9ID0gZGVmYXVsdFN0eWxlO1xuICBjb25zdCBmaWxsID0gdG9GaWxsU3R5bGUodmFsdWUsIHJlc3QpO1xuICBpZiAoIWZpbGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGFsaWdubWVudCxcbiAgICBtaXRlckxpbWl0LFxuICAgIGNhcCxcbiAgICBqb2luLFxuICAgIC4uLmZpbGxcbiAgfTtcbn1cblxuZXhwb3J0IHsgdG9GaWxsU3R5bGUsIHRvU3Ryb2tlU3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4915\n')},5263:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   j: () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4973);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3747);\n/* harmony import */ var _view_View_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2906);\n\n\n\n\n\n"use strict";\nclass Sprite extends _view_View_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ViewContainer */ .$ {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY) {\n    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x) {\n      options = { texture: options };\n    }\n    const { texture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: "Sprite",\n      ...rest\n    });\n    this.renderPipeId = "sprite";\n    this.batched = true;\n    this._didSpriteUpdate = false;\n    this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._sourceBoundsDirty = true;\n    this._anchor = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__/* .ObservablePoint */ .A(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x) {\n      return new Sprite(source);\n    }\n    return new Sprite(_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off("update", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on("update", this.onViewUpdate, this);\n    this._texture = value;\n    if (this._width) {\n      this._setWidth(this._width, this._texture.orig.width);\n    }\n    if (this._height) {\n      this._setHeight(this._height, this._texture.orig.height);\n    }\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /**\n   * The bounds of the sprite, taking the texture\'s trim into account.\n   * @type {rendering.Bounds}\n   */\n  get sourceBounds() {\n    if (this._sourceBoundsDirty) {\n      this._updateSourceBounds();\n      this._sourceBoundsDirty = false;\n    }\n    return this._sourceBounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.sourceBounds;\n    if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n      if (point.y >= bounds.maxY && point.y <= bounds.minY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._didSpriteUpdate = true;\n    this._sourceBoundsDirty = this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _updateBounds() {\n    (0,_utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__/* .updateQuadBounds */ .w)(this._bounds, this._anchor, this._texture, 0);\n  }\n  _updateSourceBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const sourceBounds = this._sourceBounds;\n    const { width, height } = texture.orig;\n    sourceBounds.maxX = -anchor._x * width;\n    sourceBounds.minX = sourceBounds.maxX + width;\n    sourceBounds.maxY = -anchor._y * height;\n    sourceBounds.minY = sourceBounds.maxY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._bounds = null;\n    this._sourceBounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite\'s origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite\'s origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite\'s origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n    this._width = value;\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n    this._height = value;\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === "object") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this._texture.orig.width);\n    height !== void 0 && this._setHeight(height, this._texture.orig.height);\n  }\n}\n\n\n//# sourceMappingURL=Sprite.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI2My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdFO0FBQ087QUFDTjtBQUN4Qjs7QUFFakQ7QUFDQSxxQkFBcUIsa0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZGQUFPO0FBQy9CLDJCQUEyQiw2RkFBTztBQUNsQyxrQkFBa0I7QUFDbEI7QUFDQSxZQUFZLFVBQVUsNkZBQU8sc0RBQXNEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUIsc0ZBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkZBQU87QUFDakM7QUFDQTtBQUNBLHNCQUFzQiw2RkFBTztBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCLDZGQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkZBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlL1Nwcml0ZS5tanM/ZWUzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlUG9pbnQgfSBmcm9tICcuLi8uLi9tYXRocy9wb2ludC9PYnNlcnZhYmxlUG9pbnQubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHVwZGF0ZVF1YWRCb3VuZHMgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzJztcbmltcG9ydCB7IFZpZXdDb250YWluZXIgfSBmcm9tICcuLi92aWV3L1ZpZXcubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBTcHJpdGUgZXh0ZW5kcyBWaWV3Q29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBzcHJpdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0gVGV4dHVyZS5FTVBUWSkge1xuICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgb3B0aW9ucyA9IHsgdGV4dHVyZTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjb25zdCB7IHRleHR1cmUgPSBUZXh0dXJlLkVNUFRZLCBhbmNob3IsIHJvdW5kUGl4ZWxzLCB3aWR0aCwgaGVpZ2h0LCAuLi5yZXN0IH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKHtcbiAgICAgIGxhYmVsOiBcIlNwcml0ZVwiLFxuICAgICAgLi4ucmVzdFxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJzcHJpdGVcIjtcbiAgICB0aGlzLmJhdGNoZWQgPSB0cnVlO1xuICAgIHRoaXMuX2RpZFNwcml0ZVVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3NvdXJjZUJvdW5kcyA9IHsgbWluWDogMCwgbWF4WDogMSwgbWluWTogMCwgbWF4WTogMCB9O1xuICAgIHRoaXMuX3NvdXJjZUJvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9hbmNob3IgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KFxuICAgICAge1xuICAgICAgICBfb25VcGRhdGU6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9uVmlld1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB9IGVsc2UgaWYgKHRleHR1cmUuZGVmYXVsdEFuY2hvcikge1xuICAgICAgdGhpcy5hbmNob3IgPSB0ZXh0dXJlLmRlZmF1bHRBbmNob3I7XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5hbGxvd0NoaWxkcmVuID0gZmFsc2U7XG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IHJvdW5kUGl4ZWxzID8/IGZhbHNlO1xuICAgIGlmICh3aWR0aCAhPT0gdm9pZCAwKVxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIGlmIChoZWlnaHQgIT09IHZvaWQgMClcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSwgdmlkZW8sIGNhbnZhcyBlbGVtZW50LCB2aWRlbyBlbGVtZW50LCB0ZXh0dXJlXG4gICAqIEBwYXJhbSBzb3VyY2UgLSBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICAgKiBAcGFyYW0gW3NraXBDYWNoZV0gLSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIG9yIG5vdFxuICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBzcHJpdGVcbiAgICovXG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgcmV0dXJuIG5ldyBTcHJpdGUoc291cmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTcHJpdGUoVGV4dHVyZS5mcm9tKHNvdXJjZSwgc2tpcENhY2hlKSk7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICB2YWx1ZSB8fCAodmFsdWUgPSBUZXh0dXJlLkVNUFRZKTtcbiAgICBjb25zdCBjdXJyZW50VGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgaWYgKGN1cnJlbnRUZXh0dXJlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY3VycmVudFRleHR1cmUgJiYgY3VycmVudFRleHR1cmUuZHluYW1pYylcbiAgICAgIGN1cnJlbnRUZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLm9uVmlld1VwZGF0ZSwgdGhpcyk7XG4gICAgaWYgKHZhbHVlLmR5bmFtaWMpXG4gICAgICB2YWx1ZS5vbihcInVwZGF0ZVwiLCB0aGlzLm9uVmlld1VwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLl93aWR0aCkge1xuICAgICAgdGhpcy5fc2V0V2lkdGgodGhpcy5fd2lkdGgsIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9oZWlnaHQpIHtcbiAgICAgIHRoaXMuX3NldEhlaWdodCh0aGlzLl9oZWlnaHQsIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLm9uVmlld1VwZGF0ZSgpO1xuICB9XG4gIC8qKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBzcHJpdGUgaXMgdXNpbmcuICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbG9jYWwgYm91bmRzIG9mIHRoZSBzcHJpdGUuXG4gICAqIEB0eXBlIHtyZW5kZXJpbmcuQm91bmRzfVxuICAgKi9cbiAgZ2V0IGJvdW5kcygpIHtcbiAgICBpZiAodGhpcy5fYm91bmRzRGlydHkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICAgICAgdGhpcy5fYm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgfVxuICAvKipcbiAgICogVGhlIGJvdW5kcyBvZiB0aGUgc3ByaXRlLCB0YWtpbmcgdGhlIHRleHR1cmUncyB0cmltIGludG8gYWNjb3VudC5cbiAgICogQHR5cGUge3JlbmRlcmluZy5Cb3VuZHN9XG4gICAqL1xuICBnZXQgc291cmNlQm91bmRzKCkge1xuICAgIGlmICh0aGlzLl9zb3VyY2VCb3VuZHNEaXJ0eSkge1xuICAgICAgdGhpcy5fdXBkYXRlU291cmNlQm91bmRzKCk7XG4gICAgICB0aGlzLl9zb3VyY2VCb3VuZHNEaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc291cmNlQm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgKi9cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuc291cmNlQm91bmRzO1xuICAgIGlmIChwb2ludC54ID49IGJvdW5kcy5tYXhYICYmIHBvaW50LnggPD0gYm91bmRzLm1pblgpIHtcbiAgICAgIGlmIChwb2ludC55ID49IGJvdW5kcy5tYXhZICYmIHBvaW50LnkgPD0gYm91bmRzLm1pblkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQWRkcyB0aGUgYm91bmRzIG9mIHRoaXMgb2JqZWN0IHRvIHRoZSBib3VuZHMgb2JqZWN0LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIG91dHB1dCBib3VuZHMgb2JqZWN0LlxuICAgKi9cbiAgYWRkQm91bmRzKGJvdW5kcykge1xuICAgIGNvbnN0IF9ib3VuZHMgPSB0aGlzLl90ZXh0dXJlLnRyaW0gPyB0aGlzLnNvdXJjZUJvdW5kcyA6IHRoaXMuYm91bmRzO1xuICAgIGJvdW5kcy5hZGRGcmFtZShfYm91bmRzLm1pblgsIF9ib3VuZHMubWluWSwgX2JvdW5kcy5tYXhYLCBfYm91bmRzLm1heFkpO1xuICB9XG4gIG9uVmlld1VwZGF0ZSgpIHtcbiAgICB0aGlzLl9kaWRWaWV3Q2hhbmdlVGljaysrO1xuICAgIHRoaXMuX2RpZFNwcml0ZVVwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5fc291cmNlQm91bmRzRGlydHkgPSB0aGlzLl9ib3VuZHNEaXJ0eSA9IHRydWU7XG4gICAgaWYgKHRoaXMuZGlkVmlld1VwZGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRpZFZpZXdVcGRhdGUgPSB0cnVlO1xuICAgIGNvbnN0IHJlbmRlckdyb3VwID0gdGhpcy5yZW5kZXJHcm91cCB8fCB0aGlzLnBhcmVudFJlbmRlckdyb3VwO1xuICAgIGlmIChyZW5kZXJHcm91cCkge1xuICAgICAgcmVuZGVyR3JvdXAub25DaGlsZFZpZXdVcGRhdGUodGhpcyk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVCb3VuZHMoKSB7XG4gICAgdXBkYXRlUXVhZEJvdW5kcyh0aGlzLl9ib3VuZHMsIHRoaXMuX2FuY2hvciwgdGhpcy5fdGV4dHVyZSwgMCk7XG4gIH1cbiAgX3VwZGF0ZVNvdXJjZUJvdW5kcygpIHtcbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLl9hbmNob3I7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgY29uc3Qgc291cmNlQm91bmRzID0gdGhpcy5fc291cmNlQm91bmRzO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGV4dHVyZS5vcmlnO1xuICAgIHNvdXJjZUJvdW5kcy5tYXhYID0gLWFuY2hvci5feCAqIHdpZHRoO1xuICAgIHNvdXJjZUJvdW5kcy5taW5YID0gc291cmNlQm91bmRzLm1heFggKyB3aWR0aDtcbiAgICBzb3VyY2VCb3VuZHMubWF4WSA9IC1hbmNob3IuX3kgKiBoZWlnaHQ7XG4gICAgc291cmNlQm91bmRzLm1pblkgPSBzb3VyY2VCb3VuZHMubWF4WSArIGhlaWdodDtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBzcHJpdGUgcmVuZGVyYWJsZSBhbmQgb3B0aW9uYWxseSBpdHMgdGV4dHVyZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHJlbmRlcmFibGUgYXMgd2VsbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmVTb3VyY2Ugb2YgdGhlIHJlbmRlcmFibGUgYXMgd2VsbFxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zID0gZmFsc2UpIHtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmU7XG4gICAgaWYgKGRlc3Ryb3lUZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXN0cm95VGV4dHVyZVNvdXJjZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlU291cmNlO1xuICAgICAgdGhpcy5fdGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICB9XG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICB0aGlzLl9zb3VyY2VCb3VuZHMgPSBudWxsO1xuICAgIHRoaXMuX2FuY2hvciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSBzcHJpdGUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRha2VuIGZyb20gdGhlIHtAbGluayBUZXh0dXJlfVxuICAgKiBhbmQgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgaXMgYCgwLDApYCwgdGhpcyBtZWFucyB0aGUgc3ByaXRlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdC5cbiAgICpcbiAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIGAoMC41LDAuNSlgIG1lYW5zIHRoZSBzcHJpdGUncyBvcmlnaW4gaXMgY2VudGVyZWQuXG4gICAqXG4gICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byBgKDEsMSlgIHdvdWxkIG1lYW4gdGhlIHNwcml0ZSdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICAgKlxuICAgKiBJZiB5b3UgcGFzcyBvbmx5IHNpbmdsZSBwYXJhbWV0ZXIsIGl0IHdpbGwgc2V0IGJvdGggeCBhbmQgeSB0byB0aGUgc2FtZSB2YWx1ZSBhcyBzaG93biBpbiB0aGUgZXhhbXBsZSBiZWxvdy5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUoe3RleHR1cmU6IFRleHR1cmUuV0hJVEV9KTtcbiAgICogc3ByaXRlLmFuY2hvci5zZXQoMC41KTsgLy8gVGhpcyB3aWxsIHNldCB0aGUgb3JpZ2luIHRvIGNlbnRlci4gKDAuNSkgaXMgc2FtZSBhcyAoMC41LCAwLjUpLlxuICAgKi9cbiAgZ2V0IGFuY2hvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xuICB9XG4gIHNldCBhbmNob3IodmFsdWUpIHtcbiAgICB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB0aGlzLl9hbmNob3Iuc2V0KHZhbHVlKSA6IHRoaXMuX2FuY2hvci5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldC4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3NldFdpZHRoKHZhbHVlLCB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGgpO1xuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRIZWlnaHQodmFsdWUsIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQpO1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgdGhlIFNwcml0ZSBhcyBhIFtTaXplXXtAbGluayBTaXplfSBvYmplY3QuXG4gICAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gZ2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHNlcGFyYXRlbHkuXG4gICAqIEBwYXJhbSBvdXQgLSBPcHRpb25hbCBvYmplY3QgdG8gc3RvcmUgdGhlIHNpemUgaW4uXG4gICAqIEByZXR1cm5zIC0gVGhlIHNpemUgb2YgdGhlIFNwcml0ZS5cbiAgICovXG4gIGdldFNpemUob3V0KSB7XG4gICAgb3V0IHx8IChvdXQgPSB7fSk7XG4gICAgb3V0LndpZHRoID0gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICBvdXQuaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgU3ByaXRlIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cbiAgICogVGhpcyBpcyBmYXN0ZXIgdGhhbiBzZXR0aW5nIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHNlcGFyYXRlbHkuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoaXMgY2FuIGJlIGVpdGhlciBhIG51bWJlciBvciBhIFtTaXplXXtAbGluayBTaXplfSBvYmplY3QuXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IHRvIHNldC4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIGB3aWR0aGAgaWYgbm90IHByb3ZpZGVkLlxuICAgKi9cbiAgc2V0U2l6ZSh2YWx1ZSwgaGVpZ2h0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaGVpZ2h0ID0gdmFsdWUuaGVpZ2h0ID8/IHZhbHVlLndpZHRoO1xuICAgICAgdmFsdWUgPSB2YWx1ZS53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID8/IChoZWlnaHQgPSB2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlICE9PSB2b2lkIDAgJiYgdGhpcy5fc2V0V2lkdGgodmFsdWUsIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aCk7XG4gICAgaGVpZ2h0ICE9PSB2b2lkIDAgJiYgdGhpcy5fc2V0SGVpZ2h0KGhlaWdodCwgdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU3ByaXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5263\n')},2906:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ ViewContainer)\n/* harmony export */ });\n/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(535);\n/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8400);\n\n\n\n"use strict";\nclass ViewContainer extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Container */ .W2 {\n  constructor() {\n    super(...arguments);\n    /** @private */\n    this.canBundle = true;\n    /** @private */\n    this.allowChildren = false;\n    /** @private */\n    this._roundPixels = 0;\n    /** @private */\n    this._lastUsed = 0;\n    /** @private */\n    this._lastInstructionTick = -1;\n    this._bounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Bounds */ .Y(0, 1, 0, 0);\n    this._boundsDirty = true;\n  }\n  /** @private */\n  _updateBounds() {\n  }\n  /**\n   * Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.bounds;\n    const { x, y } = point;\n    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._bounds = null;\n  }\n}\n\n\n//# sourceMappingURL=View.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkwNi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDtBQUNEOztBQUV2RDtBQUNBLDRCQUE0Qix5RUFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUVBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3ZpZXcvVmlldy5tanM/OTgxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFZpZXdDb250YWluZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuY2FuQnVuZGxlID0gdHJ1ZTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmFsbG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IDA7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5fbGFzdFVzZWQgPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX2xhc3RJbnN0cnVjdGlvblRpY2sgPSAtMTtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKDAsIDEsIDAsIDApO1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgX3VwZGF0ZUJvdW5kcygpIHtcbiAgfVxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gcm91bmQgdGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgc3ByaXRlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5ib3VuZHM7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICByZXR1cm4geCA+PSBib3VuZHMubWluWCAmJiB4IDw9IGJvdW5kcy5tYXhYICYmIHkgPj0gYm91bmRzLm1pblkgJiYgeSA8PSBib3VuZHMubWF4WTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgVmlld0NvbnRhaW5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlldy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2906\n')},342:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\n\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";\n  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";\n  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\n\n//# sourceMappingURL=LoaderParser.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\n\n\n"use strict";\nfunction assertPath(path2) {\n  if (typeof path2 !== "string") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split("?")[0];\n  return re.split("#")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = "";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf("/");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = "";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = "";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += "/..";\n          } else {\n            res = "..";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, "\\\\", "/");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&\',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith("blob:");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return "";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it\'s not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? adapter/* DOMAdapter */.z.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith("/")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving \'..\' and \'.\' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = "";\n    const isAbsolute = path2.startsWith("/");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith("/");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += "/";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith("/");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return ".";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? "";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return ".";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return "//";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = "";\n    if (path2.startsWith("/"))\n      root = "/";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf("/", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith("/"))\n        root += "/";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return "";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return "";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return "";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the \'root\', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: "", dir: "", base: "", ext: "", name: "" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = "";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: "/",\n  delimiter: ":",\n  joinExtensions: [".html"]\n};\n\n\n//# sourceMappingURL=path.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/convertToList.mjs\nvar convertToList = __webpack_require__(9879);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs\n\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(",");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\n\n//# sourceMappingURL=createStringVariations.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs\n\nconst isSingleItem = (item) => !Array.isArray(item);\n\n\n//# sourceMappingURL=isSingleItem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs\n\n\n\n\n\n\n"use strict";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: "-",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {\n      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: [\'format\', \'resolution\'],\n   *     params:{\n   *         format:\'webp\', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add(\'foo\', [\'bar@2x.webp\', \'bar@2x.png\', \'bar.webp\', \'bar.png\']);\n   * resolver.resolveUrl(\'foo\') // => \'bar@2x.webp\'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = \'https://home.com/\';\n   * resolver.add(\'foo\', \'bar.ong\');\n   * resolver.resolveUrl(\'foo\', \'bar.png\'); // => \'https://home.com/bar.png\'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`\'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = \'https://home.com/some-path/\';\n   * resolver.rootPath = \'https://home.com/\';\n   * resolver.add(\'foo\', \'/bar.png\');\n   * resolver.resolveUrl(\'foo\', \'/bar.png\'); // => \'https://home.com/bar.png\'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add(\'foo\', [\n   *     {\n   *         resolution: 2,\n   *         format: \'png\',\n   *         src: \'image@2x.png\',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:\'png\',\n   *         src: \'image.png\',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \'1\'),\n   *         format: value.split(\'.\').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add(\'foo\', [\n   *     \'image@2x.png\',\n   *     \'image.png\',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === "string") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = (0,convertToList/* convertToList */.S)(\n      alias || src,\n      (value) => {\n        if (typeof value === "string")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      (0,warn/* warn */.Z)("[Resolver] Manifest already exists, this will be overwritten");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle(\'animals\', [\n   *  { alias: \'bunny\', src: \'bunny.png\' },\n   *  { alias: \'chicken\', src: \'chicken.png\' },\n   *  { alias: \'thumper\', src: \'thumper.png\' },\n   * ]);\n   * // or\n   * resolver.addBundle(\'animals\', {\n   *     bunny: \'bunny.png\',\n   *     chicken: \'chicken.png\',\n   *     thumper: \'thumper.png\',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle(\'animals\');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === "string" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === "string") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: \'foo\', src: \'bar.png\');\n   * resolver.resolveUrl(\'foo\') // => \'bar.png\'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: [\'foo\', \'boo\'], src: \'bar.png\'});\n   * resolver.resolveUrl(\'foo\') // => \'bar.png\'\n   * resolver.resolveUrl(\'boo\') // => \'bar.png\'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: [\'foo\', \'boo\'], src: [\'bar.png\', \'bar.webp\']});\n   * resolver.resolveUrl(\'foo\') // => \'bar.png\'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: \'bunnyBooBooSmooth\',\n   *     src: \'bunny{png,webp}\',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve(\'bunnyBooBooSmooth\') // => { src: \'bunny.png\', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        (0,warn/* warn */.Z)(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = (0,convertToList/* convertToList */.S)(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = (0,convertToList/* convertToList */.S)(src).map((src2) => {\n        if (typeof src2 === "string") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== "object") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: \'load-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'background\',\n   *                     src: \'sunset.png\',\n   *                 },\n   *                 {\n   *                     alias: \'bar\',\n   *                     src: \'load-bar.{png,webp}\',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: \'game-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'character\',\n   *                     src: \'robot.png\',\n   *                 },\n   *                 {\n   *                     alias: \'enemy\',\n   *                     src: \'bad-guy.png\',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle(\'load-screen\');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = (0,convertToList/* convertToList */.S)(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== "string") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = (0,convertToList/* convertToList */.S)(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? "&" : "?";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(".").pop().split("?").shift().split("#").shift();\n}\n\n\n//# sourceMappingURL=Resolver.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\n\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split("?")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\n\n//# sourceMappingURL=copySearchParams.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs\n\n\n\n"use strict";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture/* Texture */.x ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle/* Rectangle */.A(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle/* Rectangle */.A(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle/* Rectangle */.A(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle/* Rectangle */.A(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture/* Texture */.x({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don\'t use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\n\n//# sourceMappingURL=Spritesheet.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst validImages = [\n  "jpg",\n  "png",\n  "jpeg",\n  "avif",\n  "webp",\n  "basis",\n  "etc2",\n  "bc7",\n  "bc6h",\n  "bc5",\n  "bc4",\n  "bc3",\n  "bc2",\n  "bc1",\n  "eac",\n  "astc"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: Extensions/* ExtensionType */.nw.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    extension: {\n      type: Extensions/* ExtensionType */.nw.ResolveParser,\n      name: "resolveSpritesheet"\n    },\n    test: (value) => {\n      const tempURL = value.split("?")[0];\n      const split = tempURL.split(".");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === "json" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(".");\n      return {\n        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: "spritesheetLoader",\n    extension: {\n      type: Extensions/* ExtensionType */.nw.LoadParser,\n      priority: LoaderParserPriority.Normal,\n      name: "spritesheetLoader"\n    },\n    async testParse(asset, options) {\n      return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename\n        // if user need to use custom filename (not from jsonFile.meta.image)\n      } = options?.data ?? {};\n      let basePath = path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {\n        basePath += "/";\n      }\n      let texture;\n      if (imageTexture instanceof Texture/* Texture */.x) {\n        texture = imageTexture;\n      } else {\n        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([imagePath]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== "string") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\n\n//# sourceMappingURL=spritesheetAsset.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7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TDtBQUNBLGFBQWEsSUFBSTtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFPO0FBQ3pDO0FBQ0EsUUFBUTtBQUNSLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCO0FBQzVCOzs7QUNwSjBEO0FBQ0E7O0FBRTFEO0FBQ0EsNkJBQVUsS0FBSyxnQkFBZ0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL2xvYWRlci9wYXJzZXJzL0xvYWRlclBhcnNlci5tanM/OWM3YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvcGF0aC5tanM/ZjViNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL3V0aWxzL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMubWpzP2ZjYTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy91dGlscy9pc1NpbmdsZUl0ZW0ubWpzPzMyMzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9yZXNvbHZlci9SZXNvbHZlci5tanM/ZjNjMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMubWpzPzg2MzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3Nwcml0ZXNoZWV0L1Nwcml0ZXNoZWV0Lm1qcz9mMGU2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zcHJpdGVzaGVldC9zcHJpdGVzaGVldEFzc2V0Lm1qcz82NTA3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zcHJpdGVzaGVldC9pbml0Lm1qcz8wMWMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIExvYWRlclBhcnNlclByaW9yaXR5ID0gLyogQF9fUFVSRV9fICovICgoTG9hZGVyUGFyc2VyUHJpb3JpdHkyKSA9PiB7XG4gIExvYWRlclBhcnNlclByaW9yaXR5MltMb2FkZXJQYXJzZXJQcmlvcml0eTJbXCJMb3dcIl0gPSAwXSA9IFwiTG93XCI7XG4gIExvYWRlclBhcnNlclByaW9yaXR5MltMb2FkZXJQYXJzZXJQcmlvcml0eTJbXCJOb3JtYWxcIl0gPSAxXSA9IFwiTm9ybWFsXCI7XG4gIExvYWRlclBhcnNlclByaW9yaXR5MltMb2FkZXJQYXJzZXJQcmlvcml0eTJbXCJIaWdoXCJdID0gMl0gPSBcIkhpZ2hcIjtcbiAgcmV0dXJuIExvYWRlclBhcnNlclByaW9yaXR5Mjtcbn0pKExvYWRlclBhcnNlclByaW9yaXR5IHx8IHt9KTtcblxuZXhwb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlclBhcnNlci5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aDIpIHtcbiAgaWYgKHR5cGVvZiBwYXRoMiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShwYXRoMil9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVVybFBhcmFtcyh1cmwpIHtcbiAgY29uc3QgcmUgPSB1cmwuc3BsaXQoXCI/XCIpWzBdO1xuICByZXR1cm4gcmUuc3BsaXQoXCIjXCIpWzBdO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VBbGwoc3RyLCBmaW5kLCByZXBsYWNlKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChmaW5kKSwgXCJnXCIpLCByZXBsYWNlKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgyLCBhbGxvd0Fib3ZlUm9vdCkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgbGV0IGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgbGV0IGxhc3RTbGFzaCA9IC0xO1xuICBsZXQgZG90cyA9IDA7XG4gIGxldCBjb2RlID0gLTE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHBhdGgyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBwYXRoMi5sZW5ndGgpIHtcbiAgICAgIGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gNDc7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xuICAgICAgfSBlbHNlIGlmIChsYXN0U2xhc2ggIT09IGkgLSAxICYmIGRvdHMgPT09IDIpIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gNDYgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDIpICE9PSA0Nikge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ICE9PSByZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IHJlcy5sZW5ndGggLSAxIC0gcmVzLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9IFwiXCI7XG4gICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXMgKz0gXCIvLi5cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gXCIuLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlcyArPSBgLyR7cGF0aDIuc2xpY2UobGFzdFNsYXNoICsgMSwgaSl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBwYXRoMi5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgfVxuICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgIGRvdHMgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDYgJiYgZG90cyAhPT0gLTEpIHtcbiAgICAgICsrZG90cztcbiAgICB9IGVsc2Uge1xuICAgICAgZG90cyA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuY29uc3QgcGF0aCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcGF0aCB0byBwb3NpeCBmb3JtYXQuXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY29udmVydCB0byBwb3NpeFxuICAgKi9cbiAgdG9Qb3NpeChwYXRoMikge1xuICAgIHJldHVybiByZXBsYWNlQWxsKHBhdGgyLCBcIlxcXFxcIiwgXCIvXCIpO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXRoIGlzIGEgVVJMIGUuZy4gaHR0cDovLywgaHR0cHM6Ly9cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVja1xuICAgKi9cbiAgaXNVcmwocGF0aDIpIHtcbiAgICByZXR1cm4gL15odHRwcz86Ly50ZXN0KHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXRoIGlzIGEgZGF0YSBVUkxcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVja1xuICAgKi9cbiAgaXNEYXRhVXJsKHBhdGgyKSB7XG4gICAgcmV0dXJuIC9eZGF0YTooW2Etel0rXFwvW2EtejAtOS0rLl0rKDtbYS16MC05LS4hIyQlKisue318fmBdKz1bYS16MC05LS4hIyQlKisue30oKV98fmBdKykqKT8oO2Jhc2U2NCk/LChbYS16MC05ISQmJywoKSorOz1cXC0uX346QFxcLz8lXFxzPD5dKj8pJC9pLnRlc3QocGF0aDIpO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXRoIGlzIGEgYmxvYiBVUkxcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVja1xuICAgKi9cbiAgaXNCbG9iVXJsKHBhdGgyKSB7XG4gICAgcmV0dXJuIHBhdGgyLnN0YXJ0c1dpdGgoXCJibG9iOlwiKTtcbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGF0aCBoYXMgYSBwcm90b2NvbCBlLmcuIGh0dHA6Ly8sIGh0dHBzOi8vLCBmaWxlOi8vLywgZGF0YTosIGJsb2I6LCBDOi9cbiAgICogVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciB3aW5kb3dzIGZpbGUgcGF0aHNcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVja1xuICAgKi9cbiAgaGFzUHJvdG9jb2wocGF0aDIpIHtcbiAgICByZXR1cm4gL15bXi86XSs6Ly50ZXN0KHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvdG9jb2wgb2YgdGhlIHBhdGggZS5nLiBodHRwOi8vLCBodHRwczovLywgZmlsZTovLy8sIGRhdGE6LCBibG9iOiwgQzovXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gZ2V0IHRoZSBwcm90b2NvbCBmcm9tXG4gICAqL1xuICBnZXRQcm90b2NvbChwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBjb25zdCBtYXRjaEZpbGUgPSAvXmZpbGU6XFwvXFwvXFwvLy5leGVjKHBhdGgyKTtcbiAgICBpZiAobWF0Y2hGaWxlKSB7XG4gICAgICByZXR1cm4gbWF0Y2hGaWxlWzBdO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaFByb3RvY29sID0gL15bXi86XSs6XFwvezAsMn0vLmV4ZWMocGF0aDIpO1xuICAgIGlmIChtYXRjaFByb3RvY29sKSB7XG4gICAgICByZXR1cm4gbWF0Y2hQcm90b2NvbFswXTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0sXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBVUkwgdG8gYW4gYWJzb2x1dGUgcGF0aC5cbiAgICogV2hlbiBsb2FkaW5nIGZyb20gYSBXZWIgV29ya2VyLCB3ZSBtdXN0IHVzZSBhYnNvbHV0ZSBwYXRocy5cbiAgICogSWYgdGhlIFVSTCBpcyBhbHJlYWR5IGFic29sdXRlIHdlIHJldHVybiBpdCBhcyBpc1xuICAgKiBJZiBpdCdzIG5vdCwgd2UgY29udmVydCBpdFxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byB0ZXN0XG4gICAqIEBwYXJhbSBjdXN0b21CYXNlVXJsIC0gVGhlIGJhc2UgVVJMIHRvIHVzZVxuICAgKiBAcGFyYW0gY3VzdG9tUm9vdFVybCAtIFRoZSByb290IFVSTCB0byB1c2VcbiAgICovXG4gIHRvQWJzb2x1dGUodXJsLCBjdXN0b21CYXNlVXJsLCBjdXN0b21Sb290VXJsKSB7XG4gICAgYXNzZXJ0UGF0aCh1cmwpO1xuICAgIGlmICh0aGlzLmlzRGF0YVVybCh1cmwpIHx8IHRoaXMuaXNCbG9iVXJsKHVybCkpXG4gICAgICByZXR1cm4gdXJsO1xuICAgIGNvbnN0IGJhc2VVcmwgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KGN1c3RvbUJhc2VVcmwgPz8gRE9NQWRhcHRlci5nZXQoKS5nZXRCYXNlVXJsKCkpKTtcbiAgICBjb25zdCByb290VXJsID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChjdXN0b21Sb290VXJsID8/IHRoaXMucm9vdG5hbWUoYmFzZVVybCkpKTtcbiAgICB1cmwgPSB0aGlzLnRvUG9zaXgodXJsKTtcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICByZXR1cm4gcGF0aC5qb2luKHJvb3RVcmwsIHVybC5zbGljZSgxKSk7XG4gICAgfVxuICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHRoaXMuaXNBYnNvbHV0ZSh1cmwpID8gdXJsIDogdGhpcy5qb2luKGJhc2VVcmwsIHVybCk7XG4gICAgcmV0dXJuIGFic29sdXRlUGF0aDtcbiAgfSxcbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHBhdGgsIHJlc29sdmluZyAnLi4nIGFuZCAnLicgc2VnbWVudHNcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBub3JtYWxpemVcbiAgICovXG4gIG5vcm1hbGl6ZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGlmIChwYXRoMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgaWYgKHRoaXMuaXNEYXRhVXJsKHBhdGgyKSB8fCB0aGlzLmlzQmxvYlVybChwYXRoMikpXG4gICAgICByZXR1cm4gcGF0aDI7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGxldCBwcm90b2NvbCA9IFwiXCI7XG4gICAgY29uc3QgaXNBYnNvbHV0ZSA9IHBhdGgyLnN0YXJ0c1dpdGgoXCIvXCIpO1xuICAgIGlmICh0aGlzLmhhc1Byb3RvY29sKHBhdGgyKSkge1xuICAgICAgcHJvdG9jb2wgPSB0aGlzLnJvb3RuYW1lKHBhdGgyKTtcbiAgICAgIHBhdGgyID0gcGF0aDIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoMi5lbmRzV2l0aChcIi9cIik7XG4gICAgcGF0aDIgPSBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoMiwgZmFsc2UpO1xuICAgIGlmIChwYXRoMi5sZW5ndGggPiAwICYmIHRyYWlsaW5nU2VwYXJhdG9yKVxuICAgICAgcGF0aDIgKz0gXCIvXCI7XG4gICAgaWYgKGlzQWJzb2x1dGUpXG4gICAgICByZXR1cm4gYC8ke3BhdGgyfWA7XG4gICAgcmV0dXJuIHByb3RvY29sICsgcGF0aDI7XG4gIH0sXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHBhdGggaXMgYW4gYWJzb2x1dGUgcGF0aC5cbiAgICogQWJzb2x1dGUgcGF0aHMgY2FuIGJlIHVybHMsIGRhdGEgdXJscywgb3IgcGF0aHMgb24gZGlza1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRlc3RcbiAgICovXG4gIGlzQWJzb2x1dGUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgaWYgKHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHBhdGgyLnN0YXJ0c1dpdGgoXCIvXCIpO1xuICB9LFxuICAvKipcbiAgICogSm9pbnMgYWxsIGdpdmVuIHBhdGggc2VnbWVudHMgdG9nZXRoZXIgdXNpbmcgdGhlIHBsYXRmb3JtLXNwZWNpZmljIHNlcGFyYXRvciBhcyBhIGRlbGltaXRlcixcbiAgICogdGhlbiBub3JtYWxpemVzIHRoZSByZXN1bHRpbmcgcGF0aFxuICAgKiBAcGFyYW0gc2VnbWVudHMgLSBUaGUgc2VnbWVudHMgb2YgdGhlIHBhdGggdG8gam9pblxuICAgKi9cbiAgam9pbiguLi5zZWdtZW50cykge1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICB9XG4gICAgbGV0IGpvaW5lZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBhcmcgPSBzZWdtZW50c1tpXTtcbiAgICAgIGFzc2VydFBhdGgoYXJnKTtcbiAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoam9pbmVkID09PSB2b2lkIDApXG4gICAgICAgICAgam9pbmVkID0gYXJnO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwcmV2QXJnID0gc2VnbWVudHNbaSAtIDFdID8/IFwiXCI7XG4gICAgICAgICAgaWYgKHRoaXMuam9pbkV4dGVuc2lvbnMuaW5jbHVkZXModGhpcy5leHRuYW1lKHByZXZBcmcpLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBqb2luZWQgKz0gYC8uLi8ke2FyZ31gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqb2luZWQgKz0gYC8ke2FyZ31gO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoam9pbmVkID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKGpvaW5lZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaXJlY3RvcnkgbmFtZSBvZiBhIHBhdGhcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgZGlybmFtZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGlmIChwYXRoMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGxldCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBoYXNSb290ID0gY29kZSA9PT0gNDc7XG4gICAgbGV0IGVuZCA9IC0xO1xuICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGNvbnN0IHByb3RvID0gdGhpcy5nZXRQcm90b2NvbChwYXRoMik7XG4gICAgY29uc3Qgb3JpZ3BhdGggPSBwYXRoMjtcbiAgICBwYXRoMiA9IHBhdGgyLnNsaWNlKHByb3RvLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgIHJldHVybiBoYXNSb290ID8gXCIvXCIgOiB0aGlzLmlzVXJsKG9yaWdwYXRoKSA/IHByb3RvICsgcGF0aDIgOiBwcm90bztcbiAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpXG4gICAgICByZXR1cm4gXCIvL1wiO1xuICAgIHJldHVybiBwcm90byArIHBhdGgyLnNsaWNlKDAsIGVuZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG9mIHRoZSBwYXRoIGUuZy4gLywgQzovLCBmaWxlOi8vLywgaHR0cDovL2RvbWFpbi5jb20vXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gcGFyc2VcbiAgICovXG4gIHJvb3RuYW1lKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGxldCByb290ID0gXCJcIjtcbiAgICBpZiAocGF0aDIuc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICByb290ID0gXCIvXCI7XG4gICAgZWxzZSB7XG4gICAgICByb290ID0gdGhpcy5nZXRQcm90b2NvbChwYXRoMik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXJsKHBhdGgyKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXRoMi5pbmRleE9mKFwiL1wiLCByb290Lmxlbmd0aCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJvb3QgPSBwYXRoMi5zbGljZSgwLCBpbmRleCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcm9vdCA9IHBhdGgyO1xuICAgICAgaWYgKCFyb290LmVuZHNXaXRoKFwiL1wiKSlcbiAgICAgICAgcm9vdCArPSBcIi9cIjtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IHBvcnRpb24gb2YgYSBwYXRoXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdGVzdFxuICAgKiBAcGFyYW0gZXh0IC0gT3B0aW9uYWwgZXh0ZW5zaW9uIHRvIHJlbW92ZVxuICAgKi9cbiAgYmFzZW5hbWUocGF0aDIsIGV4dCkge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGlmIChleHQpXG4gICAgICBhc3NlcnRQYXRoKGV4dCk7XG4gICAgcGF0aDIgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgbGV0IGk7XG4gICAgaWYgKGV4dCAhPT0gdm9pZCAwICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aDIubGVuZ3RoKSB7XG4gICAgICBpZiAoZXh0Lmxlbmd0aCA9PT0gcGF0aDIubGVuZ3RoICYmIGV4dCA9PT0gcGF0aDIpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgbGV0IGV4dElkeCA9IGV4dC5sZW5ndGggLSAxO1xuICAgICAgbGV0IGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcbiAgICAgIGZvciAoaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XG4gICAgICAgICAgICAgIGlmICgtLWV4dElkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKVxuICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgZWxzZSBpZiAoZW5kID09PSAtMSlcbiAgICAgICAgZW5kID0gcGF0aDIubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBhdGgyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgaWYgKHBhdGgyLmNoYXJDb2RlQXQoaSkgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICByZXR1cm4gcGF0aDIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gb2YgdGhlIHBhdGgsIGZyb20gdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiB0aGUgLiAocGVyaW9kKSBjaGFyYWN0ZXIgdG8gZW5kIG9mIHN0cmluZyBpbiB0aGUgbGFzdFxuICAgKiBwb3J0aW9uIG9mIHRoZSBwYXRoLiBJZiB0aGVyZSBpcyBubyAuIGluIHRoZSBsYXN0IHBvcnRpb24gb2YgdGhlIHBhdGgsIG9yIGlmIHRoZXJlIGFyZSBubyAuIGNoYXJhY3RlcnMgb3RoZXIgdGhhblxuICAgKiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBiYXNlbmFtZSBvZiBwYXRoLCBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gcGFyc2VcbiAgICovXG4gIGV4dG5hbWUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgbGV0IHByZURvdFN0YXRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fCBwcmVEb3RTdGF0ZSA9PT0gMCB8fCBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBwYXRoMi5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgfSxcbiAgLyoqXG4gICAqIFBhcnNlcyBhIHBhdGggaW50byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgJ3Jvb3QnLCBgZGlyYCwgYGJhc2VgLCBgZXh0YCwgYW5kIGBuYW1lYCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHBhcnNlXG4gICAqL1xuICBwYXJzZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGNvbnN0IHJldCA9IHsgcm9vdDogXCJcIiwgZGlyOiBcIlwiLCBiYXNlOiBcIlwiLCBleHQ6IFwiXCIsIG5hbWU6IFwiXCIgfTtcbiAgICBpZiAocGF0aDIubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHJldDtcbiAgICBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3QgaXNBYnNvbHV0ZSA9IHRoaXMuaXNBYnNvbHV0ZShwYXRoMik7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGNvbnN0IHByb3RvY29sID0gXCJcIjtcbiAgICByZXQucm9vdCA9IHRoaXMucm9vdG5hbWUocGF0aDIpO1xuICAgIGlmIChpc0Fic29sdXRlIHx8IHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpKSB7XG4gICAgICBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgbGV0IHN0YXJ0RG90ID0gLTE7XG4gICAgbGV0IHN0YXJ0UGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IC0xO1xuICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGxldCBpID0gcGF0aDIubGVuZ3RoIC0gMTtcbiAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fCBwcmVEb3RTdGF0ZSA9PT0gMCB8fCBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKVxuICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoMi5zbGljZSgxLCBlbmQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aDIuc2xpY2UoMSwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGgyLnNsaWNlKDEsIGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQubmFtZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldC5leHQgPSBwYXRoMi5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICB9XG4gICAgcmV0LmRpciA9IHRoaXMuZGlybmFtZShwYXRoMik7XG4gICAgaWYgKHByb3RvY29sKVxuICAgICAgcmV0LmRpciA9IHByb3RvY29sICsgcmV0LmRpcjtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBzZXA6IFwiL1wiLFxuICBkZWxpbWl0ZXI6IFwiOlwiLFxuICBqb2luRXh0ZW5zaW9uczogW1wiLmh0bWxcIl1cbn07XG5cbmV4cG9ydCB7IHBhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBwcm9jZXNzWChiYXNlLCBpZHMsIGRlcHRoLCByZXN1bHQsIHRhZ3MpIHtcbiAgY29uc3QgaWQgPSBpZHNbZGVwdGhdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBpZFtpXTtcbiAgICBpZiAoZGVwdGggPCBpZHMubGVuZ3RoIC0gMSkge1xuICAgICAgcHJvY2Vzc1goYmFzZS5yZXBsYWNlKHJlc3VsdFtkZXB0aF0sIHZhbHVlKSwgaWRzLCBkZXB0aCArIDEsIHJlc3VsdCwgdGFncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ3MucHVzaChiYXNlLnJlcGxhY2UocmVzdWx0W2RlcHRoXSwgdmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMoc3RyaW5nKSB7XG4gIGNvbnN0IHJlZ2V4ID0gL1xceyguKj8pXFx9L2c7XG4gIGNvbnN0IHJlc3VsdCA9IHN0cmluZy5tYXRjaChyZWdleCk7XG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgIHJlc3VsdC5mb3JFYWNoKCh2YXJzKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IHZhcnMuc3Vic3RyaW5nKDEsIHZhcnMubGVuZ3RoIC0gMSkuc3BsaXQoXCIsXCIpO1xuICAgICAgaWRzLnB1c2goc3BsaXQpO1xuICAgIH0pO1xuICAgIHByb2Nlc3NYKHN0cmluZywgaWRzLCAwLCByZXN1bHQsIHRhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRhZ3MucHVzaChzdHJpbmcpO1xuICB9XG4gIHJldHVybiB0YWdzO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNTaW5nbGVJdGVtID0gKGl0ZW0pID0+ICFBcnJheS5pc0FycmF5KGl0ZW0pO1xuXG5leHBvcnQgeyBpc1NpbmdsZUl0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2luZ2xlSXRlbS5tanMubWFwXG4iLCJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnLi4vLi4vdXRpbHMvcGF0aC5tanMnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4uL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgfSBmcm9tICcuLi91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcyc7XG5pbXBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tICcuLi91dGlscy9pc1NpbmdsZUl0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBSZXNvbHZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucyA9IHtcbiAgICAgIGNvbm5lY3RvcjogXCItXCIsXG4gICAgICBjcmVhdGVCdW5kbGVBc3NldElkOiAoYnVuZGxlSWQsIGFzc2V0SWQpID0+IGAke2J1bmRsZUlkfSR7dGhpcy5fYnVuZGxlSWRDb25uZWN0b3J9JHthc3NldElkfWAsXG4gICAgICBleHRyYWN0QXNzZXRJZEZyb21CdW5kbGU6IChidW5kbGVJZCwgYXNzZXRCdW5kbGVJZCkgPT4gYXNzZXRCdW5kbGVJZC5yZXBsYWNlKGAke2J1bmRsZUlkfSR7dGhpcy5fYnVuZGxlSWRDb25uZWN0b3J9YCwgXCJcIilcbiAgICB9O1xuICAgIC8qKiBUaGUgY2hhcmFjdGVyIHRoYXQgaXMgdXNlZCB0byBjb25uZWN0IHRoZSBidW5kbGVJZCBhbmQgdGhlIGFzc2V0SWQgd2hlbiBnZW5lcmF0aW5nIGEgYnVuZGxlIGFzc2V0IGlkIGtleSAqL1xuICAgIHRoaXMuX2J1bmRsZUlkQ29ubmVjdG9yID0gdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zLmNvbm5lY3RvcjtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGEgYnVuZGxlIGFzc2V0IGlkIGtleSBmcm9tIGEgYnVuZGxlSWQgYW5kIGFuIGFzc2V0SWRcbiAgICAgKiBAcGFyYW0gYnVuZGxlSWQgLSB0aGUgYnVuZGxlSWRcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAgLSB0aGUgYXNzZXRJZFxuICAgICAqIEByZXR1cm5zIHRoZSBidW5kbGUgYXNzZXQgaWQga2V5XG4gICAgICovXG4gICAgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZCA9IHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucy5jcmVhdGVCdW5kbGVBc3NldElkO1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYW4gYXNzZXRJZCBmcm9tIGEgYnVuZGxlIGFzc2V0IGlkIGtleS4gVGhpcyBpcyB0aGUgcmV2ZXJzZSBvZiBnZW5lcmF0ZUJ1bmRsZUFzc2V0SWRcbiAgICAgKiBAcGFyYW0gYnVuZGxlSWQgLSB0aGUgYnVuZGxlSWRcbiAgICAgKiBAcGFyYW0gYXNzZXRCdW5kbGVJZCAtIHRoZSBidW5kbGUgYXNzZXQgaWQga2V5XG4gICAgICogQHJldHVybnMgdGhlIGFzc2V0SWRcbiAgICAgKi9cbiAgICB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPSB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMuZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlO1xuICAgIHRoaXMuX2Fzc2V0TWFwID0ge307XG4gICAgdGhpcy5fcHJlZmVycmVkT3JkZXIgPSBbXTtcbiAgICB0aGlzLl9wYXJzZXJzID0gW107XG4gICAgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge307XG4gICAgdGhpcy5fYnVuZGxlcyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSBob3cgdGhlIHJlc29sdmVyIGRlYWxzIHdpdGggZ2VuZXJhdGluZyBidW5kbGUgaWRzLlxuICAgKiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYW55IGJ1bmRsZXMgYXJlIGFkZGVkXG4gICAqIEBwYXJhbSBidW5kbGVJZGVudGlmaWVyIC0gdGhlIGJ1bmRsZSBpZGVudGlmaWVyIG9wdGlvbnNcbiAgICovXG4gIHNldEJ1bmRsZUlkZW50aWZpZXIoYnVuZGxlSWRlbnRpZmllcikge1xuICAgIHRoaXMuX2J1bmRsZUlkQ29ubmVjdG9yID0gYnVuZGxlSWRlbnRpZmllci5jb25uZWN0b3IgPz8gdGhpcy5fYnVuZGxlSWRDb25uZWN0b3I7XG4gICAgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZCA9IGJ1bmRsZUlkZW50aWZpZXIuY3JlYXRlQnVuZGxlQXNzZXRJZCA/PyB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkO1xuICAgIHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZSA9IGJ1bmRsZUlkZW50aWZpZXIuZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlID8/IHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZTtcbiAgICBpZiAodGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlKFwiZm9vXCIsIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoXCJmb29cIiwgXCJiYXJcIikpICE9PSBcImJhclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbUmVzb2x2ZXJdIEdlbmVyYXRlQnVuZGxlQXNzZXRJZCBhcmUgbm90IHdvcmtpbmcgY29ycmVjdGx5XCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTGV0IHRoZSByZXNvbHZlciBrbm93IHdoaWNoIGFzc2V0cyB5b3UgcHJlZmVyIHRvIHVzZSB3aGVuIHJlc29sdmluZyBhc3NldHMuXG4gICAqIE11bHRpcGxlIHByZWZlciB1c2VyIGRlZmluZWQgcnVsZXMgY2FuIGJlIGFkZGVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiByZXNvbHZlci5wcmVmZXIoe1xuICAgKiAgICAgLy8gZmlyc3QgbG9vayBmb3Igc29tZXRoaW5nIHdpdGggdGhlIGNvcnJlY3QgZm9ybWF0LCBhbmQgdGhlbiB0aGVuIGNvcnJlY3QgcmVzb2x1dGlvblxuICAgKiAgICAgcHJpb3JpdHk6IFsnZm9ybWF0JywgJ3Jlc29sdXRpb24nXSxcbiAgICogICAgIHBhcmFtczp7XG4gICAqICAgICAgICAgZm9ybWF0Oid3ZWJwJywgLy8gcHJlZmVyIHdlYnAgaW1hZ2VzXG4gICAqICAgICAgICAgcmVzb2x1dGlvbjogMiwgLy8gcHJlZmVyIGEgcmVzb2x1dGlvbiBvZiAyXG4gICAqICAgICB9XG4gICAqIH0pXG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgWydiYXJAMngud2VicCcsICdiYXJAMngucG5nJywgJ2Jhci53ZWJwJywgJ2Jhci5wbmcnXSk7XG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2ZvbycpIC8vID0+ICdiYXJAMngud2VicCdcbiAgICogQHBhcmFtIHByZWZlck9yZGVycyAtIHRoZSBwcmVmZXIgb3B0aW9uc1xuICAgKi9cbiAgcHJlZmVyKC4uLnByZWZlck9yZGVycykge1xuICAgIHByZWZlck9yZGVycy5mb3JFYWNoKChwcmVmZXIpID0+IHtcbiAgICAgIHRoaXMuX3ByZWZlcnJlZE9yZGVyLnB1c2gocHJlZmVyKTtcbiAgICAgIGlmICghcHJlZmVyLnByaW9yaXR5KSB7XG4gICAgICAgIHByZWZlci5wcmlvcml0eSA9IE9iamVjdC5rZXlzKHByZWZlci5wYXJhbXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3Jlc29sdmVySGFzaCA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGJhc2UgcGF0aCB0byBwcmVwZW5kIHRvIGFsbCB1cmxzIHdoZW4gcmVzb2x2aW5nXG4gICAqIEBleGFtcGxlXG4gICAqIHJlc29sdmVyLmJhc2VQYXRoID0gJ2h0dHBzOi8vaG9tZS5jb20vJztcbiAgICogcmVzb2x2ZXIuYWRkKCdmb28nLCAnYmFyLm9uZycpO1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdmb28nLCAnYmFyLnBuZycpOyAvLyA9PiAnaHR0cHM6Ly9ob21lLmNvbS9iYXIucG5nJ1xuICAgKiBAcGFyYW0gYmFzZVBhdGggLSB0aGUgYmFzZSBwYXRoIHRvIHVzZVxuICAgKi9cbiAgc2V0IGJhc2VQYXRoKGJhc2VQYXRoKSB7XG4gICAgdGhpcy5fYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgfVxuICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VQYXRoO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvb3QgcGF0aCBmb3Igcm9vdC1yZWxhdGl2ZSBVUkxzLiBCeSBkZWZhdWx0IHRoZSBgYmFzZVBhdGhgJ3Mgcm9vdCBpcyB1c2VkLiBJZiBubyBgYmFzZVBhdGhgIGlzIHNldCwgdGhlbiB0aGVcbiAgICogZGVmYXVsdCB2YWx1ZSBmb3IgYnJvd3NlcnMgaXMgYHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5gXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEFwcGxpY2F0aW9uIGhvc3RlZCBvbiBodHRwczovL2hvbWUuY29tL3NvbWUtcGF0aC9pbmRleC5odG1sXG4gICAqIHJlc29sdmVyLmJhc2VQYXRoID0gJ2h0dHBzOi8vaG9tZS5jb20vc29tZS1wYXRoLyc7XG4gICAqIHJlc29sdmVyLnJvb3RQYXRoID0gJ2h0dHBzOi8vaG9tZS5jb20vJztcbiAgICogcmVzb2x2ZXIuYWRkKCdmb28nLCAnL2Jhci5wbmcnKTtcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnZm9vJywgJy9iYXIucG5nJyk7IC8vID0+ICdodHRwczovL2hvbWUuY29tL2Jhci5wbmcnXG4gICAqIEBwYXJhbSByb290UGF0aCAtIHRoZSByb290IHBhdGggdG8gdXNlXG4gICAqL1xuICBzZXQgcm9vdFBhdGgocm9vdFBhdGgpIHtcbiAgICB0aGlzLl9yb290UGF0aCA9IHJvb3RQYXRoO1xuICB9XG4gIGdldCByb290UGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdFBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIEFsbCB0aGUgYWN0aXZlIFVSTCBwYXJzZXJzIHRoYXQgaGVscCB0aGUgcGFyc2VyIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gYW5kIGNyZWF0ZVxuICAgKiBhbiBhc3NldCBvYmplY3QtYmFzZWQgb24gcGFyc2luZyB0aGUgVVJMIGl0c2VsZi5cbiAgICpcbiAgICogQ2FuIGJlIGFkZGVkIHVzaW5nIHRoZSBleHRlbnNpb25zIEFQSVxuICAgKiBAZXhhbXBsZVxuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsIFtcbiAgICogICAgIHtcbiAgICogICAgICAgICByZXNvbHV0aW9uOiAyLFxuICAgKiAgICAgICAgIGZvcm1hdDogJ3BuZycsXG4gICAqICAgICAgICAgc3JjOiAnaW1hZ2VAMngucG5nJyxcbiAgICogICAgIH0sXG4gICAqICAgICB7XG4gICAqICAgICAgICAgcmVzb2x1dGlvbjoxLFxuICAgKiAgICAgICAgIGZvcm1hdDoncG5nJyxcbiAgICogICAgICAgICBzcmM6ICdpbWFnZS5wbmcnLFxuICAgKiAgICAgfSxcbiAgICogXSk7XG4gICAqXG4gICAqIC8vIFdpdGggYSB1cmwgcGFyc2VyIHRoZSBpbmZvcm1hdGlvbiBzdWNoIGFzIHJlc29sdXRpb24gYW5kIGZpbGUgZm9ybWF0IGNvdWxkIGV4dHJhY3RlZCBmcm9tIHRoZSB1cmwgaXRzZWxmOlxuICAgKiBleHRlbnNpb25zLmFkZCh7XG4gICAqICAgICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlcixcbiAgICogICAgIHRlc3Q6IGxvYWRUZXh0dXJlcy50ZXN0LCAvLyB0ZXN0IGlmIHVybCBlbmRzIGluIGFuIGltYWdlXG4gICAqICAgICBwYXJzZTogKHZhbHVlOiBzdHJpbmcpID0+XG4gICAqICAgICAoe1xuICAgKiAgICAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoUmVzb2x2ZXIuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/ICcxJyksXG4gICAqICAgICAgICAgZm9ybWF0OiB2YWx1ZS5zcGxpdCgnLicpLnBvcCgpLFxuICAgKiAgICAgICAgIHNyYzogdmFsdWUsXG4gICAqICAgICB9KSxcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIE5vdyByZXNvbHV0aW9uIGFuZCBmb3JtYXQgY2FuIGJlIGV4dHJhY3RlZCBmcm9tIHRoZSB1cmxcbiAgICogcmVzb2x2ZXIuYWRkKCdmb28nLCBbXG4gICAqICAgICAnaW1hZ2VAMngucG5nJyxcbiAgICogICAgICdpbWFnZS5wbmcnLFxuICAgKiBdKTtcbiAgICovXG4gIGdldCBwYXJzZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZXJzO1xuICB9XG4gIC8qKiBVc2VkIGZvciB0ZXN0aW5nLCB0aGlzIHJlc2V0cyB0aGUgcmVzb2x2ZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zZXRCdW5kbGVJZGVudGlmaWVyKHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucyk7XG4gICAgdGhpcy5fYXNzZXRNYXAgPSB7fTtcbiAgICB0aGlzLl9wcmVmZXJyZWRPcmRlciA9IFtdO1xuICAgIHRoaXMuX3Jlc29sdmVySGFzaCA9IHt9O1xuICAgIHRoaXMuX3Jvb3RQYXRoID0gbnVsbDtcbiAgICB0aGlzLl9iYXNlUGF0aCA9IG51bGw7XG4gICAgdGhpcy5fbWFuaWZlc3QgPSBudWxsO1xuICAgIHRoaXMuX2J1bmRsZXMgPSB7fTtcbiAgICB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVmYXVsdCBVUkwgc2VhcmNoIHBhcmFtZXRlcnMgZm9yIHRoZSBVUkwgcmVzb2x2ZXIuIFRoZSB1cmxzIGNhbiBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0gc2VhcmNoUGFyYW1zIC0gdGhlIGRlZmF1bHQgdXJsIHBhcmFtZXRlcnMgdG8gYXBwZW5kIHdoZW4gcmVzb2x2aW5nIHVybHNcbiAgICovXG4gIHNldERlZmF1bHRTZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBzZWFyY2hQYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMgPSBzZWFyY2hQYXJhbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHF1ZXJ5VmFsdWVzID0gc2VhcmNoUGFyYW1zO1xuICAgICAgdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcyA9IE9iamVjdC5rZXlzKHF1ZXJ5VmFsdWVzKS5tYXAoKGtleSkgPT4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5VmFsdWVzW2tleV0pfWApLmpvaW4oXCImXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWxpYXNlcyBmb3IgYSBnaXZlbiBhc3NldFxuICAgKiBAcGFyYW0gYXNzZXQgLSB0aGUgYXNzZXQgdG8gZ2V0IHRoZSBhbGlhc2VzIGZvclxuICAgKi9cbiAgZ2V0QWxpYXMoYXNzZXQpIHtcbiAgICBjb25zdCB7IGFsaWFzLCBzcmMgfSA9IGFzc2V0O1xuICAgIGNvbnN0IGFsaWFzZXNUb1VzZSA9IGNvbnZlcnRUb0xpc3QoXG4gICAgICBhbGlhcyB8fCBzcmMsXG4gICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB2Py5zcmMgPz8gdik7XG4gICAgICAgIGlmICh2YWx1ZT8uc3JjKVxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zcmM7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gYWxpYXNlc1RvVXNlO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBtYW5pZmVzdCB0byB0aGUgYXNzZXQgcmVzb2x2ZXIuIFRoaXMgaXMgYSBuaWNlIHdheSB0byBhZGQgYWxsIHRoZSBhc3NldCBpbmZvcm1hdGlvbiBpbiBvbmUgZ28uXG4gICAqIGdlbmVyYWxseSBhIG1hbmlmZXN0IHdvdWxkIGJlIGJ1aWx0IHVzaW5nIGEgdG9vbC5cbiAgICogQHBhcmFtIG1hbmlmZXN0IC0gdGhlIG1hbmlmZXN0IHRvIGFkZCB0byB0aGUgcmVzb2x2ZXJcbiAgICovXG4gIGFkZE1hbmlmZXN0KG1hbmlmZXN0KSB7XG4gICAgaWYgKHRoaXMuX21hbmlmZXN0KSB7XG4gICAgICB3YXJuKFwiW1Jlc29sdmVyXSBNYW5pZmVzdCBhbHJlYWR5IGV4aXN0cywgdGhpcyB3aWxsIGJlIG92ZXJ3cml0dGVuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9tYW5pZmVzdCA9IG1hbmlmZXN0O1xuICAgIG1hbmlmZXN0LmJ1bmRsZXMuZm9yRWFjaCgoYnVuZGxlKSA9PiB7XG4gICAgICB0aGlzLmFkZEJ1bmRsZShidW5kbGUubmFtZSwgYnVuZGxlLmFzc2V0cyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgYWRkcyBhIGJ1bmRsZSBvZiBhc3NldHMgaW4gb25lIGdvIHNvIHRoYXQgeW91IGNhbiByZXNvbHZlIHRoZW0gYXMgYSBncm91cC5cbiAgICogRm9yIGV4YW1wbGUgeW91IGNvdWxkIGFkZCBhIGJ1bmRsZSBmb3IgZWFjaCBzY3JlZW4gaW4geW91IHBpeGkgYXBwXG4gICAqIEBleGFtcGxlXG4gICAqIHJlc29sdmVyLmFkZEJ1bmRsZSgnYW5pbWFscycsIFtcbiAgICogIHsgYWxpYXM6ICdidW5ueScsIHNyYzogJ2J1bm55LnBuZycgfSxcbiAgICogIHsgYWxpYXM6ICdjaGlja2VuJywgc3JjOiAnY2hpY2tlbi5wbmcnIH0sXG4gICAqICB7IGFsaWFzOiAndGh1bXBlcicsIHNyYzogJ3RodW1wZXIucG5nJyB9LFxuICAgKiBdKTtcbiAgICogLy8gb3JcbiAgICogcmVzb2x2ZXIuYWRkQnVuZGxlKCdhbmltYWxzJywge1xuICAgKiAgICAgYnVubnk6ICdidW5ueS5wbmcnLFxuICAgKiAgICAgY2hpY2tlbjogJ2NoaWNrZW4ucG5nJyxcbiAgICogICAgIHRodW1wZXI6ICd0aHVtcGVyLnBuZycsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCByZXNvbHZlZEFzc2V0cyA9IGF3YWl0IHJlc29sdmVyLnJlc29sdmVCdW5kbGUoJ2FuaW1hbHMnKTtcbiAgICogQHBhcmFtIGJ1bmRsZUlkIC0gVGhlIGlkIG9mIHRoZSBidW5kbGUgdG8gYWRkXG4gICAqIEBwYXJhbSBhc3NldHMgLSBBIHJlY29yZCBvZiB0aGUgYXNzZXQgb3IgYXNzZXRzIHRoYXQgd2lsbCBiZSBjaG9zZW4gZnJvbSB3aGVuIGxvYWRpbmcgdmlhIHRoZSBzcGVjaWZpZWQga2V5XG4gICAqL1xuICBhZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cykge1xuICAgIGNvbnN0IGFzc2V0TmFtZXMgPSBbXTtcbiAgICBsZXQgY29udmVydGVkQXNzZXRzID0gYXNzZXRzO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NldHMpKSB7XG4gICAgICBjb252ZXJ0ZWRBc3NldHMgPSBPYmplY3QuZW50cmllcyhhc3NldHMpLm1hcCgoW2FsaWFzLCBzcmNdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICAgIHJldHVybiB7IGFsaWFzLCBzcmMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBhbGlhcywgLi4uc3JjIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29udmVydGVkQXNzZXRzLmZvckVhY2goKGFzc2V0KSA9PiB7XG4gICAgICBjb25zdCBzcmNzID0gYXNzZXQuc3JjO1xuICAgICAgY29uc3QgYWxpYXNlcyA9IGFzc2V0LmFsaWFzO1xuICAgICAgbGV0IGlkcztcbiAgICAgIGlmICh0eXBlb2YgYWxpYXNlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBidW5kbGVBc3NldElkID0gdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChidW5kbGVJZCwgYWxpYXNlcyk7XG4gICAgICAgIGFzc2V0TmFtZXMucHVzaChidW5kbGVBc3NldElkKTtcbiAgICAgICAgaWRzID0gW2FsaWFzZXMsIGJ1bmRsZUFzc2V0SWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVuZGxlSWRzID0gYWxpYXNlcy5tYXAoKG5hbWUpID0+IHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIG5hbWUpKTtcbiAgICAgICAgYXNzZXROYW1lcy5wdXNoKC4uLmJ1bmRsZUlkcyk7XG4gICAgICAgIGlkcyA9IFsuLi5hbGlhc2VzLCAuLi5idW5kbGVJZHNdO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGQoe1xuICAgICAgICAuLi5hc3NldCxcbiAgICAgICAgLi4ue1xuICAgICAgICAgIGFsaWFzOiBpZHMsXG4gICAgICAgICAgc3JjOiBzcmNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2J1bmRsZXNbYnVuZGxlSWRdID0gYXNzZXROYW1lcztcbiAgfVxuICAvKipcbiAgICogVGVsbHMgdGhlIHJlc29sdmVyIHdoYXQga2V5cyBhcmUgYXNzb2NpYXRlZCB3aXRoIHdpdGNoIGFzc2V0LlxuICAgKiBUaGUgbW9zdCBpbXBvcnRhbnQgdGhpbmcgdGhlIHJlc29sdmVyIGRvZXNcbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2luZ2xlIGtleSwgc2luZ2xlIGFzc2V0OlxuICAgKiByZXNvbHZlci5hZGQoe2FsaWFzOiAnZm9vJywgc3JjOiAnYmFyLnBuZycpO1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdmb28nKSAvLyA9PiAnYmFyLnBuZydcbiAgICpcbiAgICogLy8gTXVsdGlwbGUga2V5cywgc2luZ2xlIGFzc2V0OlxuICAgKiByZXNvbHZlci5hZGQoe2FsaWFzOiBbJ2ZvbycsICdib28nXSwgc3JjOiAnYmFyLnBuZyd9KTtcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnZm9vJykgLy8gPT4gJ2Jhci5wbmcnXG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2JvbycpIC8vID0+ICdiYXIucG5nJ1xuICAgKlxuICAgKiAvLyBNdWx0aXBsZSBrZXlzLCBtdWx0aXBsZSBhc3NldHM6XG4gICAqIHJlc29sdmVyLmFkZCh7YWxpYXM6IFsnZm9vJywgJ2JvbyddLCBzcmM6IFsnYmFyLnBuZycsICdiYXIud2VicCddfSk7XG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2ZvbycpIC8vID0+ICdiYXIucG5nJ1xuICAgKlxuICAgKiAvLyBBZGQgY3VzdG9tIGRhdGEgYXR0YWNoZWQgdG8gdGhlIHJlc29sdmVyXG4gICAqIFJlc29sdmVyLmFkZCh7XG4gICAqICAgICBhbGlhczogJ2J1bm55Qm9vQm9vU21vb3RoJyxcbiAgICogICAgIHNyYzogJ2J1bm55e3BuZyx3ZWJwfScsXG4gICAqICAgICBkYXRhOiB7IHNjYWxlTW9kZTpTQ0FMRV9NT0RFUy5ORUFSRVNUIH0sIC8vIEJhc2UgdGV4dHVyZSBvcHRpb25zXG4gICAqIH0pO1xuICAgKlxuICAgKiByZXNvbHZlci5yZXNvbHZlKCdidW5ueUJvb0Jvb1Ntb290aCcpIC8vID0+IHsgc3JjOiAnYnVubnkucG5nJywgZGF0YTogeyBzY2FsZU1vZGU6IFNDQUxFX01PREVTLk5FQVJFU1QgfSB9XG4gICAqIEBwYXJhbSBhbGlhc2VzIC0gdGhlIFVucmVzb2x2ZWRBc3NldCBvciBhcnJheSBvZiBVbnJlc29sdmVkQXNzZXRzIHRvIGFkZCB0byB0aGUgcmVzb2x2ZXJcbiAgICovXG4gIGFkZChhbGlhc2VzKSB7XG4gICAgY29uc3QgYXNzZXRzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxpYXNlcykpIHtcbiAgICAgIGFzc2V0cy5wdXNoKC4uLmFsaWFzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NldHMucHVzaChhbGlhc2VzKTtcbiAgICB9XG4gICAgbGV0IGtleUNoZWNrO1xuICAgIGtleUNoZWNrID0gKGtleSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzS2V5KGtleSkpIHtcbiAgICAgICAgd2FybihgW1Jlc29sdmVyXSBhbHJlYWR5IGhhcyBrZXk6ICR7a2V5fSBvdmVyd3JpdGluZ2ApO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXNzZXRBcnJheSA9IGNvbnZlcnRUb0xpc3QoYXNzZXRzKTtcbiAgICBhc3NldEFycmF5LmZvckVhY2goKGFzc2V0KSA9PiB7XG4gICAgICBjb25zdCB7IHNyYyB9ID0gYXNzZXQ7XG4gICAgICBsZXQgeyBkYXRhLCBmb3JtYXQsIGxvYWRQYXJzZXIgfSA9IGFzc2V0O1xuICAgICAgY29uc3Qgc3Jjc1RvVXNlID0gY29udmVydFRvTGlzdChzcmMpLm1hcCgoc3JjMikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNyYzIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyhzcmMyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzcmMyKSA/IHNyYzIgOiBbc3JjMl07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFsaWFzZXNUb1VzZSA9IHRoaXMuZ2V0QWxpYXMoYXNzZXQpO1xuICAgICAgQXJyYXkuaXNBcnJheShhbGlhc2VzVG9Vc2UpID8gYWxpYXNlc1RvVXNlLmZvckVhY2goa2V5Q2hlY2spIDoga2V5Q2hlY2soYWxpYXNlc1RvVXNlKTtcbiAgICAgIGNvbnN0IHJlc29sdmVkQXNzZXRzID0gW107XG4gICAgICBzcmNzVG9Vc2UuZm9yRWFjaCgoc3JjcykgPT4ge1xuICAgICAgICBzcmNzLmZvckVhY2goKHNyYzIpID0+IHtcbiAgICAgICAgICBsZXQgZm9ybWF0dGVkQXNzZXQgPSB7fTtcbiAgICAgICAgICBpZiAodHlwZW9mIHNyYzIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZEFzc2V0LnNyYyA9IHNyYzI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gdGhpcy5fcGFyc2Vyc1tpXTtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci50ZXN0KHNyYzIpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQXNzZXQgPSBwYXJzZXIucGFyc2Uoc3JjMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHNyYzIuZGF0YSA/PyBkYXRhO1xuICAgICAgICAgICAgZm9ybWF0ID0gc3JjMi5mb3JtYXQgPz8gZm9ybWF0O1xuICAgICAgICAgICAgbG9hZFBhcnNlciA9IHNyYzIubG9hZFBhcnNlciA/PyBsb2FkUGFyc2VyO1xuICAgICAgICAgICAgZm9ybWF0dGVkQXNzZXQgPSB7XG4gICAgICAgICAgICAgIC4uLmZvcm1hdHRlZEFzc2V0LFxuICAgICAgICAgICAgICAuLi5zcmMyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFsaWFzZXNUb1VzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbUmVzb2x2ZXJdIGFsaWFzIGlzIHVuZGVmaW5lZCBmb3IgdGhpcyBhc3NldDogJHtmb3JtYXR0ZWRBc3NldC5zcmN9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcm1hdHRlZEFzc2V0ID0gdGhpcy5fYnVpbGRSZXNvbHZlZEFzc2V0KGZvcm1hdHRlZEFzc2V0LCB7XG4gICAgICAgICAgICBhbGlhc2VzOiBhbGlhc2VzVG9Vc2UsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgbG9hZFBhcnNlclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc29sdmVkQXNzZXRzLnB1c2goZm9ybWF0dGVkQXNzZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYWxpYXNlc1RvVXNlLmZvckVhY2goKGFsaWFzKSA9PiB7XG4gICAgICAgIHRoaXMuX2Fzc2V0TWFwW2FsaWFzXSA9IHJlc29sdmVkQXNzZXRzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gVE9ETzogdGhpcyBuZWVkcyBhbiBvdmVybG9hZCBsaWtlIGxvYWQgZGlkIGluIEFzc2V0c1xuICAvKipcbiAgICogSWYgdGhlIHJlc29sdmVyIGhhcyBoYWQgYSBtYW5pZmVzdCBzZXQgdmlhIHNldE1hbmlmZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBhc3NldHMgdXJscyBmb3JcbiAgICogYSBnaXZlbiBidW5kbGVJZCBvciBidW5kbGVJZHMuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE1hbmlmZXN0IEV4YW1wbGVcbiAgICogY29uc3QgbWFuaWZlc3QgPSB7XG4gICAqICAgICBidW5kbGVzOiBbXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnbG9hZC1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhY2tncm91bmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNyYzogJ3N1bnNldC5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnbG9hZC1iYXIue3BuZyx3ZWJwfScsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICBdLFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnZ2FtZS1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2NoYXJhY3RlcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAncm9ib3QucG5nJyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgYWxpYXM6ICdlbmVteScsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnYmFkLWd1eS5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgXSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgXVxuICAgKiB9O1xuICAgKlxuICAgKiByZXNvbHZlci5zZXRNYW5pZmVzdChtYW5pZmVzdCk7XG4gICAqIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZXIucmVzb2x2ZUJ1bmRsZSgnbG9hZC1zY3JlZW4nKTtcbiAgICogQHBhcmFtIGJ1bmRsZUlkcyAtIFRoZSBidW5kbGUgaWRzIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgQWxsIHRoZSBidW5kbGVzIGFzc2V0cyBvciBhIGhhc2ggb2YgYXNzZXRzIGZvciBlYWNoIGJ1bmRsZSBzcGVjaWZpZWRcbiAgICovXG4gIHJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKSB7XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0oYnVuZGxlSWRzKTtcbiAgICBidW5kbGVJZHMgPSBjb252ZXJ0VG9MaXN0KGJ1bmRsZUlkcyk7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgYnVuZGxlSWRzLmZvckVhY2goKGJ1bmRsZUlkKSA9PiB7XG4gICAgICBjb25zdCBhc3NldE5hbWVzID0gdGhpcy5fYnVuZGxlc1tidW5kbGVJZF07XG4gICAgICBpZiAoYXNzZXROYW1lcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5yZXNvbHZlKGFzc2V0TmFtZXMpO1xuICAgICAgICBjb25zdCBhc3NldHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgICAgIGNvbnN0IGFzc2V0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICAgIGFzc2V0c1t0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUoYnVuZGxlSWQsIGtleSldID0gYXNzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgb3V0W2J1bmRsZUlkXSA9IGFzc2V0cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2luZ2xlQXNzZXQgPyBvdXRbYnVuZGxlSWRzWzBdXSA6IG91dDtcbiAgfVxuICAvKipcbiAgICogRG9lcyBleGFjdGx5IHdoYXQgcmVzb2x2ZSBkb2VzLCBidXQgcmV0dXJucyBqdXN0IHRoZSBVUkwgcmF0aGVyIHRoYW4gdGhlIHdob2xlIGFzc2V0IG9iamVjdFxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvciBrZXlzIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgLSBUaGUgVVJMcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleShzKVxuICAgKi9cbiAgcmVzb2x2ZVVybChrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc29sdmUoa2V5KTtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3Qgb3V0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gcmVzdWx0KSB7XG4gICAgICAgIG91dFtpXSA9IHJlc3VsdFtpXS5zcmM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNyYztcbiAgfVxuICByZXNvbHZlKGtleXMpIHtcbiAgICBjb25zdCBzaW5nbGVBc3NldCA9IGlzU2luZ2xlSXRlbShrZXlzKTtcbiAgICBrZXlzID0gY29udmVydFRvTGlzdChrZXlzKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlckhhc2hba2V5XSkge1xuICAgICAgICBpZiAodGhpcy5fYXNzZXRNYXBba2V5XSkge1xuICAgICAgICAgIGxldCBhc3NldHMgPSB0aGlzLl9hc3NldE1hcFtrZXldO1xuICAgICAgICAgIGNvbnN0IHByZWZlcnJlZE9yZGVyID0gdGhpcy5fZ2V0UHJlZmVycmVkT3JkZXIoYXNzZXRzKTtcbiAgICAgICAgICBwcmVmZXJyZWRPcmRlcj8ucHJpb3JpdHkuZm9yRWFjaCgocHJpb3JpdHlLZXkpID0+IHtcbiAgICAgICAgICAgIHByZWZlcnJlZE9yZGVyLnBhcmFtc1twcmlvcml0eUtleV0uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRBc3NldHMgPSBhc3NldHMuZmlsdGVyKChhc3NldCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhc3NldFtwcmlvcml0eUtleV0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhc3NldFtwcmlvcml0eUtleV0gPT09IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRBc3NldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXNzZXRzID0gZmlsdGVyZWRBc3NldHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVySGFzaFtrZXldID0gYXNzZXRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVySGFzaFtrZXldID0gdGhpcy5fYnVpbGRSZXNvbHZlZEFzc2V0KHtcbiAgICAgICAgICAgIGFsaWFzOiBba2V5XSxcbiAgICAgICAgICAgIHNyYzoga2V5XG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHRba2V5XSA9IHRoaXMuX3Jlc29sdmVySGFzaFtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IHJlc3VsdFtrZXlzWzBdXSA6IHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFuIGFzc2V0IHdpdGggYSBnaXZlbiBrZXkgZXhpc3RzIGluIHRoZSByZXNvbHZlclxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgYXNzZXRcbiAgICovXG4gIGhhc0tleShrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLl9hc3NldE1hcFtrZXldO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBidW5kbGUgd2l0aCB0aGUgZ2l2ZW4ga2V5IGV4aXN0cyBpbiB0aGUgcmVzb2x2ZXJcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGJ1bmRsZVxuICAgKi9cbiAgaGFzQnVuZGxlKGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuX2J1bmRsZXNba2V5XTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWwgZnVuY3Rpb24gZm9yIGZpZ3VyaW5nIG91dCB3aGF0IHByZWZlciBjcml0ZXJpYSBhbiBhc3NldCBzaG91bGQgdXNlLlxuICAgKiBAcGFyYW0gYXNzZXRzXG4gICAqL1xuICBfZ2V0UHJlZmVycmVkT3JkZXIoYXNzZXRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRzWzBdO1xuICAgICAgY29uc3QgcHJlZmVycmVkID0gdGhpcy5fcHJlZmVycmVkT3JkZXIuZmluZCgocHJlZmVyZW5jZSkgPT4gcHJlZmVyZW5jZS5wYXJhbXMuZm9ybWF0LmluY2x1ZGVzKGFzc2V0LmZvcm1hdCkpO1xuICAgICAgaWYgKHByZWZlcnJlZCkge1xuICAgICAgICByZXR1cm4gcHJlZmVycmVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJlZmVycmVkT3JkZXJbMF07XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGRlZmF1bHQgdXJsIHBhcmFtZXRlcnMgdG8gdGhlIHVybFxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIHVybCB0byBhcHBlbmQgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyB0b1xuICAgKiBAcmV0dXJucyAtIFRoZSB1cmwgd2l0aCB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzIGFwcGVuZGVkXG4gICAqL1xuICBfYXBwZW5kRGVmYXVsdFNlYXJjaFBhcmFtcyh1cmwpIHtcbiAgICBpZiAoIXRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMpXG4gICAgICByZXR1cm4gdXJsO1xuICAgIGNvbnN0IHBhcmFtQ29ubmVjdG9yID0gL1xcPy8udGVzdCh1cmwpID8gXCImXCIgOiBcIj9cIjtcbiAgICByZXR1cm4gYCR7dXJsfSR7cGFyYW1Db25uZWN0b3J9JHt0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zfWA7XG4gIH1cbiAgX2J1aWxkUmVzb2x2ZWRBc3NldChmb3JtYXR0ZWRBc3NldCwgZGF0YSkge1xuICAgIGNvbnN0IHsgYWxpYXNlcywgZGF0YTogYXNzZXREYXRhLCBsb2FkUGFyc2VyLCBmb3JtYXQgfSA9IGRhdGE7XG4gICAgaWYgKHRoaXMuX2Jhc2VQYXRoIHx8IHRoaXMuX3Jvb3RQYXRoKSB7XG4gICAgICBmb3JtYXR0ZWRBc3NldC5zcmMgPSBwYXRoLnRvQWJzb2x1dGUoZm9ybWF0dGVkQXNzZXQuc3JjLCB0aGlzLl9iYXNlUGF0aCwgdGhpcy5fcm9vdFBhdGgpO1xuICAgIH1cbiAgICBmb3JtYXR0ZWRBc3NldC5hbGlhcyA9IGFsaWFzZXMgPz8gZm9ybWF0dGVkQXNzZXQuYWxpYXMgPz8gW2Zvcm1hdHRlZEFzc2V0LnNyY107XG4gICAgZm9ybWF0dGVkQXNzZXQuc3JjID0gdGhpcy5fYXBwZW5kRGVmYXVsdFNlYXJjaFBhcmFtcyhmb3JtYXR0ZWRBc3NldC5zcmMpO1xuICAgIGZvcm1hdHRlZEFzc2V0LmRhdGEgPSB7IC4uLmFzc2V0RGF0YSB8fCB7fSwgLi4uZm9ybWF0dGVkQXNzZXQuZGF0YSB9O1xuICAgIGZvcm1hdHRlZEFzc2V0LmxvYWRQYXJzZXIgPSBsb2FkUGFyc2VyID8/IGZvcm1hdHRlZEFzc2V0LmxvYWRQYXJzZXI7XG4gICAgZm9ybWF0dGVkQXNzZXQuZm9ybWF0ID0gZm9ybWF0ID8/IGZvcm1hdHRlZEFzc2V0LmZvcm1hdCA/PyBnZXRVcmxFeHRlbnNpb24oZm9ybWF0dGVkQXNzZXQuc3JjKTtcbiAgICByZXR1cm4gZm9ybWF0dGVkQXNzZXQ7XG4gIH1cbn1cbi8qKlxuICogVGhlIHByZWZpeCB0aGF0IGRlbm90ZXMgYSBVUkwgaXMgZm9yIGEgcmV0aW5hIGFzc2V0LlxuICogQHN0YXRpY1xuICogQG5hbWUgUkVUSU5BX1BSRUZJWFxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBkZWZhdWx0IC9AKFswLTlcXC5dKyl4L1xuICogQGV4YW1wbGUgYEAyeGBcbiAqL1xuUmVzb2x2ZXIuUkVUSU5BX1BSRUZJWCA9IC9AKFswLTlcXC5dKyl4LztcbmZ1bmN0aW9uIGdldFVybEV4dGVuc2lvbih1cmwpIHtcbiAgcmV0dXJuIHVybC5zcGxpdChcIi5cIikucG9wKCkuc3BsaXQoXCI/XCIpLnNoaWZ0KCkuc3BsaXQoXCIjXCIpLnNoaWZ0KCk7XG59XG5cbmV4cG9ydCB7IFJlc29sdmVyLCBnZXRVcmxFeHRlbnNpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc29sdmVyLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY29weVNlYXJjaFBhcmFtcyA9ICh0YXJnZXRVcmwsIHNvdXJjZVVybCkgPT4ge1xuICBjb25zdCBzZWFyY2hQYXJhbXMgPSBzb3VyY2VVcmwuc3BsaXQoXCI/XCIpWzFdO1xuICBpZiAoc2VhcmNoUGFyYW1zKSB7XG4gICAgdGFyZ2V0VXJsICs9IGA/JHtzZWFyY2hQYXJhbXN9YDtcbiAgfVxuICByZXR1cm4gdGFyZ2V0VXJsO1xufTtcblxuZXhwb3J0IHsgY29weVNlYXJjaFBhcmFtcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29weVNlYXJjaFBhcmFtcy5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX1Nwcml0ZXNoZWV0ID0gY2xhc3MgX1Nwcml0ZXNoZWV0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gUmVmZXJlbmNlIHRvIHRoZSBzb3VyY2UgQmFzZVRleHR1cmUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIFNwcml0ZXNoZWV0IGltYWdlIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBkYXRhKSB7XG4gICAgLyoqIEZvciBtdWx0aS1wYWNrZWQgc3ByaXRlc2hlZXRzLCB0aGlzIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIGFsbCB0aGUgb3RoZXIgc3ByaXRlc2hlZXRzIGl0IGRlcGVuZHMgb24uICovXG4gICAgdGhpcy5saW5rZWRTaGVldHMgPSBbXTtcbiAgICB0aGlzLl90ZXh0dXJlID0gdGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUgPyB0ZXh0dXJlIDogbnVsbDtcbiAgICB0aGlzLnRleHR1cmVTb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcbiAgICB0aGlzLnRleHR1cmVzID0ge307XG4gICAgdGhpcy5hbmltYXRpb25zID0ge307XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICBjb25zdCBtZXRhUmVzb2x1dGlvbiA9IHBhcnNlRmxvYXQoZGF0YS5tZXRhLnNjYWxlKTtcbiAgICBpZiAobWV0YVJlc29sdXRpb24pIHtcbiAgICAgIHRoaXMucmVzb2x1dGlvbiA9IG1ldGFSZXNvbHV0aW9uO1xuICAgICAgdGV4dHVyZS5zb3VyY2UucmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNvbHV0aW9uID0gdGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lcyA9IHRoaXMuZGF0YS5mcmFtZXM7XG4gICAgdGhpcy5fZnJhbWVLZXlzID0gT2JqZWN0LmtleXModGhpcy5fZnJhbWVzKTtcbiAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlciBzcHJpdGVzaGVldCBmcm9tIGxvYWRlZCBkYXRhLiBUaGlzIGlzIGRvbmUgYXN5bmNocm9ub3VzbHlcbiAgICogdG8gcHJldmVudCBjcmVhdGluZyB0b28gbWFueSBUZXh0dXJlIHdpdGhpbiBhIHNpbmdsZSBwcm9jZXNzLlxuICAgKi9cbiAgcGFyc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9jYWxsYmFjayA9IHJlc29sdmU7XG4gICAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcbiAgICAgIGlmICh0aGlzLl9mcmFtZUtleXMubGVuZ3RoIDw9IF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXMoMCk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlQ29tcGxldGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25leHRCYXRjaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgYmF0Y2ggb2YgZnJhbWVzXG4gICAqIEBwYXJhbSBpbml0aWFsRnJhbWVJbmRleCAtIFRoZSBpbmRleCBvZiBmcmFtZSB0byBzdGFydC5cbiAgICovXG4gIF9wcm9jZXNzRnJhbWVzKGluaXRpYWxGcmFtZUluZGV4KSB7XG4gICAgbGV0IGZyYW1lSW5kZXggPSBpbml0aWFsRnJhbWVJbmRleDtcbiAgICBjb25zdCBtYXhGcmFtZXMgPSBfU3ByaXRlc2hlZXQuQkFUQ0hfU0laRTtcbiAgICB3aGlsZSAoZnJhbWVJbmRleCAtIGluaXRpYWxGcmFtZUluZGV4IDwgbWF4RnJhbWVzICYmIGZyYW1lSW5kZXggPCB0aGlzLl9mcmFtZUtleXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZnJhbWVLZXlzW2ZyYW1lSW5kZXhdO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2ZyYW1lc1tpXTtcbiAgICAgIGNvbnN0IHJlY3QgPSBkYXRhLmZyYW1lO1xuICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgbGV0IGZyYW1lID0gbnVsbDtcbiAgICAgICAgbGV0IHRyaW0gPSBudWxsO1xuICAgICAgICBjb25zdCBzb3VyY2VTaXplID0gZGF0YS50cmltbWVkICE9PSBmYWxzZSAmJiBkYXRhLnNvdXJjZVNpemUgPyBkYXRhLnNvdXJjZVNpemUgOiBkYXRhLmZyYW1lO1xuICAgICAgICBjb25zdCBvcmlnID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5mbG9vcihzb3VyY2VTaXplLncpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGguZmxvb3Ioc291cmNlU2l6ZS5oKSAvIHRoaXMucmVzb2x1dGlvblxuICAgICAgICApO1xuICAgICAgICBpZiAoZGF0YS5yb3RhdGVkKSB7XG4gICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LngpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFtZSA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICBNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgICBNYXRoLmZsb29yKHJlY3QueSkgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgICBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgICBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnRyaW1tZWQgIT09IGZhbHNlICYmIGRhdGEuc3ByaXRlU291cmNlU2l6ZSkge1xuICAgICAgICAgIHRyaW0gPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgTWF0aC5mbG9vcihkYXRhLnNwcml0ZVNvdXJjZVNpemUueCkgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgICBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS55KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0dXJlc1tpXSA9IG5ldyBUZXh0dXJlKHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMudGV4dHVyZVNvdXJjZSxcbiAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICBvcmlnLFxuICAgICAgICAgIHRyaW0sXG4gICAgICAgICAgcm90YXRlOiBkYXRhLnJvdGF0ZWQgPyAyIDogMCxcbiAgICAgICAgICBkZWZhdWx0QW5jaG9yOiBkYXRhLmFuY2hvcixcbiAgICAgICAgICBkZWZhdWx0Qm9yZGVyczogZGF0YS5ib3JkZXJzLFxuICAgICAgICAgIGxhYmVsOiBpLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmcmFtZUluZGV4Kys7XG4gICAgfVxuICB9XG4gIC8qKiBQYXJzZSBhbmltYXRpb25zIGNvbmZpZy4gKi9cbiAgX3Byb2Nlc3NBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLmRhdGEuYW5pbWF0aW9ucyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGFuaW1OYW1lIGluIGFuaW1hdGlvbnMpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltTmFtZV0gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5pbWF0aW9uc1thbmltTmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZnJhbWVOYW1lID0gYW5pbWF0aW9uc1thbmltTmFtZV1baV07XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltTmFtZV0ucHVzaCh0aGlzLnRleHR1cmVzW2ZyYW1lTmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogVGhlIHBhcnNlIGhhcyBjb21wbGV0ZWQuICovXG4gIF9wYXJzZUNvbXBsZXRlKCkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2s7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuX2JhdGNoSW5kZXggPSAwO1xuICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy50ZXh0dXJlcyk7XG4gIH1cbiAgLyoqIEJlZ2luIHRoZSBuZXh0IGJhdGNoIG9mIHRleHR1cmVzLiAqL1xuICBfbmV4dEJhdGNoKCkge1xuICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXModGhpcy5fYmF0Y2hJbmRleCAqIF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFKTtcbiAgICB0aGlzLl9iYXRjaEluZGV4Kys7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fYmF0Y2hJbmRleCAqIF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFIDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSBTcHJpdGVzaGVldCBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rlc3Ryb3lCYXNlPWZhbHNlXSAtIFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAgICovXG4gIGRlc3Ryb3koZGVzdHJveUJhc2UgPSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnRleHR1cmVzKSB7XG4gICAgICB0aGlzLnRleHR1cmVzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fZnJhbWVzID0gbnVsbDtcbiAgICB0aGlzLl9mcmFtZUtleXMgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlcyA9IG51bGw7XG4gICAgaWYgKGRlc3Ryb3lCYXNlKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlPy5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRleHR1cmVTb3VyY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMubGlua2VkU2hlZXRzID0gW107XG4gIH1cbn07XG4vKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIFRleHR1cmVzIHRvIGJ1aWxkIHBlciBwcm9jZXNzLiAqL1xuX1Nwcml0ZXNoZWV0LkJBVENIX1NJWkUgPSAxZTM7XG5sZXQgU3ByaXRlc2hlZXQgPSBfU3ByaXRlc2hlZXQ7XG5cbmV4cG9ydCB7IFNwcml0ZXNoZWV0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGVzaGVldC5tanMubWFwXG4iLCJpbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4uL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIubWpzJztcbmltcG9ydCB7IFJlc29sdmVyIH0gZnJvbSAnLi4vYXNzZXRzL3Jlc29sdmVyL1Jlc29sdmVyLm1qcyc7XG5pbXBvcnQgeyBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vYXNzZXRzL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHBhdGggfSBmcm9tICcuLi91dGlscy9wYXRoLm1qcyc7XG5pbXBvcnQgeyBTcHJpdGVzaGVldCB9IGZyb20gJy4vU3ByaXRlc2hlZXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB2YWxpZEltYWdlcyA9IFtcbiAgXCJqcGdcIixcbiAgXCJwbmdcIixcbiAgXCJqcGVnXCIsXG4gIFwiYXZpZlwiLFxuICBcIndlYnBcIixcbiAgXCJiYXNpc1wiLFxuICBcImV0YzJcIixcbiAgXCJiYzdcIixcbiAgXCJiYzZoXCIsXG4gIFwiYmM1XCIsXG4gIFwiYmM0XCIsXG4gIFwiYmMzXCIsXG4gIFwiYmMyXCIsXG4gIFwiYmMxXCIsXG4gIFwiZWFjXCIsXG4gIFwiYXN0Y1wiXG5dO1xuZnVuY3Rpb24gZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIGFzc2V0LCBpZ25vcmVNdWx0aVBhY2spIHtcbiAgY29uc3Qgb3V0ID0ge307XG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgb3V0W2tleV0gPSBhc3NldDtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKGFzc2V0LnRleHR1cmVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBvdXRba2V5XSA9IGFzc2V0LnRleHR1cmVzW2tleV07XG4gIH0pO1xuICBpZiAoIWlnbm9yZU11bHRpUGFjaykge1xuICAgIGNvbnN0IGJhc2VQYXRoID0gcGF0aC5kaXJuYW1lKGtleXNbMF0pO1xuICAgIGFzc2V0LmxpbmtlZFNoZWV0cy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBvdXQyID0gZ2V0Q2FjaGVhYmxlQXNzZXRzKFtgJHtiYXNlUGF0aH0vJHthc3NldC5kYXRhLm1ldGEucmVsYXRlZF9tdWx0aV9wYWNrc1tpXX1gXSwgaXRlbSwgdHJ1ZSk7XG4gICAgICBPYmplY3QuYXNzaWduKG91dCwgb3V0Mik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IHNwcml0ZXNoZWV0QXNzZXQgPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5Bc3NldCxcbiAgLyoqIEhhbmRsZSB0aGUgY2FjaGluZyBvZiB0aGUgcmVsYXRlZCBTcHJpdGVzaGVldCBUZXh0dXJlcyAqL1xuICBjYWNoZToge1xuICAgIHRlc3Q6IChhc3NldCkgPT4gYXNzZXQgaW5zdGFuY2VvZiBTcHJpdGVzaGVldCxcbiAgICBnZXRDYWNoZWFibGVBc3NldHM6IChrZXlzLCBhc3NldCkgPT4gZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIGFzc2V0LCBmYWxzZSlcbiAgfSxcbiAgLyoqIFJlc29sdmUgdGhlIHJlc29sdXRpb24gb2YgdGhlIGFzc2V0LiAqL1xuICByZXNvbHZlcjoge1xuICAgIGV4dGVuc2lvbjoge1xuICAgICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICAgICAgbmFtZTogXCJyZXNvbHZlU3ByaXRlc2hlZXRcIlxuICAgIH0sXG4gICAgdGVzdDogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wVVJMID0gdmFsdWUuc3BsaXQoXCI/XCIpWzBdO1xuICAgICAgY29uc3Qgc3BsaXQgPSB0ZW1wVVJMLnNwbGl0KFwiLlwiKTtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHNwbGl0LnBvcCgpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gc3BsaXQucG9wKCk7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uID09PSBcImpzb25cIiAmJiB2YWxpZEltYWdlcy5pbmNsdWRlcyhmb3JtYXQpO1xuICAgIH0sXG4gICAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgc3BsaXQgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KFJlc29sdmVyLlJFVElOQV9QUkVGSVguZXhlYyh2YWx1ZSk/LlsxXSA/PyBcIjFcIiksXG4gICAgICAgIGZvcm1hdDogc3BsaXRbc3BsaXQubGVuZ3RoIC0gMl0sXG4gICAgICAgIHNyYzogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogTG9hZGVyIHBsdWdpbiB0aGF0IHBhcnNlcyBzcHJpdGUgc2hlZXRzIVxuICAgKiBvbmNlIHRoZSBKU09OIGhhcyBiZWVuIGxvYWRlZCB0aGlzIGNoZWNrcyB0byBzZWUgaWYgdGhlIEpTT04gaXMgc3ByaXRlc2hlZXQgZGF0YS5cbiAgICogSWYgaXQgaXMsIHdlIGxvYWQgdGhlIHNwcml0ZXNoZWV0cyBpbWFnZSBhbmQgcGFyc2UgdGhlIGRhdGEgaW50byBTcHJpdGVzaGVldFxuICAgKiBBbGwgdGV4dHVyZXMgaW4gdGhlIHNwcml0ZSBzaGVldCBhcmUgdGhlbiBhZGRlZCB0byB0aGUgY2FjaGVcbiAgICovXG4gIGxvYWRlcjoge1xuICAgIG5hbWU6IFwic3ByaXRlc2hlZXRMb2FkZXJcIixcbiAgICBleHRlbnNpb246IHtcbiAgICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Ob3JtYWwsXG4gICAgICBuYW1lOiBcInNwcml0ZXNoZWV0TG9hZGVyXCJcbiAgICB9LFxuICAgIGFzeW5jIHRlc3RQYXJzZShhc3NldCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHBhdGguZXh0bmFtZShvcHRpb25zLnNyYykudG9Mb3dlckNhc2UoKSA9PT0gXCIuanNvblwiICYmICEhYXNzZXQuZnJhbWVzO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2UoYXNzZXQsIG9wdGlvbnMsIGxvYWRlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0ZXh0dXJlOiBpbWFnZVRleHR1cmUsXG4gICAgICAgIC8vIGlmIHVzZXIgbmVlZCB0byB1c2UgcHJlbG9hZGVkIHRleHR1cmVcbiAgICAgICAgaW1hZ2VGaWxlbmFtZVxuICAgICAgICAvLyBpZiB1c2VyIG5lZWQgdG8gdXNlIGN1c3RvbSBmaWxlbmFtZSAobm90IGZyb20ganNvbkZpbGUubWV0YS5pbWFnZSlcbiAgICAgIH0gPSBvcHRpb25zPy5kYXRhID8/IHt9O1xuICAgICAgbGV0IGJhc2VQYXRoID0gcGF0aC5kaXJuYW1lKG9wdGlvbnMuc3JjKTtcbiAgICAgIGlmIChiYXNlUGF0aCAmJiBiYXNlUGF0aC5sYXN0SW5kZXhPZihcIi9cIikgIT09IGJhc2VQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgYmFzZVBhdGggKz0gXCIvXCI7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dHVyZTtcbiAgICAgIGlmIChpbWFnZVRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgIHRleHR1cmUgPSBpbWFnZVRleHR1cmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbWFnZVBhdGggPSBjb3B5U2VhcmNoUGFyYW1zKGJhc2VQYXRoICsgKGltYWdlRmlsZW5hbWUgPz8gYXNzZXQubWV0YS5pbWFnZSksIG9wdGlvbnMuc3JjKTtcbiAgICAgICAgY29uc3QgYXNzZXRzID0gYXdhaXQgbG9hZGVyLmxvYWQoW2ltYWdlUGF0aF0pO1xuICAgICAgICB0ZXh0dXJlID0gYXNzZXRzW2ltYWdlUGF0aF07XG4gICAgICB9XG4gICAgICBjb25zdCBzcHJpdGVzaGVldCA9IG5ldyBTcHJpdGVzaGVldChcbiAgICAgICAgdGV4dHVyZS5zb3VyY2UsXG4gICAgICAgIGFzc2V0XG4gICAgICApO1xuICAgICAgYXdhaXQgc3ByaXRlc2hlZXQucGFyc2UoKTtcbiAgICAgIGNvbnN0IG11bHRpUGFja3MgPSBhc3NldD8ubWV0YT8ucmVsYXRlZF9tdWx0aV9wYWNrcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG11bHRpUGFja3MpKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtdWx0aVBhY2tzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGl0ZW1VcmwgPSBiYXNlUGF0aCArIGl0ZW07XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YT8uaWdub3JlTXVsdGlQYWNrKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbVVybCA9IGNvcHlTZWFyY2hQYXJhbXMoaXRlbVVybCwgb3B0aW9ucy5zcmMpO1xuICAgICAgICAgIHByb21pc2VzLnB1c2gobG9hZGVyLmxvYWQoe1xuICAgICAgICAgICAgc3JjOiBpdGVtVXJsLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpZ25vcmVNdWx0aVBhY2s6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICBzcHJpdGVzaGVldC5saW5rZWRTaGVldHMgPSByZXM7XG4gICAgICAgIHJlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgaXRlbS5saW5rZWRTaGVldHMgPSBbc3ByaXRlc2hlZXRdLmNvbmNhdChzcHJpdGVzaGVldC5saW5rZWRTaGVldHMuZmlsdGVyKChzcCkgPT4gc3AgIT09IGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ByaXRlc2hlZXQ7XG4gICAgfSxcbiAgICBhc3luYyB1bmxvYWQoc3ByaXRlc2hlZXQsIF9yZXNvbHZlZEFzc2V0LCBsb2FkZXIpIHtcbiAgICAgIGF3YWl0IGxvYWRlci51bmxvYWQoc3ByaXRlc2hlZXQudGV4dHVyZVNvdXJjZS5fc291cmNlT3JpZ2luKTtcbiAgICAgIHNwcml0ZXNoZWV0LmRlc3Ryb3koZmFsc2UpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IHsgc3ByaXRlc2hlZXRBc3NldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlc2hlZXRBc3NldC5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBzcHJpdGVzaGVldEFzc2V0IH0gZnJvbSAnLi9zcHJpdGVzaGVldEFzc2V0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoc3ByaXRlc2hlZXRBc3NldCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///342\n')},9366:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  v: () => (/* binding */ Ticker)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(901);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/ticker/TickerListener.mjs\n\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\n\n//# sourceMappingURL=TickerListener.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs\n\n\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = ticker_const/* UPDATE_PRIORITY */.u.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = ticker_const/* UPDATE_PRIORITY */.u.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\n\n//# sourceMappingURL=Ticker.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi90aWNrZXIvVGlja2VyTGlzdGVuZXIubWpzPzgxNzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3RpY2tlci9UaWNrZXIubWpzPzcxNjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBUaWNrZXJMaXN0ZW5lciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXG4gICAqIEBwYXJhbSBvbmNlIC0gSWYgdGhlIGhhbmRsZXIgc2hvdWxkIGZpcmUgb25jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZm4sIGNvbnRleHQgPSBudWxsLCBwcmlvcml0eSA9IDAsIG9uY2UgPSBmYWxzZSkge1xuICAgIC8qKiBUaGUgbmV4dCBpdGVtIGluIGNoYWluLiAqL1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgLyoqIFRoZSBwcmV2aW91cyBpdGVtIGluIGNoYWluLiAqL1xuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgIC8qKiBgdHJ1ZWAgaWYgdGhpcyBsaXN0ZW5lciBoYXMgYmVlbiBkZXN0cm95ZWQgYWxyZWFkeS4gKi9cbiAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9mbiA9IGZuO1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICB0aGlzLl9vbmNlID0gb25jZTtcbiAgfVxuICAvKipcbiAgICogU2ltcGxlIGNvbXBhcmUgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiBhIGZ1bmN0aW9uIGFuZCBjb250ZXh0IG1hdGNoLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGxpc3RlbmVyIG1hdGNoIHRoZSBhcmd1bWVudHNcbiAgICovXG4gIG1hdGNoKGZuLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9mbiA9PT0gZm4gJiYgdGhpcy5fY29udGV4dCA9PT0gY29udGV4dDtcbiAgfVxuICAvKipcbiAgICogRW1pdCBieSBjYWxsaW5nIHRoZSBjdXJyZW50IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gdGlja2VyIC0gVGhlIHRpY2tlciBlbWl0dGluZy5cbiAgICogQHJldHVybnMgTmV4dCB0aWNrZXJcbiAgICovXG4gIGVtaXQodGlja2VyKSB7XG4gICAgaWYgKHRoaXMuX2ZuKSB7XG4gICAgICBpZiAodGhpcy5fY29udGV4dCkge1xuICAgICAgICB0aGlzLl9mbi5jYWxsKHRoaXMuX2NvbnRleHQsIHRpY2tlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mbih0aWNrZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMubmV4dDtcbiAgICBpZiAodGhpcy5fb25jZSkge1xuICAgICAgdGhpcy5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVkaXJlY3Q7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gdGhlIGxpc3QuXG4gICAqIEBwYXJhbSBwcmV2aW91cyAtIElucHV0IG5vZGUsIHByZXZpb3VzIGxpc3RlbmVyXG4gICAqL1xuICBjb25uZWN0KHByZXZpb3VzKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIGlmIChwcmV2aW91cy5uZXh0KSB7XG4gICAgICBwcmV2aW91cy5uZXh0LnByZXZpb3VzID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5uZXh0ID0gcHJldmlvdXMubmV4dDtcbiAgICBwcmV2aW91cy5uZXh0ID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAqIEBwYXJhbSBoYXJkIC0gYHRydWVgIHRvIHJlbW92ZSB0aGUgYG5leHRgIHJlZmVyZW5jZSwgdGhpc1xuICAgKiAgICAgICAgaXMgY29uc2lkZXJlZCBhIGhhcmQgZGVzdHJveS4gU29mdCBkZXN0cm95IG1haW50YWlucyB0aGUgbmV4dCByZWZlcmVuY2UuXG4gICAqIEByZXR1cm5zIFRoZSBsaXN0ZW5lciB0byByZWRpcmVjdCB3aGlsZSBlbWl0dGluZyBvciByZW1vdmluZy5cbiAgICovXG4gIGRlc3Ryb3koaGFyZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgIHRoaXMucHJldmlvdXMubmV4dCA9IHRoaXMubmV4dDtcbiAgICB9XG4gICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgdGhpcy5uZXh0LnByZXZpb3VzID0gdGhpcy5wcmV2aW91cztcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XG4gICAgdGhpcy5uZXh0ID0gaGFyZCA/IG51bGwgOiByZWRpcmVjdDtcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICByZXR1cm4gcmVkaXJlY3Q7XG4gIH1cbn1cblxuZXhwb3J0IHsgVGlja2VyTGlzdGVuZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpY2tlckxpc3RlbmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IFVQREFURV9QUklPUklUWSB9IGZyb20gJy4vY29uc3QubWpzJztcbmltcG9ydCB7IFRpY2tlckxpc3RlbmVyIH0gZnJvbSAnLi9UaWNrZXJMaXN0ZW5lci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9UaWNrZXIgPSBjbGFzcyBfVGlja2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgc2hvdWxkIGludm9rZSB0aGUgbWV0aG9kXG4gICAgICoge0BsaW5rIHRpY2tlci5UaWNrZXIjc3RhcnR8c3RhcnR9IGF1dG9tYXRpY2FsbHkgd2hlbiBhIGxpc3RlbmVyIGlzIGFkZGVkLlxuICAgICAqL1xuICAgIHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2NhbGFyIHRpbWUgdmFsdWUgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBjYXBwZWQgYnkgc2V0dGluZyB7QGxpbmsgdGlja2VyLlRpY2tlciNtaW5GUFN8bWluRlBTfVxuICAgICAqIGFuZCBpcyBzY2FsZWQgd2l0aCB7QGxpbmsgdGlja2VyLlRpY2tlciNzcGVlZHxzcGVlZH0uXG4gICAgICogKipOb3RlOioqIFRoZSBjYXAgbWF5IGJlIGV4Y2VlZGVkIGJ5IHNjYWxpbmcuXG4gICAgICovXG4gICAgdGhpcy5kZWx0YVRpbWUgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IHRpbWUge0BsaW5rIHRpY2tlci5UaWNrZXIjdXBkYXRlfHVwZGF0ZX0gd2FzIGludm9rZWQuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBhbHNvIHJlc2V0IGludGVybmFsbHkgb3V0c2lkZSBvZiBpbnZva2luZ1xuICAgICAqIHVwZGF0ZSwgYnV0IG9ubHkgd2hlbiBhIG5ldyBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkLlxuICAgICAqIElmIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyBET01IaWdoUmVzVGltZVN0YW1wLFxuICAgICAqIHRoaXMgdmFsdWUgd2lsbCBoYXZlIGEgcHJlY2lzaW9uIG9mIDEgwrVzLlxuICAgICAqL1xuICAgIHRoaXMubGFzdFRpbWUgPSAtMTtcbiAgICAvKipcbiAgICAgKiBGYWN0b3Igb2YgY3VycmVudCB7QGxpbmsgdGlja2VyLlRpY2tlciNkZWx0YVRpbWV8ZGVsdGFUaW1lfS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNjYWxlcyB0aWNrZXIuZGVsdGFUaW1lIHRvIHdoYXQgd291bGQgYmVcbiAgICAgKiAvLyB0aGUgZXF1aXZhbGVudCBvZiBhcHByb3hpbWF0ZWx5IDEyMCBGUFNcbiAgICAgKiB0aWNrZXIuc3BlZWQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgdGlja2VyIGhhcyBiZWVuIHN0YXJ0ZWQuXG4gICAgICogYHRydWVgIGlmIHtAbGluayB0aWNrZXIuVGlja2VyI3N0YXJ0fHN0YXJ0fSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICogYGZhbHNlYCBpZiB7QGxpbmsgdGlja2VyLlRpY2tlciNzdG9wfFN0b3B9IGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKiBXaGlsZSBgZmFsc2VgLCB0aGlzIHZhbHVlIG1heSBjaGFuZ2UgdG8gYHRydWVgIGluIHRoZVxuICAgICAqIGV2ZW50IG9mIHtAbGluayB0aWNrZXIuVGlja2VyI2F1dG9TdGFydHxhdXRvU3RhcnR9IGJlaW5nIGB0cnVlYFxuICAgICAqIGFuZCBhIGxpc3RlbmVyIGlzIGFkZGVkLlxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIC8qKiBJbnRlcm5hbCBjdXJyZW50IGZyYW1lIHJlcXVlc3QgSUQgKi9cbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIHZhbHVlIG1hbmFnZWQgYnkgbWluRlBTIHByb3BlcnR5IHNldHRlciBhbmQgZ2V0dGVyLlxuICAgICAqIFRoaXMgaXMgdGhlIG1heGltdW0gYWxsb3dlZCBtaWxsaXNlY29uZHMgYmV0d2VlbiB1cGRhdGVzLlxuICAgICAqL1xuICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEwMDtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1pbkZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cbiAgICAgKiBUaGlzIGlzIHRoZSBtaW5pbXVtIGFsbG93ZWQgbWlsbGlzZWNvbmRzIGJldHdlZW4gdXBkYXRlcy5cbiAgICAgKi9cbiAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgIC8qKiBJZiBlbmFibGVkLCBkZWxldGluZyBpcyBkaXNhYmxlZC4qL1xuICAgIHRoaXMuX3Byb3RlY3RlZCA9IGZhbHNlO1xuICAgIC8qKiBUaGUgbGFzdCB0aW1lIGtleWZyYW1lIHdhcyBleGVjdXRlZC4gTWFpbnRhaW5zIGEgcmVsYXRpdmVseSBmaXhlZCBpbnRlcnZhbCB3aXRoIHRoZSBwcmV2aW91cyB2YWx1ZS4gKi9cbiAgICB0aGlzLl9sYXN0RnJhbWUgPSAtMTtcbiAgICB0aGlzLl9oZWFkID0gbmV3IFRpY2tlckxpc3RlbmVyKG51bGwsIG51bGwsIEluZmluaXR5KTtcbiAgICB0aGlzLmRlbHRhTVMgPSAxIC8gX1RpY2tlci50YXJnZXRGUE1TO1xuICAgIHRoaXMuZWxhcHNlZE1TID0gMSAvIF9UaWNrZXIudGFyZ2V0RlBNUztcbiAgICB0aGlzLl90aWNrID0gKHRpbWUpID0+IHtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHRpbWUpO1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkICYmIHRoaXMuX3JlcXVlc3RJZCA9PT0gbnVsbCAmJiB0aGlzLl9oZWFkLm5leHQpIHtcbiAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZS5cbiAgICogSWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHkgYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWxcbiAgICogZW1pdHRlciBoYXMgbGlzdGVuZXJzLCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVxdWVzdElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICB0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLl9sYXN0RnJhbWUgPSB0aGlzLmxhc3RUaW1lO1xuICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSBjYW5jZWxzIGEgcGVuZGluZyBhbmltYXRpb24gZnJhbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FuY2VsSWZOZWVkZWQoKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdElkKTtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZS5cbiAgICogSWYgdGhlIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkIGl0IGNoZWNrcyBpZiBhIGZyYW1lIGhhcyBub3QgYWxyZWFkeVxuICAgKiBiZWVuIHJlcXVlc3RlZCwgYW5kIGlmIHRoZSBpbnRlcm5hbCBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMuIElmIHRoZXNlXG4gICAqIGNvbmRpdGlvbnMgYXJlIG1ldCwgYSBuZXcgZnJhbWUgaXMgcmVxdWVzdGVkLiBJZiB0aGUgdGlja2VyIGhhcyBub3RcbiAgICogYmVlbiBzdGFydGVkLCBidXQgYXV0b1N0YXJ0IGlzIGB0cnVlYCwgdGhlbiB0aGUgdGlja2VyIHN0YXJ0cyBub3csXG4gICAqIGFuZCBjb250aW51ZXMgd2l0aCB0aGUgcHJldmlvdXMgY29uZGl0aW9ucyB0byByZXF1ZXN0IGEgbmV3IGZyYW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0YXJ0SWZQb3NzaWJsZSgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b1N0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIHRpY2sgZXZlbnRzLiBDYWxscyBjb250aW51b3VzbHkgdW5sZXNzXG4gICAqIGl0IGlzIHJlbW92ZWQgb3IgdGhlIHRpY2tlciBpcyBzdG9wcGVkLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIHVwZGF0ZXNcbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PVVQREFURV9QUklPUklUWS5OT1JNQUxdIC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgKiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXG4gICAqL1xuICBhZGQoZm4sIGNvbnRleHQsIHByaW9yaXR5ID0gVVBEQVRFX1BSSU9SSVRZLk5PUk1BTCkge1xuICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcihuZXcgVGlja2VyTGlzdGVuZXIoZm4sIGNvbnRleHQsIHByaW9yaXR5KSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgZm9yIHRoZSB0aWNrIGV2ZW50IHdoaWNoIGlzIG9ubHkgZXhlY3V0ZSBvbmNlLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PVVQREFURV9QUklPUklUWS5OT1JNQUxdIC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgKiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXG4gICAqL1xuICBhZGRPbmNlKGZuLCBjb250ZXh0LCBwcmlvcml0eSA9IFVQREFURV9QUklPUklUWS5OT1JNQUwpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSwgdHJ1ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbGx5IGFkZHMgdGhlIGV2ZW50IGhhbmRsZXIgc28gdGhhdCBpdCBjYW4gYmUgc29ydGVkIGJ5IHByaW9yaXR5LlxuICAgKiBQcmlvcml0eSBhbGxvd3MgY2VydGFpbiBoYW5kbGVyICh1c2VyLCBBbmltYXRlZFNwcml0ZSwgSW50ZXJhY3Rpb24pIHRvIGJlIHJ1blxuICAgKiBiZWZvcmUgdGhlIHJlbmRlcmluZy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ3VycmVudCBsaXN0ZW5lciBiZWluZyBhZGRlZC5cbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgX2FkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgbGV0IHByZXZpb3VzID0gdGhpcy5faGVhZDtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBpZiAobGlzdGVuZXIucHJpb3JpdHkgPiBjdXJyZW50LnByaW9yaXR5KSB7XG4gICAgICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKCFsaXN0ZW5lci5wcmV2aW91cykge1xuICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc3RhcnRJZlBvc3NpYmxlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW55IGhhbmRsZXJzIG1hdGNoaW5nIHRoZSBmdW5jdGlvbiBhbmQgY29udGV4dCBwYXJhbWV0ZXJzLlxuICAgKiBJZiBubyBoYW5kbGVycyBhcmUgbGVmdCBhZnRlciByZW1vdmluZywgdGhlbiBpdCBjYW5jZWxzIHRoZSBhbmltYXRpb24gZnJhbWUuXG4gICAqIEBwYXJhbSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSByZW1vdmVkXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHQgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXG4gICAqL1xuICByZW1vdmUoZm4sIGNvbnRleHQpIHtcbiAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICBpZiAobGlzdGVuZXIubWF0Y2goZm4sIGNvbnRleHQpKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIG9uIHRoaXMgdGlja2VyLCBjYWxjdWxhdGVkIGJ5IHdhbGtpbmcgdGhyb3VnaCBsaW5rZWQgbGlzdFxuICAgKiBAcmVhZG9ubHlcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvdW50KCkge1xuICAgIGlmICghdGhpcy5faGVhZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5uZXh0KSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgLyoqIFN0YXJ0cyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyBsaXN0ZW5lcnMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZCBhdCB0aGlzIHBvaW50LiAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZk5lZWRlZCgpO1xuICAgIH1cbiAgfVxuICAvKiogU3RvcHMgdGhlIHRpY2tlci4gSWYgdGhlIHRpY2tlciBoYXMgcmVxdWVzdGVkIGFuIGFuaW1hdGlvbiBmcmFtZSBpdCBpcyBjYW5jZWxlZCBhdCB0aGlzIHBvaW50LiAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqIERlc3Ryb3kgdGhlIHRpY2tlciBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuIENhbGxpbmcgdGhpcyBtZXRob2QgcmVtb3ZlcyBhbGwgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBldmVudHMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLl9wcm90ZWN0ZWQpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZGVzdHJveSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hlYWQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhbiB1cGRhdGUuIEFuIHVwZGF0ZSBlbnRhaWxzIHNldHRpbmcgdGhlXG4gICAqIGN1cnJlbnQge0BsaW5rIHRpY2tlci5UaWNrZXIjZWxhcHNlZE1TfGVsYXBzZWRNU30sXG4gICAqIHRoZSBjdXJyZW50IHtAbGluayB0aWNrZXIuVGlja2VyI2RlbHRhVGltZXxkZWx0YVRpbWV9LFxuICAgKiBpbnZva2luZyBhbGwgbGlzdGVuZXJzIHdpdGggY3VycmVudCBkZWx0YVRpbWUsXG4gICAqIGFuZCB0aGVuIGZpbmFsbHkgc2V0dGluZyB7QGxpbmsgdGlja2VyLlRpY2tlciNsYXN0VGltZXxsYXN0VGltZX1cbiAgICogd2l0aCB0aGUgdmFsdWUgb2YgY3VycmVudFRpbWUgdGhhdCB3YXMgcHJvdmlkZWQuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXG4gICAqIGZyYW1lIGNhbGxiYWNrcyBpZiB0aGUgdGlja2VyIGluc3RhbmNlIGhhcyBiZWVuIHN0YXJ0ZWRcbiAgICogYW5kIGxpc3RlbmVycyBhcmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VycmVudFRpbWU9cGVyZm9ybWFuY2Uubm93KCldIC0gdGhlIGN1cnJlbnQgdGltZSBvZiBleGVjdXRpb25cbiAgICovXG4gIHVwZGF0ZShjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpKSB7XG4gICAgbGV0IGVsYXBzZWRNUztcbiAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RUaW1lKSB7XG4gICAgICBlbGFwc2VkTVMgPSB0aGlzLmVsYXBzZWRNUyA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgIGlmIChlbGFwc2VkTVMgPiB0aGlzLl9tYXhFbGFwc2VkTVMpIHtcbiAgICAgICAgZWxhcHNlZE1TID0gdGhpcy5fbWF4RWxhcHNlZE1TO1xuICAgICAgfVxuICAgICAgZWxhcHNlZE1TICo9IHRoaXMuc3BlZWQ7XG4gICAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gY3VycmVudFRpbWUgLSB0aGlzLl9sYXN0RnJhbWUgfCAwO1xuICAgICAgICBpZiAoZGVsdGEgPCB0aGlzLl9taW5FbGFwc2VkTVMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gY3VycmVudFRpbWUgLSBkZWx0YSAlIHRoaXMuX21pbkVsYXBzZWRNUztcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVsdGFNUyA9IGVsYXBzZWRNUztcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TICogX1RpY2tlci50YXJnZXRGUE1TO1xuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBsZXQgbGlzdGVuZXIgPSBoZWFkLm5leHQ7XG4gICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5lbWl0KHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFoZWFkLm5leHQpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLmRlbHRhTVMgPSB0aGlzLmVsYXBzZWRNUyA9IDA7XG4gICAgfVxuICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZyYW1lcyBwZXIgc2Vjb25kIGF0IHdoaWNoIHRoaXMgdGlja2VyIGlzIHJ1bm5pbmcuXG4gICAqIFRoZSBkZWZhdWx0IGlzIGFwcHJveGltYXRlbHkgNjAgaW4gbW9zdCBtb2Rlcm4gYnJvd3NlcnMuXG4gICAqICoqTm90ZToqKiBUaGlzIGRvZXMgbm90IGZhY3RvciBpbiB0aGUgdmFsdWUgb2ZcbiAgICoge0BsaW5rIHRpY2tlci5UaWNrZXIjc3BlZWR8c3BlZWR9LCB3aGljaCBpcyBzcGVjaWZpY1xuICAgKiB0byBzY2FsaW5nIHtAbGluayB0aWNrZXIuVGlja2VyI2RlbHRhVGltZXxkZWx0YVRpbWV9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IEZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5lbGFwc2VkTVM7XG4gIH1cbiAgLyoqXG4gICAqIE1hbmFnZXMgdGhlIG1heGltdW0gYW1vdW50IG9mIG1pbGxpc2Vjb25kcyBhbGxvd2VkIHRvXG4gICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayB0aWNrZXIuVGlja2VyI3VwZGF0ZXx1cGRhdGV9LlxuICAgKiBUaGlzIHZhbHVlIGlzIHVzZWQgdG8gY2FwIHtAbGluayB0aWNrZXIuVGlja2VyI2RlbHRhVGltZXxkZWx0YVRpbWV9LFxuICAgKiBidXQgZG9lcyBub3QgZWZmZWN0IHRoZSBtZWFzdXJlZCB2YWx1ZSBvZiB7QGxpbmsgdGlja2VyLlRpY2tlciNGUFN8RlBTfS5cbiAgICogV2hlbiBzZXR0aW5nIHRoaXMgcHJvcGVydHkgaXQgaXMgY2xhbXBlZCB0byBhIHZhbHVlIGJldHdlZW5cbiAgICogYDBgIGFuZCBgVGlja2VyLnRhcmdldEZQTVMgKiAxMDAwYC5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMFxuICAgKi9cbiAgZ2V0IG1pbkZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5fbWF4RWxhcHNlZE1TO1xuICB9XG4gIHNldCBtaW5GUFMoZnBzKSB7XG4gICAgY29uc3QgbWluRlBTID0gTWF0aC5taW4odGhpcy5tYXhGUFMsIGZwcyk7XG4gICAgY29uc3QgbWluRlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDAsIG1pbkZQUykgLyAxZTMsIF9UaWNrZXIudGFyZ2V0RlBNUyk7XG4gICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMSAvIG1pbkZQTVM7XG4gIH1cbiAgLyoqXG4gICAqIE1hbmFnZXMgdGhlIG1pbmltdW0gYW1vdW50IG9mIG1pbGxpc2Vjb25kcyByZXF1aXJlZCB0b1xuICAgKiBlbGFwc2UgYmV0d2VlbiBpbnZva2luZyB7QGxpbmsgdGlja2VyLlRpY2tlciN1cGRhdGV8dXBkYXRlfS5cbiAgICogVGhpcyB3aWxsIGVmZmVjdCB0aGUgbWVhc3VyZWQgdmFsdWUgb2Yge0BsaW5rIHRpY2tlci5UaWNrZXIjRlBTfEZQU30uXG4gICAqIElmIGl0IGlzIHNldCB0byBgMGAsIHRoZW4gdGhlcmUgaXMgbm8gbGltaXQ7IFBpeGlKUyB3aWxsIHJlbmRlciBhcyBtYW55IGZyYW1lcyBhcyBpdCBjYW4uXG4gICAqIE90aGVyd2lzZSBpdCB3aWxsIGJlIGF0IGxlYXN0IGBtaW5GUFNgXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IG1heEZQUygpIHtcbiAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgxZTMgLyB0aGlzLl9taW5FbGFwc2VkTVMpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBzZXQgbWF4RlBTKGZwcykge1xuICAgIGlmIChmcHMgPT09IDApIHtcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heEZQUyA9IE1hdGgubWF4KHRoaXMubWluRlBTLCBmcHMpO1xuICAgICAgdGhpcy5fbWluRWxhcHNlZE1TID0gMSAvIChtYXhGUFMgLyAxZTMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIHNoYXJlZCB0aWNrZXIgaW5zdGFuY2UgdXNlZCBieSB7QGxpbmsgQW5pbWF0ZWRTcHJpdGV9IGFuZCBieVxuICAgKiB7QGxpbmsgVmlkZW9SZXNvdXJjZX0gdG8gdXBkYXRlIGFuaW1hdGlvbiBmcmFtZXMgLyB2aWRlbyB0ZXh0dXJlcy5cbiAgICpcbiAgICogSXQgbWF5IGFsc28gYmUgdXNlZCBieSB7QGxpbmsgQXBwbGljYXRpb259IGlmIGNyZWF0ZWQgd2l0aCB0aGUgYHNoYXJlZFRpY2tlcmAgb3B0aW9uIHByb3BlcnR5IHNldCB0byB0cnVlLlxuICAgKlxuICAgKiBUaGUgcHJvcGVydHkge0BsaW5rIHRpY2tlci5UaWNrZXIjYXV0b1N0YXJ0fGF1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogUGxlYXNlIGZvbGxvdyB0aGUgZXhhbXBsZXMgZm9yIHVzYWdlLCBpbmNsdWRpbmcgaG93IHRvIG9wdC1vdXQgb2YgYXV0by1zdGFydGluZyB0aGUgc2hhcmVkIHRpY2tlci5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgVGlja2VyIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IHRpY2tlciA9IFRpY2tlci5zaGFyZWQ7XG4gICAqIC8vIFNldCB0aGlzIHRvIHByZXZlbnQgc3RhcnRpbmcgdGhpcyB0aWNrZXIgd2hlbiBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxuICAgKiAvLyBCeSBkZWZhdWx0IHRoaXMgaXMgdHJ1ZSBvbmx5IGZvciB0aGUgVGlja2VyLnNoYXJlZCBpbnN0YW5jZS5cbiAgICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgKlxuICAgKiAvLyBGWUksIGNhbGwgdGhpcyB0byBlbnN1cmUgdGhlIHRpY2tlciBpcyBzdG9wcGVkLiBJdCBzaG91bGQgYmUgc3RvcHBlZFxuICAgKiAvLyBpZiB5b3UgaGF2ZSBub3QgYXR0ZW1wdGVkIHRvIHJlbmRlciBhbnl0aGluZyB5ZXQuXG4gICAqIHRpY2tlci5zdG9wKCk7XG4gICAqXG4gICAqIC8vIENhbGwgdGhpcyB3aGVuIHlvdSBhcmUgcmVhZHkgZm9yIGEgcnVubmluZyBzaGFyZWQgdGlja2VyLlxuICAgKiB0aWNrZXIuc3RhcnQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgYXV0b0RldGVjdFJlbmRlcmVyLCBDb250YWluZXIgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogLy8gWW91IG1heSB1c2UgdGhlIHNoYXJlZCB0aWNrZXIgdG8gcmVuZGVyLi4uXG4gICAqIGNvbnN0IHJlbmRlcmVyID0gYXV0b0RldGVjdFJlbmRlcmVyKCk7XG4gICAqIGNvbnN0IHN0YWdlID0gbmV3IENvbnRhaW5lcigpO1xuICAgKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlbmRlcmVyLnZpZXcpO1xuICAgKiB0aWNrZXIuYWRkKCh0aW1lKSA9PiByZW5kZXJlci5yZW5kZXIoc3RhZ2UpKTtcbiAgICpcbiAgICogLy8gT3IgeW91IGNhbiBqdXN0IHVwZGF0ZSBpdCBtYW51YWxseS5cbiAgICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgKiB0aWNrZXIuc3RvcCgpO1xuICAgKiBjb25zdCBhbmltYXRlID0gKHRpbWUpID0+IHtcbiAgICogICAgIHRpY2tlci51cGRhdGUodGltZSk7XG4gICAqICAgICByZW5kZXJlci5yZW5kZXIoc3RhZ2UpO1xuICAgKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgKiB9O1xuICAgKiBhbmltYXRlKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICogQG1lbWJlciB7dGlja2VyLlRpY2tlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2hhcmVkKCkge1xuICAgIGlmICghX1RpY2tlci5fc2hhcmVkKSB7XG4gICAgICBjb25zdCBzaGFyZWQgPSBfVGlja2VyLl9zaGFyZWQgPSBuZXcgX1RpY2tlcigpO1xuICAgICAgc2hhcmVkLmF1dG9TdGFydCA9IHRydWU7XG4gICAgICBzaGFyZWQuX3Byb3RlY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBfVGlja2VyLl9zaGFyZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIEJhc2VQcmVwYXJlfSBmb3IgY29yZSB0aW1pbmdcbiAgICogZnVuY3Rpb25hbGl0eSB0aGF0IHNob3VsZG4ndCB1c3VhbGx5IG5lZWQgdG8gYmUgcGF1c2VkLCB1bmxpa2UgdGhlIGBzaGFyZWRgXG4gICAqIHRpY2tlciB3aGljaCBkcml2ZXMgdmlzdWFsIGFuaW1hdGlvbnMgYW5kIHJlbmRlcmluZyB3aGljaCBtYXkgd2FudCB0byBiZSBwYXVzZWQuXG4gICAqXG4gICAqIFRoZSBwcm9wZXJ0eSB7QGxpbmsgdGlja2VyLlRpY2tlciNhdXRvU3RhcnR8YXV0b1N0YXJ0fSBpcyBzZXQgdG8gYHRydWVgIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAbWVtYmVyIHt0aWNrZXIuVGlja2VyfVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGdldCBzeXN0ZW0oKSB7XG4gICAgaWYgKCFfVGlja2VyLl9zeXN0ZW0pIHtcbiAgICAgIGNvbnN0IHN5c3RlbSA9IF9UaWNrZXIuX3N5c3RlbSA9IG5ldyBfVGlja2VyKCk7XG4gICAgICBzeXN0ZW0uYXV0b1N0YXJ0ID0gdHJ1ZTtcbiAgICAgIHN5c3RlbS5fcHJvdGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIF9UaWNrZXIuX3N5c3RlbTtcbiAgfVxufTtcbi8qKlxuICogVGFyZ2V0IGZyYW1lcyBwZXIgbWlsbGlzZWNvbmQuXG4gKiBAc3RhdGljXG4gKi9cbl9UaWNrZXIudGFyZ2V0RlBNUyA9IDAuMDY7XG5sZXQgVGlja2VyID0gX1RpY2tlcjtcblxuZXhwb3J0IHsgVGlja2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9366\n")},901:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u: () => (/* binding */ UPDATE_PRIORITY)\n/* harmony export */ });\n\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxLmpzIiwibWFwcGluZ3MiOiI7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qjs7QUFFRztBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi90aWNrZXIvY29uc3QubWpzPzU2ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVVBEQVRFX1BSSU9SSVRZID0gLyogQF9fUFVSRV9fICovICgoVVBEQVRFX1BSSU9SSVRZMikgPT4ge1xuICBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTJbXCJJTlRFUkFDVElPTlwiXSA9IDUwXSA9IFwiSU5URVJBQ1RJT05cIjtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiSElHSFwiXSA9IDI1XSA9IFwiSElHSFwiO1xuICBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTJbXCJOT1JNQUxcIl0gPSAwXSA9IFwiTk9STUFMXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIkxPV1wiXSA9IC0yNV0gPSBcIkxPV1wiO1xuICBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTJbXCJVVElMSVRZXCJdID0gLTUwXSA9IFwiVVRJTElUWVwiO1xuICByZXR1cm4gVVBEQVRFX1BSSU9SSVRZMjtcbn0pKFVQREFURV9QUklPUklUWSB8fCB7fSk7XG5cbmV4cG9ydCB7IFVQREFURV9QUklPUklUWSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///901\n')},1013:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   O: () => (/* binding */ unsafeEvalSupported)\n/* harmony export */ });\n\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === "boolean") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");\n    unsafeEval = func({ a: "b" }, "a", "b") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\n\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxMy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5Rix3QkFBd0IsUUFBUTtBQUNoQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2Jyb3dzZXIvdW5zYWZlRXZhbFN1cHBvcnRlZC5tanM/YzAwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmxldCB1bnNhZmVFdmFsO1xuZnVuY3Rpb24gdW5zYWZlRXZhbFN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiB1bnNhZmVFdmFsID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB1bnNhZmVFdmFsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZnVuYyA9IG5ldyBGdW5jdGlvbihcInBhcmFtMVwiLCBcInBhcmFtMlwiLCBcInBhcmFtM1wiLCBcInJldHVybiBwYXJhbTFbcGFyYW0yXSA9PT0gcGFyYW0zO1wiKTtcbiAgICB1bnNhZmVFdmFsID0gZnVuYyh7IGE6IFwiYlwiIH0sIFwiYVwiLCBcImJcIikgPT09IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1bnNhZmVFdmFsID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZUV2YWw7XG59XG5cbmV4cG9ydCB7IHVuc2FmZUV2YWxTdXBwb3J0ZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuc2FmZUV2YWxTdXBwb3J0ZWQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1013\n')},7040:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ removeItems)\n/* harmony export */ });\n\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\n\n//# sourceMappingURL=removeItems.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA0MC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvZGF0YS9yZW1vdmVJdGVtcy5tanM/NmVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHJlbW92ZUl0ZW1zKGFyciwgc3RhcnRJZHgsIHJlbW92ZUNvdW50KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIGxldCBpO1xuICBpZiAoc3RhcnRJZHggPj0gbGVuZ3RoIHx8IHJlbW92ZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlbW92ZUNvdW50ID0gc3RhcnRJZHggKyByZW1vdmVDb3VudCA+IGxlbmd0aCA/IGxlbmd0aCAtIHN0YXJ0SWR4IDogcmVtb3ZlQ291bnQ7XG4gIGNvbnN0IGxlbiA9IGxlbmd0aCAtIHJlbW92ZUNvdW50O1xuICBmb3IgKGkgPSBzdGFydElkeDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXJyW2ldID0gYXJyW2kgKyByZW1vdmVDb3VudF07XG4gIH1cbiAgYXJyLmxlbmd0aCA9IGxlbjtcbn1cblxuZXhwb3J0IHsgcmVtb3ZlSXRlbXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZUl0ZW1zLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7040\n")},6258:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ uid)\n/* harmony export */ });\n/* unused harmony export resetUids */\n\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = "default") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\n\n//# sourceMappingURL=uid.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI1OC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9kYXRhL3VpZC5tanM/NDA1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHVpZENhY2hlID0ge1xuICBkZWZhdWx0OiAtMVxufTtcbmZ1bmN0aW9uIHVpZChuYW1lID0gXCJkZWZhdWx0XCIpIHtcbiAgaWYgKHVpZENhY2hlW25hbWVdID09PSB2b2lkIDApIHtcbiAgICB1aWRDYWNoZVtuYW1lXSA9IC0xO1xuICB9XG4gIHJldHVybiArK3VpZENhY2hlW25hbWVdO1xufVxuZnVuY3Rpb24gcmVzZXRVaWRzKCkge1xuICBmb3IgKGNvbnN0IGtleSBpbiB1aWRDYWNoZSkge1xuICAgIGRlbGV0ZSB1aWRDYWNoZVtrZXldO1xuICB9XG59XG5cbmV4cG9ydCB7IHJlc2V0VWlkcywgdWlkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aWQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6258\n')},3747:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ updateQuadBounds)\n/* harmony export */ });\n\nfunction updateQuadBounds(bounds, anchor, texture, padding) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width - padding;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height - padding;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n  return;\n}\n\n\n//# sourceMappingURL=updateQuadBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvZGF0YS91cGRhdGVRdWFkQm91bmRzLm1qcz84NmI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdXBkYXRlUXVhZEJvdW5kcyhib3VuZHMsIGFuY2hvciwgdGV4dHVyZSwgcGFkZGluZykge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRleHR1cmUub3JpZztcbiAgY29uc3QgdHJpbSA9IHRleHR1cmUudHJpbTtcbiAgaWYgKHRyaW0pIHtcbiAgICBjb25zdCBzb3VyY2VXaWR0aCA9IHRyaW0ud2lkdGg7XG4gICAgY29uc3Qgc291cmNlSGVpZ2h0ID0gdHJpbS5oZWlnaHQ7XG4gICAgYm91bmRzLm1pblggPSB0cmltLnggLSBhbmNob3IuX3ggKiB3aWR0aCAtIHBhZGRpbmc7XG4gICAgYm91bmRzLm1heFggPSBib3VuZHMubWluWCArIHNvdXJjZVdpZHRoO1xuICAgIGJvdW5kcy5taW5ZID0gdHJpbS55IC0gYW5jaG9yLl95ICogaGVpZ2h0IC0gcGFkZGluZztcbiAgICBib3VuZHMubWF4WSA9IGJvdW5kcy5taW5ZICsgc291cmNlSGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGJvdW5kcy5taW5YID0gLWFuY2hvci5feCAqIHdpZHRoIC0gcGFkZGluZztcbiAgICBib3VuZHMubWF4WCA9IGJvdW5kcy5taW5YICsgd2lkdGg7XG4gICAgYm91bmRzLm1pblkgPSAtYW5jaG9yLl95ICogaGVpZ2h0IC0gcGFkZGluZztcbiAgICBib3VuZHMubWF4WSA9IGJvdW5kcy5taW5ZICsgaGVpZ2h0O1xuICB9XG4gIHJldHVybjtcbn1cblxuZXhwb3J0IHsgdXBkYXRlUXVhZEJvdW5kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlUXVhZEJvdW5kcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3747\n")},6999:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ RendererInitHook),\n/* harmony export */   l: () => (/* binding */ ApplicationInitHook)\n/* harmony export */ });\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3489);\n\n\n"use strict";\nclass ApplicationInitHook {\n  static init() {\n    globalThis.__PIXI_APP_INIT__?.(this);\n  }\n  static destroy() {\n  }\n}\n/** @ignore */\nApplicationInitHook.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ExtensionType */ .nw.Application;\nclass RendererInitHook {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  init() {\n    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRendererInitHook.extension = {\n  type: [\n    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ExtensionType */ .nw.WebGLSystem,\n    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ExtensionType */ .nw.WebGPUSystem\n  ],\n  name: "initHook",\n  priority: -10\n};\n\n\n//# sourceMappingURL=globalHooks.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk5OS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtFQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtFQUFhO0FBQ2pCLElBQUksK0VBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRWlEO0FBQ2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2dsb2JhbC9nbG9iYWxIb29rcy5tanM/ZTFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQXBwbGljYXRpb25Jbml0SG9vayB7XG4gIHN0YXRpYyBpbml0KCkge1xuICAgIGdsb2JhbFRoaXMuX19QSVhJX0FQUF9JTklUX18/Lih0aGlzKTtcbiAgfVxuICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkFwcGxpY2F0aW9uSW5pdEhvb2suZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcbmNsYXNzIFJlbmRlcmVySW5pdEhvb2sge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBnbG9iYWxUaGlzLl9fUElYSV9SRU5ERVJFUl9JTklUX18/Lih0aGlzLl9yZW5kZXJlcik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5SZW5kZXJlckluaXRIb29rLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJpbml0SG9va1wiLFxuICBwcmlvcml0eTogLTEwXG59O1xuXG5leHBvcnQgeyBBcHBsaWNhdGlvbkluaXRIb29rLCBSZW5kZXJlckluaXRIb29rIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxIb29rcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6999\n')},156:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ v8_0_0),\n/* harmony export */   a: () => (/* binding */ deprecation)\n/* harmony export */ });\n\nconst warnings = {};\nconst v8_0_0 = "8.0.0";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === "undefined") {\n    console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split("\\n").splice(ignoreDepth).join("\\n");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        "%cPixiJS Deprecation Warning: %c%s",\n        "color:#614108;background:#fffbe6",\n        "font-weight:normal;color:#614108;background:#fffbe6",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\n\n//# sourceMappingURL=deprecation.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsb0JBQW9CLFFBQVE7QUFDNUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDRCQUE0QixjQUFjO0FBQzFDLFdBQVc7QUFDWCxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0RBQXNEO0FBQ3RELG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzP2IxZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB3YXJuaW5ncyA9IHt9O1xuY29uc3QgdjhfMF8wID0gXCI4LjAuMFwiO1xuZnVuY3Rpb24gZGVwcmVjYXRpb24odmVyc2lvbiwgbWVzc2FnZSwgaWdub3JlRGVwdGggPSAzKSB7XG4gIGlmICh3YXJuaW5nc1ttZXNzYWdlXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUud2FybihcIlBpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiBcIiwgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFjayA9IHN0YWNrLnNwbGl0KFwiXFxuXCIpLnNwbGljZShpZ25vcmVEZXB0aCkuam9pbihcIlxcblwiKTtcbiAgICBpZiAoY29uc29sZS5ncm91cENvbGxhcHNlZCkge1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICAgICAgXCIlY1BpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiAlYyVzXCIsXG4gICAgICAgIFwiY29sb3I6IzYxNDEwODtiYWNrZ3JvdW5kOiNmZmZiZTZcIixcbiAgICAgICAgXCJmb250LXdlaWdodDpub3JtYWw7Y29sb3I6IzYxNDEwODtiYWNrZ3JvdW5kOiNmZmZiZTZcIixcbiAgICAgICAgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gXG4gICAgICApO1xuICAgICAgY29uc29sZS53YXJuKHN0YWNrKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiUGl4aUpTIERlcHJlY2F0aW9uIFdhcm5pbmc6IFwiLCBgJHttZXNzYWdlfVxuRGVwcmVjYXRlZCBzaW5jZSB2JHt2ZXJzaW9ufWApO1xuICAgICAgY29uc29sZS53YXJuKHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgd2FybmluZ3NbbWVzc2FnZV0gPSB0cnVlO1xufVxuXG5leHBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXByZWNhdGlvbi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///156\n')},4796:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (/* binding */ warn)\n/* harmony export */ });\n\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");\n  } else {\n    console.warn("PixiJS Warning: ", ...args);\n  }\n}\n\n\n//# sourceMappingURL=warn.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc5Ni5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9sb2dnaW5nL3dhcm4ubWpzPzk5YzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgd2FybkNvdW50ID0gMDtcbmNvbnN0IG1heFdhcm5pbmdzID0gNTAwO1xuZnVuY3Rpb24gd2FybiguLi5hcmdzKSB7XG4gIGlmICh3YXJuQ291bnQgPT09IG1heFdhcm5pbmdzKVxuICAgIHJldHVybjtcbiAgd2FybkNvdW50Kys7XG4gIGlmICh3YXJuQ291bnQgPT09IG1heFdhcm5pbmdzKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGl4aUpTIFdhcm5pbmc6IHRvbyBtYW55IHdhcm5pbmdzLCBubyBtb3JlIHdhcm5pbmdzIHdpbGwgYmUgcmVwb3J0ZWQgdG8gdGhlIGNvbnNvbGUgYnkgUGl4aUpTLlwiKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgV2FybmluZzogXCIsIC4uLmFyZ3MpO1xuICB9XG59XG5cbmV4cG9ydCB7IHdhcm4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4796\n')},5374:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   K: () => (/* binding */ Pool)\n/* harmony export */ });\n\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n  /** clears the pool - mainly used for debugging! */\n  clear() {\n    this._pool.length = 0;\n    this._index = 0;\n  }\n}\n\n\n//# sourceMappingURL=Pool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM3NC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL3Bvb2wvUG9vbC5tanM/MGE1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIFBvb2wge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBQb29sLlxuICAgKiBAcGFyYW0gQ2xhc3NUeXBlIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBpdGVtcyBpbiB0aGUgcG9vbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbml0aWFsU2l6ZV0gLSBUaGUgaW5pdGlhbCBzaXplIG9mIHRoZSBwb29sLlxuICAgKi9cbiAgY29uc3RydWN0b3IoQ2xhc3NUeXBlLCBpbml0aWFsU2l6ZSkge1xuICAgIHRoaXMuX3Bvb2wgPSBbXTtcbiAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgdGhpcy5faW5kZXggPSAwO1xuICAgIHRoaXMuX2NsYXNzVHlwZSA9IENsYXNzVHlwZTtcbiAgICBpZiAoaW5pdGlhbFNpemUpIHtcbiAgICAgIHRoaXMucHJlcG9wdWxhdGUoaW5pdGlhbFNpemUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUHJlcG9wdWxhdGVzIHRoZSBwb29sIHdpdGggYSBnaXZlbiBudW1iZXIgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSB0b3RhbCAtIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYWRkIHRvIHRoZSBwb29sLlxuICAgKi9cbiAgcHJlcG9wdWxhdGUodG90YWwpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIHRoaXMuX3Bvb2xbdGhpcy5faW5kZXgrK10gPSBuZXcgdGhpcy5fY2xhc3NUeXBlKCk7XG4gICAgfVxuICAgIHRoaXMuX2NvdW50ICs9IHRvdGFsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFuIGl0ZW0gZnJvbSB0aGUgcG9vbC4gQ2FsbHMgdGhlIGl0ZW0ncyBgaW5pdGAgbWV0aG9kIGlmIGl0IGV4aXN0cy5cbiAgICogSWYgdGhlcmUgYXJlIG5vIGl0ZW1zIGxlZnQgaW4gdGhlIHBvb2wsIGEgbmV3IG9uZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gW2RhdGFdIC0gT3B0aW9uYWwgZGF0YSB0byBwYXNzIHRvIHRoZSBpdGVtJ3MgY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm5zIHtUfSBUaGUgaXRlbSBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZ2V0KGRhdGEpIHtcbiAgICBsZXQgaXRlbTtcbiAgICBpZiAodGhpcy5faW5kZXggPiAwKSB7XG4gICAgICBpdGVtID0gdGhpcy5fcG9vbFstLXRoaXMuX2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbSA9IG5ldyB0aGlzLl9jbGFzc1R5cGUoKTtcbiAgICB9XG4gICAgaXRlbS5pbml0Py4oZGF0YSk7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaXRlbSB0byB0aGUgcG9vbC4gQ2FsbHMgdGhlIGl0ZW0ncyBgcmVzZXRgIG1ldGhvZCBpZiBpdCBleGlzdHMuXG4gICAqIEBwYXJhbSB7VH0gaXRlbSAtIFRoZSBpdGVtIHRvIHJldHVybiB0byB0aGUgcG9vbC5cbiAgICovXG4gIHJldHVybihpdGVtKSB7XG4gICAgaXRlbS5yZXNldD8uKCk7XG4gICAgdGhpcy5fcG9vbFt0aGlzLl9pbmRleCsrXSA9IGl0ZW07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgcG9vbC5cbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCB0b3RhbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBvb2wgdGhhdCBhcmUgZnJlZSB0byB1c2Ugd2l0aG91dCBuZWVkaW5nIHRvIGNyZWF0ZSBtb3JlLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRvdGFsRnJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgcG9vbCB0aGF0IGFyZSBjdXJyZW50bHkgaW4gdXNlLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRvdGFsVXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY291bnQgLSB0aGlzLl9pbmRleDtcbiAgfVxuICAvKiogY2xlYXJzIHRoZSBwb29sIC0gbWFpbmx5IHVzZWQgZm9yIGRlYnVnZ2luZyEgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fcG9vbC5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBQb29sIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb29sLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5374\n")},5906:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u: () => (/* binding */ BigPool)\n/* harmony export */ });\n/* unused harmony export PoolGroupClass */\n/* harmony import */ var _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5374);\n\n\n"use strict";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item\'s constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\n\n//# sourceMappingURL=PoolGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkwNi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLFNBQVM7QUFDdEIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9wb29sL1Bvb2xHcm91cC5tanM/YmJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb29sIH0gZnJvbSAnLi9Qb29sLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgUG9vbEdyb3VwQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBBIG1hcCB0byBzdG9yZSB0aGUgcG9vbHMgYnkgdGhlaXIgY2xhc3MgdHlwZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Bvb2xzQnlDbGFzcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBvcHVsYXRlcyBhIHNwZWNpZmljIHBvb2wgd2l0aCBhIGdpdmVuIG51bWJlciBvZiBpdGVtcy5cbiAgICogQHRlbXBsYXRlIFQgVGhlIHR5cGUgb2YgaXRlbXMgaW4gdGhlIHBvb2wuIE11c3QgZXh0ZW5kIFBvb2xJdGVtLlxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtQ29uc3RydWN0b3I8VD59IENsYXNzIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBpdGVtcyBpbiB0aGUgcG9vbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsIC0gVGhlIG51bWJlciBvZiBpdGVtcyB0byBhZGQgdG8gdGhlIHBvb2wuXG4gICAqL1xuICBwcmVwb3B1bGF0ZShDbGFzcywgdG90YWwpIHtcbiAgICBjb25zdCBjbGFzc1Bvb2wgPSB0aGlzLmdldFBvb2woQ2xhc3MpO1xuICAgIGNsYXNzUG9vbC5wcmVwb3B1bGF0ZSh0b3RhbCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYW4gaXRlbSBmcm9tIGEgc3BlY2lmaWMgcG9vbC5cbiAgICogQHRlbXBsYXRlIFQgVGhlIHR5cGUgb2YgaXRlbXMgaW4gdGhlIHBvb2wuIE11c3QgZXh0ZW5kIFBvb2xJdGVtLlxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtQ29uc3RydWN0b3I8VD59IENsYXNzIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBpdGVtcyBpbiB0aGUgcG9vbC5cbiAgICogQHBhcmFtIHt1bmtub3dufSBbZGF0YV0gLSBPcHRpb25hbCBkYXRhIHRvIHBhc3MgdG8gdGhlIGl0ZW0ncyBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybnMge1R9IFRoZSBpdGVtIGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBnZXQoQ2xhc3MsIGRhdGEpIHtcbiAgICBjb25zdCBwb29sID0gdGhpcy5nZXRQb29sKENsYXNzKTtcbiAgICByZXR1cm4gcG9vbC5nZXQoZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaXRlbSB0byBpdHMgcmVzcGVjdGl2ZSBwb29sLlxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtfSBpdGVtIC0gVGhlIGl0ZW0gdG8gcmV0dXJuIHRvIHRoZSBwb29sLlxuICAgKi9cbiAgcmV0dXJuKGl0ZW0pIHtcbiAgICBjb25zdCBwb29sID0gdGhpcy5nZXRQb29sKGl0ZW0uY29uc3RydWN0b3IpO1xuICAgIHBvb2wucmV0dXJuKGl0ZW0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgc3BlY2lmaWMgcG9vbCBiYXNlZCBvbiB0aGUgY2xhc3MgdHlwZS5cbiAgICogQHRlbXBsYXRlIFQgVGhlIHR5cGUgb2YgaXRlbXMgaW4gdGhlIHBvb2wuIE11c3QgZXh0ZW5kIFBvb2xJdGVtLlxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtQ29uc3RydWN0b3I8VD59IENsYXNzVHlwZSAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgaXRlbXMgaW4gdGhlIHBvb2wuXG4gICAqIEByZXR1cm5zIHtQb29sPFQ+fSBUaGUgcG9vbCBvZiB0aGUgZ2l2ZW4gY2xhc3MgdHlwZS5cbiAgICovXG4gIGdldFBvb2woQ2xhc3NUeXBlKSB7XG4gICAgaWYgKCF0aGlzLl9wb29sc0J5Q2xhc3MuaGFzKENsYXNzVHlwZSkpIHtcbiAgICAgIHRoaXMuX3Bvb2xzQnlDbGFzcy5zZXQoQ2xhc3NUeXBlLCBuZXcgUG9vbChDbGFzc1R5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Bvb2xzQnlDbGFzcy5nZXQoQ2xhc3NUeXBlKTtcbiAgfVxuICAvKiogZ2V0cyB0aGUgdXNhZ2Ugc3RhdHMgb2YgZWFjaCBwb29sIGluIHRoZSBzeXN0ZW0gKi9cbiAgc3RhdHMoKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7fTtcbiAgICB0aGlzLl9wb29sc0J5Q2xhc3MuZm9yRWFjaCgocG9vbCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHN0YXRzW3Bvb2wuX2NsYXNzVHlwZS5uYW1lXSA/IHBvb2wuX2NsYXNzVHlwZS5uYW1lICsgcG9vbC5fY2xhc3NUeXBlLklEIDogcG9vbC5fY2xhc3NUeXBlLm5hbWU7XG4gICAgICBzdGF0c1tuYW1lXSA9IHtcbiAgICAgICAgZnJlZTogcG9vbC50b3RhbEZyZWUsXG4gICAgICAgIHVzZWQ6IHBvb2wudG90YWxVc2VkLFxuICAgICAgICBzaXplOiBwb29sLnRvdGFsU2l6ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbn1cbmNvbnN0IEJpZ1Bvb2wgPSBuZXcgUG9vbEdyb3VwQ2xhc3MoKTtcblxuZXhwb3J0IHsgQmlnUG9vbCwgUG9vbEdyb3VwQ2xhc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvb2xHcm91cC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5906\n')},3921:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ sayHello)\n/* harmony export */ });\n/* unused harmony export VERSION */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n\n\n"use strict";\nlet saidHello = false;\nconst VERSION = "8.3.4";\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      "background: #E72264; padding:5px 0;",\n      "background: #6CA2EA; padding:5px 0;",\n      "background: #B5D33D; padding:5px 0;",\n      "background: #FED23F; padding:5px 0;",\n      "color: #FFFFFF; background: #E72264; padding:5px 0;",\n      "color: #E72264; background: #FFFFFF; padding:5px 0;"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\n\n//# sourceMappingURL=sayHello.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkyMS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlFQUFVO0FBQ2hCO0FBQ0EsdUNBQXVDLFNBQVMsR0FBRyxLQUFLOztBQUV4RDtBQUNBLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLHVCQUF1QixxQkFBcUIsY0FBYztBQUMxRCx1QkFBdUIscUJBQXFCLGNBQWM7QUFDMUQ7QUFDQTtBQUNBLElBQUk7QUFDSixxQ0FBcUMsU0FBUyxJQUFJLE1BQU07QUFDeEQ7QUFDQTtBQUNBOztBQUU2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9zYXlIZWxsby5tanM/MTM3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBzYWlkSGVsbG8gPSBmYWxzZTtcbmNvbnN0IFZFUlNJT04gPSBcIjguMy40XCI7XG5mdW5jdGlvbiBzYXlIZWxsbyh0eXBlKSB7XG4gIGlmIChzYWlkSGVsbG8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKERPTUFkYXB0ZXIuZ2V0KCkuZ2V0TmF2aWdhdG9yKCkudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNocm9tZVwiKSA+IC0xKSB7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIGAlYyAgJWMgICVjICAlYyAgJWMgUGl4aUpTICVjIHYke1ZFUlNJT059ICgke3R5cGV9KSBodHRwOi8vd3d3LnBpeGlqcy5jb20vXG5cbmAsXG4gICAgICBcImJhY2tncm91bmQ6ICNFNzIyNjQ7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImJhY2tncm91bmQ6ICM2Q0EyRUE7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImJhY2tncm91bmQ6ICNCNUQzM0Q7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImJhY2tncm91bmQ6ICNGRUQyM0Y7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImNvbG9yOiAjRkZGRkZGOyBiYWNrZ3JvdW5kOiAjRTcyMjY0OyBwYWRkaW5nOjVweCAwO1wiLFxuICAgICAgXCJjb2xvcjogI0U3MjI2NDsgYmFja2dyb3VuZDogI0ZGRkZGRjsgcGFkZGluZzo1cHggMDtcIlxuICAgIF07XG4gICAgZ2xvYmFsVGhpcy5jb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgfSBlbHNlIGlmIChnbG9iYWxUaGlzLmNvbnNvbGUpIHtcbiAgICBnbG9iYWxUaGlzLmNvbnNvbGUubG9nKGBQaXhpSlMgJHtWRVJTSU9OfSAtICR7dHlwZX0gLSBodHRwOi8vd3d3LnBpeGlqcy5jb20vYCk7XG4gIH1cbiAgc2FpZEhlbGxvID0gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgVkVSU0lPTiwgc2F5SGVsbG8gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNheUhlbGxvLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3921\n')},1580:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2218);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU4MC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXFDOztBQUVkO0FBQ3ZCLGlFQUFlLHNDQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzP2UwYmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2luZGV4LmpzJ1xuXG5leHBvcnQgeyBFdmVudEVtaXR0ZXIgfVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1580\n")},1984:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   kX: () => (/* binding */ Tween),\n/* harmony export */   oY: () => (/* binding */ Easing)\n/* harmony export */ });\n/* unused harmony exports Group, Interpolation, Sequence, VERSION, add, default, getAll, nextId, now, remove, removeAll, update */\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\nvar Easing = Object.freeze({\n    Linear: Object.freeze({\n        None: function (amount) {\n            return amount;\n        },\n        In: function (amount) {\n            return amount;\n        },\n        Out: function (amount) {\n            return amount;\n        },\n        InOut: function (amount) {\n            return amount;\n        },\n    }),\n    Quadratic: Object.freeze({\n        In: function (amount) {\n            return amount * amount;\n        },\n        Out: function (amount) {\n            return amount * (2 - amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount;\n            }\n            return -0.5 * (--amount * (amount - 2) - 1);\n        },\n    }),\n    Cubic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount + 2);\n        },\n    }),\n    Quartic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return 1 - --amount * amount * amount * amount;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount;\n            }\n            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n        },\n    }),\n    Quintic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n        },\n    }),\n    Sinusoidal: Object.freeze({\n        In: function (amount) {\n            return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);\n        },\n        Out: function (amount) {\n            return Math.sin((amount * Math.PI) / 2);\n        },\n        InOut: function (amount) {\n            return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));\n        },\n    }),\n    Exponential: Object.freeze({\n        In: function (amount) {\n            return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n        },\n        Out: function (amount) {\n            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            if ((amount *= 2) < 1) {\n                return 0.5 * Math.pow(1024, amount - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n        },\n    }),\n    Circular: Object.freeze({\n        In: function (amount) {\n            return 1 - Math.sqrt(1 - amount * amount);\n        },\n        Out: function (amount) {\n            return Math.sqrt(1 - --amount * amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n        },\n    }),\n    Elastic: Object.freeze({\n        In: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n        },\n        Out: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            amount *= 2;\n            if (amount < 1) {\n                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n            }\n            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n        },\n    }),\n    Back: Object.freeze({\n        In: function (amount) {\n            var s = 1.70158;\n            return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\n        },\n        Out: function (amount) {\n            var s = 1.70158;\n            return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;\n        },\n        InOut: function (amount) {\n            var s = 1.70158 * 1.525;\n            if ((amount *= 2) < 1) {\n                return 0.5 * (amount * amount * ((s + 1) * amount - s));\n            }\n            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n        },\n    }),\n    Bounce: Object.freeze({\n        In: function (amount) {\n            return 1 - Easing.Bounce.Out(1 - amount);\n        },\n        Out: function (amount) {\n            if (amount < 1 / 2.75) {\n                return 7.5625 * amount * amount;\n            }\n            else if (amount < 2 / 2.75) {\n                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n            }\n            else if (amount < 2.5 / 2.75) {\n                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n            }\n            else {\n                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n            }\n        },\n        InOut: function (amount) {\n            if (amount < 0.5) {\n                return Easing.Bounce.In(amount * 2) * 0.5;\n            }\n            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n        },\n    }),\n    generatePow: function (power) {\n        if (power === void 0) { power = 4; }\n        power = power < Number.EPSILON ? Number.EPSILON : power;\n        power = power > 10000 ? 10000 : power;\n        return {\n            In: function (amount) {\n                return Math.pow(amount, power);\n            },\n            Out: function (amount) {\n                return 1 - Math.pow((1 - amount), power);\n            },\n            InOut: function (amount) {\n                if (amount < 0.5) {\n                    return Math.pow((amount * 2), power) / 2;\n                }\n                return (1 - Math.pow((2 - amount * 2), power)) / 2 + 0.5;\n            },\n        };\n    },\n});\n\nvar now = function () { return performance.now(); };\n\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tween\n */\nvar Group = /** @class */ (function () {\n    function Group() {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        this._tweens = {};\n        this._tweensAddedDuringUpdate = {};\n        this.add.apply(this, tweens);\n    }\n    Group.prototype.getAll = function () {\n        var _this = this;\n        return Object.keys(this._tweens).map(function (tweenId) { return _this._tweens[tweenId]; });\n    };\n    Group.prototype.removeAll = function () {\n        this._tweens = {};\n    };\n    Group.prototype.add = function () {\n        var _a;\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        for (var _b = 0, tweens_1 = tweens; _b < tweens_1.length; _b++) {\n            var tween = tweens_1[_b];\n            // Remove from any other group first, a tween can only be in one group at a time.\n            // @ts-expect-error library internal access\n            (_a = tween._group) === null || _a === void 0 ? void 0 : _a.remove(tween);\n            // @ts-expect-error library internal access\n            tween._group = this;\n            this._tweens[tween.getId()] = tween;\n            this._tweensAddedDuringUpdate[tween.getId()] = tween;\n        }\n    };\n    Group.prototype.remove = function () {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        for (var _a = 0, tweens_2 = tweens; _a < tweens_2.length; _a++) {\n            var tween = tweens_2[_a];\n            // @ts-expect-error library internal access\n            tween._group = undefined;\n            delete this._tweens[tween.getId()];\n            delete this._tweensAddedDuringUpdate[tween.getId()];\n        }\n    };\n    /** Return true if all tweens in the group are not paused or playing. */\n    Group.prototype.allStopped = function () {\n        return this.getAll().every(function (tween) { return !tween.isPlaying(); });\n    };\n    Group.prototype.update = function (time, preserve) {\n        if (time === void 0) { time = now(); }\n        if (preserve === void 0) { preserve = true; }\n        var tweenIds = Object.keys(this._tweens);\n        if (tweenIds.length === 0)\n            return;\n        // Tweens are updated in \"batches\". If you add a new tween during an\n        // update, then the new tween will be updated in the next batch.\n        // If you remove a tween during an update, it may or may not be updated.\n        // However, if the removed tween was added during the current batch,\n        // then it will not be updated.\n        while (tweenIds.length > 0) {\n            this._tweensAddedDuringUpdate = {};\n            for (var i = 0; i < tweenIds.length; i++) {\n                var tween = this._tweens[tweenIds[i]];\n                var autoStart = !preserve;\n                if (tween && tween.update(time, autoStart) === false && !preserve)\n                    this.remove(tween);\n            }\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n        }\n    };\n    return Group;\n}());\n\n/**\n *\n */\nvar Interpolation = {\n    Linear: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.Linear;\n        if (k < 0) {\n            return fn(v[0], v[1], f);\n        }\n        if (k > 1) {\n            return fn(v[m], v[m - 1], m - f);\n        }\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n    },\n    Bezier: function (v, k) {\n        var b = 0;\n        var n = v.length - 1;\n        var pw = Math.pow;\n        var bn = Interpolation.Utils.Bernstein;\n        for (var i = 0; i <= n; i++) {\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n        }\n        return b;\n    },\n    CatmullRom: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.CatmullRom;\n        if (v[0] === v[m]) {\n            if (k < 0) {\n                i = Math.floor((f = m * (1 + k)));\n            }\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else {\n            if (k < 0) {\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n            if (k > 1) {\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n    },\n    Utils: {\n        Linear: function (p0, p1, t) {\n            return (p1 - p0) * t + p0;\n        },\n        Bernstein: function (n, i) {\n            var fc = Interpolation.Utils.Factorial;\n            return fc(n) / fc(i) / fc(n - i);\n        },\n        Factorial: (function () {\n            var a = [1];\n            return function (n) {\n                var s = 1;\n                if (a[n]) {\n                    return a[n];\n                }\n                for (var i = n; i > 1; i--) {\n                    s *= i;\n                }\n                a[n] = s;\n                return s;\n            };\n        })(),\n        CatmullRom: function (p0, p1, p2, p3, t) {\n            var v0 = (p2 - p0) * 0.5;\n            var v1 = (p3 - p1) * 0.5;\n            var t2 = t * t;\n            var t3 = t * t2;\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n        },\n    },\n};\n\n/**\n * Utils\n */\nvar Sequence = /** @class */ (function () {\n    function Sequence() {\n    }\n    Sequence.nextId = function () {\n        return Sequence._nextId++;\n    };\n    Sequence._nextId = 0;\n    return Sequence;\n}());\n\nvar mainGroup = new Group();\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar Tween = /** @class */ (function () {\n    function Tween(object, group) {\n        this._isPaused = false;\n        this._pauseStart = 0;\n        this._valuesStart = {};\n        this._valuesEnd = {};\n        this._valuesStartRepeat = {};\n        this._duration = 1000;\n        this._isDynamic = false;\n        this._initialRepeat = 0;\n        this._repeat = 0;\n        this._yoyo = false;\n        this._isPlaying = false;\n        this._reversed = false;\n        this._delayTime = 0;\n        this._startTime = 0;\n        this._easingFunction = Easing.Linear.None;\n        this._interpolationFunction = Interpolation.Linear;\n        // eslint-disable-next-line\n        this._chainedTweens = [];\n        this._onStartCallbackFired = false;\n        this._onEveryStartCallbackFired = false;\n        this._id = Sequence.nextId();\n        this._isChainStopped = false;\n        this._propertiesAreSetUp = false;\n        this._goToEnd = false;\n        this._object = object;\n        if (typeof group === 'object') {\n            this._group = group;\n            group.add(this);\n        }\n        // Use \"true\" to restore old behavior (will be removed in future release).\n        else if (group === true) {\n            this._group = mainGroup;\n            mainGroup.add(this);\n        }\n    }\n    Tween.prototype.getId = function () {\n        return this._id;\n    };\n    Tween.prototype.isPlaying = function () {\n        return this._isPlaying;\n    };\n    Tween.prototype.isPaused = function () {\n        return this._isPaused;\n    };\n    Tween.prototype.getDuration = function () {\n        return this._duration;\n    };\n    Tween.prototype.to = function (target, duration) {\n        if (duration === void 0) { duration = 1000; }\n        if (this._isPlaying)\n            throw new Error('Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.');\n        this._valuesEnd = target;\n        this._propertiesAreSetUp = false;\n        this._duration = duration < 0 ? 0 : duration;\n        return this;\n    };\n    Tween.prototype.duration = function (duration) {\n        if (duration === void 0) { duration = 1000; }\n        this._duration = duration < 0 ? 0 : duration;\n        return this;\n    };\n    Tween.prototype.dynamic = function (dynamic) {\n        if (dynamic === void 0) { dynamic = false; }\n        this._isDynamic = dynamic;\n        return this;\n    };\n    Tween.prototype.start = function (time, overrideStartingValues) {\n        if (time === void 0) { time = now(); }\n        if (overrideStartingValues === void 0) { overrideStartingValues = false; }\n        if (this._isPlaying) {\n            return this;\n        }\n        this._repeat = this._initialRepeat;\n        if (this._reversed) {\n            // If we were reversed (f.e. using the yoyo feature) then we need to\n            // flip the tween direction back to forward.\n            this._reversed = false;\n            for (var property in this._valuesStartRepeat) {\n                this._swapEndStartRepeatValues(property);\n                this._valuesStart[property] = this._valuesStartRepeat[property];\n            }\n        }\n        this._isPlaying = true;\n        this._isPaused = false;\n        this._onStartCallbackFired = false;\n        this._onEveryStartCallbackFired = false;\n        this._isChainStopped = false;\n        this._startTime = time;\n        this._startTime += this._delayTime;\n        if (!this._propertiesAreSetUp || overrideStartingValues) {\n            this._propertiesAreSetUp = true;\n            // If dynamic is not enabled, clone the end values instead of using the passed-in end values.\n            if (!this._isDynamic) {\n                var tmp = {};\n                for (var prop in this._valuesEnd)\n                    tmp[prop] = this._valuesEnd[prop];\n                this._valuesEnd = tmp;\n            }\n            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);\n        }\n        return this;\n    };\n    Tween.prototype.startFromCurrentValues = function (time) {\n        return this.start(time, true);\n    };\n    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {\n        for (var property in _valuesEnd) {\n            var startValue = _object[property];\n            var startValueIsArray = Array.isArray(startValue);\n            var propType = startValueIsArray ? 'array' : typeof startValue;\n            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\n            // If `to()` specifies a property that doesn't exist in the source object,\n            // we should not set that property in the object\n            if (propType === 'undefined' || propType === 'function') {\n                continue;\n            }\n            // Check if an Array was provided as property value\n            if (isInterpolationList) {\n                var endValues = _valuesEnd[property];\n                if (endValues.length === 0) {\n                    continue;\n                }\n                // Handle an array of relative values.\n                // Creates a local copy of the Array with the start value at the front\n                var temp = [startValue];\n                for (var i = 0, l = endValues.length; i < l; i += 1) {\n                    var value = this._handleRelativeValue(startValue, endValues[i]);\n                    if (isNaN(value)) {\n                        isInterpolationList = false;\n                        console.warn('Found invalid interpolation list. Skipping.');\n                        break;\n                    }\n                    temp.push(value);\n                }\n                if (isInterpolationList) {\n                    // if (_valuesStart[property] === undefined) { // handle end values only the first time. NOT NEEDED? setupProperties is now guarded by _propertiesAreSetUp.\n                    _valuesEnd[property] = temp;\n                    // }\n                }\n            }\n            // handle the deepness of the values\n            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {\n                _valuesStart[property] = startValueIsArray ? [] : {};\n                var nestedObject = startValue;\n                for (var prop in nestedObject) {\n                    _valuesStart[property][prop] = nestedObject[prop];\n                }\n                // TODO? repeat nested values? And yoyo? And array values?\n                _valuesStartRepeat[property] = startValueIsArray ? [] : {};\n                var endValues = _valuesEnd[property];\n                // If dynamic is not enabled, clone the end values instead of using the passed-in end values.\n                if (!this._isDynamic) {\n                    var tmp = {};\n                    for (var prop in endValues)\n                        tmp[prop] = endValues[prop];\n                    _valuesEnd[property] = endValues = tmp;\n                }\n                this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);\n            }\n            else {\n                // Save the starting value, but only once unless override is requested.\n                if (typeof _valuesStart[property] === 'undefined' || overrideStartingValues) {\n                    _valuesStart[property] = startValue;\n                }\n                if (!startValueIsArray) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n                }\n                if (isInterpolationList) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\n                }\n                else {\n                    _valuesStartRepeat[property] = _valuesStart[property] || 0;\n                }\n            }\n        }\n    };\n    Tween.prototype.stop = function () {\n        if (!this._isChainStopped) {\n            this._isChainStopped = true;\n            this.stopChainedTweens();\n        }\n        if (!this._isPlaying) {\n            return this;\n        }\n        this._isPlaying = false;\n        this._isPaused = false;\n        if (this._onStopCallback) {\n            this._onStopCallback(this._object);\n        }\n        return this;\n    };\n    Tween.prototype.end = function () {\n        this._goToEnd = true;\n        this.update(this._startTime + this._duration);\n        return this;\n    };\n    Tween.prototype.pause = function (time) {\n        if (time === void 0) { time = now(); }\n        if (this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = true;\n        this._pauseStart = time;\n        return this;\n    };\n    Tween.prototype.resume = function (time) {\n        if (time === void 0) { time = now(); }\n        if (!this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = false;\n        this._startTime += time - this._pauseStart;\n        this._pauseStart = 0;\n        return this;\n    };\n    Tween.prototype.stopChainedTweens = function () {\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n            this._chainedTweens[i].stop();\n        }\n        return this;\n    };\n    Tween.prototype.group = function (group) {\n        if (!group) {\n            console.warn('tween.group() without args has been removed, use group.add(tween) instead.');\n            return this;\n        }\n        group.add(this);\n        return this;\n    };\n    /**\n     * Removes the tween from whichever group it is in.\n     */\n    Tween.prototype.remove = function () {\n        var _a;\n        (_a = this._group) === null || _a === void 0 ? void 0 : _a.remove(this);\n        return this;\n    };\n    Tween.prototype.delay = function (amount) {\n        if (amount === void 0) { amount = 0; }\n        this._delayTime = amount;\n        return this;\n    };\n    Tween.prototype.repeat = function (times) {\n        if (times === void 0) { times = 0; }\n        this._initialRepeat = times;\n        this._repeat = times;\n        return this;\n    };\n    Tween.prototype.repeatDelay = function (amount) {\n        this._repeatDelayTime = amount;\n        return this;\n    };\n    Tween.prototype.yoyo = function (yoyo) {\n        if (yoyo === void 0) { yoyo = false; }\n        this._yoyo = yoyo;\n        return this;\n    };\n    Tween.prototype.easing = function (easingFunction) {\n        if (easingFunction === void 0) { easingFunction = Easing.Linear.None; }\n        this._easingFunction = easingFunction;\n        return this;\n    };\n    Tween.prototype.interpolation = function (interpolationFunction) {\n        if (interpolationFunction === void 0) { interpolationFunction = Interpolation.Linear; }\n        this._interpolationFunction = interpolationFunction;\n        return this;\n    };\n    // eslint-disable-next-line\n    Tween.prototype.chain = function () {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        this._chainedTweens = tweens;\n        return this;\n    };\n    Tween.prototype.onStart = function (callback) {\n        this._onStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onEveryStart = function (callback) {\n        this._onEveryStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onUpdate = function (callback) {\n        this._onUpdateCallback = callback;\n        return this;\n    };\n    Tween.prototype.onRepeat = function (callback) {\n        this._onRepeatCallback = callback;\n        return this;\n    };\n    Tween.prototype.onComplete = function (callback) {\n        this._onCompleteCallback = callback;\n        return this;\n    };\n    Tween.prototype.onStop = function (callback) {\n        this._onStopCallback = callback;\n        return this;\n    };\n    /**\n     * @returns true if the tween is still playing after the update, false\n     * otherwise (calling update on a paused tween still returns true because\n     * it is still playing, just paused).\n     *\n     * @param autoStart - When true, calling update will implicitly call start()\n     * as well. Note, if you stop() or end() the tween, but are still calling\n     * update(), it will start again!\n     */\n    Tween.prototype.update = function (time, autoStart) {\n        var _this = this;\n        var _a;\n        if (time === void 0) { time = now(); }\n        if (autoStart === void 0) { autoStart = Tween.autoStartOnUpdate; }\n        if (this._isPaused)\n            return true;\n        var property;\n        if (!this._goToEnd && !this._isPlaying) {\n            if (autoStart)\n                this.start(time, true);\n            else\n                return false;\n        }\n        this._goToEnd = false;\n        if (time < this._startTime) {\n            return true;\n        }\n        if (this._onStartCallbackFired === false) {\n            if (this._onStartCallback) {\n                this._onStartCallback(this._object);\n            }\n            this._onStartCallbackFired = true;\n        }\n        if (this._onEveryStartCallbackFired === false) {\n            if (this._onEveryStartCallback) {\n                this._onEveryStartCallback(this._object);\n            }\n            this._onEveryStartCallbackFired = true;\n        }\n        var elapsedTime = time - this._startTime;\n        var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);\n        var totalTime = this._duration + this._repeat * durationAndDelay;\n        var calculateElapsedPortion = function () {\n            if (_this._duration === 0)\n                return 1;\n            if (elapsedTime > totalTime) {\n                return 1;\n            }\n            var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);\n            var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;\n            // TODO use %?\n            // const timeIntoCurrentRepeat = elapsedTime % durationAndDelay\n            var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);\n            if (portion === 0 && elapsedTime === _this._duration) {\n                return 1;\n            }\n            return portion;\n        };\n        var elapsed = calculateElapsedPortion();\n        var value = this._easingFunction(elapsed);\n        // properties transformations\n        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);\n        if (this._onUpdateCallback) {\n            this._onUpdateCallback(this._object, elapsed);\n        }\n        if (this._duration === 0 || elapsedTime >= this._duration) {\n            if (this._repeat > 0) {\n                var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);\n                if (isFinite(this._repeat)) {\n                    this._repeat -= completeCount;\n                }\n                // Reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat) {\n                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {\n                        this._valuesStartRepeat[property] =\n                            // eslint-disable-next-line\n                            // @ts-ignore FIXME?\n                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n                    }\n                    if (this._yoyo) {\n                        this._swapEndStartRepeatValues(property);\n                    }\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n                if (this._yoyo) {\n                    this._reversed = !this._reversed;\n                }\n                this._startTime += durationAndDelay * completeCount;\n                if (this._onRepeatCallback) {\n                    this._onRepeatCallback(this._object);\n                }\n                this._onEveryStartCallbackFired = false;\n                return true;\n            }\n            else {\n                if (this._onCompleteCallback) {\n                    this._onCompleteCallback(this._object);\n                }\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n                    // Make the chained tweens start exactly at the time they should,\n                    // even if the `update()` method was called way past the duration of the tween\n                    this._chainedTweens[i].start(this._startTime + this._duration, false);\n                }\n                this._isPlaying = false;\n                return false;\n            }\n        }\n        return true;\n    };\n    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {\n        for (var property in _valuesEnd) {\n            // Don't update properties that do not exist in the source object\n            if (_valuesStart[property] === undefined) {\n                continue;\n            }\n            var start = _valuesStart[property] || 0;\n            var end = _valuesEnd[property];\n            var startIsArray = Array.isArray(_object[property]);\n            var endIsArray = Array.isArray(end);\n            var isInterpolationList = !startIsArray && endIsArray;\n            if (isInterpolationList) {\n                _object[property] = this._interpolationFunction(end, value);\n            }\n            else if (typeof end === 'object' && end) {\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._updateProperties(_object[property], start, end, value);\n            }\n            else {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                end = this._handleRelativeValue(start, end);\n                // Protect against non numeric properties.\n                if (typeof end === 'number') {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _object[property] = start + (end - start) * value;\n                }\n            }\n        }\n    };\n    Tween.prototype._handleRelativeValue = function (start, end) {\n        if (typeof end !== 'string') {\n            return end;\n        }\n        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n            return start + parseFloat(end);\n        }\n        return parseFloat(end);\n    };\n    Tween.prototype._swapEndStartRepeatValues = function (property) {\n        var tmp = this._valuesStartRepeat[property];\n        var endValue = this._valuesEnd[property];\n        if (typeof endValue === 'string') {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\n        }\n        else {\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\n        }\n        this._valuesEnd[property] = tmp;\n    };\n    Tween.autoStartOnUpdate = false;\n    return Tween;\n}());\n\nvar VERSION = '25.0.0';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar nextId = Sequence.nextId;\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tweens.\n */\nvar TWEEN = mainGroup;\n// This is the best way to export things in a way that's compatible with both ES\n// Modules and CommonJS, without build hacks, and so as not to break the\n// existing API.\n// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881\n/**\n * @deprecated The global TWEEN Group will be removed in a following major\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n * group.\n *\n * Old code:\n *\n * ```js\n * import * as TWEEN from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new TWEEN.Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   TWEEN.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n *\n * New code:\n *\n * ```js\n * import {Tween, Group} from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * const group = new Group()\n * group.add(tween)\n * group.add(tween2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   group.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n */\nvar getAll = TWEEN.getAll.bind(TWEEN);\n/**\n * @deprecated The global TWEEN Group will be removed in a following major\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n * group.\n *\n * Old code:\n *\n * ```js\n * import * as TWEEN from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new TWEEN.Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   TWEEN.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n *\n * New code:\n *\n * ```js\n * import {Tween, Group} from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * const group = new Group()\n * group.add(tween)\n * group.add(tween2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   group.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n */\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\n/**\n * @deprecated The global TWEEN Group will be removed in a following major\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n * group.\n *\n * Old code:\n *\n * ```js\n * import * as TWEEN from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new TWEEN.Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   TWEEN.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n *\n * New code:\n *\n * ```js\n * import {Tween, Group} from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * const group = new Group()\n * group.add(tween)\n * group.add(tween2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   group.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n */\nvar add = TWEEN.add.bind(TWEEN);\n/**\n * @deprecated The global TWEEN Group will be removed in a following major\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n * group.\n *\n * Old code:\n *\n * ```js\n * import * as TWEEN from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new TWEEN.Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   TWEEN.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n *\n * New code:\n *\n * ```js\n * import {Tween, Group} from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * const group = new Group()\n * group.add(tween)\n * group.add(tween2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   group.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n */\nvar remove = TWEEN.remove.bind(TWEEN);\n/**\n * @deprecated The global TWEEN Group will be removed in a following major\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n * group.\n *\n * Old code:\n *\n * ```js\n * import * as TWEEN from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new TWEEN.Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   TWEEN.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n *\n * New code:\n *\n * ```js\n * import {Tween, Group} from '@tweenjs/tween.js'\n *\n * //...\n *\n * const tween = new Tween(obj)\n * const tween2 = new TWEEN.Tween(obj2)\n *\n * //...\n *\n * const group = new Group()\n * group.add(tween)\n * group.add(tween2)\n *\n * //...\n *\n * requestAnimationFrame(function loop(time) {\n *   group.update(time)\n *   requestAnimationFrame(loop)\n * })\n * ```\n */\nvar update = TWEEN.update.bind(TWEEN);\nvar exports = {\n    Easing: Easing,\n    Group: Group,\n    Interpolation: Interpolation,\n    now: now,\n    Sequence: Sequence,\n    nextId: nextId,\n    Tween: Tween,\n    VERSION: VERSION,\n    /**\n     * @deprecated The global TWEEN Group will be removed in a following major\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n     * group.\n     *\n     * Old code:\n     *\n     * ```js\n     * import * as TWEEN from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new TWEEN.Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   TWEEN.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     *\n     * New code:\n     *\n     * ```js\n     * import {Tween, Group} from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * const group = new Group()\n     * group.add(tween)\n     * group.add(tween2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   group.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     */\n    getAll: getAll,\n    /**\n     * @deprecated The global TWEEN Group will be removed in a following major\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n     * group.\n     *\n     * Old code:\n     *\n     * ```js\n     * import * as TWEEN from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new TWEEN.Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   TWEEN.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     *\n     * New code:\n     *\n     * ```js\n     * import {Tween, Group} from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * const group = new Group()\n     * group.add(tween)\n     * group.add(tween2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   group.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     */\n    removeAll: removeAll,\n    /**\n     * @deprecated The global TWEEN Group will be removed in a following major\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n     * group.\n     *\n     * Old code:\n     *\n     * ```js\n     * import * as TWEEN from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new TWEEN.Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   TWEEN.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     *\n     * New code:\n     *\n     * ```js\n     * import {Tween, Group} from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * const group = new Group()\n     * group.add(tween)\n     * group.add(tween2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   group.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     */\n    add: add,\n    /**\n     * @deprecated The global TWEEN Group will be removed in a following major\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n     * group.\n     *\n     * Old code:\n     *\n     * ```js\n     * import * as TWEEN from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new TWEEN.Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   TWEEN.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     *\n     * New code:\n     *\n     * ```js\n     * import {Tween, Group} from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * const group = new Group()\n     * group.add(tween)\n     * group.add(tween2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   group.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     */\n    remove: remove,\n    /**\n     * @deprecated The global TWEEN Group will be removed in a following major\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\n     * group.\n     *\n     * Old code:\n     *\n     * ```js\n     * import * as TWEEN from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new TWEEN.Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   TWEEN.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     *\n     * New code:\n     *\n     * ```js\n     * import {Tween, Group} from '@tweenjs/tween.js'\n     *\n     * //...\n     *\n     * const tween = new Tween(obj)\n     * const tween2 = new TWEEN.Tween(obj2)\n     *\n     * //...\n     *\n     * const group = new Group()\n     * group.add(tween)\n     * group.add(tween2)\n     *\n     * //...\n     *\n     * requestAnimationFrame(function loop(time) {\n     *   group.update(time)\n     *   requestAnimationFrame(loop)\n     * })\n     * ```\n     */\n    update: update,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVELHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdDQUFnQztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNEJBQTRCO0FBQ2xGO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNCQUFzQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFMkkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHR3ZWVuanMvdHdlZW4uanMvZGlzdC90d2Vlbi5lc20uanM/MjVlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCB0d2Vlbi5qcy5cbiAqL1xudmFyIEVhc2luZyA9IE9iamVjdC5mcmVlemUoe1xuICAgIExpbmVhcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE5vbmU6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIFF1YWRyYXRpYzogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiAoMiAtIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS1hbW91bnQgKiAoYW1vdW50IC0gMikgLSAxKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBDdWJpYzogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogYW1vdW50ICsgMik7XG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgUXVhcnRpYzogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAtIDIpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIFF1aW50aWM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDIpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIFNpbnVzb2lkYWw6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNpbigoKDEuMCAtIGFtb3VudCkgKiBNYXRoLlBJKSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbigoYW1vdW50ICogTWF0aC5QSSkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguc2luKE1hdGguUEkgKiAoMC41IC0gYW1vdW50KSkpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIEV4cG9uZW50aWFsOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgYW1vdW50IC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBhbW91bnQgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBDaXJjdWxhcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gYW1vdW50ICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWFtb3VudCAqIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGFtb3VudCAqIGFtb3VudCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoYW1vdW50IC09IDIpICogYW1vdW50KSArIDEpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIEVsYXN0aWM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAxMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KSAqIE1hdGguc2luKChhbW91bnQgLSAwLjEpICogNSAqIE1hdGguUEkpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFtb3VudCAqPSAyO1xuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIE1hdGgucG93KDIsIDEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgQmFjazogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ID09PSAxID8gMSA6IGFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50IC0gcyk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IDAgOiAtLWFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50ICsgcykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKGFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50IC0gcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgKyBzKSArIDIpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIEJvdW5jZTogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIEVhc2luZy5Cb3VuY2UuT3V0KDEgLSBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPCAxIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoYW1vdW50IC09IDEuNSAvIDIuNzUpICogYW1vdW50ICsgMC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFtb3VudCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjI1IC8gMi43NSkgKiBhbW91bnQgKyAwLjkzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjYyNSAvIDIuNzUpICogYW1vdW50ICsgMC45ODQzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMC41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuSW4oYW1vdW50ICogMikgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRWFzaW5nLkJvdW5jZS5PdXQoYW1vdW50ICogMiAtIDEpICogMC41ICsgMC41O1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIGdlbmVyYXRlUG93OiBmdW5jdGlvbiAocG93ZXIpIHtcbiAgICAgICAgaWYgKHBvd2VyID09PSB2b2lkIDApIHsgcG93ZXIgPSA0OyB9XG4gICAgICAgIHBvd2VyID0gcG93ZXIgPCBOdW1iZXIuRVBTSUxPTiA/IE51bWJlci5FUFNJTE9OIDogcG93ZXI7XG4gICAgICAgIHBvd2VyID0gcG93ZXIgPiAxMDAwMCA/IDEwMDAwIDogcG93ZXI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhhbW91bnQsIHBvd2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAtIE1hdGgucG93KCgxIC0gYW1vdW50KSwgcG93ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFtb3VudCA8IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coKGFtb3VudCAqIDIpLCBwb3dlcikgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDEgLSBNYXRoLnBvdygoMiAtIGFtb3VudCAqIDIpLCBwb3dlcikpIC8gMiArIDAuNTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG52YXIgbm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG5cbi8qKlxuICogQ29udHJvbGxpbmcgZ3JvdXBzIG9mIHR3ZWVuc1xuICpcbiAqIFVzaW5nIHRoZSBUV0VFTiBzaW5nbGV0b24gdG8gbWFuYWdlIHlvdXIgdHdlZW5zIGNhbiBjYXVzZSBpc3N1ZXMgaW4gbGFyZ2UgYXBwcyB3aXRoIG1hbnkgY29tcG9uZW50cy5cbiAqIEluIHRoZXNlIGNhc2VzLCB5b3UgbWF5IHdhbnQgdG8gY3JlYXRlIHlvdXIgb3duIHNtYWxsZXIgZ3JvdXBzIG9mIHR3ZWVuXG4gKi9cbnZhciBHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcm91cCgpIHtcbiAgICAgICAgdmFyIHR3ZWVucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdHdlZW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHdlZW5zID0ge307XG4gICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XG4gICAgICAgIHRoaXMuYWRkLmFwcGx5KHRoaXMsIHR3ZWVucyk7XG4gICAgfVxuICAgIEdyb3VwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnMpLm1hcChmdW5jdGlvbiAodHdlZW5JZCkgeyByZXR1cm4gX3RoaXMuX3R3ZWVuc1t0d2VlbklkXTsgfSk7XG4gICAgfTtcbiAgICBHcm91cC5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90d2VlbnMgPSB7fTtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHR3ZWVucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdHdlZW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCB0d2VlbnNfMSA9IHR3ZWVuczsgX2IgPCB0d2VlbnNfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciB0d2VlbiA9IHR3ZWVuc18xW19iXTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGFueSBvdGhlciBncm91cCBmaXJzdCwgYSB0d2VlbiBjYW4gb25seSBiZSBpbiBvbmUgZ3JvdXAgYXQgYSB0aW1lLlxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsaWJyYXJ5IGludGVybmFsIGFjY2Vzc1xuICAgICAgICAgICAgKF9hID0gdHdlZW4uX2dyb3VwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKHR3ZWVuKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbGlicmFyeSBpbnRlcm5hbCBhY2Nlc3NcbiAgICAgICAgICAgIHR3ZWVuLl9ncm91cCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcbiAgICAgICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldID0gdHdlZW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0d2VlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHR3ZWVuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgdHdlZW5zXzIgPSB0d2VlbnM7IF9hIDwgdHdlZW5zXzIubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgdHdlZW4gPSB0d2VlbnNfMltfYV07XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxpYnJhcnkgaW50ZXJuYWwgYWNjZXNzXG4gICAgICAgICAgICB0d2Vlbi5fZ3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdHdlZW5zW3R3ZWVuLmdldElkKCldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogUmV0dXJuIHRydWUgaWYgYWxsIHR3ZWVucyBpbiB0aGUgZ3JvdXAgYXJlIG5vdCBwYXVzZWQgb3IgcGxheWluZy4gKi9cbiAgICBHcm91cC5wcm90b3R5cGUuYWxsU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsKCkuZXZlcnkoZnVuY3Rpb24gKHR3ZWVuKSB7IHJldHVybiAhdHdlZW4uaXNQbGF5aW5nKCk7IH0pO1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBwcmVzZXJ2ZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3coKTsgfVxuICAgICAgICBpZiAocHJlc2VydmUgPT09IHZvaWQgMCkgeyBwcmVzZXJ2ZSA9IHRydWU7IH1cbiAgICAgICAgdmFyIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKTtcbiAgICAgICAgaWYgKHR3ZWVuSWRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVHdlZW5zIGFyZSB1cGRhdGVkIGluIFwiYmF0Y2hlc1wiLiBJZiB5b3UgYWRkIGEgbmV3IHR3ZWVuIGR1cmluZyBhblxuICAgICAgICAvLyB1cGRhdGUsIHRoZW4gdGhlIG5ldyB0d2VlbiB3aWxsIGJlIHVwZGF0ZWQgaW4gdGhlIG5leHQgYmF0Y2guXG4gICAgICAgIC8vIElmIHlvdSByZW1vdmUgYSB0d2VlbiBkdXJpbmcgYW4gdXBkYXRlLCBpdCBtYXkgb3IgbWF5IG5vdCBiZSB1cGRhdGVkLlxuICAgICAgICAvLyBIb3dldmVyLCBpZiB0aGUgcmVtb3ZlZCB0d2VlbiB3YXMgYWRkZWQgZHVyaW5nIHRoZSBjdXJyZW50IGJhdGNoLFxuICAgICAgICAvLyB0aGVuIGl0IHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAgICAgIHdoaWxlICh0d2Vlbklkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0d2Vlbklkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IHRoaXMuX3R3ZWVuc1t0d2Vlbklkc1tpXV07XG4gICAgICAgICAgICAgICAgdmFyIGF1dG9TdGFydCA9ICFwcmVzZXJ2ZTtcbiAgICAgICAgICAgICAgICBpZiAodHdlZW4gJiYgdHdlZW4udXBkYXRlKHRpbWUsIGF1dG9TdGFydCkgPT09IGZhbHNlICYmICFwcmVzZXJ2ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodHdlZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHdlZW5JZHMgPSBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHcm91cDtcbn0oKSk7XG5cbi8qKlxuICpcbiAqL1xudmFyIEludGVycG9sYXRpb24gPSB7XG4gICAgTGluZWFyOiBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGYgPSBtICogaztcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xuICAgICAgICB2YXIgZm4gPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkxpbmVhcjtcbiAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odlswXSwgdlsxXSwgZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odlttXSwgdlttIC0gMV0sIG0gLSBmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4odltpXSwgdltpICsgMSA+IG0gPyBtIDogaSArIDFdLCBmIC0gaSk7XG4gICAgfSxcbiAgICBCZXppZXI6IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHZhciBiID0gMDtcbiAgICAgICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBwdyA9IE1hdGgucG93O1xuICAgICAgICB2YXIgYm4gPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkJlcm5zdGVpbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgICAgICBiICs9IHB3KDEgLSBrLCBuIC0gaSkgKiBwdyhrLCBpKSAqIHZbaV0gKiBibihuLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYjtcbiAgICB9LFxuICAgIENhdG11bGxSb206IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgZiA9IG0gKiBrO1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XG4gICAgICAgIHZhciBmbiA9IEludGVycG9sYXRpb24uVXRpbHMuQ2F0bXVsbFJvbTtcbiAgICAgICAgaWYgKHZbMF0gPT09IHZbbV0pIHtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgIGkgPSBNYXRoLmZsb29yKChmID0gbSAqICgxICsgaykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbih2WyhpIC0gMSArIG0pICUgbV0sIHZbaV0sIHZbKGkgKyAxKSAlIG1dLCB2WyhpICsgMikgJSBtXSwgZiAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZbMF0gLSAoZm4odlswXSwgdlswXSwgdlsxXSwgdlsxXSwgLWYpIC0gdlswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdlttXSAtIChmbih2W21dLCB2W21dLCB2W20gLSAxXSwgdlttIC0gMV0sIGYgLSBtKSAtIHZbbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuKHZbaSA/IGkgLSAxIDogMF0sIHZbaV0sIHZbbSA8IGkgKyAxID8gbSA6IGkgKyAxXSwgdlttIDwgaSArIDIgPyBtIDogaSArIDJdLCBmIC0gaSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFV0aWxzOiB7XG4gICAgICAgIExpbmVhcjogZnVuY3Rpb24gKHAwLCBwMSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgICAgICAgfSxcbiAgICAgICAgQmVybnN0ZWluOiBmdW5jdGlvbiAobiwgaSkge1xuICAgICAgICAgICAgdmFyIGZjID0gSW50ZXJwb2xhdGlvbi5VdGlscy5GYWN0b3JpYWw7XG4gICAgICAgICAgICByZXR1cm4gZmMobikgLyBmYyhpKSAvIGZjKG4gLSBpKTtcbiAgICAgICAgfSxcbiAgICAgICAgRmFjdG9yaWFsOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBbMV07XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGFbbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBuOyBpID4gMTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKj0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYVtuXSA9IHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpLFxuICAgICAgICBDYXRtdWxsUm9tOiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgICAgIHZhciB0MiA9IHQgKiB0O1xuICAgICAgICAgICAgdmFyIHQzID0gdCAqIHQyO1xuICAgICAgICAgICAgcmV0dXJuICgyICogcDEgLSAyICogcDIgKyB2MCArIHYxKSAqIHQzICsgKC0zICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG4vKipcbiAqIFV0aWxzXG4gKi9cbnZhciBTZXF1ZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXF1ZW5jZSgpIHtcbiAgICB9XG4gICAgU2VxdWVuY2UubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU2VxdWVuY2UuX25leHRJZCsrO1xuICAgIH07XG4gICAgU2VxdWVuY2UuX25leHRJZCA9IDA7XG4gICAgcmV0dXJuIFNlcXVlbmNlO1xufSgpKTtcblxudmFyIG1haW5Hcm91cCA9IG5ldyBHcm91cCgpO1xuXG4vKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG52YXIgVHdlZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHdlZW4ob2JqZWN0LCBncm91cCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnQgPSB7fTtcbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kID0ge307XG4gICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0ID0ge307XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMDtcbiAgICAgICAgdGhpcy5faXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luaXRpYWxSZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLl95b3lvID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IEVhc2luZy5MaW5lYXIuTm9uZTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gSW50ZXJwb2xhdGlvbi5MaW5lYXI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gW107XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faWQgPSBTZXF1ZW5jZS5uZXh0SWQoKTtcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0FyZVNldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2dvVG9FbmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXAgPSBncm91cDtcbiAgICAgICAgICAgIGdyb3VwLmFkZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgXCJ0cnVlXCIgdG8gcmVzdG9yZSBvbGQgYmVoYXZpb3IgKHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZSkuXG4gICAgICAgIGVsc2UgaWYgKGdyb3VwID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm91cCA9IG1haW5Hcm91cDtcbiAgICAgICAgICAgIG1haW5Hcm91cC5hZGQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHdlZW4ucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQYXVzZWQ7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uICh0YXJnZXQsIGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7IGR1cmF0aW9uID0gMTAwMDsgfVxuICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGNhbGwgVHdlZW4udG8oKSB3aGlsZSBUd2VlbiBpcyBhbHJlYWR5IHN0YXJ0ZWQgb3IgcGF1c2VkLiBTdG9wIHRoZSBUd2VlbiBmaXJzdC4nKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzQXJlU2V0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiA8IDAgPyAwIDogZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7IGR1cmF0aW9uID0gMTAwMDsgfVxuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIDwgMCA/IDAgOiBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZHluYW1pYyA9IGZ1bmN0aW9uIChkeW5hbWljKSB7XG4gICAgICAgIGlmIChkeW5hbWljID09PSB2b2lkIDApIHsgZHluYW1pYyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX2lzRHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMpIHtcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93KCk7IH1cbiAgICAgICAgaWYgKG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMgPT09IHZvaWQgMCkgeyBvdmVycmlkZVN0YXJ0aW5nVmFsdWVzID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGhpcy5faW5pdGlhbFJlcGVhdDtcbiAgICAgICAgaWYgKHRoaXMuX3JldmVyc2VkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHJldmVyc2VkIChmLmUuIHVzaW5nIHRoZSB5b3lvIGZlYXR1cmUpIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZmxpcCB0aGUgdHdlZW4gZGlyZWN0aW9uIGJhY2sgdG8gZm9yd2FyZC5cbiAgICAgICAgICAgIHRoaXMuX3JldmVyc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lICs9IHRoaXMuX2RlbGF5VGltZTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzQXJlU2V0VXAgfHwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc0FyZVNldFVwID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIElmIGR5bmFtaWMgaXMgbm90IGVuYWJsZWQsIGNsb25lIHRoZSBlbmQgdmFsdWVzIGluc3RlYWQgb2YgdXNpbmcgdGhlIHBhc3NlZC1pbiBlbmQgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLl92YWx1ZXNFbmQpXG4gICAgICAgICAgICAgICAgICAgIHRtcFtwcm9wXSA9IHRoaXMuX3ZhbHVlc0VuZFtwcm9wXTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNFbmQgPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXR1cFByb3BlcnRpZXModGhpcy5fb2JqZWN0LCB0aGlzLl92YWx1ZXNTdGFydCwgdGhpcy5fdmFsdWVzRW5kLCB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RhcnRGcm9tQ3VycmVudFZhbHVlcyA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KHRpbWUsIHRydWUpO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl9zZXR1cFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoX29iamVjdCwgX3ZhbHVlc1N0YXJ0LCBfdmFsdWVzRW5kLCBfdmFsdWVzU3RhcnRSZXBlYXQsIG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBfb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHZhciBzdGFydFZhbHVlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgcHJvcFR5cGUgPSBzdGFydFZhbHVlSXNBcnJheSA/ICdhcnJheScgOiB0eXBlb2Ygc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHZhciBpc0ludGVycG9sYXRpb25MaXN0ID0gIXN0YXJ0VmFsdWVJc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgLy8gSWYgYHRvKClgIHNwZWNpZmllcyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdCxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBub3Qgc2V0IHRoYXQgcHJvcGVydHkgaW4gdGhlIG9iamVjdFxuICAgICAgICAgICAgaWYgKHByb3BUeXBlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gQXJyYXkgd2FzIHByb3ZpZGVkIGFzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRWYWx1ZXMgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFuIGFycmF5IG9mIHJlbGF0aXZlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGEgbG9jYWwgY29weSBvZiB0aGUgQXJyYXkgd2l0aCB0aGUgc3RhcnQgdmFsdWUgYXQgdGhlIGZyb250XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBbc3RhcnRWYWx1ZV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbmRWYWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2hhbmRsZVJlbGF0aXZlVmFsdWUoc3RhcnRWYWx1ZSwgZW5kVmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnRlcnBvbGF0aW9uTGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGb3VuZCBpbnZhbGlkIGludGVycG9sYXRpb24gbGlzdC4gU2tpcHBpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7IC8vIGhhbmRsZSBlbmQgdmFsdWVzIG9ubHkgdGhlIGZpcnN0IHRpbWUuIE5PVCBORUVERUQ/IHNldHVwUHJvcGVydGllcyBpcyBub3cgZ3VhcmRlZCBieSBfcHJvcGVydGllc0FyZVNldFVwLlxuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzRW5kW3Byb3BlcnR5XSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIGRlZXBuZXNzIG9mIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICgocHJvcFR5cGUgPT09ICdvYmplY3QnIHx8IHN0YXJ0VmFsdWVJc0FycmF5KSAmJiBzdGFydFZhbHVlICYmICFpc0ludGVycG9sYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHN0YXJ0VmFsdWVJc0FycmF5ID8gW10gOiB7fTtcbiAgICAgICAgICAgICAgICB2YXIgbmVzdGVkT2JqZWN0ID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG5lc3RlZE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldW3Byb3BdID0gbmVzdGVkT2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPPyByZXBlYXQgbmVzdGVkIHZhbHVlcz8gQW5kIHlveW8/IEFuZCBhcnJheSB2YWx1ZXM/XG4gICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IHN0YXJ0VmFsdWVJc0FycmF5ID8gW10gOiB7fTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kVmFsdWVzID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgLy8gSWYgZHluYW1pYyBpcyBub3QgZW5hYmxlZCwgY2xvbmUgdGhlIGVuZCB2YWx1ZXMgaW5zdGVhZCBvZiB1c2luZyB0aGUgcGFzc2VkLWluIGVuZCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGVuZFZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcFtwcm9wXSA9IGVuZFZhbHVlc1twcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSBlbmRWYWx1ZXMgPSB0bXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwUHJvcGVydGllcyhuZXN0ZWRPYmplY3QsIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0sIGVuZFZhbHVlcywgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBzdGFydGluZyB2YWx1ZSwgYnV0IG9ubHkgb25jZSB1bmxlc3Mgb3ZlcnJpZGUgaXMgcmVxdWVzdGVkLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9PT0gJ3VuZGVmaW5lZCcgfHwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydFZhbHVlSXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSAqPSAxLjA7IC8vIEVuc3VyZXMgd2UncmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3NcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBfdmFsdWVzRW5kW3Byb3BlcnR5XS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBfdmFsdWVzU3RhcnRbcHJvcGVydHldIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NoYWluU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdG9wQ2hhaW5lZFR3ZWVucygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX29uU3RvcENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9vblN0b3BDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3coKTsgfVxuICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQgfHwgIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gdGltZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93KCk7IH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgKz0gdGltZSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5zdG9wQ2hhaW5lZFR3ZWVucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZ3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0d2Vlbi5ncm91cCgpIHdpdGhvdXQgYXJncyBoYXMgYmVlbiByZW1vdmVkLCB1c2UgZ3JvdXAuYWRkKHR3ZWVuKSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXAuYWRkKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHR3ZWVuIGZyb20gd2hpY2hldmVyIGdyb3VwIGl0IGlzIGluLlxuICAgICAqL1xuICAgIFR3ZWVuLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fZ3JvdXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIHsgYW1vdW50ID0gMDsgfVxuICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSBhbW91bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICBpZiAodGltZXMgPT09IHZvaWQgMCkgeyB0aW1lcyA9IDA7IH1cbiAgICAgICAgdGhpcy5faW5pdGlhbFJlcGVhdCA9IHRpbWVzO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aW1lcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX3JlcGVhdERlbGF5VGltZSA9IGFtb3VudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUueW95byA9IGZ1bmN0aW9uICh5b3lvKSB7XG4gICAgICAgIGlmICh5b3lvID09PSB2b2lkIDApIHsgeW95byA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX3lveW8gPSB5b3lvO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5lYXNpbmcgPSBmdW5jdGlvbiAoZWFzaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKGVhc2luZ0Z1bmN0aW9uID09PSB2b2lkIDApIHsgZWFzaW5nRnVuY3Rpb24gPSBFYXNpbmcuTGluZWFyLk5vbmU7IH1cbiAgICAgICAgdGhpcy5fZWFzaW5nRnVuY3Rpb24gPSBlYXNpbmdGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuaW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25GdW5jdGlvbiA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25GdW5jdGlvbiA9IEludGVycG9sYXRpb24uTGluZWFyOyB9XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb25GdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBUd2Vlbi5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0d2VlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHR3ZWVuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnMgPSB0d2VlbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uRXZlcnlTdGFydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uUmVwZWF0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uU3RvcENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdlZW4gaXMgc3RpbGwgcGxheWluZyBhZnRlciB0aGUgdXBkYXRlLCBmYWxzZVxuICAgICAqIG90aGVyd2lzZSAoY2FsbGluZyB1cGRhdGUgb24gYSBwYXVzZWQgdHdlZW4gc3RpbGwgcmV0dXJucyB0cnVlIGJlY2F1c2VcbiAgICAgKiBpdCBpcyBzdGlsbCBwbGF5aW5nLCBqdXN0IHBhdXNlZCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXV0b1N0YXJ0IC0gV2hlbiB0cnVlLCBjYWxsaW5nIHVwZGF0ZSB3aWxsIGltcGxpY2l0bHkgY2FsbCBzdGFydCgpXG4gICAgICogYXMgd2VsbC4gTm90ZSwgaWYgeW91IHN0b3AoKSBvciBlbmQoKSB0aGUgdHdlZW4sIGJ1dCBhcmUgc3RpbGwgY2FsbGluZ1xuICAgICAqIHVwZGF0ZSgpLCBpdCB3aWxsIHN0YXJ0IGFnYWluIVxuICAgICAqL1xuICAgIFR3ZWVuLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodGltZSwgYXV0b1N0YXJ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93KCk7IH1cbiAgICAgICAgaWYgKGF1dG9TdGFydCA9PT0gdm9pZCAwKSB7IGF1dG9TdGFydCA9IFR3ZWVuLmF1dG9TdGFydE9uVXBkYXRlOyB9XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgcHJvcGVydHk7XG4gICAgICAgIGlmICghdGhpcy5fZ29Ub0VuZCAmJiAhdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICBpZiAoYXV0b1N0YXJ0KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQodGltZSwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dvVG9FbmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRpbWUgPCB0aGlzLl9zdGFydFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vblN0YXJ0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2tGaXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFja0ZpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSB0aW1lIC0gdGhpcy5fc3RhcnRUaW1lO1xuICAgICAgICB2YXIgZHVyYXRpb25BbmREZWxheSA9IHRoaXMuX2R1cmF0aW9uICsgKChfYSA9IHRoaXMuX3JlcGVhdERlbGF5VGltZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fZGVsYXlUaW1lKTtcbiAgICAgICAgdmFyIHRvdGFsVGltZSA9IHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0ICogZHVyYXRpb25BbmREZWxheTtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZUVsYXBzZWRQb3J0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9kdXJhdGlvbiA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmIChlbGFwc2VkVGltZSA+IHRvdGFsVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRpbWVzUmVwZWF0ZWQgPSBNYXRoLnRydW5jKGVsYXBzZWRUaW1lIC8gZHVyYXRpb25BbmREZWxheSk7XG4gICAgICAgICAgICB2YXIgdGltZUludG9DdXJyZW50UmVwZWF0ID0gZWxhcHNlZFRpbWUgLSB0aW1lc1JlcGVhdGVkICogZHVyYXRpb25BbmREZWxheTtcbiAgICAgICAgICAgIC8vIFRPRE8gdXNlICU/XG4gICAgICAgICAgICAvLyBjb25zdCB0aW1lSW50b0N1cnJlbnRSZXBlYXQgPSBlbGFwc2VkVGltZSAlIGR1cmF0aW9uQW5kRGVsYXlcbiAgICAgICAgICAgIHZhciBwb3J0aW9uID0gTWF0aC5taW4odGltZUludG9DdXJyZW50UmVwZWF0IC8gX3RoaXMuX2R1cmF0aW9uLCAxKTtcbiAgICAgICAgICAgIGlmIChwb3J0aW9uID09PSAwICYmIGVsYXBzZWRUaW1lID09PSBfdGhpcy5fZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb3J0aW9uO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZWxhcHNlZCA9IGNhbGN1bGF0ZUVsYXBzZWRQb3J0aW9uKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2Vhc2luZ0Z1bmN0aW9uKGVsYXBzZWQpO1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX29iamVjdCwgdGhpcy5fdmFsdWVzU3RhcnQsIHRoaXMuX3ZhbHVlc0VuZCwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fb25VcGRhdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fb25VcGRhdGVDYWxsYmFjayh0aGlzLl9vYmplY3QsIGVsYXBzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCB8fCBlbGFwc2VkVGltZSA+PSB0aGlzLl9kdXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVDb3VudCA9IE1hdGgubWluKE1hdGgudHJ1bmMoKGVsYXBzZWRUaW1lIC0gdGhpcy5fZHVyYXRpb24pIC8gZHVyYXRpb25BbmREZWxheSkgKyAxLCB0aGlzLl9yZXBlYXQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh0aGlzLl9yZXBlYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcGVhdCAtPSBjb21wbGV0ZUNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWFzc2lnbiBzdGFydGluZyB2YWx1ZXMsIHJlc3RhcnQgYnkgbWFraW5nIHN0YXJ0VGltZSA9IG5vd1xuICAgICAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl95b3lvICYmIHR5cGVvZiB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSArIHBhcnNlRmxvYXQodGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3lveW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5feW95bykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXZlcnNlZCA9ICF0aGlzLl9yZXZlcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lICs9IGR1cmF0aW9uQW5kRGVsYXkgKiBjb21wbGV0ZUNvdW50O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vblJlcGVhdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ29tcGxldGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBjaGFpbmVkIHR3ZWVucyBzdGFydCBleGFjdGx5IGF0IHRoZSB0aW1lIHRoZXkgc2hvdWxkLFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBgdXBkYXRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIHdheSBwYXN0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdGFydCh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3VwZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoX29iamVjdCwgX3ZhbHVlc1N0YXJ0LCBfdmFsdWVzRW5kLCB2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB1cGRhdGUgcHJvcGVydGllcyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdFxuICAgICAgICAgICAgaWYgKF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xuICAgICAgICAgICAgdmFyIGVuZCA9IF92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX29iamVjdFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgdmFyIGVuZElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGVuZCk7XG4gICAgICAgICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uTGlzdCA9ICFzdGFydElzQXJyYXkgJiYgZW5kSXNBcnJheTtcbiAgICAgICAgICAgIGlmIChpc0ludGVycG9sYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICAgX29iamVjdFtwcm9wZXJ0eV0gPSB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24oZW5kLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnb2JqZWN0JyAmJiBlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnRpZXMoX29iamVjdFtwcm9wZXJ0eV0sIHN0YXJ0LCBlbmQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlcyByZWxhdGl2ZSBlbmQgdmFsdWVzIHdpdGggc3RhcnQgYXMgYmFzZSAoZS5nLjogKzEwLCAtMylcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLl9oYW5kbGVSZWxhdGl2ZVZhbHVlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCBub24gbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX29iamVjdFtwcm9wZXJ0eV0gPSBzdGFydCArIChlbmQgLSBzdGFydCkgKiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5faGFuZGxlUmVsYXRpdmVWYWx1ZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kLmNoYXJBdCgwKSA9PT0gJysnIHx8IGVuZC5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgcGFyc2VGbG9hdChlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGVuZCk7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICBpZiAodHlwZW9mIGVuZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSB0bXA7XG4gICAgfTtcbiAgICBUd2Vlbi5hdXRvU3RhcnRPblVwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiBUd2Vlbjtcbn0oKSk7XG5cbnZhciBWRVJTSU9OID0gJzI1LjAuMCc7XG5cbi8qKlxuICogVHdlZW4uanMgLSBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzL2dyYXBocy9jb250cmlidXRvcnMgZm9yIHRoZSBmdWxsIGxpc3Qgb2YgY29udHJpYnV0b3JzLlxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXG4gKi9cbnZhciBuZXh0SWQgPSBTZXF1ZW5jZS5uZXh0SWQ7XG4vKipcbiAqIENvbnRyb2xsaW5nIGdyb3VwcyBvZiB0d2VlbnNcbiAqXG4gKiBVc2luZyB0aGUgVFdFRU4gc2luZ2xldG9uIHRvIG1hbmFnZSB5b3VyIHR3ZWVucyBjYW4gY2F1c2UgaXNzdWVzIGluIGxhcmdlIGFwcHMgd2l0aCBtYW55IGNvbXBvbmVudHMuXG4gKiBJbiB0aGVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBzbWFsbGVyIGdyb3VwcyBvZiB0d2VlbnMuXG4gKi9cbnZhciBUV0VFTiA9IG1haW5Hcm91cDtcbi8vIFRoaXMgaXMgdGhlIGJlc3Qgd2F5IHRvIGV4cG9ydCB0aGluZ3MgaW4gYSB3YXkgdGhhdCdzIGNvbXBhdGlibGUgd2l0aCBib3RoIEVTXG4vLyBNb2R1bGVzIGFuZCBDb21tb25KUywgd2l0aG91dCBidWlsZCBoYWNrcywgYW5kIHNvIGFzIG5vdCB0byBicmVhayB0aGVcbi8vIGV4aXN0aW5nIEFQSS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xOTYxI2lzc3VlY29tbWVudC00MjMwMzc4ODFcbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcbiAqIHJlbGVhc2UuIFRvIG1pZ3JhdGUsIGNyZWF0ZSBhIGBuZXcgR3JvdXAoKWAgaW5zdGVhZCBvZiB1c2luZyBgVFdFRU5gIGFzIGFcbiAqIGdyb3VwLlxuICpcbiAqIE9sZCBjb2RlOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcbiAqXG4gKiAvLy4uLlxuICpcbiAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcbiAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICpcbiAqIC8vLi4uXG4gKlxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xuICogICBUV0VFTi51cGRhdGUodGltZSlcbiAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gKiB9KVxuICogYGBgXG4gKlxuICogTmV3IGNvZGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7VHdlZW4sIEdyb3VwfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcbiAqXG4gKiAvLy4uLlxuICpcbiAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcbiAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICpcbiAqIC8vLi4uXG4gKlxuICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKVxuICogZ3JvdXAuYWRkKHR3ZWVuKVxuICogZ3JvdXAuYWRkKHR3ZWVuMilcbiAqXG4gKiAvLy4uLlxuICpcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXG4gKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICogfSlcbiAqIGBgYFxuICovXG52YXIgZ2V0QWxsID0gVFdFRU4uZ2V0QWxsLmJpbmQoVFdFRU4pO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGUgZ2xvYmFsIFRXRUVOIEdyb3VwIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZvbGxvd2luZyBtYWpvclxuICogcmVsZWFzZS4gVG8gbWlncmF0ZSwgY3JlYXRlIGEgYG5ldyBHcm91cCgpYCBpbnN0ZWFkIG9mIHVzaW5nIGBUV0VFTmAgYXMgYVxuICogZ3JvdXAuXG4gKlxuICogT2xkIGNvZGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCAqIGFzIFRXRUVOIGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJ1xuICpcbiAqIC8vLi4uXG4gKlxuICogY29uc3QgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4ob2JqKVxuICogY29uc3QgdHdlZW4yID0gbmV3IFRXRUVOLlR3ZWVuKG9iajIpXG4gKlxuICogLy8uLi5cbiAqXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gKiAgIFRXRUVOLnVwZGF0ZSh0aW1lKVxuICogICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcClcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBOZXcgY29kZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHtUd2VlbiwgR3JvdXB9IGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJ1xuICpcbiAqIC8vLi4uXG4gKlxuICogY29uc3QgdHdlZW4gPSBuZXcgVHdlZW4ob2JqKVxuICogY29uc3QgdHdlZW4yID0gbmV3IFRXRUVOLlR3ZWVuKG9iajIpXG4gKlxuICogLy8uLi5cbiAqXG4gKiBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpXG4gKiBncm91cC5hZGQodHdlZW4pXG4gKiBncm91cC5hZGQodHdlZW4yKVxuICpcbiAqIC8vLi4uXG4gKlxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xuICogICBncm91cC51cGRhdGUodGltZSlcbiAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciByZW1vdmVBbGwgPSBUV0VFTi5yZW1vdmVBbGwuYmluZChUV0VFTik7XG4vKipcbiAqIEBkZXByZWNhdGVkIFRoZSBnbG9iYWwgVFdFRU4gR3JvdXAgd2lsbCBiZSByZW1vdmVkIGluIGEgZm9sbG93aW5nIG1ham9yXG4gKiByZWxlYXNlLiBUbyBtaWdyYXRlLCBjcmVhdGUgYSBgbmV3IEdyb3VwKClgIGluc3RlYWQgb2YgdXNpbmcgYFRXRUVOYCBhcyBhXG4gKiBncm91cC5cbiAqXG4gKiBPbGQgY29kZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0ICogYXMgVFdFRU4gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gKlxuICogLy8uLi5cbiAqXG4gKiBjb25zdCB0d2VlbiA9IG5ldyBUV0VFTi5Ud2VlbihvYmopXG4gKiBjb25zdCB0d2VlbjIgPSBuZXcgVFdFRU4uVHdlZW4ob2JqMilcbiAqXG4gKiAvLy4uLlxuICpcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAqICAgVFdFRU4udXBkYXRlKHRpbWUpXG4gKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICogfSlcbiAqIGBgYFxuICpcbiAqIE5ldyBjb2RlOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQge1R3ZWVuLCBHcm91cH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gKlxuICogLy8uLi5cbiAqXG4gKiBjb25zdCB0d2VlbiA9IG5ldyBUd2VlbihvYmopXG4gKiBjb25zdCB0d2VlbjIgPSBuZXcgVFdFRU4uVHdlZW4ob2JqMilcbiAqXG4gKiAvLy4uLlxuICpcbiAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKClcbiAqIGdyb3VwLmFkZCh0d2VlbilcbiAqIGdyb3VwLmFkZCh0d2VlbjIpXG4gKlxuICogLy8uLi5cbiAqXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gKiAgIGdyb3VwLnVwZGF0ZSh0aW1lKVxuICogICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcClcbiAqIH0pXG4gKiBgYGBcbiAqL1xudmFyIGFkZCA9IFRXRUVOLmFkZC5iaW5kKFRXRUVOKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcbiAqIHJlbGVhc2UuIFRvIG1pZ3JhdGUsIGNyZWF0ZSBhIGBuZXcgR3JvdXAoKWAgaW5zdGVhZCBvZiB1c2luZyBgVFdFRU5gIGFzIGFcbiAqIGdyb3VwLlxuICpcbiAqIE9sZCBjb2RlOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcbiAqXG4gKiAvLy4uLlxuICpcbiAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcbiAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICpcbiAqIC8vLi4uXG4gKlxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xuICogICBUV0VFTi51cGRhdGUodGltZSlcbiAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gKiB9KVxuICogYGBgXG4gKlxuICogTmV3IGNvZGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7VHdlZW4sIEdyb3VwfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcbiAqXG4gKiAvLy4uLlxuICpcbiAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcbiAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICpcbiAqIC8vLi4uXG4gKlxuICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKVxuICogZ3JvdXAuYWRkKHR3ZWVuKVxuICogZ3JvdXAuYWRkKHR3ZWVuMilcbiAqXG4gKiAvLy4uLlxuICpcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXG4gKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICogfSlcbiAqIGBgYFxuICovXG52YXIgcmVtb3ZlID0gVFdFRU4ucmVtb3ZlLmJpbmQoVFdFRU4pO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGUgZ2xvYmFsIFRXRUVOIEdyb3VwIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZvbGxvd2luZyBtYWpvclxuICogcmVsZWFzZS4gVG8gbWlncmF0ZSwgY3JlYXRlIGEgYG5ldyBHcm91cCgpYCBpbnN0ZWFkIG9mIHVzaW5nIGBUV0VFTmAgYXMgYVxuICogZ3JvdXAuXG4gKlxuICogT2xkIGNvZGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCAqIGFzIFRXRUVOIGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJ1xuICpcbiAqIC8vLi4uXG4gKlxuICogY29uc3QgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4ob2JqKVxuICogY29uc3QgdHdlZW4yID0gbmV3IFRXRUVOLlR3ZWVuKG9iajIpXG4gKlxuICogLy8uLi5cbiAqXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gKiAgIFRXRUVOLnVwZGF0ZSh0aW1lKVxuICogICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcClcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBOZXcgY29kZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHtUd2VlbiwgR3JvdXB9IGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJ1xuICpcbiAqIC8vLi4uXG4gKlxuICogY29uc3QgdHdlZW4gPSBuZXcgVHdlZW4ob2JqKVxuICogY29uc3QgdHdlZW4yID0gbmV3IFRXRUVOLlR3ZWVuKG9iajIpXG4gKlxuICogLy8uLi5cbiAqXG4gKiBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpXG4gKiBncm91cC5hZGQodHdlZW4pXG4gKiBncm91cC5hZGQodHdlZW4yKVxuICpcbiAqIC8vLi4uXG4gKlxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xuICogICBncm91cC51cGRhdGUodGltZSlcbiAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciB1cGRhdGUgPSBUV0VFTi51cGRhdGUuYmluZChUV0VFTik7XG52YXIgZXhwb3J0cyA9IHtcbiAgICBFYXNpbmc6IEVhc2luZyxcbiAgICBHcm91cDogR3JvdXAsXG4gICAgSW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGlvbixcbiAgICBub3c6IG5vdyxcbiAgICBTZXF1ZW5jZTogU2VxdWVuY2UsXG4gICAgbmV4dElkOiBuZXh0SWQsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFZFUlNJT046IFZFUlNJT04sXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcbiAgICAgKiByZWxlYXNlLiBUbyBtaWdyYXRlLCBjcmVhdGUgYSBgbmV3IEdyb3VwKClgIGluc3RlYWQgb2YgdXNpbmcgYFRXRUVOYCBhcyBhXG4gICAgICogZ3JvdXAuXG4gICAgICpcbiAgICAgKiBPbGQgY29kZTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0ICogYXMgVFdFRU4gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAgICAgKiAgIFRXRUVOLnVwZGF0ZSh0aW1lKVxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5ldyBjb2RlOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQge1R3ZWVuLCBHcm91cH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKClcbiAgICAgKiBncm91cC5hZGQodHdlZW4pXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcbiAgICAgKlxuICAgICAqIC8vLi4uXG4gICAgICpcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gICAgICogICBncm91cC51cGRhdGUodGltZSlcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0QWxsOiBnZXRBbGwsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcbiAgICAgKiByZWxlYXNlLiBUbyBtaWdyYXRlLCBjcmVhdGUgYSBgbmV3IEdyb3VwKClgIGluc3RlYWQgb2YgdXNpbmcgYFRXRUVOYCBhcyBhXG4gICAgICogZ3JvdXAuXG4gICAgICpcbiAgICAgKiBPbGQgY29kZTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0ICogYXMgVFdFRU4gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAgICAgKiAgIFRXRUVOLnVwZGF0ZSh0aW1lKVxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5ldyBjb2RlOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQge1R3ZWVuLCBHcm91cH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKClcbiAgICAgKiBncm91cC5hZGQodHdlZW4pXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcbiAgICAgKlxuICAgICAqIC8vLi4uXG4gICAgICpcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gICAgICogICBncm91cC51cGRhdGUodGltZSlcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcbiAgICAgKiByZWxlYXNlLiBUbyBtaWdyYXRlLCBjcmVhdGUgYSBgbmV3IEdyb3VwKClgIGluc3RlYWQgb2YgdXNpbmcgYFRXRUVOYCBhcyBhXG4gICAgICogZ3JvdXAuXG4gICAgICpcbiAgICAgKiBPbGQgY29kZTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0ICogYXMgVFdFRU4gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAgICAgKiAgIFRXRUVOLnVwZGF0ZSh0aW1lKVxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5ldyBjb2RlOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQge1R3ZWVuLCBHcm91cH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKClcbiAgICAgKiBncm91cC5hZGQodHdlZW4pXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcbiAgICAgKlxuICAgICAqIC8vLi4uXG4gICAgICpcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gICAgICogICBncm91cC51cGRhdGUodGltZSlcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYWRkOiBhZGQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcbiAgICAgKiByZWxlYXNlLiBUbyBtaWdyYXRlLCBjcmVhdGUgYSBgbmV3IEdyb3VwKClgIGluc3RlYWQgb2YgdXNpbmcgYFRXRUVOYCBhcyBhXG4gICAgICogZ3JvdXAuXG4gICAgICpcbiAgICAgKiBPbGQgY29kZTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0ICogYXMgVFdFRU4gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAgICAgKiAgIFRXRUVOLnVwZGF0ZSh0aW1lKVxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5ldyBjb2RlOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQge1R3ZWVuLCBHcm91cH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKClcbiAgICAgKiBncm91cC5hZGQodHdlZW4pXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcbiAgICAgKlxuICAgICAqIC8vLi4uXG4gICAgICpcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gICAgICogICBncm91cC51cGRhdGUodGltZSlcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcbiAgICAgKiByZWxlYXNlLiBUbyBtaWdyYXRlLCBjcmVhdGUgYSBgbmV3IEdyb3VwKClgIGluc3RlYWQgb2YgdXNpbmcgYFRXRUVOYCBhcyBhXG4gICAgICogZ3JvdXAuXG4gICAgICpcbiAgICAgKiBPbGQgY29kZTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0ICogYXMgVFdFRU4gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAgICAgKiAgIFRXRUVOLnVwZGF0ZSh0aW1lKVxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5ldyBjb2RlOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQge1R3ZWVuLCBHcm91cH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXG4gICAgICpcbiAgICAgKiAvLy4uLlxuICAgICAqXG4gICAgICogY29uc3QgdHdlZW4gPSBuZXcgVHdlZW4ob2JqKVxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxuICAgICAqXG4gICAgICogLy8uLi5cbiAgICAgKlxuICAgICAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKClcbiAgICAgKiBncm91cC5hZGQodHdlZW4pXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcbiAgICAgKlxuICAgICAqIC8vLi4uXG4gICAgICpcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gICAgICogICBncm91cC51cGRhdGUodGltZSlcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgdXBkYXRlOiB1cGRhdGUsXG59O1xuXG5leHBvcnQgeyBFYXNpbmcsIEdyb3VwLCBJbnRlcnBvbGF0aW9uLCBTZXF1ZW5jZSwgVHdlZW4sIFZFUlNJT04sIGFkZCwgZXhwb3J0cyBhcyBkZWZhdWx0LCBnZXRBbGwsIG5leHRJZCwgbm93LCByZW1vdmUsIHJlbW92ZUFsbCwgdXBkYXRlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1984\n")}}]);