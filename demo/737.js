"use strict";(self.webpackChunk_masatomakino_pixijs_basic_scrollbar=self.webpackChunk_masatomakino_pixijs_basic_scrollbar||[]).push([[737],{4687:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/ResizePlugin.mjs\n\n\n"use strict";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      "resizeTo",\n      /**\n       * The HTML element or window to automatically resize the\n       * renderer\'s view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */\n      {\n        set(dom) {\n          globalThis.removeEventListener("resize", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener("resize", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener("resize", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = Extensions/* ExtensionType */.nw.Application;\n\n\n//# sourceMappingURL=ResizePlugin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(901);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(9366);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/TickerPlugin.mjs\n\n\n\n\n"use strict";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      "ticker",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, ticker_const/* UPDATE_PRIORITY */.u.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker/* Ticker */.v.shared : new Ticker/* Ticker */.v();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = Extensions/* ExtensionType */.nw.Application;\n\n\n//# sourceMappingURL=TickerPlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(ResizePlugin);\nExtensions/* extensions */.Rw.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWE7O0FBRWQ7QUFDeEI7Ozs7Ozs7QUN4RjZEO0FBQ1A7QUFDUjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUNBQWU7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFNLGNBQWMsb0JBQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFhOztBQUVkO0FBQ3hCOzs7QUNoRTBEO0FBQ1I7QUFDQTs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxZQUFZO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9SZXNpemVQbHVnaW4ubWpzPzg3MDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9UaWNrZXJQbHVnaW4ubWpzPzMzYmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9pbml0Lm1qcz82MDcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJyZXNpemVUb1wiLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSFRNTCBlbGVtZW50IG9yIHdpbmRvdyB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB0aGVcbiAgICAgICAqIHJlbmRlcmVyJ3MgdmlldyBlbGVtZW50IHRvIG1hdGNoIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgKiBAbWVtYmVyIHtXaW5kb3d8SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAbmFtZSByZXNpemVUb1xuICAgICAgICogQG1lbWJlcm9mIGFwcC5BcHBsaWNhdGlvbiNcbiAgICAgICAqL1xuICAgICAge1xuICAgICAgICBzZXQoZG9tKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gZG9tO1xuICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jYW5jZWxSZXNpemUoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgIH07XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Jlc2l6ZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3Jlc2l6ZUlkKTtcbiAgICAgICAgdGhpcy5fcmVzaXplSWQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc2l6ZVRvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbmNlbFJlc2l6ZSgpO1xuICAgICAgbGV0IHdpZHRoO1xuICAgICAgbGV0IGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpIHtcbiAgICAgICAgd2lkdGggPSBnbG9iYWxUaGlzLmlubmVyV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGdsb2JhbFRoaXMuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB3aWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBvcHRpb25zLnJlc2l6ZVRvIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5xdWV1ZVJlc2l6ZSk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplKCk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZVRvID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5SZXNpemVQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgUmVzaXplUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi4vdGlja2VyL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tICcuLi90aWNrZXIvVGlja2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGlja2VyUGx1Z2luIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHBsdWdpbiB3aXRoIHNjb3BlIG9mIGFwcGxpY2F0aW9uIGluc3RhbmNlXG4gICAqIEBzdGF0aWNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFNlZSBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAqL1xuICBzdGF0aWMgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgICAgc2hhcmVkVGlja2VyOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICBcInRpY2tlclwiLFxuICAgICAge1xuICAgICAgICBzZXQodGlja2VyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5fdGlja2VyLnJlbW92ZSh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICB0aWNrZXIuYWRkKHRoaXMucmVuZGVyLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuTE9XKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnN0b3AgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xuICAgIH07XG4gICAgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xuICAgIH07XG4gICAgdGhpcy5fdGlja2VyID0gbnVsbDtcbiAgICB0aGlzLnRpY2tlciA9IG9wdGlvbnMuc2hhcmVkVGlja2VyID8gVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXIoKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvbi5cbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgY29uc3Qgb2xkVGlja2VyID0gdGhpcy5fdGlja2VyO1xuICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgb2xkVGlja2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgVGlja2VyUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVzaXplUGx1Z2luIH0gZnJvbSAnLi9SZXNpemVQbHVnaW4ubWpzJztcbmltcG9ydCB7IFRpY2tlclBsdWdpbiB9IGZyb20gJy4vVGlja2VyUGx1Z2luLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoUmVzaXplUGx1Z2luKTtcbmV4dGVuc2lvbnMuYWRkKFRpY2tlclBsdWdpbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4687\n')},9249:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterPipe.mjs\n\n\n"use strict";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      canBundle: false,\n      action: "pushFilter",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      action: "popFilter",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === "pushFilter") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === "popFilter") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs + 2 modules\nvar Geometry = __webpack_require__(1980);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(2692);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.y();\nfunction getFastGlobalBounds(target, bounds) {\n  bounds.clear();\n  _getGlobalBoundsRecursive(target, bounds);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  if (!target.isRenderGroupRoot) {\n    bounds.applyMatrix(target.renderGroup.worldTransform);\n  } else {\n    bounds.applyMatrix(target.renderGroup.localTransform);\n  }\n  return bounds;\n}\nfunction _getGlobalBoundsRecursive(target, bounds) {\n  if (target.localDisplayStatus !== 7 || !target.measurable) {\n    return;\n  }\n  const manageEffects = !!target.effects.length;\n  let localBounds = bounds;\n  if (target.isRenderGroupRoot || manageEffects) {\n    localBounds = matrixAndBoundsPool/* boundsPool */.W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, target.worldTransform);\n  } else {\n    if (target.renderPipeId) {\n      const viewBounds = target.bounds;\n      localBounds.addFrame(\n        viewBounds.minX,\n        viewBounds.minY,\n        viewBounds.maxX,\n        viewBounds.maxY,\n        target.groupTransform\n      );\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getGlobalBoundsRecursive(children[i], localBounds);\n    }\n  }\n  if (manageEffects) {\n    let advanced = false;\n    for (let i = 0; i < target.effects.length; i++) {\n      if (target.effects[i].addBounds) {\n        if (!advanced) {\n          advanced = true;\n          localBounds.applyMatrix(target.renderGroup.worldTransform);\n        }\n        target.effects[i].addBounds(localBounds, true);\n      }\n    }\n    if (advanced) {\n      localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n      bounds.addBounds(localBounds, target.relativeGroupTransform);\n    }\n    bounds.addBounds(localBounds);\n    matrixAndBoundsPool/* boundsPool */.W.return(localBounds);\n  } else if (target.isRenderGroupRoot) {\n    bounds.addBounds(localBounds, target.relativeGroupTransform);\n    matrixAndBoundsPool/* boundsPool */.W.return(localBounds);\n  }\n}\n\n\n//# sourceMappingURL=getFastGlobalBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs\n\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    renderable.addBounds(bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getRenderableBounds.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst quadGeometry = new Geometry/* Geometry */.Z({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      location: 0,\n      format: "float32x2",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup/* UniformGroup */.o({\n      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }\n    });\n    this._globalFilterBindGroup = new BindGroup/* BindGroup */.v({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n    let resolution = colorTextureSource._resolution;\n    let padding = 0;\n    let antialias = colorTextureSource.antialias;\n    let blendRequired = false;\n    let enabled = false;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias !== "inherit") {\n        if (filter.antialias === "on") {\n          antialias = true;\n        } else {\n          antialias = false;\n        }\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        (0,warn/* warn */.Z)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    bounds.scale(resolution).fit(renderer.renderTarget.rootViewPort).scale(1 / resolution).pad(padding).ceil();\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool/* TexturePool */.z.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      resolution,\n      antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture/* Texture */.x.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.z.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool/* TexturePool */.z.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.z.returnTexture(flip);\n      TexturePool/* TexturePool */.z.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool/* TexturePool */.z.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool/* TexturePool */.z.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point/* Point */.E.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture/* Texture */.x) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: "triangle-list"\n    });\n    if (renderer.type === types/* RendererType */.g.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds/* Bounds */.Y(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix/* Matrix */.y.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(FilterSystem);\nExtensions/* extensions */.Rw.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQix5QkFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQkFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRXdCO0FBQ3hCOzs7QUN0VjBEO0FBQ1o7QUFDSTs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxVQUFVO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvRmlsdGVyUGlwZS5tanM/NTg5MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRGYXN0R2xvYmFsQm91bmRzLm1qcz9hZWJiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldFJlbmRlcmFibGVCb3VuZHMubWpzPzI4N2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcz81ZTg4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL2luaXQubWpzP2Y3ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEZpbHRlclBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgcHVzaChmaWx0ZXJFZmZlY3QsIGNvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCByZW5kZXJQaXBlcyA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzO1xuICAgIHJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcImZpbHRlclwiLFxuICAgICAgY2FuQnVuZGxlOiBmYWxzZSxcbiAgICAgIGFjdGlvbjogXCJwdXNoRmlsdGVyXCIsXG4gICAgICBjb250YWluZXIsXG4gICAgICBmaWx0ZXJFZmZlY3RcbiAgICB9KTtcbiAgfVxuICBwb3AoX2ZpbHRlckVmZmVjdCwgX2NvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgIHJlbmRlclBpcGVJZDogXCJmaWx0ZXJcIixcbiAgICAgIGFjdGlvbjogXCJwb3BGaWx0ZXJcIixcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBleGVjdXRlKGluc3RydWN0aW9uKSB7XG4gICAgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwdXNoRmlsdGVyXCIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZpbHRlci5wdXNoKGluc3RydWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwb3BGaWx0ZXJcIikge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuRmlsdGVyUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiZmlsdGVyXCJcbn07XG5cbmV4cG9ydCB7IEZpbHRlclBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlclBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgYm91bmRzUG9vbCB9IGZyb20gJy4vdXRpbHMvbWF0cml4QW5kQm91bmRzUG9vbC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5mdW5jdGlvbiBnZXRGYXN0R2xvYmFsQm91bmRzKHRhcmdldCwgYm91bmRzKSB7XG4gIGJvdW5kcy5jbGVhcigpO1xuICBfZ2V0R2xvYmFsQm91bmRzUmVjdXJzaXZlKHRhcmdldCwgYm91bmRzKTtcbiAgaWYgKCFib3VuZHMuaXNWYWxpZCkge1xuICAgIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7XG4gIH1cbiAgaWYgKCF0YXJnZXQuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICBib3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICBib3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnJlbmRlckdyb3VwLmxvY2FsVHJhbnNmb3JtKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuZnVuY3Rpb24gX2dldEdsb2JhbEJvdW5kc1JlY3Vyc2l2ZSh0YXJnZXQsIGJvdW5kcykge1xuICBpZiAodGFyZ2V0LmxvY2FsRGlzcGxheVN0YXR1cyAhPT0gNyB8fCAhdGFyZ2V0Lm1lYXN1cmFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWFuYWdlRWZmZWN0cyA9ICEhdGFyZ2V0LmVmZmVjdHMubGVuZ3RoO1xuICBsZXQgbG9jYWxCb3VuZHMgPSBib3VuZHM7XG4gIGlmICh0YXJnZXQuaXNSZW5kZXJHcm91cFJvb3QgfHwgbWFuYWdlRWZmZWN0cykge1xuICAgIGxvY2FsQm91bmRzID0gYm91bmRzUG9vbC5nZXQoKS5jbGVhcigpO1xuICB9XG4gIGlmICh0YXJnZXQuYm91bmRzQXJlYSkge1xuICAgIGJvdW5kcy5hZGRSZWN0KHRhcmdldC5ib3VuZHNBcmVhLCB0YXJnZXQud29ybGRUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQucmVuZGVyUGlwZUlkKSB7XG4gICAgICBjb25zdCB2aWV3Qm91bmRzID0gdGFyZ2V0LmJvdW5kcztcbiAgICAgIGxvY2FsQm91bmRzLmFkZEZyYW1lKFxuICAgICAgICB2aWV3Qm91bmRzLm1pblgsXG4gICAgICAgIHZpZXdCb3VuZHMubWluWSxcbiAgICAgICAgdmlld0JvdW5kcy5tYXhYLFxuICAgICAgICB2aWV3Qm91bmRzLm1heFksXG4gICAgICAgIHRhcmdldC5ncm91cFRyYW5zZm9ybVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgX2dldEdsb2JhbEJvdW5kc1JlY3Vyc2l2ZShjaGlsZHJlbltpXSwgbG9jYWxCb3VuZHMpO1xuICAgIH1cbiAgfVxuICBpZiAobWFuYWdlRWZmZWN0cykge1xuICAgIGxldCBhZHZhbmNlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YXJnZXQuZWZmZWN0c1tpXS5hZGRCb3VuZHMpIHtcbiAgICAgICAgaWYgKCFhZHZhbmNlZCkge1xuICAgICAgICAgIGFkdmFuY2VkID0gdHJ1ZTtcbiAgICAgICAgICBsb2NhbEJvdW5kcy5hcHBseU1hdHJpeCh0YXJnZXQucmVuZGVyR3JvdXAud29ybGRUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5lZmZlY3RzW2ldLmFkZEJvdW5kcyhsb2NhbEJvdW5kcywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhZHZhbmNlZCkge1xuICAgICAgbG9jYWxCb3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtLmNvcHlUbyh0ZW1wTWF0cml4KS5pbnZlcnQoKSk7XG4gICAgICBib3VuZHMuYWRkQm91bmRzKGxvY2FsQm91bmRzLCB0YXJnZXQucmVsYXRpdmVHcm91cFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGJvdW5kcy5hZGRCb3VuZHMobG9jYWxCb3VuZHMpO1xuICAgIGJvdW5kc1Bvb2wucmV0dXJuKGxvY2FsQm91bmRzKTtcbiAgfSBlbHNlIGlmICh0YXJnZXQuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICBib3VuZHMuYWRkQm91bmRzKGxvY2FsQm91bmRzLCB0YXJnZXQucmVsYXRpdmVHcm91cFRyYW5zZm9ybSk7XG4gICAgYm91bmRzUG9vbC5yZXR1cm4obG9jYWxCb3VuZHMpO1xuICB9XG59XG5cbmV4cG9ydCB7IF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUsIGdldEZhc3RHbG9iYWxCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEZhc3RHbG9iYWxCb3VuZHMubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzKHJlbmRlcmFibGVzLCBib3VuZHMpIHtcbiAgYm91bmRzLmNsZWFyKCk7XG4gIGNvbnN0IHRlbXBNYXRyaXggPSBib3VuZHMubWF0cml4O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVuZGVyYWJsZSA9IHJlbmRlcmFibGVzW2ldO1xuICAgIGlmIChyZW5kZXJhYmxlLmdsb2JhbERpc3BsYXlTdGF0dXMgPCA3KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYm91bmRzLm1hdHJpeCA9IHJlbmRlcmFibGUud29ybGRUcmFuc2Zvcm07XG4gICAgcmVuZGVyYWJsZS5hZGRCb3VuZHMoYm91bmRzKTtcbiAgfVxuICBib3VuZHMubWF0cml4ID0gdGVtcE1hdHJpeDtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZXhwb3J0IHsgZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0UmVuZGVyYWJsZUJvdW5kcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyBCaW5kR3JvdXAgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvQmluZEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvdHlwZXMubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBnZXRGYXN0R2xvYmFsQm91bmRzIH0gZnJvbSAnLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRGYXN0R2xvYmFsQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzIH0gZnJvbSAnLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRSZW5kZXJhYmxlQm91bmRzLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgcXVhZEdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KHtcbiAgYXR0cmlidXRlczoge1xuICAgIGFQb3NpdGlvbjoge1xuICAgICAgYnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSksXG4gICAgICBsb2NhdGlvbjogMCxcbiAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgIHN0cmlkZTogMiAqIDQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9XG4gIH0sXG4gIGluZGV4QnVmZmVyOiBuZXcgVWludDMyQXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKVxufSk7XG5jbGFzcyBGaWx0ZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2ZpbHRlclN0YWNrSW5kZXggPSAwO1xuICAgIHRoaXMuX2ZpbHRlclN0YWNrID0gW107XG4gICAgdGhpcy5fZmlsdGVyR2xvYmFsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVJbnB1dFNpemU6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoNCksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVJbnB1dFBpeGVsOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1SW5wdXRDbGFtcDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdU91dHB1dEZyYW1lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1R2xvYmFsRnJhbWU6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoNCksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVPdXRwdXRUZXh0dXJlOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH1cbiAgICB9KTtcbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAgPSBuZXcgQmluZEdyb3VwKHt9KTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYWNrIHRleHR1cmUgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyLiBSZXF1aXJlcyB0aGUgZmlsdGVyIHRvIGhhdmUgYGJsZW5kUmVxdWlyZWRgIHNldCB0byB0cnVlLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBhY3RpdmVCYWNrVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlRmlsdGVyRGF0YT8uYmFja1RleHR1cmU7XG4gIH1cbiAgcHVzaChpbnN0cnVjdGlvbikge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBmaWx0ZXJzID0gaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0LmZpbHRlcnM7XG4gICAgaWYgKCF0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4XSkge1xuICAgICAgdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF0gPSB0aGlzLl9nZXRGaWx0ZXJEYXRhKCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckRhdGEgPSB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4XTtcbiAgICB0aGlzLl9maWx0ZXJTdGFja0luZGV4Kys7XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmaWx0ZXJEYXRhLnNraXAgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBib3VuZHMgPSBmaWx0ZXJEYXRhLmJvdW5kcztcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ucmVuZGVyYWJsZXMpIHtcbiAgICAgIGdldEdsb2JhbFJlbmRlcmFibGVCb3VuZHMoaW5zdHJ1Y3Rpb24ucmVuZGVyYWJsZXMsIGJvdW5kcyk7XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5maWx0ZXJFZmZlY3QuZmlsdGVyQXJlYSkge1xuICAgICAgYm91bmRzLmNsZWFyKCk7XG4gICAgICBib3VuZHMuYWRkUmVjdChpbnN0cnVjdGlvbi5maWx0ZXJFZmZlY3QuZmlsdGVyQXJlYSk7XG4gICAgICBib3VuZHMuYXBwbHlNYXRyaXgoaW5zdHJ1Y3Rpb24uY29udGFpbmVyLndvcmxkVHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0RmFzdEdsb2JhbEJvdW5kcyhpbnN0cnVjdGlvbi5jb250YWluZXIsIGJvdW5kcyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yVGV4dHVyZVNvdXJjZSA9IHJlbmRlcmVyLnJlbmRlclRhcmdldC5yb290UmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZS5zb3VyY2U7XG4gICAgbGV0IHJlc29sdXRpb24gPSBjb2xvclRleHR1cmVTb3VyY2UuX3Jlc29sdXRpb247XG4gICAgbGV0IHBhZGRpbmcgPSAwO1xuICAgIGxldCBhbnRpYWxpYXMgPSBjb2xvclRleHR1cmVTb3VyY2UuYW50aWFsaWFzO1xuICAgIGxldCBibGVuZFJlcXVpcmVkID0gZmFsc2U7XG4gICAgbGV0IGVuYWJsZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpbHRlciA9IGZpbHRlcnNbaV07XG4gICAgICByZXNvbHV0aW9uID0gTWF0aC5taW4ocmVzb2x1dGlvbiwgZmlsdGVyLnJlc29sdXRpb24pO1xuICAgICAgcGFkZGluZyArPSBmaWx0ZXIucGFkZGluZztcbiAgICAgIGlmIChmaWx0ZXIuYW50aWFsaWFzICE9PSBcImluaGVyaXRcIikge1xuICAgICAgICBpZiAoZmlsdGVyLmFudGlhbGlhcyA9PT0gXCJvblwiKSB7XG4gICAgICAgICAgYW50aWFsaWFzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbnRpYWxpYXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaXNDb21wYXRpYmxlID0gISEoZmlsdGVyLmNvbXBhdGlibGVSZW5kZXJlcnMgJiByZW5kZXJlci50eXBlKTtcbiAgICAgIGlmICghaXNDb21wYXRpYmxlKSB7XG4gICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLmJsZW5kUmVxdWlyZWQgJiYgIShyZW5kZXJlci5iYWNrQnVmZmVyPy51c2VCYWNrQnVmZmVyID8/IHRydWUpKSB7XG4gICAgICAgIHdhcm4oXCJCbGVuZCBmaWx0ZXIgcmVxdWlyZXMgYmFja0J1ZmZlciBvbiBXZWJHTCByZW5kZXJlciB0byBiZSBlbmFibGVkLiBTZXQgYHVzZUJhY2tCdWZmZXI6IHRydWVgIGluIHRoZSByZW5kZXJlciBvcHRpb25zLlwiKTtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVuYWJsZWQgPSBmaWx0ZXIuZW5hYmxlZCB8fCBlbmFibGVkO1xuICAgICAgYmxlbmRSZXF1aXJlZCA9IGJsZW5kUmVxdWlyZWQgfHwgZmlsdGVyLmJsZW5kUmVxdWlyZWQ7XG4gICAgfVxuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgZmlsdGVyRGF0YS5za2lwID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYm91bmRzLnNjYWxlKHJlc29sdXRpb24pLmZpdChyZW5kZXJlci5yZW5kZXJUYXJnZXQucm9vdFZpZXdQb3J0KS5zY2FsZSgxIC8gcmVzb2x1dGlvbikucGFkKHBhZGRpbmcpLmNlaWwoKTtcbiAgICBpZiAoIWJvdW5kcy5pc1Bvc2l0aXZlKSB7XG4gICAgICBmaWx0ZXJEYXRhLnNraXAgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWx0ZXJEYXRhLnNraXAgPSBmYWxzZTtcbiAgICBmaWx0ZXJEYXRhLmJvdW5kcyA9IGJvdW5kcztcbiAgICBmaWx0ZXJEYXRhLmJsZW5kUmVxdWlyZWQgPSBibGVuZFJlcXVpcmVkO1xuICAgIGZpbHRlckRhdGEuY29udGFpbmVyID0gaW5zdHJ1Y3Rpb24uY29udGFpbmVyO1xuICAgIGZpbHRlckRhdGEuZmlsdGVyRWZmZWN0ID0gaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0O1xuICAgIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclN1cmZhY2U7XG4gICAgZmlsdGVyRGF0YS5pbnB1dFRleHR1cmUgPSBUZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgYW50aWFsaWFzXG4gICAgKTtcbiAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuYmluZChmaWx0ZXJEYXRhLmlucHV0VGV4dHVyZSwgdHJ1ZSk7XG4gICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucHVzaCh7XG4gICAgICBvZmZzZXQ6IGJvdW5kc1xuICAgIH0pO1xuICB9XG4gIHBvcCgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5fZmlsdGVyU3RhY2tJbmRleC0tO1xuICAgIGNvbnN0IGZpbHRlckRhdGEgPSB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4XTtcbiAgICBpZiAoZmlsdGVyRGF0YS5za2lwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUZpbHRlckRhdGEgPSBmaWx0ZXJEYXRhO1xuICAgIGNvbnN0IGlucHV0VGV4dHVyZSA9IGZpbHRlckRhdGEuaW5wdXRUZXh0dXJlO1xuICAgIGNvbnN0IGJvdW5kcyA9IGZpbHRlckRhdGEuYm91bmRzO1xuICAgIGxldCBiYWNrVGV4dHVyZSA9IFRleHR1cmUuRU1QVFk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmZpbmlzaFJlbmRlclBhc3MoKTtcbiAgICBpZiAoZmlsdGVyRGF0YS5ibGVuZFJlcXVpcmVkKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0JvdW5kcyA9IHRoaXMuX2ZpbHRlclN0YWNrSW5kZXggPiAwID8gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleCAtIDFdLmJvdW5kcyA6IG51bGw7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQuZ2V0UmVuZGVyVGFyZ2V0KGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlKTtcbiAgICAgIGJhY2tUZXh0dXJlID0gdGhpcy5nZXRCYWNrVGV4dHVyZShyZW5kZXJUYXJnZXQsIGJvdW5kcywgcHJldmlvdXNCb3VuZHMpO1xuICAgIH1cbiAgICBmaWx0ZXJEYXRhLmJhY2tUZXh0dXJlID0gYmFja1RleHR1cmU7XG4gICAgY29uc3QgZmlsdGVycyA9IGZpbHRlckRhdGEuZmlsdGVyRWZmZWN0LmZpbHRlcnM7XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGlucHV0VGV4dHVyZS5zb3VyY2Uuc3R5bGUsIDIpO1xuICAgIHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cC5zZXRSZXNvdXJjZShiYWNrVGV4dHVyZS5zb3VyY2UsIDMpO1xuICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnBvcCgpO1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsdGVyc1swXS5hcHBseSh0aGlzLCBpbnB1dFRleHR1cmUsIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlLCBmYWxzZSk7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGlucHV0VGV4dHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBmbGlwID0gZmlsdGVyRGF0YS5pbnB1dFRleHR1cmU7XG4gICAgICBsZXQgZmxvcCA9IFRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKFxuICAgICAgICBib3VuZHMud2lkdGgsXG4gICAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICAgIGZsaXAuc291cmNlLl9yZXNvbHV0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgICBmaWx0ZXIuYXBwbHkodGhpcywgZmxpcCwgZmxvcCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHQgPSBmbGlwO1xuICAgICAgICBmbGlwID0gZmxvcDtcbiAgICAgICAgZmxvcCA9IHQ7XG4gICAgICB9XG4gICAgICBmaWx0ZXJzW2ldLmFwcGx5KHRoaXMsIGZsaXAsIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlLCBmYWxzZSk7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGZsaXApO1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShmbG9wKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlckRhdGEuYmxlbmRSZXF1aXJlZCkge1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShiYWNrVGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIGdldEJhY2tUZXh0dXJlKGxhc3RSZW5kZXJTdXJmYWNlLCBib3VuZHMsIHByZXZpb3VzQm91bmRzKSB7XG4gICAgY29uc3QgYmFja2dyb3VuZFJlc29sdXRpb24gPSBsYXN0UmVuZGVyU3VyZmFjZS5jb2xvclRleHR1cmUuc291cmNlLl9yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGJhY2tUZXh0dXJlID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgICBib3VuZHMud2lkdGgsXG4gICAgICBib3VuZHMuaGVpZ2h0LFxuICAgICAgYmFja2dyb3VuZFJlc29sdXRpb24sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgbGV0IHggPSBib3VuZHMubWluWDtcbiAgICBsZXQgeSA9IGJvdW5kcy5taW5ZO1xuICAgIGlmIChwcmV2aW91c0JvdW5kcykge1xuICAgICAgeCAtPSBwcmV2aW91c0JvdW5kcy5taW5YO1xuICAgICAgeSAtPSBwcmV2aW91c0JvdW5kcy5taW5ZO1xuICAgIH1cbiAgICB4ID0gTWF0aC5mbG9vcih4ICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIHkgPSBNYXRoLmZsb29yKHkgKiBiYWNrZ3JvdW5kUmVzb2x1dGlvbik7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0ICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGFyZ2V0LmNvcHlUb1RleHR1cmUoXG4gICAgICBsYXN0UmVuZGVyU3VyZmFjZSxcbiAgICAgIGJhY2tUZXh0dXJlLFxuICAgICAgeyB4LCB5IH0sXG4gICAgICB7IHdpZHRoLCBoZWlnaHQgfSxcbiAgICAgIHsgeDogMCwgeTogMCB9XG4gICAgKTtcbiAgICByZXR1cm4gYmFja1RleHR1cmU7XG4gIH1cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBmaWx0ZXJEYXRhID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF07XG4gICAgY29uc3QgYm91bmRzID0gZmlsdGVyRGF0YS5ib3VuZHM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gUG9pbnQuc2hhcmVkO1xuICAgIGNvbnN0IHByZXZpb3VzUmVuZGVyU3VyZmFjZSA9IGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlO1xuICAgIGNvbnN0IGlzRmluYWxUYXJnZXQgPSBwcmV2aW91c1JlbmRlclN1cmZhY2UgPT09IG91dHB1dDtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJvb3RSZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlLnNvdXJjZS5fcmVzb2x1dGlvbjtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5fZmlsdGVyU3RhY2tJbmRleCAtIDE7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA+IDAgJiYgdGhpcy5fZmlsdGVyU3RhY2tbY3VycmVudEluZGV4XS5za2lwKSB7XG4gICAgICAtLWN1cnJlbnRJbmRleDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRJbmRleCA+IDApIHtcbiAgICAgIHJlc29sdXRpb24gPSB0aGlzLl9maWx0ZXJTdGFja1tjdXJyZW50SW5kZXhdLmlucHV0VGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclVuaWZvcm1zID0gdGhpcy5fZmlsdGVyR2xvYmFsVW5pZm9ybXM7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBmaWx0ZXJVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBjb25zdCBvdXRwdXRGcmFtZSA9IHVuaWZvcm1zLnVPdXRwdXRGcmFtZTtcbiAgICBjb25zdCBpbnB1dFNpemUgPSB1bmlmb3Jtcy51SW5wdXRTaXplO1xuICAgIGNvbnN0IGlucHV0UGl4ZWwgPSB1bmlmb3Jtcy51SW5wdXRQaXhlbDtcbiAgICBjb25zdCBpbnB1dENsYW1wID0gdW5pZm9ybXMudUlucHV0Q2xhbXA7XG4gICAgY29uc3QgZ2xvYmFsRnJhbWUgPSB1bmlmb3Jtcy51R2xvYmFsRnJhbWU7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZSA9IHVuaWZvcm1zLnVPdXRwdXRUZXh0dXJlO1xuICAgIGlmIChpc0ZpbmFsVGFyZ2V0KSB7XG4gICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5fZmlsdGVyU3RhY2tJbmRleDtcbiAgICAgIHdoaWxlIChsYXN0SW5kZXggPiAwKSB7XG4gICAgICAgIGxhc3RJbmRleC0tO1xuICAgICAgICBjb25zdCBmaWx0ZXJEYXRhMiA9IHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXggLSAxXTtcbiAgICAgICAgaWYgKCFmaWx0ZXJEYXRhMi5za2lwKSB7XG4gICAgICAgICAgb2Zmc2V0LnggPSBmaWx0ZXJEYXRhMi5ib3VuZHMubWluWDtcbiAgICAgICAgICBvZmZzZXQueSA9IGZpbHRlckRhdGEyLmJvdW5kcy5taW5ZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXRwdXRGcmFtZVswXSA9IGJvdW5kcy5taW5YIC0gb2Zmc2V0Lng7XG4gICAgICBvdXRwdXRGcmFtZVsxXSA9IGJvdW5kcy5taW5ZIC0gb2Zmc2V0Lnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dEZyYW1lWzBdID0gMDtcbiAgICAgIG91dHB1dEZyYW1lWzFdID0gMDtcbiAgICB9XG4gICAgb3V0cHV0RnJhbWVbMl0gPSBpbnB1dC5mcmFtZS53aWR0aDtcbiAgICBvdXRwdXRGcmFtZVszXSA9IGlucHV0LmZyYW1lLmhlaWdodDtcbiAgICBpbnB1dFNpemVbMF0gPSBpbnB1dC5zb3VyY2Uud2lkdGg7XG4gICAgaW5wdXRTaXplWzFdID0gaW5wdXQuc291cmNlLmhlaWdodDtcbiAgICBpbnB1dFNpemVbMl0gPSAxIC8gaW5wdXRTaXplWzBdO1xuICAgIGlucHV0U2l6ZVszXSA9IDEgLyBpbnB1dFNpemVbMV07XG4gICAgaW5wdXRQaXhlbFswXSA9IGlucHV0LnNvdXJjZS5waXhlbFdpZHRoO1xuICAgIGlucHV0UGl4ZWxbMV0gPSBpbnB1dC5zb3VyY2UucGl4ZWxIZWlnaHQ7XG4gICAgaW5wdXRQaXhlbFsyXSA9IDEgLyBpbnB1dFBpeGVsWzBdO1xuICAgIGlucHV0UGl4ZWxbM10gPSAxIC8gaW5wdXRQaXhlbFsxXTtcbiAgICBpbnB1dENsYW1wWzBdID0gMC41ICogaW5wdXRQaXhlbFsyXTtcbiAgICBpbnB1dENsYW1wWzFdID0gMC41ICogaW5wdXRQaXhlbFszXTtcbiAgICBpbnB1dENsYW1wWzJdID0gaW5wdXQuZnJhbWUud2lkdGggKiBpbnB1dFNpemVbMl0gLSAwLjUgKiBpbnB1dFBpeGVsWzJdO1xuICAgIGlucHV0Q2xhbXBbM10gPSBpbnB1dC5mcmFtZS5oZWlnaHQgKiBpbnB1dFNpemVbM10gLSAwLjUgKiBpbnB1dFBpeGVsWzNdO1xuICAgIGNvbnN0IHJvb3RUZXh0dXJlID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUYXJnZXQucm9vdFJlbmRlclRhcmdldC5jb2xvclRleHR1cmU7XG4gICAgZ2xvYmFsRnJhbWVbMF0gPSBvZmZzZXQueCAqIHJlc29sdXRpb247XG4gICAgZ2xvYmFsRnJhbWVbMV0gPSBvZmZzZXQueSAqIHJlc29sdXRpb247XG4gICAgZ2xvYmFsRnJhbWVbMl0gPSByb290VGV4dHVyZS5zb3VyY2Uud2lkdGggKiByZXNvbHV0aW9uO1xuICAgIGdsb2JhbEZyYW1lWzNdID0gcm9vdFRleHR1cmUuc291cmNlLmhlaWdodCAqIHJlc29sdXRpb247XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUYXJnZXQuZ2V0UmVuZGVyVGFyZ2V0KG91dHB1dCk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmJpbmQob3V0cHV0LCAhIWNsZWFyKTtcbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgb3V0cHV0VGV4dHVyZVswXSA9IG91dHB1dC5mcmFtZS53aWR0aDtcbiAgICAgIG91dHB1dFRleHR1cmVbMV0gPSBvdXRwdXQuZnJhbWUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRUZXh0dXJlWzBdID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgICAgb3V0cHV0VGV4dHVyZVsxXSA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG4gICAgfVxuICAgIG91dHB1dFRleHR1cmVbMl0gPSByZW5kZXJUYXJnZXQuaXNSb290ID8gLTEgOiAxO1xuICAgIGZpbHRlclVuaWZvcm1zLnVwZGF0ZSgpO1xuICAgIGlmIChyZW5kZXJlci5yZW5kZXJQaXBlcy51bmlmb3JtQmF0Y2gpIHtcbiAgICAgIGNvbnN0IGJhdGNoVW5pZm9ybXMgPSByZW5kZXJlci5yZW5kZXJQaXBlcy51bmlmb3JtQmF0Y2guZ2V0VWJvUmVzb3VyY2UoZmlsdGVyVW5pZm9ybXMpO1xuICAgICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGJhdGNoVW5pZm9ybXMsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoZmlsdGVyVW5pZm9ybXMsIDApO1xuICAgIH1cbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoaW5wdXQuc291cmNlLCAxKTtcbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoaW5wdXQuc291cmNlLnN0eWxlLCAyKTtcbiAgICBmaWx0ZXIuZ3JvdXBzWzBdID0gdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwO1xuICAgIHJlbmRlcmVyLmVuY29kZXIuZHJhdyh7XG4gICAgICBnZW9tZXRyeTogcXVhZEdlb21ldHJ5LFxuICAgICAgc2hhZGVyOiBmaWx0ZXIsXG4gICAgICBzdGF0ZTogZmlsdGVyLl9zdGF0ZSxcbiAgICAgIHRvcG9sb2d5OiBcInRyaWFuZ2xlLWxpc3RcIlxuICAgIH0pO1xuICAgIGlmIChyZW5kZXJlci50eXBlID09PSBSZW5kZXJlclR5cGUuV0VCR0wpIHtcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5maW5pc2hSZW5kZXJQYXNzKCk7XG4gICAgfVxuICB9XG4gIF9nZXRGaWx0ZXJEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBza2lwOiBmYWxzZSxcbiAgICAgIGlucHV0VGV4dHVyZTogbnVsbCxcbiAgICAgIGJvdW5kczogbmV3IEJvdW5kcygpLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgZmlsdGVyRWZmZWN0OiBudWxsLFxuICAgICAgYmxlbmRSZXF1aXJlZDogZmFsc2UsXG4gICAgICBwcmV2aW91c1JlbmRlclN1cmZhY2U6IG51bGxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSBfaW5wdXQgbm9ybWFsaXplZCBjb29yZGluYXRlc18gdG8gdGhpcyBtYXRyaXggdG8gZ2V0IF9zcHJpdGUgdGV4dHVyZSBub3JtYWxpemVkIGNvb3JkaW5hdGVzXy5cbiAgICpcbiAgICogVXNlIGBvdXRwdXRNYXRyaXggKiB2VGV4dHVyZUNvb3JkYCBpbiB0aGUgc2hhZGVyLlxuICAgKiBAcGFyYW0gb3V0cHV0TWF0cml4IC0gVGhlIG1hdHJpeCB0byBvdXRwdXQgdG8uXG4gICAqIEBwYXJhbSB7U3ByaXRlfSBzcHJpdGUgLSBUaGUgc3ByaXRlIHRvIG1hcCB0by5cbiAgICogQHJldHVybnMgVGhlIG1hcHBlZCBtYXRyaXguXG4gICAqL1xuICBjYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBzcHJpdGUpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fYWN0aXZlRmlsdGVyRGF0YTtcbiAgICBjb25zdCBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguc2V0KFxuICAgICAgZGF0YS5pbnB1dFRleHR1cmUuX3NvdXJjZS53aWR0aCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgZGF0YS5pbnB1dFRleHR1cmUuX3NvdXJjZS5oZWlnaHQsXG4gICAgICBkYXRhLmJvdW5kcy5taW5YLFxuICAgICAgZGF0YS5ib3VuZHMubWluWVxuICAgICk7XG4gICAgY29uc3Qgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm0uY29weVRvKE1hdHJpeC5zaGFyZWQpO1xuICAgIHdvcmxkVHJhbnNmb3JtLmludmVydCgpO1xuICAgIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKTtcbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoXG4gICAgICAxIC8gc3ByaXRlLnRleHR1cmUuZnJhbWUud2lkdGgsXG4gICAgICAxIC8gc3ByaXRlLnRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKHNwcml0ZS5hbmNob3IueCwgc3ByaXRlLmFuY2hvci55KTtcbiAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuRmlsdGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJmaWx0ZXJcIlxufTtcblxuZXhwb3J0IHsgRmlsdGVyU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgRmlsdGVyUGlwZSB9IGZyb20gJy4vRmlsdGVyUGlwZS5tanMnO1xuaW1wb3J0IHsgRmlsdGVyU3lzdGVtIH0gZnJvbSAnLi9GaWx0ZXJTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChGaWx0ZXJTeXN0ZW0pO1xuZXh0ZW5zaW9ucy5hZGQoRmlsdGVyUGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9249\n')},5774:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   y: () => (/* binding */ batchSamplersUniformGroup)\n/* harmony export */ });\n/* harmony import */ var _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4589);\n/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3870);\n\n\n\n"use strict";\nconst sampleValues = new Int32Array(_batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A);\nfor (let i = 0; i < _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A; i++) {\n  sampleValues[i] = i;\n}\nconst batchSamplersUniformGroup = new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__/* .UniformGroup */ .o({\n  uTextures: { value: sampleValues, type: `i32`, size: _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A }\n}, { isStatic: true });\n\n\n//# sourceMappingURL=batchSamplersUniformGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc3NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRTtBQUNHOztBQUVwRTtBQUNBLG9DQUFvQyw0RUFBWTtBQUNoRCxnQkFBZ0IsSUFBSSw0RUFBWSxFQUFFO0FBQ2xDO0FBQ0E7QUFDQSxzQ0FBc0Msa0ZBQVk7QUFDbEQsZUFBZSx3Q0FBd0MsNEVBQVk7QUFDbkUsQ0FBQyxJQUFJLGdCQUFnQjs7QUFFZ0I7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cC5tanM/NDQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNQVhfVEVYVFVSRVMgfSBmcm9tICcuLi8uLi8uLi9iYXRjaGVyL3NoYXJlZC9jb25zdC5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShNQVhfVEVYVFVSRVMpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfVEVYVFVSRVM7IGkrKykge1xuICBzYW1wbGVWYWx1ZXNbaV0gPSBpO1xufVxuY29uc3QgYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cCA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICB1VGV4dHVyZXM6IHsgdmFsdWU6IHNhbXBsZVZhbHVlcywgdHlwZTogYGkzMmAsIHNpemU6IE1BWF9URVhUVVJFUyB9XG59LCB7IGlzU3RhdGljOiB0cnVlIH0pO1xuXG5leHBvcnQgeyBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5774\n')},131:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ CanvasPool)\n/* harmony export */ });\n/* unused harmony export CanvasPoolClass */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4181);\n\n\n\n"use strict";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext("2d");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minWidth);\n    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const { width, height } = canvasAndContext.canvas;\n    const key = (width << 17) + (height << 1);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\n\n//# sourceMappingURL=CanvasPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRTtBQUNOOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0VBQVE7QUFDdkIsZ0JBQWdCLHdFQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanM/NGQwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgbmV4dFBvdzIgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9taXNjL3BvdzIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYW52YXNQb29sQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNPcHRpb25zKSB7XG4gICAgdGhpcy5fY2FudmFzUG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FudmFzT3B0aW9ucyA9IGNhbnZhc09wdGlvbnMgfHwge307XG4gICAgdGhpcy5lbmFibGVGdWxsU2NyZWVuID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGV4dHVyZSB3aXRoIHBhcmFtcyB0aGF0IHdlcmUgc3BlY2lmaWVkIGluIHBvb2wgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBwaXhlbFdpZHRoIC0gV2lkdGggb2YgdGV4dHVyZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSBwaXhlbEhlaWdodCAtIEhlaWdodCBvZiB0ZXh0dXJlIGluIHBpeGVscy5cbiAgICovXG4gIF9jcmVhdGVDYW52YXNBbmRDb250ZXh0KHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0KSB7XG4gICAgY29uc3QgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBwaXhlbFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwaXhlbEhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICByZXR1cm4geyBjYW52YXMsIGNvbnRleHQgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIFBvd2VyLW9mLVR3byByZW5kZXIgdGV4dHVyZSBvciBmdWxsU2NyZWVuIHRleHR1cmVcbiAgICogQHBhcmFtIG1pbldpZHRoIC0gVGhlIG1pbmltdW0gd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gbWluSGVpZ2h0IC0gVGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgcmVuZGVyIHRleHR1cmUuXG4gICAqL1xuICBnZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dChtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uID0gMSkge1xuICAgIG1pbldpZHRoID0gTWF0aC5jZWlsKG1pbldpZHRoICogcmVzb2x1dGlvbiAtIDFlLTYpO1xuICAgIG1pbkhlaWdodCA9IE1hdGguY2VpbChtaW5IZWlnaHQgKiByZXNvbHV0aW9uIC0gMWUtNik7XG4gICAgbWluV2lkdGggPSBuZXh0UG93MihtaW5XaWR0aCk7XG4gICAgbWluSGVpZ2h0ID0gbmV4dFBvdzIobWluSGVpZ2h0KTtcbiAgICBjb25zdCBrZXkgPSAobWluV2lkdGggPDwgMTcpICsgKG1pbkhlaWdodCA8PCAxKTtcbiAgICBpZiAoIXRoaXMuX2NhbnZhc1Bvb2xba2V5XSkge1xuICAgICAgdGhpcy5fY2FudmFzUG9vbFtrZXldID0gW107XG4gICAgfVxuICAgIGxldCBjYW52YXNBbmRDb250ZXh0ID0gdGhpcy5fY2FudmFzUG9vbFtrZXldLnBvcCgpO1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dCkge1xuICAgICAgY2FudmFzQW5kQ29udGV4dCA9IHRoaXMuX2NyZWF0ZUNhbnZhc0FuZENvbnRleHQobWluV2lkdGgsIG1pbkhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNBbmRDb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBQbGFjZSBhIHJlbmRlciB0ZXh0dXJlIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIGNhbnZhc0FuZENvbnRleHRcbiAgICovXG4gIHJldHVybkNhbnZhc0FuZENvbnRleHQoY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzQW5kQ29udGV4dC5jYW52YXM7XG4gICAgY29uc3Qga2V5ID0gKHdpZHRoIDw8IDE3KSArIChoZWlnaHQgPDwgMSk7XG4gICAgdGhpcy5fY2FudmFzUG9vbFtrZXldLnB1c2goY2FudmFzQW5kQ29udGV4dCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2FudmFzUG9vbCA9IHt9O1xuICB9XG59XG5jb25zdCBDYW52YXNQb29sID0gbmV3IENhbnZhc1Bvb2xDbGFzcygpO1xuXG5leHBvcnQgeyBDYW52YXNQb29sLCBDYW52YXNQb29sQ2xhc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1Bvb2wubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///131\n')},9010:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(4108);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs\nvar BatchableGraphics = __webpack_require__(26);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State/* State */.Z.for2d();\n    // batchable graphics list, used to render batches\n    this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics._didGraphicsUpdate) {\n      graphics._didGraphicsUpdate = false;\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const batches = this._graphicsBatchesHash[graphics.uid];\n    if (batches) {\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        batch.batcher.updateElement(batch);\n      }\n    }\n  }\n  destroyRenderable(graphics) {\n    if (this._graphicsBatchesHash[graphics.uid]) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (wasBatched) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n    if (gpuContext.isBatchable) {\n      this._initBatchesForRenderable(graphics);\n    }\n    graphics.batched = gpuContext.isBatchable;\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getBatchesForRenderable(graphics);\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getBatchesForRenderable(graphics) {\n    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n  }\n  _initBatchesForRenderable(graphics) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    const batches = gpuContext.batches.map((batch) => {\n      const batchClone = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n    this._graphicsBatchesHash[graphics.uid] = batches;\n    graphics.on("destroyed", () => {\n      this.destroyRenderable(graphics);\n    });\n    return batches;\n  }\n  _removeBatchForRenderable(graphicsUid) {\n    this._graphicsBatchesHash[graphicsUid].forEach((batch) => {\n      PoolGroup/* BigPool */.u.return(batch);\n    });\n    this._graphicsBatchesHash[graphicsUid] = null;\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n    for (const i in this._graphicsBatchesHash) {\n      this._removeBatchForRenderable(i);\n    }\n    this._graphicsBatchesHash = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "graphics"\n};\n\n\n//# sourceMappingURL=GraphicsPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(GraphicsPipe);\nExtensions/* extensions */.Rw.add(GraphicsContextSystem/* GraphicsContextSystem */.hJ);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFtRTtBQUNTO0FBQ2hCO0FBQ0k7QUFDSjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBTyxLQUFLLDBDQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUFPO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUV3QjtBQUN4Qjs7O0FDNUk2RDtBQUNjO0FBQ2xCOztBQUV6RDtBQUNBLDZCQUFVLEtBQUssWUFBWTtBQUMzQiw2QkFBVSxLQUFLLG1EQUFxQjtBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NQaXBlLm1qcz9lNDJkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9pbml0Lm1qcz9iNDMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSB9IGZyb20gJy4uL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlR3JhcGhpY3MgfSBmcm9tICcuL0JhdGNoYWJsZUdyYXBoaWNzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3JhcGhpY3NQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIsIGFkYXB0b3IpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICAvLyBiYXRjaGFibGUgZ3JhcGhpY3MgbGlzdCwgdXNlZCB0byByZW5kZXIgYmF0Y2hlc1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgdGhpcy5fYWRhcHRvci5pbml0KCk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3Qgd2FzQmF0Y2hlZCA9ICEhdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljcy51aWRdO1xuICAgIGNvbnN0IGdwdUNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dC51cGRhdGVHcHVDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChncHVDb250ZXh0LmlzQmF0Y2hhYmxlIHx8IHdhc0JhdGNoZWQgIT09IGdwdUNvbnRleHQuaXNCYXRjaGFibGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShncmFwaGljcywgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChncmFwaGljcy5jb250ZXh0KTtcbiAgICBpZiAoZ3JhcGhpY3MuX2RpZEdyYXBoaWNzVXBkYXRlKSB7XG4gICAgICBncmFwaGljcy5fZGlkR3JhcGhpY3NVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlYnVpbGQoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICBpZiAoZ3B1Q29udGV4dC5pc0JhdGNoYWJsZSkge1xuICAgICAgdGhpcy5fYWRkVG9CYXRjaGVyKGdyYXBoaWNzLCBpbnN0cnVjdGlvblNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKGdyYXBoaWNzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF07XG4gICAgaWYgKGJhdGNoZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICAgIGJhdGNoLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgaWYgKHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXSkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzLnVpZCk7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGUoZ3JhcGhpY3MpIHtcbiAgICBpZiAoIWdyYXBoaWNzLmlzUmVuZGVyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3QgY29udGV4dFN5c3RlbSA9IHJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dDtcbiAgICBpZiAoIWNvbnRleHRTeXN0ZW0uZ2V0R3B1Q29udGV4dChjb250ZXh0KS5iYXRjaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaGFkZXIgPSBjb250ZXh0LmN1c3RvbVNoYWRlciB8fCB0aGlzLl9hZGFwdG9yLnNoYWRlcjtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IGdyYXBoaWNzLmdyb3VwQmxlbmRNb2RlO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSBzaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gZ3JhcGhpY3MuZ3JvdXBUcmFuc2Zvcm07XG4gICAgbG9jYWxVbmlmb3Jtcy51Um91bmQgPSByZW5kZXJlci5fcm91bmRQaXhlbHMgfCBncmFwaGljcy5fcm91bmRQaXhlbHM7XG4gICAgY29sb3IzMkJpdFRvVW5pZm9ybShcbiAgICAgIGdyYXBoaWNzLmdyb3VwQ29sb3JBbHBoYSxcbiAgICAgIGxvY2FsVW5pZm9ybXMudUNvbG9yLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fYWRhcHRvci5leGVjdXRlKHRoaXMsIGdyYXBoaWNzKTtcbiAgfVxuICBfcmVidWlsZChncmFwaGljcykge1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSAhIXRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXTtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChncmFwaGljcy5jb250ZXh0KTtcbiAgICBpZiAod2FzQmF0Y2hlZCkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzLnVpZCk7XG4gICAgfVxuICAgIGlmIChncHVDb250ZXh0LmlzQmF0Y2hhYmxlKSB7XG4gICAgICB0aGlzLl9pbml0QmF0Y2hlc0ZvclJlbmRlcmFibGUoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICBncmFwaGljcy5iYXRjaGVkID0gZ3B1Q29udGV4dC5pc0JhdGNoYWJsZTtcbiAgfVxuICBfYWRkVG9CYXRjaGVyKGdyYXBoaWNzLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGJhdGNoUGlwZSA9IHRoaXMucmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2g7XG4gICAgY29uc3QgYmF0Y2hlcyA9IHRoaXMuX2dldEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoUGlwZS5hZGRUb0JhdGNoKGJhdGNoLCBpbnN0cnVjdGlvblNldCk7XG4gICAgfVxuICB9XG4gIF9nZXRCYXRjaGVzRm9yUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIHJldHVybiB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF0gfHwgdGhpcy5faW5pdEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKTtcbiAgfVxuICBfaW5pdEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMucmVuZGVyZXIuZ3JhcGhpY3NDb250ZXh0LmdldEdwdUNvbnRleHQoY29udGV4dCk7XG4gICAgY29uc3Qgcm91bmRQaXhlbHMgPSB0aGlzLnJlbmRlcmVyLl9yb3VuZFBpeGVscyB8IGdyYXBoaWNzLl9yb3VuZFBpeGVscztcbiAgICBjb25zdCBiYXRjaGVzID0gZ3B1Q29udGV4dC5iYXRjaGVzLm1hcCgoYmF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IGJhdGNoQ2xvbmUgPSBCaWdQb29sLmdldChCYXRjaGFibGVHcmFwaGljcyk7XG4gICAgICBiYXRjaC5jb3B5VG8oYmF0Y2hDbG9uZSk7XG4gICAgICBiYXRjaENsb25lLnJlbmRlcmFibGUgPSBncmFwaGljcztcbiAgICAgIGJhdGNoQ2xvbmUucm91bmRQaXhlbHMgPSByb3VuZFBpeGVscztcbiAgICAgIHJldHVybiBiYXRjaENsb25lO1xuICAgIH0pO1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXSA9IGJhdGNoZXM7XG4gICAgZ3JhcGhpY3Mub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShncmFwaGljcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJhdGNoZXM7XG4gIH1cbiAgX3JlbW92ZUJhdGNoRm9yUmVuZGVyYWJsZShncmFwaGljc1VpZCkge1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3NVaWRdLmZvckVhY2goKGJhdGNoKSA9PiB7XG4gICAgICBCaWdQb29sLnJldHVybihiYXRjaCk7XG4gICAgfSk7XG4gICAgdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljc1VpZF0gPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fYWRhcHRvci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYWRhcHRvciA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2gpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUJhdGNoRm9yUmVuZGVyYWJsZShpKTtcbiAgICB9XG4gICAgdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaCA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcmFwaGljc1BpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImdyYXBoaWNzXCJcbn07XG5cbmV4cG9ydCB7IEdyYXBoaWNzUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzQ29udGV4dFN5c3RlbSB9IGZyb20gJy4vc2hhcmVkL0dyYXBoaWNzQ29udGV4dFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NQaXBlIH0gZnJvbSAnLi9zaGFyZWQvR3JhcGhpY3NQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoR3JhcGhpY3NQaXBlKTtcbmV4dGVuc2lvbnMuYWRkKEdyYXBoaWNzQ29udGV4dFN5c3RlbSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9010\n')},8540:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup/* UniformGroup */.o({\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uRound: { value: 0, type: "f32" }\n    });\n    this.localUniformsBindGroup = new BindGroup/* BindGroup */.v({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */ Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add({\n        renderPipeId: "mesh",\n        mesh\n      });\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    PoolGroup/* BigPool */.u.return(gpuMesh);\n    this._gpuBatchableMeshHash[mesh.uid] = null;\n  }\n  execute({ mesh }) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = mesh.groupBlendMode;\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on("destroyed", () => {\n      this.destroyRenderable(mesh);\n    });\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = PoolGroup/* BigPool */.u.get(BatchableMesh/* BatchableMesh */.X);\n    gpuMesh.mesh = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    gpuMesh.mesh = mesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        PoolGroup/* BigPool */.u.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "mesh"\n};\n\n\n//# sourceMappingURL=MeshPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU0MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ1Q7QUFDd0I7QUFDUztBQUMvQjtBQUNnQjtBQUN4Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFZO0FBQ3pDLDBCQUEwQixXQUFXLG9CQUFNLHlCQUF5QjtBQUNwRSxnQkFBZ0IsMERBQTBEO0FBQzFFLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsc0NBQXNDLDBCQUFTO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBTztBQUNYO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBTyxLQUFLLGtDQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRW9CO0FBQ3BCOzs7QUNsSjZEO0FBQ1o7O0FBRWpEO0FBQ0EsNkJBQVUsS0FBSyxRQUFRO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL21lc2gvc2hhcmVkL01lc2hQaXBlLm1qcz84ZmExIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL2luaXQubWpzPzUzZmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBjb2xvcjMyQml0VG9Vbmlmb3JtIH0gZnJvbSAnLi4vLi4vZ3JhcGhpY3MvZ3B1L2NvbG9yVG9Vbmlmb3JtLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVNZXNoIH0gZnJvbSAnLi9CYXRjaGFibGVNZXNoLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgTWVzaFBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgYWRhcHRvcikge1xuICAgIHRoaXMubG9jYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1Um91bmQ6IHsgdmFsdWU6IDAsIHR5cGU6IFwiZjMyXCIgfVxuICAgIH0pO1xuICAgIHRoaXMubG9jYWxVbmlmb3Jtc0JpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoe1xuICAgICAgMDogdGhpcy5sb2NhbFVuaWZvcm1zXG4gICAgfSk7XG4gICAgdGhpcy5fbWVzaERhdGFIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgdGhpcy5fYWRhcHRvci5pbml0KCk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKG1lc2gpIHtcbiAgICBjb25zdCBtZXNoRGF0YSA9IHRoaXMuX2dldE1lc2hEYXRhKG1lc2gpO1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSBtZXNoRGF0YS5iYXRjaGVkO1xuICAgIGNvbnN0IGlzQmF0Y2hlZCA9IG1lc2guYmF0Y2hlZDtcbiAgICBtZXNoRGF0YS5iYXRjaGVkID0gaXNCYXRjaGVkO1xuICAgIGlmICh3YXNCYXRjaGVkICE9PSBpc0JhdGNoZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNCYXRjaGVkKSB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IG1lc2guX2dlb21ldHJ5O1xuICAgICAgaWYgKGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICE9PSBtZXNoRGF0YS5pbmRleFNpemUgfHwgZ2VvbWV0cnkucG9zaXRpb25zLmxlbmd0aCAhPT0gbWVzaERhdGEudmVydGV4U2l6ZSkge1xuICAgICAgICBtZXNoRGF0YS5pbmRleFNpemUgPSBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgbWVzaERhdGEudmVydGV4U2l6ZSA9IGdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYmF0Y2hhYmxlTWVzaCA9IHRoaXMuX2dldEJhdGNoYWJsZU1lc2gobWVzaCk7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gbWVzaC50ZXh0dXJlO1xuICAgICAgaWYgKGJhdGNoYWJsZU1lc2gudGV4dHVyZS5fc291cmNlICE9PSB0ZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgICAgaWYgKGJhdGNoYWJsZU1lc2gudGV4dHVyZS5fc291cmNlICE9PSB0ZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gIWJhdGNoYWJsZU1lc2guYmF0Y2hlci5jaGVja0FuZFVwZGF0ZVRleHR1cmUoYmF0Y2hhYmxlTWVzaCwgdGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUobWVzaCwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBiYXRjaGVyID0gdGhpcy5yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaDtcbiAgICBjb25zdCB7IGJhdGNoZWQgfSA9IHRoaXMuX2dldE1lc2hEYXRhKG1lc2gpO1xuICAgIGlmIChiYXRjaGVkKSB7XG4gICAgICBjb25zdCBncHVCYXRjaGFibGVNZXNoID0gdGhpcy5fZ2V0QmF0Y2hhYmxlTWVzaChtZXNoKTtcbiAgICAgIGdwdUJhdGNoYWJsZU1lc2gudGV4dHVyZSA9IG1lc2guX3RleHR1cmU7XG4gICAgICBncHVCYXRjaGFibGVNZXNoLmdlb21ldHJ5ID0gbWVzaC5fZ2VvbWV0cnk7XG4gICAgICBiYXRjaGVyLmFkZFRvQmF0Y2goZ3B1QmF0Y2hhYmxlTWVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhdGNoZXIuYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgICAgcmVuZGVyUGlwZUlkOiBcIm1lc2hcIixcbiAgICAgICAgbWVzaFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUobWVzaCkge1xuICAgIGlmIChtZXNoLmJhdGNoZWQpIHtcbiAgICAgIGNvbnN0IGdwdUJhdGNoYWJsZU1lc2ggPSB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF07XG4gICAgICBncHVCYXRjaGFibGVNZXNoLnRleHR1cmUgPSBtZXNoLl90ZXh0dXJlO1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IG1lc2guX2dlb21ldHJ5O1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC5iYXRjaGVyLnVwZGF0ZUVsZW1lbnQoZ3B1QmF0Y2hhYmxlTWVzaCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKG1lc2gpIHtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdID0gbnVsbDtcbiAgICBjb25zdCBncHVNZXNoID0gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdO1xuICAgIEJpZ1Bvb2wucmV0dXJuKGdwdU1lc2gpO1xuICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW21lc2gudWlkXSA9IG51bGw7XG4gIH1cbiAgZXhlY3V0ZSh7IG1lc2ggfSkge1xuICAgIGlmICghbWVzaC5pc1JlbmRlcmFibGUpXG4gICAgICByZXR1cm47XG4gICAgbWVzaC5zdGF0ZS5ibGVuZE1vZGUgPSBtZXNoLmdyb3VwQmxlbmRNb2RlO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSB0aGlzLmxvY2FsVW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51bmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gbWVzaC5ncm91cFRyYW5zZm9ybTtcbiAgICBsb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVSb3VuZCA9IHRoaXMucmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgbWVzaC5fcm91bmRQaXhlbHM7XG4gICAgbG9jYWxVbmlmb3Jtcy51cGRhdGUoKTtcbiAgICBjb2xvcjMyQml0VG9Vbmlmb3JtKFxuICAgICAgbWVzaC5ncm91cENvbG9yQWxwaGEsXG4gICAgICBsb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVDb2xvcixcbiAgICAgIDBcbiAgICApO1xuICAgIHRoaXMuX2FkYXB0b3IuZXhlY3V0ZSh0aGlzLCBtZXNoKTtcbiAgfVxuICBfZ2V0TWVzaERhdGEobWVzaCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdIHx8IHRoaXMuX2luaXRNZXNoRGF0YShtZXNoKTtcbiAgfVxuICBfaW5pdE1lc2hEYXRhKG1lc2gpIHtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdID0ge1xuICAgICAgYmF0Y2hlZDogbWVzaC5iYXRjaGVkLFxuICAgICAgaW5kZXhTaXplOiBtZXNoLl9nZW9tZXRyeS5pbmRpY2VzPy5sZW5ndGgsXG4gICAgICB2ZXJ0ZXhTaXplOiBtZXNoLl9nZW9tZXRyeS5wb3NpdGlvbnM/Lmxlbmd0aFxuICAgIH07XG4gICAgbWVzaC5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKG1lc2gpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdO1xuICB9XG4gIF9nZXRCYXRjaGFibGVNZXNoKG1lc2gpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdIHx8IHRoaXMuX2luaXRCYXRjaGFibGVNZXNoKG1lc2gpO1xuICB9XG4gIF9pbml0QmF0Y2hhYmxlTWVzaChtZXNoKSB7XG4gICAgY29uc3QgZ3B1TWVzaCA9IEJpZ1Bvb2wuZ2V0KEJhdGNoYWJsZU1lc2gpO1xuICAgIGdwdU1lc2gubWVzaCA9IG1lc2g7XG4gICAgZ3B1TWVzaC50ZXh0dXJlID0gbWVzaC5fdGV4dHVyZTtcbiAgICBncHVNZXNoLnJvdW5kUGl4ZWxzID0gdGhpcy5yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBtZXNoLl9yb3VuZFBpeGVscztcbiAgICB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF0gPSBncHVNZXNoO1xuICAgIGdwdU1lc2gubWVzaCA9IG1lc2g7XG4gICAgcmV0dXJuIGdwdU1lc2g7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2gpIHtcbiAgICAgIGlmICh0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFtpXSkge1xuICAgICAgICBCaWdQb29sLnJldHVybih0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2ggPSBudWxsO1xuICAgIHRoaXMubG9jYWxVbmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5sb2NhbFVuaWZvcm1zQmluZEdyb3VwID0gbnVsbDtcbiAgICB0aGlzLl9hZGFwdG9yLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9hZGFwdG9yID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbk1lc2hQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJtZXNoXCJcbn07XG5cbmV4cG9ydCB7IE1lc2hQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNZXNoUGlwZSB9IGZyb20gJy4vc2hhcmVkL01lc2hQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoTWVzaFBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8540\n')},2653:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   X: () => (/* binding */ BatchableMesh)\n/* harmony export */ });\n\nclass BatchableMesh {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  get blendMode() {\n    return this.mesh.groupBlendMode;\n  }\n  reset() {\n    this.mesh = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometry.indices;\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const mesh = this.mesh;\n    const geometry = this.geometry;\n    const wt = mesh.groupTransform;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const positions = geometry.positions;\n    const uvBuffer = geometry.getBuffer("aUV");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    const abgr = mesh.groupColorAlpha;\n    for (let i = 0; i < positions.length; i += 2) {\n      const x = positions[i];\n      const y = positions[i + 1];\n      float32View[index] = a * x + c * y + tx;\n      float32View[index + 1] = b * x + d * y + ty;\n      float32View[index + 2] = transformedUvs[i];\n      float32View[index + 3] = transformedUvs[i + 1];\n      uint32View[index + 4] = abgr;\n      uint32View[index + 5] = textureIdAndRound;\n      index += 6;\n    }\n  }\n  get vertexSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\n\n//# sourceMappingURL=BatchableMesh.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY1My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL3NoYXJlZC9CYXRjaGFibGVNZXNoLm1qcz8wMzFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgQmF0Y2hhYmxlTWVzaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlciA9IG51bGw7XG4gICAgdGhpcy5iYXRjaCA9IG51bGw7XG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IDA7XG4gICAgdGhpcy5fdXZVcGRhdGVJZCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVNYXRyaXhVcGRhdGVJZCA9IC0xO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzaC5ncm91cEJsZW5kTW9kZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5iYXRjaGVyID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoID0gbnVsbDtcbiAgfVxuICBwYWNrSW5kZXgoaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuZ2VvbWV0cnkuaW5kaWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGV4QnVmZmVyW2luZGV4KytdID0gaW5kaWNlc1tpXSArIGluZGljZXNPZmZzZXQ7XG4gICAgfVxuICB9XG4gIHBhY2tBdHRyaWJ1dGVzKGZsb2F0MzJWaWV3LCB1aW50MzJWaWV3LCBpbmRleCwgdGV4dHVyZUlkKSB7XG4gICAgY29uc3QgbWVzaCA9IHRoaXMubWVzaDtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgY29uc3Qgd3QgPSBtZXNoLmdyb3VwVHJhbnNmb3JtO1xuICAgIGNvbnN0IHRleHR1cmVJZEFuZFJvdW5kID0gdGV4dHVyZUlkIDw8IDE2IHwgdGhpcy5yb3VuZFBpeGVscyAmIDY1NTM1O1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5wb3NpdGlvbnM7XG4gICAgY29uc3QgdXZCdWZmZXIgPSBnZW9tZXRyeS5nZXRCdWZmZXIoXCJhVVZcIik7XG4gICAgY29uc3QgdXZzID0gdXZCdWZmZXIuZGF0YTtcbiAgICBsZXQgdHJhbnNmb3JtZWRVdnMgPSB1dnM7XG4gICAgY29uc3QgdGV4dHVyZU1hdHJpeCA9IHRoaXMudGV4dHVyZS50ZXh0dXJlTWF0cml4O1xuICAgIGlmICghdGV4dHVyZU1hdHJpeC5pc1NpbXBsZSkge1xuICAgICAgdHJhbnNmb3JtZWRVdnMgPSB0aGlzLl90cmFuc2Zvcm1lZFV2cztcbiAgICAgIGlmICh0aGlzLl90ZXh0dXJlTWF0cml4VXBkYXRlSWQgIT09IHRleHR1cmVNYXRyaXguX3VwZGF0ZUlEIHx8IHRoaXMuX3V2VXBkYXRlSWQgIT09IHV2QnVmZmVyLl91cGRhdGVJRCkge1xuICAgICAgICBpZiAoIXRyYW5zZm9ybWVkVXZzIHx8IHRyYW5zZm9ybWVkVXZzLmxlbmd0aCA8IHV2cy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZFV2cyA9IHRoaXMuX3RyYW5zZm9ybWVkVXZzID0gbmV3IEZsb2F0MzJBcnJheSh1dnMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0dXJlTWF0cml4VXBkYXRlSWQgPSB0ZXh0dXJlTWF0cml4Ll91cGRhdGVJRDtcbiAgICAgICAgdGhpcy5fdXZVcGRhdGVJZCA9IHV2QnVmZmVyLl91cGRhdGVJRDtcbiAgICAgICAgdGV4dHVyZU1hdHJpeC5tdWx0aXBseVV2cyh1dnMsIHRyYW5zZm9ybWVkVXZzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWJnciA9IG1lc2guZ3JvdXBDb2xvckFscGhhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gcG9zaXRpb25zW2ldO1xuICAgICAgY29uc3QgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICBmbG9hdDMyVmlld1tpbmRleCArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAyXSA9IHRyYW5zZm9ybWVkVXZzW2ldO1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAzXSA9IHRyYW5zZm9ybWVkVXZzW2kgKyAxXTtcbiAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyA0XSA9IGFiZ3I7XG4gICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWRBbmRSb3VuZDtcbiAgICAgIGluZGV4ICs9IDY7XG4gICAgfVxuICB9XG4gIGdldCB2ZXJ0ZXhTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGggLyAyO1xuICB9XG4gIGdldCBpbmRleFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGg7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hhYmxlTWVzaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hhYmxlTWVzaC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2653\n')},4428:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   x: () => (/* binding */ MeshGeometry)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7494);\n/* harmony import */ var _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5324);\n/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1980);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(156);\n\n\n\n\n\n"use strict";\nconst _MeshGeometry = class _MeshGeometry extends _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .Z {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .P, "use new MeshGeometry({ positions, uvs, indices }) instead");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: positions,\n      label: "attribute-mesh-positions",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    const uvBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: uvs,\n      label: "attribute-mesh-uvs",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    const indexBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: indices,\n      label: "index-mesh-buffer",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.INDEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = "auto";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: "triangle-list",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\n\n//# sourceMappingURL=MeshGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStFO0FBQ0k7QUFDRTtBQUNSOztBQUU3RTtBQUNBLGtEQUFrRCxnR0FBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9GQUFXLENBQUMsMkVBQU0sMEJBQTBCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEZBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCx5QkFBeUIsMEZBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCw0QkFBNEIsMEZBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxTQUFTLDhGQUFXO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL3NoYXJlZC9NZXNoR2VvbWV0cnkubWpzPzFlODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgQnVmZmVyVXNhZ2UgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvY29uc3QubWpzJztcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX01lc2hHZW9tZXRyeSA9IGNsYXNzIF9NZXNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJ1c2UgbmV3IE1lc2hHZW9tZXRyeSh7IHBvc2l0aW9ucywgdXZzLCBpbmRpY2VzIH0pIGluc3RlYWRcIik7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBwb3NpdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIHV2czogYXJnc1sxXSxcbiAgICAgICAgaW5kaWNlczogYXJnc1syXVxuICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX01lc2hHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IG9wdGlvbnMucG9zaXRpb25zIHx8IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKTtcbiAgICBjb25zdCB1dnMgPSBvcHRpb25zLnV2cyB8fCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSk7XG4gICAgY29uc3QgaW5kaWNlcyA9IG9wdGlvbnMuaW5kaWNlcyB8fCBuZXcgVWludDMyQXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbiAgICBjb25zdCBzaHJpbmtUb0ZpdCA9IG9wdGlvbnMuc2hyaW5rQnVmZmVyc1RvRml0O1xuICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gbmV3IEJ1ZmZlcih7XG4gICAgICBkYXRhOiBwb3NpdGlvbnMsXG4gICAgICBsYWJlbDogXCJhdHRyaWJ1dGUtbWVzaC1wb3NpdGlvbnNcIixcbiAgICAgIHNocmlua1RvRml0LFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgfSk7XG4gICAgY29uc3QgdXZCdWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IHV2cyxcbiAgICAgIGxhYmVsOiBcImF0dHJpYnV0ZS1tZXNoLXV2c1wiLFxuICAgICAgc2hyaW5rVG9GaXQsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuVkVSVEVYIHwgQnVmZmVyVXNhZ2UuQ09QWV9EU1RcbiAgICB9KTtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogaW5kaWNlcyxcbiAgICAgIGxhYmVsOiBcImluZGV4LW1lc2gtYnVmZmVyXCIsXG4gICAgICBzaHJpbmtUb0ZpdCxcbiAgICAgIHVzYWdlOiBCdWZmZXJVc2FnZS5JTkRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBhUG9zaXRpb246IHtcbiAgICAgICAgICBidWZmZXI6IHBvc2l0aW9uQnVmZmVyLFxuICAgICAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBhVVY6IHtcbiAgICAgICAgICBidWZmZXI6IHV2QnVmZmVyLFxuICAgICAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5kZXhCdWZmZXIsXG4gICAgICB0b3BvbG9neTogb3B0aW9ucy50b3BvbG9neVxuICAgIH0pO1xuICAgIHRoaXMuYmF0Y2hNb2RlID0gXCJhdXRvXCI7XG4gIH1cbiAgLyoqIFRoZSBwb3NpdGlvbnMgb2YgdGhlIG1lc2guICovXG4gIGdldCBwb3NpdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5hUG9zaXRpb24uYnVmZmVyLmRhdGE7XG4gIH1cbiAgc2V0IHBvc2l0aW9ucyh2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlcy5hUG9zaXRpb24uYnVmZmVyLmRhdGEgPSB2YWx1ZTtcbiAgfVxuICAvKiogVGhlIFVWcyBvZiB0aGUgbWVzaC4gKi9cbiAgZ2V0IHV2cygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmFVVi5idWZmZXIuZGF0YTtcbiAgfVxuICBzZXQgdXZzKHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzLmFVVi5idWZmZXIuZGF0YSA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgaW5kaWNlcyBvZiB0aGUgbWVzaC4gKi9cbiAgZ2V0IGluZGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXIuZGF0YTtcbiAgfVxuICBzZXQgaW5kaWNlcyh2YWx1ZSkge1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGF0YSA9IHZhbHVlO1xuICB9XG59O1xuX01lc2hHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgdG9wb2xvZ3k6IFwidHJpYW5nbGUtbGlzdFwiLFxuICBzaHJpbmtCdWZmZXJzVG9GaXQ6IGZhbHNlXG59O1xubGV0IE1lc2hHZW9tZXRyeSA9IF9NZXNoR2VvbWV0cnk7XG5cbmV4cG9ydCB7IE1lc2hHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaEdlb21ldHJ5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4428\n')},2092:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(4428);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs\n\n\n\n"use strict";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry/* MeshGeometry */.x {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === "number") {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\n\n//# sourceMappingURL=PlaneGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs\n\n\n"use strict";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const positions = this.positions;\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this.width > w ? 1 : this.width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this.height > h ? 1 : this.height / h;\n    const scale = Math.min(scaleW, scaleH);\n    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n    positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n    positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n    this.getBuffer("aPosition").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer("aUV").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\n\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs\n\n\n\n\n\n"use strict";\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    PoolGroup/* BigPool */.u.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableMesh = new BatchableMesh/* BatchableMesh */.X();\n    batchableMesh.geometry = new NineSliceGeometry();\n    batchableMesh.mesh = sprite;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableMesh;\n    sprite.on("destroyed", () => {\n      this.destroyRenderable(sprite);\n    });\n    return batchableMesh;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      const batchableMesh = this._gpuSpriteHash[i];\n      batchableMesh.geometry.destroy();\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "nineSliceSprite"\n};\n\n\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEU7QUFDWDs7QUFFL0Q7QUFDQSxvREFBb0QsZ0NBQVk7QUFDaEU7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLE1BQU0sa0NBQVcsQ0FBQyx5QkFBTSxrREFBa0Qsc0NBQXNDO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6Qjs7O0FDN0VnRTs7QUFFaEU7QUFDQSw0REFBNEQsYUFBYTtBQUN6RSwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUNwRmdFO0FBQ1A7QUFDUTtBQUNMOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFhO0FBQzNDLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRStCO0FBQy9COzs7QUM1RTZEO0FBQ0c7O0FBRWhFO0FBQ0EsNkJBQVUsS0FBSyxtQkFBbUI7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC1wbGFuZS9QbGFuZUdlb21ldHJ5Lm1qcz85NzdlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtbmluZS1zbGljZS9OaW5lU2xpY2VHZW9tZXRyeS5tanM/ZDcwZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlU3ByaXRlUGlwZS5tanM/N2ExOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvaW5pdC5tanM/YjY5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi4vbWVzaC9zaGFyZWQvTWVzaEdlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX1BsYW5lR2VvbWV0cnkgPSBjbGFzcyBfUGxhbmVHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdID8/IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIlBsYW5lR2VvbWV0cnkgY29uc3RydWN0b3IgY2hhbmdlZCBwbGVhc2UgdXNlIHsgd2lkdGgsIGhlaWdodCwgdmVydGljZXNYLCB2ZXJ0aWNlc1kgfSBpbnN0ZWFkXCIpO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IG9wdGlvbnMsXG4gICAgICAgIGhlaWdodDogYXJnc1sxXSxcbiAgICAgICAgdmVydGljZXNYOiBhcmdzWzJdLFxuICAgICAgICB2ZXJ0aWNlc1k6IGFyZ3NbM11cbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuYnVpbGQob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyBwbGFuZSBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byBwbGFuZSBnZW9tZXRyeVxuICAgKi9cbiAgYnVpbGQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLl9QbGFuZUdlb21ldHJ5LmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy52ZXJ0aWNlc1ggPSB0aGlzLnZlcnRpY2VzWCA/PyBvcHRpb25zLnZlcnRpY2VzWDtcbiAgICB0aGlzLnZlcnRpY2VzWSA9IHRoaXMudmVydGljZXNZID8/IG9wdGlvbnMudmVydGljZXNZO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLndpZHRoID8/IG9wdGlvbnMud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmhlaWdodCA/PyBvcHRpb25zLmhlaWdodDtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMudmVydGljZXNYICogdGhpcy52ZXJ0aWNlc1k7XG4gICAgY29uc3QgdmVydHMgPSBbXTtcbiAgICBjb25zdCB1dnMgPSBbXTtcbiAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgY29uc3QgdmVydGljZXNYID0gdGhpcy52ZXJ0aWNlc1ggLSAxO1xuICAgIGNvbnN0IHZlcnRpY2VzWSA9IHRoaXMudmVydGljZXNZIC0gMTtcbiAgICBjb25zdCBzaXplWCA9IHRoaXMud2lkdGggLyB2ZXJ0aWNlc1g7XG4gICAgY29uc3Qgc2l6ZVkgPSB0aGlzLmhlaWdodCAvIHZlcnRpY2VzWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpICUgdGhpcy52ZXJ0aWNlc1g7XG4gICAgICBjb25zdCB5ID0gaSAvIHRoaXMudmVydGljZXNYIHwgMDtcbiAgICAgIHZlcnRzLnB1c2goeCAqIHNpemVYLCB5ICogc2l6ZVkpO1xuICAgICAgdXZzLnB1c2goeCAvIHZlcnRpY2VzWCwgeSAvIHZlcnRpY2VzWSk7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsU3ViID0gdmVydGljZXNYICogdmVydGljZXNZO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxTdWI7IGkrKykge1xuICAgICAgY29uc3QgeHBvcyA9IGkgJSB2ZXJ0aWNlc1g7XG4gICAgICBjb25zdCB5cG9zID0gaSAvIHZlcnRpY2VzWCB8IDA7XG4gICAgICBjb25zdCB2YWx1ZSA9IHlwb3MgKiB0aGlzLnZlcnRpY2VzWCArIHhwb3M7XG4gICAgICBjb25zdCB2YWx1ZTIgPSB5cG9zICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zICsgMTtcbiAgICAgIGNvbnN0IHZhbHVlMyA9ICh5cG9zICsgMSkgKiB0aGlzLnZlcnRpY2VzWCArIHhwb3M7XG4gICAgICBjb25zdCB2YWx1ZTQgPSAoeXBvcyArIDEpICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zICsgMTtcbiAgICAgIGluZGljZXMucHVzaChcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhbHVlMixcbiAgICAgICAgdmFsdWUzLFxuICAgICAgICB2YWx1ZTIsXG4gICAgICAgIHZhbHVlNCxcbiAgICAgICAgdmFsdWUzXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcnNbMF0uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydHMpO1xuICAgIHRoaXMuYnVmZmVyc1sxXS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh1dnMpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGF0YSA9IG5ldyBVaW50MzJBcnJheShpbmRpY2VzKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMF0udXBkYXRlKCk7XG4gICAgdGhpcy5idWZmZXJzWzFdLnVwZGF0ZSgpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gIH1cbn07XG5fUGxhbmVHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgd2lkdGg6IDEwMCxcbiAgaGVpZ2h0OiAxMDAsXG4gIHZlcnRpY2VzWDogMTAsXG4gIHZlcnRpY2VzWTogMTBcbn07XG5sZXQgUGxhbmVHZW9tZXRyeSA9IF9QbGFuZUdlb21ldHJ5O1xuXG5leHBvcnQgeyBQbGFuZUdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbGFuZUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBsYW5lR2VvbWV0cnkgfSBmcm9tICcuLi9tZXNoLXBsYW5lL1BsYW5lR2VvbWV0cnkubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfTmluZVNsaWNlR2VvbWV0cnkgPSBjbGFzcyBfTmluZVNsaWNlR2VvbWV0cnkgZXh0ZW5kcyBQbGFuZUdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX05pbmVTbGljZUdlb21ldHJ5LmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgc3VwZXIoe1xuICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGgsXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgdmVydGljZXNYOiA0LFxuICAgICAgdmVydGljZXNZOiA0XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIE5pbmVTbGljZUdlb21ldHJ5IHdpdGggdGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2YgdGhlIE5pbmVTbGljZUdlb21ldHJ5LlxuICAgKi9cbiAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCA/PyB0aGlzLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgPz8gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5fb3JpZ2luYWxXaWR0aCA9IG9wdGlvbnMub3JpZ2luYWxXaWR0aCA/PyB0aGlzLl9vcmlnaW5hbFdpZHRoO1xuICAgIHRoaXMuX29yaWdpbmFsSGVpZ2h0ID0gb3B0aW9ucy5vcmlnaW5hbEhlaWdodCA/PyB0aGlzLl9vcmlnaW5hbEhlaWdodDtcbiAgICB0aGlzLl9sZWZ0V2lkdGggPSBvcHRpb25zLmxlZnRXaWR0aCA/PyB0aGlzLl9sZWZ0V2lkdGg7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IG9wdGlvbnMucmlnaHRXaWR0aCA/PyB0aGlzLl9yaWdodFdpZHRoO1xuICAgIHRoaXMuX3RvcEhlaWdodCA9IG9wdGlvbnMudG9wSGVpZ2h0ID8/IHRoaXMuX3RvcEhlaWdodDtcbiAgICB0aGlzLl9ib3R0b21IZWlnaHQgPSBvcHRpb25zLmJvdHRvbUhlaWdodCA/PyB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucygpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2YgdGhlIHZlcnRpY2VzLiAqL1xuICB1cGRhdGVQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7XG4gICAgY29uc3QgdyA9IHRoaXMuX2xlZnRXaWR0aCArIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVXID0gdGhpcy53aWR0aCA+IHcgPyAxIDogdGhpcy53aWR0aCAvIHc7XG4gICAgY29uc3QgaCA9IHRoaXMuX3RvcEhlaWdodCArIHRoaXMuX2JvdHRvbUhlaWdodDtcbiAgICBjb25zdCBzY2FsZUggPSB0aGlzLmhlaWdodCA+IGggPyAxIDogdGhpcy5oZWlnaHQgLyBoO1xuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oc2NhbGVXLCBzY2FsZUgpO1xuICAgIHBvc2l0aW9uc1s5XSA9IHBvc2l0aW9uc1sxMV0gPSBwb3NpdGlvbnNbMTNdID0gcG9zaXRpb25zWzE1XSA9IHRoaXMuX3RvcEhlaWdodCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1sxN10gPSBwb3NpdGlvbnNbMTldID0gcG9zaXRpb25zWzIxXSA9IHBvc2l0aW9uc1syM10gPSB0aGlzLmhlaWdodCAtIHRoaXMuX2JvdHRvbUhlaWdodCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1syNV0gPSBwb3NpdGlvbnNbMjddID0gcG9zaXRpb25zWzI5XSA9IHBvc2l0aW9uc1szMV0gPSB0aGlzLmhlaWdodDtcbiAgICBwb3NpdGlvbnNbMl0gPSBwb3NpdGlvbnNbMTBdID0gcG9zaXRpb25zWzE4XSA9IHBvc2l0aW9uc1syNl0gPSB0aGlzLl9sZWZ0V2lkdGggKiBzY2FsZTtcbiAgICBwb3NpdGlvbnNbNF0gPSBwb3NpdGlvbnNbMTJdID0gcG9zaXRpb25zWzIwXSA9IHBvc2l0aW9uc1syOF0gPSB0aGlzLndpZHRoIC0gdGhpcy5fcmlnaHRXaWR0aCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1s2XSA9IHBvc2l0aW9uc1sxNF0gPSBwb3NpdGlvbnNbMjJdID0gcG9zaXRpb25zWzMwXSA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy5nZXRCdWZmZXIoXCJhUG9zaXRpb25cIikudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIFVWcyBvZiB0aGUgdmVydGljZXMuICovXG4gIHVwZGF0ZVV2cygpIHtcbiAgICBjb25zdCB1dnMgPSB0aGlzLnV2cztcbiAgICB1dnNbMF0gPSB1dnNbOF0gPSB1dnNbMTZdID0gdXZzWzI0XSA9IDA7XG4gICAgdXZzWzFdID0gdXZzWzNdID0gdXZzWzVdID0gdXZzWzddID0gMDtcbiAgICB1dnNbNl0gPSB1dnNbMTRdID0gdXZzWzIyXSA9IHV2c1szMF0gPSAxO1xuICAgIHV2c1syNV0gPSB1dnNbMjddID0gdXZzWzI5XSA9IHV2c1szMV0gPSAxO1xuICAgIGNvbnN0IF91dncgPSAxIC8gdGhpcy5fb3JpZ2luYWxXaWR0aDtcbiAgICBjb25zdCBfdXZoID0gMSAvIHRoaXMuX29yaWdpbmFsSGVpZ2h0O1xuICAgIHV2c1syXSA9IHV2c1sxMF0gPSB1dnNbMThdID0gdXZzWzI2XSA9IF91dncgKiB0aGlzLl9sZWZ0V2lkdGg7XG4gICAgdXZzWzldID0gdXZzWzExXSA9IHV2c1sxM10gPSB1dnNbMTVdID0gX3V2aCAqIHRoaXMuX3RvcEhlaWdodDtcbiAgICB1dnNbNF0gPSB1dnNbMTJdID0gdXZzWzIwXSA9IHV2c1syOF0gPSAxIC0gX3V2dyAqIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgdXZzWzE3XSA9IHV2c1sxOV0gPSB1dnNbMjFdID0gdXZzWzIzXSA9IDEgLSBfdXZoICogdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgIHRoaXMuZ2V0QnVmZmVyKFwiYVVWXCIpLnVwZGF0ZSgpO1xuICB9XG59O1xuLyoqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBOaW5lU2xpY2VHZW9tZXRyeS4gKi9cbl9OaW5lU2xpY2VHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgTmluZVNsaWNlUGxhbmUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgdmVydGljZXMgYW5kIFVWJ3Mgb2YgdGhpcyBwbGFuZS4gKi9cbiAgd2lkdGg6IDEwMCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIE5pbmVTbGljZVBsYW5lLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHZlcnRpY2VzIGFuZCBVVidzIG9mIHRoaXMgcGxhbmUuICovXG4gIGhlaWdodDogMTAwLFxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBsZWZ0IGNvbHVtbi4gKi9cbiAgbGVmdFdpZHRoOiAxMCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIHRvcCByb3cuICovXG4gIHRvcEhlaWdodDogMTAsXG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHJpZ2h0IGNvbHVtbi4gKi9cbiAgcmlnaHRXaWR0aDogMTAsXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBib3R0b20gcm93LiAqL1xuICBib3R0b21IZWlnaHQ6IDEwLFxuICAvKiogVGhlIG9yaWdpbmFsIHdpZHRoIG9mIHRoZSB0ZXh0dXJlICovXG4gIG9yaWdpbmFsV2lkdGg6IDEwMCxcbiAgLyoqIFRoZSBvcmlnaW5hbCBoZWlnaHQgb2YgdGhlIHRleHR1cmUgKi9cbiAgb3JpZ2luYWxIZWlnaHQ6IDEwMFxufTtcbmxldCBOaW5lU2xpY2VHZW9tZXRyeSA9IF9OaW5lU2xpY2VHZW9tZXRyeTtcblxuZXhwb3J0IHsgTmluZVNsaWNlR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5pbmVTbGljZUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4uL21lc2gvc2hhcmVkL0JhdGNoYWJsZU1lc2gubWpzJztcbmltcG9ydCB7IE5pbmVTbGljZUdlb21ldHJ5IH0gZnJvbSAnLi9OaW5lU2xpY2VHZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE5pbmVTbGljZVNwcml0ZVBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2dwdVNwcml0ZUhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoc3ByaXRlLCBfaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVTcHJpdGUgPSB0aGlzLl9nZXRHcHVTcHJpdGUoc3ByaXRlKTtcbiAgICBpZiAoc3ByaXRlLl9kaWRTcHJpdGVVcGRhdGUpXG4gICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBncHVTcHJpdGUpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmFkZFRvQmF0Y2goZ3B1U3ByaXRlKTtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGdwdVNwcml0ZSA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF07XG4gICAgaWYgKHNwcml0ZS5fZGlkU3ByaXRlVXBkYXRlKVxuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hhYmxlU3ByaXRlKHNwcml0ZSwgZ3B1U3ByaXRlKTtcbiAgICBncHVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGdwdVNwcml0ZSk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgY29uc3QgZ3B1U3ByaXRlID0gdGhpcy5fZ2V0R3B1U3ByaXRlKHNwcml0ZSk7XG4gICAgaWYgKGdwdVNwcml0ZS50ZXh0dXJlLl9zb3VyY2UgIT09IHRleHR1cmUuX3NvdXJjZSkge1xuICAgICAgcmV0dXJuICFncHVTcHJpdGUuYmF0Y2hlci5jaGVja0FuZFVwZGF0ZVRleHR1cmUoZ3B1U3ByaXRlLCB0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF07XG4gICAgQmlnUG9vbC5yZXR1cm4oYmF0Y2hhYmxlU3ByaXRlKTtcbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlQmF0Y2hhYmxlU3ByaXRlKHNwcml0ZSwgYmF0Y2hhYmxlU3ByaXRlKSB7XG4gICAgc3ByaXRlLl9kaWRTcHJpdGVVcGRhdGUgPSBmYWxzZTtcbiAgICBiYXRjaGFibGVTcHJpdGUuZ2VvbWV0cnkudXBkYXRlKHNwcml0ZSk7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gIH1cbiAgX2dldEdwdVNwcml0ZShzcHJpdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXSB8fCB0aGlzLl9pbml0R1BVU3ByaXRlKHNwcml0ZSk7XG4gIH1cbiAgX2luaXRHUFVTcHJpdGUoc3ByaXRlKSB7XG4gICAgY29uc3QgYmF0Y2hhYmxlTWVzaCA9IG5ldyBCYXRjaGFibGVNZXNoKCk7XG4gICAgYmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IG5ldyBOaW5lU2xpY2VHZW9tZXRyeSgpO1xuICAgIGJhdGNoYWJsZU1lc2gubWVzaCA9IHNwcml0ZTtcbiAgICBiYXRjaGFibGVNZXNoLnRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgYmF0Y2hhYmxlTWVzaC5yb3VuZFBpeGVscyA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IHNwcml0ZS5fcm91bmRQaXhlbHM7XG4gICAgdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXSA9IGJhdGNoYWJsZU1lc2g7XG4gICAgc3ByaXRlLm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUoc3ByaXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmF0Y2hhYmxlTWVzaDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVTcHJpdGVIYXNoKSB7XG4gICAgICBjb25zdCBiYXRjaGFibGVNZXNoID0gdGhpcy5fZ3B1U3ByaXRlSGFzaFtpXTtcbiAgICAgIGJhdGNoYWJsZU1lc2guZ2VvbWV0cnkuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5OaW5lU2xpY2VTcHJpdGVQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJuaW5lU2xpY2VTcHJpdGVcIlxufTtcblxuZXhwb3J0IHsgTmluZVNsaWNlU3ByaXRlUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmluZVNsaWNlU3ByaXRlUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBOaW5lU2xpY2VTcHJpdGVQaXBlIH0gZnJvbSAnLi9OaW5lU2xpY2VTcHJpdGVQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoTmluZVNsaWNlU3ByaXRlUGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2092\n')},1015:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(4428);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs\nvar localUniformBit = __webpack_require__(8070);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs\n\nconst tilingBit = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=tilingBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader/* Shader */.e {\n  constructor() {\n    gpuProgram ?? (gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBit */.XH,\n        tilingBit,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    }));\n    glProgram ?? (glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBitGl */.$g,\n        tilingBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    }));\n    const tilingUniforms = new UniformGroup/* UniformGroup */.o({\n      uMapCoord: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },\n      uTextureTransform: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup/* UniformGroup */.o({\n          uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n          uRound: { value: 0, type: "f32" }\n        }),\n        tilingUniforms,\n        uTexture: Texture/* Texture */.x.EMPTY.source,\n        uSampler: Texture/* Texture */.x.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\n\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs\n\n\n"use strict";\nclass QuadGeometry extends MeshGeometry/* MeshGeometry */.x {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\n\n//# sourceMappingURL=QuadGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs\n\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\n\n//# sourceMappingURL=setPositions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs\n\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=applyMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs\n\n\n\n"use strict";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite._applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix/* Matrix */.y.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\n\n//# sourceMappingURL=setUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (batchableMesh.texture._source !== renderable.texture._source) {\n        return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n      }\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh/* BatchableMesh */.X());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite._didTilingSpriteUpdate) {\n        tilingSprite._didTilingSpriteUpdate = false;\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.mesh = tilingSprite;\n        batchableMesh.texture = tilingSprite._texture;\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: State/* State */.Z.default2d\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite._didTilingSpriteUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh.batcher.updateElement(batchableMesh);\n    } else if (tilingSprite._didTilingSpriteUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n    tilingSprite._didTilingSpriteUpdate = false;\n  }\n  destroyRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    tilingSpriteData.batchableMesh = null;\n    tilingSpriteData.shader?.destroy();\n    this._tilingSpriteDataHash[tilingSprite.uid] = null;\n  }\n  _getTilingSpriteData(renderable) {\n    return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const geometry = new MeshGeometry/* MeshGeometry */.x({\n      indices: sharedQuad.indices,\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n    this._tilingSpriteDataHash[tilingSprite.uid] = {\n      canBatch: true,\n      renderable: tilingSprite,\n      geometry\n    };\n    tilingSprite.on("destroyed", () => {\n      this.destroyRenderable(tilingSprite);\n    });\n    return this._tilingSpriteDataHash[tilingSprite.uid];\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== "repeat") {\n      style.addressMode = "repeat";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    for (const i in this._tilingSpriteDataHash) {\n      this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n    }\n    this._tilingSpriteDataHash = null;\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === types/* RendererType */.g.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "tilingSprite"\n};\n\n\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUU0QjtBQUM1Qjs7O0FDOUo2RDtBQUNIOztBQUUxRDtBQUNBLDZCQUFVLEtBQUssZ0JBQWdCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvc2hhZGVyL3RpbGluZ0JpdC5tanM/YTM2NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy9zaGFkZXIvVGlsaW5nU3ByaXRlU2hhZGVyLm1qcz9iZjRjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL1F1YWRHZW9tZXRyeS5tanM/ODAyNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy91dGlscy9zZXRQb3NpdGlvbnMubWpzP2FhNmQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvYXBwbHlNYXRyaXgubWpzP2NmNmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvc2V0VXZzLm1qcz85ZjUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL1RpbGluZ1Nwcml0ZVBpcGUubWpzP2Q0MGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvaW5pdC5tanM/NTVjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRpbGluZ0JpdCA9IHtcbiAgbmFtZTogXCJ0aWxpbmctYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IFRpbGluZ1VuaWZvcm1zIHtcbiAgICAgICAgICAgICAgICB1TWFwQ29vcmQ6bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdUNsYW1wRnJhbWU6dmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIHVDbGFtcE9mZnNldDp2ZWMyPGYzMj4sXG4gICAgICAgICAgICAgICAgdVRleHR1cmVUcmFuc2Zvcm06bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdVNpemVBbmNob3I6dmVjNDxmMzI+XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHRpbGluZ1VuaWZvcm1zOiBUaWxpbmdVbmlmb3JtcztcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHV2ID0gKHRpbGluZ1VuaWZvcm1zLnVUZXh0dXJlVHJhbnNmb3JtICogdmVjMyh1diwgMS4wKSkueHk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gKHBvc2l0aW9uIC0gdGlsaW5nVW5pZm9ybXMudVNpemVBbmNob3IuencpICogdGlsaW5nVW5pZm9ybXMudVNpemVBbmNob3IueHk7XG4gICAgICAgIGBcbiAgICApXG4gIH0sXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBzdHJ1Y3QgVGlsaW5nVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVNYXBDb29yZDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1Q2xhbXBGcmFtZTp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdUNsYW1wT2Zmc2V0OnZlYzI8ZjMyPixcbiAgICAgICAgICAgICAgICB1VGV4dHVyZVRyYW5zZm9ybTptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1U2l6ZUFuY2hvcjp2ZWM0PGYzMj5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gdGlsaW5nVW5pZm9ybXM6IFRpbGluZ1VuaWZvcm1zO1xuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuXG4gICAgICAgICAgICB2YXIgY29vcmQgPSB2VVYgKyBjZWlsKHRpbGluZ1VuaWZvcm1zLnVDbGFtcE9mZnNldCAtIHZVVik7XG4gICAgICAgICAgICBjb29yZCA9ICh0aWxpbmdVbmlmb3Jtcy51TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcbiAgICAgICAgICAgIHZhciB1bmNsYW1wZWQgPSBjb29yZDtcbiAgICAgICAgICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHRpbGluZ1VuaWZvcm1zLnVDbGFtcEZyYW1lLnh5LCB0aWxpbmdVbmlmb3Jtcy51Q2xhbXBGcmFtZS56dyk7XG5cbiAgICAgICAgICAgIHZhciBiaWFzID0gMC47XG5cbiAgICAgICAgICAgIGlmKHVuY2xhbXBlZC54ID09IGNvb3JkLnggJiYgdW5jbGFtcGVkLnkgPT0gY29vcmQueSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaWFzID0gLTMyLjtcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIG91dENvbG9yID0gdGV4dHVyZVNhbXBsZUJpYXModVRleHR1cmUsIHVTYW1wbGVyLCBjb29yZCwgYmlhcyk7XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5jb25zdCB0aWxpbmdCaXRHbCA9IHtcbiAgbmFtZTogXCJ0aWxpbmctYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVUZXh0dXJlVHJhbnNmb3JtO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVTaXplQW5jaG9yO1xuICAgICAgICBcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdXYgPSAodVRleHR1cmVUcmFuc2Zvcm0gKiB2ZWMzKGFVViwgMS4wKSkueHk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gKHBvc2l0aW9uIC0gdVNpemVBbmNob3IuencpICogdVNpemVBbmNob3IueHk7XG4gICAgICAgIGBcbiAgICApXG4gIH0sXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1TWFwQ29vcmQ7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgdUNsYW1wRnJhbWU7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG5cbiAgICAgICAgdmVjMiBjb29yZCA9IHZVViArIGNlaWwodUNsYW1wT2Zmc2V0IC0gdlVWKTtcbiAgICAgICAgY29vcmQgPSAodU1hcENvb3JkICogdmVjMyhjb29yZCwgMS4wKSkueHk7XG4gICAgICAgIHZlYzIgdW5jbGFtcGVkID0gY29vcmQ7XG4gICAgICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVDbGFtcEZyYW1lLnh5LCB1Q2xhbXBGcmFtZS56dyk7XG4gICAgICAgIFxuICAgICAgICBvdXRDb2xvciA9IHRleHR1cmUodVRleHR1cmUsIGNvb3JkLCB1bmNsYW1wZWQgPT0gY29vcmQgPyAwLjAgOiAtMzIuMCk7Ly8gbG9kLWJpYXMgdmVyeSBuZWdhdGl2ZSB0byBmb3JjZSBsb2QgMFxuICAgIFxuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuXG5leHBvcnQgeyB0aWxpbmdCaXQsIHRpbGluZ0JpdEdsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWxpbmdCaXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtLCBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlSGlnaFNoYWRlclRvUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgbG9jYWxVbmlmb3JtQml0LCBsb2NhbFVuaWZvcm1CaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9sb2NhbFVuaWZvcm1CaXQubWpzJztcbmltcG9ydCB7IHJvdW5kUGl4ZWxzQml0LCByb3VuZFBpeGVsc0JpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL3JvdW5kUGl4ZWxzQml0Lm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB0aWxpbmdCaXQsIHRpbGluZ0JpdEdsIH0gZnJvbSAnLi90aWxpbmdCaXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgZ3B1UHJvZ3JhbTtcbmxldCBnbFByb2dyYW07XG5jbGFzcyBUaWxpbmdTcHJpdGVTaGFkZXIgZXh0ZW5kcyBTaGFkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBncHVQcm9ncmFtID8/IChncHVQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwidGlsaW5nLXNwcml0ZS1zaGFkZXJcIixcbiAgICAgIGJpdHM6IFtcbiAgICAgICAgbG9jYWxVbmlmb3JtQml0LFxuICAgICAgICB0aWxpbmdCaXQsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0XG4gICAgICBdXG4gICAgfSkpO1xuICAgIGdsUHJvZ3JhbSA/PyAoZ2xQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0oe1xuICAgICAgbmFtZTogXCJ0aWxpbmctc3ByaXRlLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBsb2NhbFVuaWZvcm1CaXRHbCxcbiAgICAgICAgdGlsaW5nQml0R2wsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0R2xcbiAgICAgIF1cbiAgICB9KSk7XG4gICAgY29uc3QgdGlsaW5nVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVNYXBDb29yZDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVDbGFtcEZyYW1lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAxXSksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVDbGFtcE9mZnNldDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICB1VGV4dHVyZVRyYW5zZm9ybTogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVTaXplQW5jaG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxMDAsIDEwMCwgMC41LCAwLjVdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9XG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBsb2NhbFVuaWZvcm1zOiBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgICAgICB1VHJhbnNmb3JtTWF0cml4OiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICAgICAgfSksXG4gICAgICAgIHRpbGluZ1VuaWZvcm1zLFxuICAgICAgICB1VGV4dHVyZTogVGV4dHVyZS5FTVBUWS5zb3VyY2UsXG4gICAgICAgIHVTYW1wbGVyOiBUZXh0dXJlLkVNUFRZLnNvdXJjZS5zdHlsZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVVuaWZvcm1zKHdpZHRoLCBoZWlnaHQsIG1hdHJpeCwgYW5jaG9yWCwgYW5jaG9yWSwgdGV4dHVyZSkge1xuICAgIGNvbnN0IHRpbGluZ1VuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMudGlsaW5nVW5pZm9ybXM7XG4gICAgY29uc3QgdGV4dHVyZVdpZHRoID0gdGV4dHVyZS53aWR0aDtcbiAgICBjb25zdCB0ZXh0dXJlSGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XG4gICAgY29uc3QgdGV4dHVyZU1hdHJpeCA9IHRleHR1cmUudGV4dHVyZU1hdHJpeDtcbiAgICBjb25zdCB1VGV4dHVyZVRyYW5zZm9ybSA9IHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVUZXh0dXJlVHJhbnNmb3JtO1xuICAgIHVUZXh0dXJlVHJhbnNmb3JtLnNldChcbiAgICAgIG1hdHJpeC5hICogdGV4dHVyZVdpZHRoIC8gd2lkdGgsXG4gICAgICBtYXRyaXguYiAqIHRleHR1cmVXaWR0aCAvIGhlaWdodCxcbiAgICAgIG1hdHJpeC5jICogdGV4dHVyZUhlaWdodCAvIHdpZHRoLFxuICAgICAgbWF0cml4LmQgKiB0ZXh0dXJlSGVpZ2h0IC8gaGVpZ2h0LFxuICAgICAgbWF0cml4LnR4IC8gd2lkdGgsXG4gICAgICBtYXRyaXgudHkgLyBoZWlnaHRcbiAgICApO1xuICAgIHVUZXh0dXJlVHJhbnNmb3JtLmludmVydCgpO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVNYXBDb29yZCA9IHRleHR1cmVNYXRyaXgubWFwQ29vcmQ7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudUNsYW1wRnJhbWUgPSB0ZXh0dXJlTWF0cml4LnVDbGFtcEZyYW1lO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVDbGFtcE9mZnNldCA9IHRleHR1cmVNYXRyaXgudUNsYW1wT2Zmc2V0O1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVUZXh0dXJlVHJhbnNmb3JtID0gdVRleHR1cmVUcmFuc2Zvcm07XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVNpemVBbmNob3JbMF0gPSB3aWR0aDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZUFuY2hvclsxXSA9IGhlaWdodDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZUFuY2hvclsyXSA9IGFuY2hvclg7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVNpemVBbmNob3JbM10gPSBhbmNob3JZO1xuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB0aGlzLnJlc291cmNlcy51VGV4dHVyZSA9IHRleHR1cmUuc291cmNlO1xuICAgICAgdGhpcy5yZXNvdXJjZXMudVNhbXBsZXIgPSB0ZXh0dXJlLnNvdXJjZS5zdHlsZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgVGlsaW5nU3ByaXRlU2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxpbmdTcHJpdGVTaGFkZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vbWVzaC9zaGFyZWQvTWVzaEdlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgUXVhZEdlb21ldHJ5IGV4dGVuZHMgTWVzaEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSksXG4gICAgICB1dnM6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKSxcbiAgICAgIGluZGljZXM6IG5ldyBVaW50MzJBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgUXVhZEdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkR2VvbWV0cnkubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBzZXRQb3NpdGlvbnModGlsaW5nU3ByaXRlLCBwb3NpdGlvbnMpIHtcbiAgY29uc3QgYW5jaG9yWCA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueDtcbiAgY29uc3QgYW5jaG9yWSA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueTtcbiAgcG9zaXRpb25zWzBdID0gLWFuY2hvclggKiB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHBvc2l0aW9uc1sxXSA9IC1hbmNob3JZICogdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgcG9zaXRpb25zWzJdID0gKDEgLSBhbmNob3JYKSAqIHRpbGluZ1Nwcml0ZS53aWR0aDtcbiAgcG9zaXRpb25zWzNdID0gLWFuY2hvclkgKiB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xuICBwb3NpdGlvbnNbNF0gPSAoMSAtIGFuY2hvclgpICogdGlsaW5nU3ByaXRlLndpZHRoO1xuICBwb3NpdGlvbnNbNV0gPSAoMSAtIGFuY2hvclkpICogdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgcG9zaXRpb25zWzZdID0gLWFuY2hvclggKiB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHBvc2l0aW9uc1s3XSA9ICgxIC0gYW5jaG9yWSkgKiB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xufVxuXG5leHBvcnQgeyBzZXRQb3NpdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldFBvc2l0aW9ucy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFwcGx5TWF0cml4KGFycmF5LCBzdHJpZGUsIG9mZnNldCwgbWF0cml4KSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IHNpemUgPSBhcnJheS5sZW5ndGggLyAoc3RyaWRlIHx8IDIpO1xuICBjb25zdCBhID0gbWF0cml4LmE7XG4gIGNvbnN0IGIgPSBtYXRyaXguYjtcbiAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICBjb25zdCBkID0gbWF0cml4LmQ7XG4gIGNvbnN0IHR4ID0gbWF0cml4LnR4O1xuICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgb2Zmc2V0ICo9IHN0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgIGNvbnN0IHggPSBhcnJheVtvZmZzZXRdO1xuICAgIGNvbnN0IHkgPSBhcnJheVtvZmZzZXQgKyAxXTtcbiAgICBhcnJheVtvZmZzZXRdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIGFycmF5W29mZnNldCArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgaW5kZXgrKztcbiAgfVxufVxuXG5leHBvcnQgeyBhcHBseU1hdHJpeCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHlNYXRyaXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgYXBwbHlNYXRyaXggfSBmcm9tICcuL2FwcGx5TWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc2V0VXZzKHRpbGluZ1Nwcml0ZSwgdXZzKSB7XG4gIGNvbnN0IHRleHR1cmUgPSB0aWxpbmdTcHJpdGUudGV4dHVyZTtcbiAgY29uc3Qgd2lkdGggPSB0ZXh0dXJlLmZyYW1lLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSB0ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgbGV0IGFuY2hvclggPSAwO1xuICBsZXQgYW5jaG9yWSA9IDA7XG4gIGlmICh0aWxpbmdTcHJpdGUuX2FwcGx5QW5jaG9yVG9UZXh0dXJlKSB7XG4gICAgYW5jaG9yWCA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueDtcbiAgICBhbmNob3JZID0gdGlsaW5nU3ByaXRlLmFuY2hvci55O1xuICB9XG4gIHV2c1swXSA9IHV2c1s2XSA9IC1hbmNob3JYO1xuICB1dnNbMl0gPSB1dnNbNF0gPSAxIC0gYW5jaG9yWDtcbiAgdXZzWzFdID0gdXZzWzNdID0gLWFuY2hvclk7XG4gIHV2c1s1XSA9IHV2c1s3XSA9IDEgLSBhbmNob3JZO1xuICBjb25zdCB0ZXh0dXJlTWF0cml4ID0gTWF0cml4LnNoYXJlZDtcbiAgdGV4dHVyZU1hdHJpeC5jb3B5RnJvbSh0aWxpbmdTcHJpdGUuX3RpbGVUcmFuc2Zvcm0ubWF0cml4KTtcbiAgdGV4dHVyZU1hdHJpeC50eCAvPSB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHRleHR1cmVNYXRyaXgudHkgLz0gdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgdGV4dHVyZU1hdHJpeC5pbnZlcnQoKTtcbiAgdGV4dHVyZU1hdHJpeC5zY2FsZSh0aWxpbmdTcHJpdGUud2lkdGggLyB3aWR0aCwgdGlsaW5nU3ByaXRlLmhlaWdodCAvIGhlaWdodCk7XG4gIGFwcGx5TWF0cml4KHV2cywgMiwgMCwgdGV4dHVyZU1hdHJpeCk7XG59XG5cbmV4cG9ydCB7IHNldFV2cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0VXZzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvdHlwZXMubWpzJztcbmltcG9ydCB7IGNvbG9yMzJCaXRUb1VuaWZvcm0gfSBmcm9tICcuLi9ncmFwaGljcy9ncHUvY29sb3JUb1VuaWZvcm0ubWpzJztcbmltcG9ydCB7IEJhdGNoYWJsZU1lc2ggfSBmcm9tICcuLi9tZXNoL3NoYXJlZC9CYXRjaGFibGVNZXNoLm1qcyc7XG5pbXBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICcuLi9tZXNoL3NoYXJlZC9NZXNoR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IFRpbGluZ1Nwcml0ZVNoYWRlciB9IGZyb20gJy4vc2hhZGVyL1RpbGluZ1Nwcml0ZVNoYWRlci5tanMnO1xuaW1wb3J0IHsgUXVhZEdlb21ldHJ5IH0gZnJvbSAnLi91dGlscy9RdWFkR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IHNldFBvc2l0aW9ucyB9IGZyb20gJy4vdXRpbHMvc2V0UG9zaXRpb25zLm1qcyc7XG5pbXBvcnQgeyBzZXRVdnMgfSBmcm9tICcuL3V0aWxzL3NldFV2cy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHNoYXJlZFF1YWQgPSBuZXcgUXVhZEdlb21ldHJ5KCk7XG5jbGFzcyBUaWxpbmdTcHJpdGVQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHJlbmRlcmFibGUpIHtcbiAgICBjb25zdCB0aWxpbmdTcHJpdGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YShyZW5kZXJhYmxlKTtcbiAgICBjb25zdCBjb3VsZEJhdGNoID0gdGlsaW5nU3ByaXRlRGF0YS5jYW5CYXRjaDtcbiAgICB0aGlzLl91cGRhdGVDYW5CYXRjaChyZW5kZXJhYmxlKTtcbiAgICBjb25zdCBjYW5CYXRjaCA9IHRpbGluZ1Nwcml0ZURhdGEuY2FuQmF0Y2g7XG4gICAgaWYgKGNhbkJhdGNoICYmIGNhbkJhdGNoID09PSBjb3VsZEJhdGNoKSB7XG4gICAgICBjb25zdCB7IGJhdGNoYWJsZU1lc2ggfSA9IHRpbGluZ1Nwcml0ZURhdGE7XG4gICAgICBpZiAoYmF0Y2hhYmxlTWVzaC50ZXh0dXJlLl9zb3VyY2UgIT09IHJlbmRlcmFibGUudGV4dHVyZS5fc291cmNlKSB7XG4gICAgICAgIHJldHVybiAhYmF0Y2hhYmxlTWVzaC5iYXRjaGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZShiYXRjaGFibGVNZXNoLCByZW5kZXJhYmxlLnRleHR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bGRCYXRjaCAhPT0gY2FuQmF0Y2g7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgYmF0Y2hlciA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoO1xuICAgIHRoaXMuX3VwZGF0ZUNhbkJhdGNoKHRpbGluZ1Nwcml0ZSk7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGdlb21ldHJ5LCBjYW5CYXRjaCB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICBpZiAoY2FuQmF0Y2gpIHtcbiAgICAgIHRpbGluZ1Nwcml0ZURhdGEuYmF0Y2hhYmxlTWVzaCB8fCAodGlsaW5nU3ByaXRlRGF0YS5iYXRjaGFibGVNZXNoID0gbmV3IEJhdGNoYWJsZU1lc2goKSk7XG4gICAgICBjb25zdCBiYXRjaGFibGVNZXNoID0gdGlsaW5nU3ByaXRlRGF0YS5iYXRjaGFibGVNZXNoO1xuICAgICAgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKSB7XG4gICAgICAgIHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoYWJsZU1lc2godGlsaW5nU3ByaXRlKTtcbiAgICAgICAgYmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICBiYXRjaGFibGVNZXNoLm1lc2ggPSB0aWxpbmdTcHJpdGU7XG4gICAgICAgIGJhdGNoYWJsZU1lc2gudGV4dHVyZSA9IHRpbGluZ1Nwcml0ZS5fdGV4dHVyZTtcbiAgICAgIH1cbiAgICAgIGJhdGNoYWJsZU1lc2gucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCB0aWxpbmdTcHJpdGUuX3JvdW5kUGl4ZWxzO1xuICAgICAgYmF0Y2hlci5hZGRUb0JhdGNoKGJhdGNoYWJsZU1lc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXRjaGVyLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICAgIHRpbGluZ1Nwcml0ZURhdGEuc2hhZGVyIHx8ICh0aWxpbmdTcHJpdGVEYXRhLnNoYWRlciA9IG5ldyBUaWxpbmdTcHJpdGVTaGFkZXIoKSk7XG4gICAgICB0aGlzLnVwZGF0ZVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKTtcbiAgICAgIGluc3RydWN0aW9uU2V0LmFkZCh0aWxpbmdTcHJpdGUpO1xuICAgIH1cbiAgfVxuICBleGVjdXRlKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHsgc2hhZGVyIH0gPSB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFt0aWxpbmdTcHJpdGUudWlkXTtcbiAgICBzaGFkZXIuZ3JvdXBzWzBdID0gdGhpcy5fcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMuYmluZEdyb3VwO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSBzaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gdGlsaW5nU3ByaXRlLmdyb3VwVHJhbnNmb3JtO1xuICAgIGxvY2FsVW5pZm9ybXMudVJvdW5kID0gdGhpcy5fcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgdGlsaW5nU3ByaXRlLl9yb3VuZFBpeGVscztcbiAgICBjb2xvcjMyQml0VG9Vbmlmb3JtKFxuICAgICAgdGlsaW5nU3ByaXRlLmdyb3VwQ29sb3JBbHBoYSxcbiAgICAgIGxvY2FsVW5pZm9ybXMudUNvbG9yLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZW5jb2Rlci5kcmF3KHtcbiAgICAgIGdlb21ldHJ5OiBzaGFyZWRRdWFkLFxuICAgICAgc2hhZGVyLFxuICAgICAgc3RhdGU6IFN0YXRlLmRlZmF1bHQyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGNhbkJhdGNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgIGlmIChjYW5CYXRjaCkge1xuICAgICAgY29uc3QgeyBiYXRjaGFibGVNZXNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgICAgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKVxuICAgICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVNZXNoKHRpbGluZ1Nwcml0ZSk7XG4gICAgICBiYXRjaGFibGVNZXNoLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaGFibGVNZXNoKTtcbiAgICB9IGVsc2UgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKSB7XG4gICAgICBjb25zdCB7IHNoYWRlciB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICAgIHNoYWRlci51cGRhdGVVbmlmb3JtcyhcbiAgICAgICAgdGlsaW5nU3ByaXRlLndpZHRoLFxuICAgICAgICB0aWxpbmdTcHJpdGUuaGVpZ2h0LFxuICAgICAgICB0aWxpbmdTcHJpdGUuX3RpbGVUcmFuc2Zvcm0ubWF0cml4LFxuICAgICAgICB0aWxpbmdTcHJpdGUuYW5jaG9yLngsXG4gICAgICAgIHRpbGluZ1Nwcml0ZS5hbmNob3IueSxcbiAgICAgICAgdGlsaW5nU3ByaXRlLnRleHR1cmVcbiAgICAgICk7XG4gICAgfVxuICAgIHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICB0aWxpbmdTcHJpdGVEYXRhLmJhdGNoYWJsZU1lc2ggPSBudWxsO1xuICAgIHRpbGluZ1Nwcml0ZURhdGEuc2hhZGVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbdGlsaW5nU3ByaXRlLnVpZF0gPSBudWxsO1xuICB9XG4gIF9nZXRUaWxpbmdTcHJpdGVEYXRhKHJlbmRlcmFibGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbcmVuZGVyYWJsZS51aWRdIHx8IHRoaXMuX2luaXRUaWxpbmdTcHJpdGVEYXRhKHJlbmRlcmFibGUpO1xuICB9XG4gIF9pbml0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBNZXNoR2VvbWV0cnkoe1xuICAgICAgaW5kaWNlczogc2hhcmVkUXVhZC5pbmRpY2VzLFxuICAgICAgcG9zaXRpb25zOiBzaGFyZWRRdWFkLnBvc2l0aW9ucy5zbGljZSgpLFxuICAgICAgdXZzOiBzaGFyZWRRdWFkLnV2cy5zbGljZSgpXG4gICAgfSk7XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbdGlsaW5nU3ByaXRlLnVpZF0gPSB7XG4gICAgICBjYW5CYXRjaDogdHJ1ZSxcbiAgICAgIHJlbmRlcmFibGU6IHRpbGluZ1Nwcml0ZSxcbiAgICAgIGdlb21ldHJ5XG4gICAgfTtcbiAgICB0aWxpbmdTcHJpdGUub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFt0aWxpbmdTcHJpdGUudWlkXTtcbiAgfVxuICBfdXBkYXRlQmF0Y2hhYmxlTWVzaCh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCByZW5kZXJhYmxlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGdlb21ldHJ5IH0gPSByZW5kZXJhYmxlRGF0YTtcbiAgICBjb25zdCBzdHlsZSA9IHRpbGluZ1Nwcml0ZS50ZXh0dXJlLnNvdXJjZS5zdHlsZTtcbiAgICBpZiAoc3R5bGUuYWRkcmVzc01vZGUgIT09IFwicmVwZWF0XCIpIHtcbiAgICAgIHN0eWxlLmFkZHJlc3NNb2RlID0gXCJyZXBlYXRcIjtcbiAgICAgIHN0eWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBzZXRVdnModGlsaW5nU3ByaXRlLCBnZW9tZXRyeS51dnMpO1xuICAgIHNldFBvc2l0aW9ucyh0aWxpbmdTcHJpdGUsIGdlb21ldHJ5LnBvc2l0aW9ucyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2gpIHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUodGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbaV0ucmVuZGVyYWJsZSk7XG4gICAgfVxuICAgIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbiAgX3VwZGF0ZUNhbkJhdGNoKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHJlbmRlcmFibGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aWxpbmdTcHJpdGUudGV4dHVyZTtcbiAgICBsZXQgX25vblBvd09mMndyYXBwaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fcmVuZGVyZXIudHlwZSA9PT0gUmVuZGVyZXJUeXBlLldFQkdMKSB7XG4gICAgICBfbm9uUG93T2Yyd3JhcHBpbmcgPSB0aGlzLl9yZW5kZXJlci5jb250ZXh0LnN1cHBvcnRzLm5vblBvd09mMndyYXBwaW5nO1xuICAgIH1cbiAgICByZW5kZXJhYmxlRGF0YS5jYW5CYXRjaCA9IHRleHR1cmUudGV4dHVyZU1hdHJpeC5pc1NpbXBsZSAmJiAoX25vblBvd09mMndyYXBwaW5nIHx8IHRleHR1cmUuc291cmNlLmlzUG93ZXJPZlR3byk7XG4gICAgcmV0dXJuIHJlbmRlcmFibGVEYXRhLmNhbkJhdGNoO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuVGlsaW5nU3ByaXRlUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwidGlsaW5nU3ByaXRlXCJcbn07XG5cbmV4cG9ydCB7IFRpbGluZ1Nwcml0ZVBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGluZ1Nwcml0ZVBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGlsaW5nU3ByaXRlUGlwZSB9IGZyb20gJy4vVGlsaW5nU3ByaXRlUGlwZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKFRpbGluZ1Nwcml0ZVBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1015\n')},6678:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(4334);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\nvar copySearchParams = __webpack_require__(8479);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(1718);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs\n\n\n\n"use strict";\nclass AbstractBitmapFont extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = "";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: "none", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or "none".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\n\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(3779);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(9160);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(13);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(778);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs\n\nfunction resolveCharacters(chars) {\n  if (chars === "") {\n    return [];\n  }\n  if (typeof chars === "string") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error("[BitmapFont]: Invalid character delimiter.");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error("[BitmapFont]: Invalid character range.");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 4;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = options;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture/* Texture */.x.WHITE;\n      style._fill.fill = null;\n    }\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics/* CanvasTextMetrics */.c.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === "italic" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== "\\n" && char !== "\\r" && char !== "\t" && char !== " ") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > 512) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > 512) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle/* Rectangle */.A(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture/* Texture */.x({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(512, 512, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture/* Texture */.x({\n      source: new ImageSource/* ImageSource */.c({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: "premultiply-alpha-on-upload"\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color/* Color */.I.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = "black";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n}\n\n\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs\n\nfunction getBitmapTextLayout(chars, style, font) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    let lastChar = currentLine.chars[index];\n    while (lastChar === " ") {\n      currentLine.width -= font.chars[lastChar].xAdvance;\n      lastChar = currentLine.chars[--index];\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[" "];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === "\\r" || char === "\\n" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === "\\r" || char === "\\n") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === "center") {\n    alignCenter(layoutData);\n  } else if (style.align === "right") {\n    alignRight(layoutData);\n  } else if (style.align === "justify") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\n\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs\n\n\n\n\n\n\n\n"use strict";\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [["a", "z"], ["A", "Z"], " "];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [["0", "9"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[" ", "~"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill) {\n      fontFamilyKey += style._fill.fill.uid;\n      overrideFill = false;\n    }\n    if (!Cache/* Cache */.C.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fnt.once("destroy", () => Cache/* Cache */.C.remove(fontFamilyKey));\n      Cache/* Cache */.C.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache/* Cache */.C.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */\n  getLayout(text, style) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout(text.split(""), style, bitmapFont);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */\n  measureText(text, style) {\n    return this.getLayout(text, style);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === "string") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error("[BitmapFontManager] Property `name` is required.");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle/* TextStyle */.p ? textStyle : new TextStyle/* TextStyle */.p(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(""));\n    Cache/* Cache */.C.set(`${name}-bitmap`, font);\n    font.once("destroy", () => Cache/* Cache */.C.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache/* Cache */.C.get(cacheKey);\n    if (font) {\n      Cache/* Cache */.C.remove(cacheKey);\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\n\n//# sourceMappingURL=BitmapFontManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs\n\n\n\n\n\n"use strict";\nclass BitmapFont extends AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const textureSource = textures[charData.page].source;\n      const frameReal = new Rectangle/* Rectangle */.A(\n        charData.x,\n        charData.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture/* Texture */.x({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: "none",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from \'pixi.js\';\n   *\n   * BitmapFont.install(\'TitleFont\', {\n   *     fontFamily: \'Arial\',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: \'purple\',\n   * });\n   *\n   * const title = new BitmapText({ text: \'This is the title\', fontFamily: \'TitleFont\' });\n   */\n  static install(options) {\n    BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager.uninstall(name);\n  }\n}\n\n\n//# sourceMappingURL=BitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs\n\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === "string" && data.startsWith("info face=");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s"\']+|"([^"]*)")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split("=");\n        const key = split[0];\n        const strValue = split[1].replace(/"/gm, "");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs\n\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName("info")[0];\n    const common = xml.getElementsByTagName("common")[0];\n    const distanceField = xml.getElementsByTagName("distanceField")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute("fieldType"),\n        range: parseInt(distanceField.getAttribute("distanceRange"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName("page");\n    const char = xml.getElementsByTagName("char");\n    const kerning = xml.getElementsByTagName("kerning");\n    data.fontSize = parseInt(info.getAttribute("size"), 10);\n    data.fontFamily = info.getAttribute("face");\n    data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute("id"), 10) || 0,\n        file: page[i].getAttribute("file")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute("id"), 10);\n      let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute("page"), 10) || 0,\n        x: parseInt(charNode.getAttribute("x"), 10),\n        y: parseInt(charNode.getAttribute("y"), 10),\n        width: parseInt(charNode.getAttribute("width"), 10),\n        height: parseInt(charNode.getAttribute("height"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute("xoffset"), 10),\n        yOffset: parseInt(charNode.getAttribute("yoffset"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute("first"), 10);\n      const second = parseInt(kerning[i].getAttribute("second"), 10);\n      const amount = parseInt(kerning[i].getAttribute("amount"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs\n\n\n\n"use strict";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === "string" && data.includes("<font>")) {\n      return bitmapFontXMLParser.test(adapter/* DOMAdapter */.z.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(adapter/* DOMAdapter */.z.get().parseXML(data));\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validExtensions = [".xml", ".fnt"];\nconst bitmapFontCachePlugin = {\n  extension: Extensions/* ExtensionType */.nw.CacheParser,\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.Normal\n  },\n  test(url) {\n    return validExtensions.includes(path/* path */.E.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path/* path */.E.join(path/* path */.E.dirname(src), pageFile);\n      imagePath = (0,copySearchParams/* copySearchParams */.u)(imagePath, src);\n      textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\n\n\n//# sourceMappingURL=loadBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\nvar Graphics = __webpack_require__(6475);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs\nvar shared_const = __webpack_require__(4589);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(2110);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(6600);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs\nvar batchSamplersUniformGroup = __webpack_require__(5774);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs\n\nconst localUniformMSDFBit = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs\n\nconst mSDFBit = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=mSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass SdfShader extends Shader/* Shader */.e {\n  constructor() {\n    const uniforms = new UniformGroup/* UniformGroup */.o({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uDistance: { value: 4, type: "f32" },\n      uRound: { value: 0, type: "f32" }\n    });\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBit */.M,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */.m)(shared_const/* MAX_TEXTURES */.A),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    });\n    const glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBitGl */.T,\n        (0,generateTextureBatchBit/* generateTextureBatchBitGl */.h)(shared_const/* MAX_TEXTURES */.A),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: batchSamplersUniformGroup/* batchSamplersUniformGroup */.y\n      }\n    });\n  }\n}\n\n\n//# sourceMappingURL=SdfShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._gpuBitmapText = {};\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  destroyRenderable(bitmapText) {\n    this._destroyRenderableByUid(bitmapText.uid);\n  }\n  _destroyRenderableByUid(renderableUid) {\n    PoolGroup/* BigPool */.u.return(this._gpuBitmapText[renderableUid]);\n    this._gpuBitmapText[renderableUid] = null;\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== "none") {\n      if (!context.customShader) {\n        if (!this._sdfShader) {\n          this._sdfShader = new SdfShader();\n        }\n        context.customShader = this._sdfShader;\n      }\n    }\n    const chars = Array.from(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = (style._stroke?.width || 0) / 2;\n    currentY += bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    context.translate(\n      -bitmapText._anchor._x * bitmapTextLayout.width - padding,\n      -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding\n    ).scale(scale, scale);\n    const tint = style._fill.color;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint ? tint : "black",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = PoolGroup/* BigPool */.u.get(Graphics/* Graphics */.T);\n    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    bitmapText.on("destroyed", () => {\n      this.destroyRenderable(bitmapText);\n    });\n    return this._gpuBitmapText[bitmapText.uid];\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache/* Cache */.C.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const resolution = bitmapText.resolution ?? this._renderer.resolution;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    for (const uid in this._gpuBitmapText) {\n      this._destroyRenderableByUid(uid);\n    }\n    this._gpuBitmapText = null;\n    this._sdfShader?.destroy(true);\n    this._sdfShader = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "bitmapText"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\n\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUFPLEtBQUssd0JBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBSyxRQUFRLFdBQVc7QUFDaEQsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCOzs7QUNwSjZEO0FBQ3NCO0FBQzdCOztBQUV0RDtBQUNBLDZCQUFVLEtBQUssY0FBYyxFQUFFLGNBQWMsRUFBRSxxQkFBcUI7QUFDcEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvQWJzdHJhY3RCaXRtYXBGb250Lm1qcz85MWFmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5tanM/YWMzYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvRHluYW1pY0JpdG1hcEZvbnQubWpzPzVlODQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL3V0aWxzL2dldEJpdG1hcFRleHRMYXlvdXQubWpzPzQ0YmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL0JpdG1hcEZvbnRNYW5hZ2VyLm1qcz9lZDAyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9CaXRtYXBGb250Lm1qcz8yNzc5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250VGV4dFBhcnNlci5tanM/M2U1MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvYXNzZXQvYml0bWFwRm9udFhNTFBhcnNlci5tanM/NWUwYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvYXNzZXQvYml0bWFwRm9udFhNTFN0cmluZ1BhcnNlci5tanM/MDVkMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvYXNzZXQvbG9hZEJpdG1hcEZvbnQubWpzPzVmMGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvc2RmU2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzPzlkYWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvc2RmU2hhZGVyL3NoYWRlci1iaXRzL21TREZCaXQubWpzPzBjNTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvc2RmU2hhZGVyL1NkZlNoYWRlci5tanM/YTAzMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwVGV4dFBpcGUubWpzPzVkYjciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL2luaXQubWpzP2VlNzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQWJzdHJhY3RCaXRtYXBGb250IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKiogVGhlIG1hcCBvZiBjaGFyYWN0ZXJzIGJ5IGNoYXJhY3RlciBjb2RlLiAqL1xuICAgIHRoaXMuY2hhcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbGluZS1oZWlnaHQgb2YgdGhlIGZvbnQgZmFjZSBpbiBwaXhlbHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmb250IGZhY2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiXCI7XG4gICAgLyoqIFRoZSBtZXRyaWNzIG9mIHRoZSBmb250IGZhY2UuICovXG4gICAgdGhpcy5mb250TWV0cmljcyA9IHsgZm9udFNpemU6IDAsIGFzY2VudDogMCwgZGVzY2VudDogMCB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgb2YgdGhlIGZvbnQgZmFjZSBmcm9tIHRoZSBiYXNlbGluZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUxpbmVPZmZzZXQgPSAwO1xuICAgIC8qKiBUaGUgcmFuZ2UgYW5kIHR5cGUgb2YgdGhlIGRpc3RhbmNlIGZpZWxkIGZvciB0aGlzIGZvbnQuICovXG4gICAgdGhpcy5kaXN0YW5jZUZpZWxkID0geyB0eXBlOiBcIm5vbmVcIiwgcmFuZ2U6IDAgfTtcbiAgICAvKiogVGhlIG1hcCBvZiBiYXNlIHBhZ2UgdGV4dHVyZXMgKGkuZS4sIHNoZWV0cyBvZiBnbHlwaHMpLiAqL1xuICAgIHRoaXMucGFnZXMgPSBbXTtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIGZvbnQgZmFjZSBpbiBwaXhlbHMuICovXG4gICAgdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZSA9IDEwMDtcbiAgICB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplID0gMTAwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZm9udCBmYWNlLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYGZvbnRGYW1pbHlgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgZm9udCgpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5mb250IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5mb250RmFtaWx5IGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmZvbnRGYW1pbHk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXAgb2YgYmFzZSBwYWdlIHRleHR1cmVzIChpLmUuLCBzaGVldHMgb2YgZ2x5cGhzKS5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBwYWdlc2AgaW5zdGVhZC5cbiAgICovXG4gIGdldCBwYWdlVGV4dHVyZXMoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQucGFnZVRleHR1cmVzIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5wYWdlcyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlcztcbiAgfVxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGZvbnQgZmFjZSBpbiBwaXhlbHMuXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSBgZm9udE1ldHJpY3MuZm9udFNpemVgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5zaXplIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5mb250TWV0cmljcy5mb250U2l6ZSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5mb250TWV0cmljcy5mb250U2l6ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGtpbmQgb2YgZGlzdGFuY2UgZmllbGQgZm9yIHRoaXMgZm9udCBvciBcIm5vbmVcIi5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBkaXN0YW5jZUZpZWxkLnR5cGVgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgZGlzdGFuY2VGaWVsZFJhbmdlKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LmRpc3RhbmNlRmllbGRSYW5nZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJpdG1hcEZvbnQuZGlzdGFuY2VGaWVsZC5yYW5nZSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZUZpZWxkLnJhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmFuZ2Ugb2YgdGhlIGRpc3RhbmNlIGZpZWxkIGluIHBpeGVscy5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBkaXN0YW5jZUZpZWxkLnJhbmdlYCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGRpc3RhbmNlRmllbGRUeXBlKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LmRpc3RhbmNlRmllbGRUeXBlIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5kaXN0YW5jZUZpZWxkLnR5cGUgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VGaWVsZC50eXBlO1xuICB9XG4gIGRlc3Ryb3koZGVzdHJveVRleHR1cmVzID0gZmFsc2UpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuY2hhcnMpIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0udGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuY2hhcnMgPSBudWxsO1xuICAgIGlmIChkZXN0cm95VGV4dHVyZXMpIHtcbiAgICAgIHRoaXMucGFnZXMuZm9yRWFjaCgocGFnZSkgPT4gcGFnZS50ZXh0dXJlLmRlc3Ryb3kodHJ1ZSkpO1xuICAgICAgdGhpcy5wYWdlcyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEFic3RyYWN0Qml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RCaXRtYXBGb250Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpIHtcbiAgaWYgKGNoYXJzID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICh0eXBlb2YgY2hhcnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjaGFycyA9IFtjaGFyc107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBqID0gY2hhcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IGNoYXJzW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBpZiAoaXRlbS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlIGxlbmd0aCwgZXhwZWN0aW5nIDIgZ290ICR7aXRlbS5sZW5ndGh9LmApO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMF0ubGVuZ3RoID09PSAwIHx8IGl0ZW1bMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgZGVsaW1pdGVyLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0Q29kZSA9IGl0ZW1bMF0uY2hhckNvZGVBdCgwKTtcbiAgICAgIGNvbnN0IGVuZENvZGUgPSBpdGVtWzFdLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoZW5kQ29kZSA8IHN0YXJ0Q29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkyID0gc3RhcnRDb2RlLCBqMiA9IGVuZENvZGU7IGkyIDw9IGoyOyBpMisrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaTIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goLi4uQXJyYXkuZnJvbShpdGVtKSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRdOiBFbXB0eSBzZXQgd2hlbiByZXNvbHZpbmcgY2hhcmFjdGVycy5cIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVDaGFyYWN0ZXJzLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IENhbnZhc1Bvb2wgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcbmltcG9ydCB7IEltYWdlU291cmNlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0ltYWdlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuLi90ZXh0L2NhbnZhcy9DYW52YXNUZXh0TWV0cmljcy5tanMnO1xuaW1wb3J0IHsgZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUgfSBmcm9tICcuLi90ZXh0L2NhbnZhcy91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH0gZnJvbSAnLi4vdGV4dC9jYW52YXMvdXRpbHMvZ2V0Q2FudmFzRmlsbFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdEJpdG1hcEZvbnQgfSBmcm9tICcuL0Fic3RyYWN0Qml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRHluYW1pY0JpdG1hcEZvbnQgZXh0ZW5kcyBBYnN0cmFjdEJpdG1hcEZvbnQge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGR5bmFtaWMgYml0bWFwIGZvbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIGEgcmVzb2x1dGlvbiBtb2RpZmllciBmb3IgdGhlIGZvbnQgc2l6ZS4uXG4gICAgICogdGV4dHVyZSByZXNvbHV0aW9uIHdpbGwgYWxzbyBiZSB1c2VkIHRvIHNjYWxlIHRleHR1cmUgYWNjb3JkaW5nIHRvIGl0cyBmb250IHNpemUgYWxzb1xuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG4gICAgLyoqIFRoZSBwYWdlcyBvZiB0aGUgZm9udC4gKi9cbiAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgdGhpcy5fcGFkZGluZyA9IDQ7XG4gICAgdGhpcy5fbWVhc3VyZUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fY3VycmVudENoYXJzID0gW107XG4gICAgdGhpcy5fY3VycmVudFggPSAwO1xuICAgIHRoaXMuX2N1cnJlbnRZID0gMDtcbiAgICB0aGlzLl9jdXJyZW50UGFnZUluZGV4ID0gLTE7XG4gICAgdGhpcy5fc2tpcEtlcm5pbmcgPSBmYWxzZTtcbiAgICBjb25zdCBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc3R5bGUgPSBkeW5hbWljT3B0aW9ucy5zdHlsZS5jbG9uZSgpO1xuICAgIGlmIChkeW5hbWljT3B0aW9ucy5vdmVycmlkZUZpbGwpIHtcbiAgICAgIHN0eWxlLl9maWxsLmNvbG9yID0gMTY3NzcyMTU7XG4gICAgICBzdHlsZS5fZmlsbC5hbHBoYSA9IDE7XG4gICAgICBzdHlsZS5fZmlsbC50ZXh0dXJlID0gVGV4dHVyZS5XSElURTtcbiAgICAgIHN0eWxlLl9maWxsLmZpbGwgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ZWRGb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgIHN0eWxlLmZvbnRTaXplID0gdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZTtcbiAgICBjb25zdCBmb250ID0gZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUoc3R5bGUpO1xuICAgIGlmIChkeW5hbWljT3B0aW9ucy5vdmVycmlkZVNpemUpIHtcbiAgICAgIGlmIChzdHlsZS5fc3Ryb2tlKSB7XG4gICAgICAgIHN0eWxlLl9zdHJva2Uud2lkdGggKj0gdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZSAvIHJlcXVlc3RlZEZvbnRTaXplO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgPSByZXF1ZXN0ZWRGb250U2l6ZTtcbiAgICB9XG4gICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLl9za2lwS2VybmluZyA9IGR5bmFtaWNPcHRpb25zLnNraXBLZXJuaW5nID8/IGZhbHNlO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IGR5bmFtaWNPcHRpb25zLnJlc29sdXRpb24gPz8gMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gZHluYW1pY09wdGlvbnMucGFkZGluZyA/PyA0O1xuICAgIHRoaXMuZm9udE1ldHJpY3MgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlRm9udChmb250KTtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IHRoaXMuZm9udE1ldHJpY3MuZm9udFNpemUgfHwgc3R5bGUuZm9udFNpemU7XG4gIH1cbiAgZW5zdXJlQ2hhcmFjdGVycyhjaGFycykge1xuICAgIGNvbnN0IGNoYXJMaXN0ID0gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpLmZpbHRlcigoY2hhcikgPT4gIXRoaXMuX2N1cnJlbnRDaGFycy5pbmNsdWRlcyhjaGFyKSkuZmlsdGVyKChjaGFyLCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKGNoYXIpID09PSBpbmRleCk7XG4gICAgaWYgKCFjaGFyTGlzdC5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY3VycmVudENoYXJzID0gWy4uLnRoaXMuX2N1cnJlbnRDaGFycywgLi4uY2hhckxpc3RdO1xuICAgIGxldCBwYWdlRGF0YTtcbiAgICBpZiAodGhpcy5fY3VycmVudFBhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgIHBhZ2VEYXRhID0gdGhpcy5fbmV4dFBhZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZURhdGEgPSB0aGlzLnBhZ2VzW3RoaXMuX2N1cnJlbnRQYWdlSW5kZXhdO1xuICAgIH1cbiAgICBsZXQgeyBjYW52YXMsIGNvbnRleHQgfSA9IHBhZ2VEYXRhLmNhbnZhc0FuZENvbnRleHQ7XG4gICAgbGV0IHRleHR1cmVTb3VyY2UgPSBwYWdlRGF0YS50ZXh0dXJlLnNvdXJjZTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgIGxldCBjdXJyZW50WCA9IHRoaXMuX2N1cnJlbnRYO1xuICAgIGxldCBjdXJyZW50WSA9IHRoaXMuX2N1cnJlbnRZO1xuICAgIGNvbnN0IGZvbnRTY2FsZSA9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgLyB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nICogZm9udFNjYWxlO1xuICAgIGNvbnN0IHdpZHRoU2NhbGUgPSBzdHlsZS5mb250U3R5bGUgPT09IFwiaXRhbGljXCIgPyAyIDogMTtcbiAgICBsZXQgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgbGV0IHNraXBUZXh0dXJlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJMaXN0W2ldO1xuICAgICAgY29uc3QgbWV0cmljcyA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVUZXh0KGNoYXIsIHN0eWxlLCBjYW52YXMsIGZhbHNlKTtcbiAgICAgIG1ldHJpY3MubGluZUhlaWdodCA9IG1ldHJpY3MuaGVpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSB3aWR0aFNjYWxlICogbWV0cmljcy53aWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IG1ldHJpY3MuaGVpZ2h0ICogZm9udFNjYWxlO1xuICAgICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIHBhZGRpbmcgKiAyO1xuICAgICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgcGFkZGluZyAqIDI7XG4gICAgICBza2lwVGV4dHVyZSA9IGZhbHNlO1xuICAgICAgaWYgKGNoYXIgIT09IFwiXFxuXCIgJiYgY2hhciAhPT0gXCJcXHJcIiAmJiBjaGFyICE9PSBcIlx0XCIgJiYgY2hhciAhPT0gXCIgXCIpIHtcbiAgICAgICAgc2tpcFRleHR1cmUgPSB0cnVlO1xuICAgICAgICBtYXhDaGFySGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KHBhZGRlZEhlaWdodCwgbWF4Q2hhckhlaWdodCkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRYICsgcGFkZGVkV2lkdGggPiA1MTIpIHtcbiAgICAgICAgY3VycmVudFkgKz0gbWF4Q2hhckhlaWdodDtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IHBhZGRlZEhlaWdodDtcbiAgICAgICAgY3VycmVudFggPSAwO1xuICAgICAgICBpZiAoY3VycmVudFkgKyBtYXhDaGFySGVpZ2h0ID4gNTEyKSB7XG4gICAgICAgICAgdGV4dHVyZVNvdXJjZS51cGRhdGUoKTtcbiAgICAgICAgICBjb25zdCBwYWdlRGF0YTIgPSB0aGlzLl9uZXh0UGFnZSgpO1xuICAgICAgICAgIGNhbnZhcyA9IHBhZ2VEYXRhMi5jYW52YXNBbmRDb250ZXh0LmNhbnZhcztcbiAgICAgICAgICBjb250ZXh0ID0gcGFnZURhdGEyLmNhbnZhc0FuZENvbnRleHQuY29udGV4dDtcbiAgICAgICAgICB0ZXh0dXJlU291cmNlID0gcGFnZURhdGEyLnRleHR1cmUuc291cmNlO1xuICAgICAgICAgIGN1cnJlbnRZID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgeEFkdmFuY2UgPSB3aWR0aCAvIGZvbnRTY2FsZSAtIChzdHlsZS5kcm9wU2hhZG93Py5kaXN0YW5jZSA/PyAwKSAtIChzdHlsZS5fc3Ryb2tlPy53aWR0aCA/PyAwKTtcbiAgICAgIHRoaXMuY2hhcnNbY2hhcl0gPSB7XG4gICAgICAgIGlkOiBjaGFyLmNvZGVQb2ludEF0KDApLFxuICAgICAgICB4T2Zmc2V0OiAtdGhpcy5fcGFkZGluZyxcbiAgICAgICAgeU9mZnNldDogLXRoaXMuX3BhZGRpbmcsXG4gICAgICAgIHhBZHZhbmNlLFxuICAgICAgICBrZXJuaW5nOiB7fVxuICAgICAgfTtcbiAgICAgIGlmIChza2lwVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9kcmF3R2x5cGgoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBtZXRyaWNzLFxuICAgICAgICAgIGN1cnJlbnRYICsgcGFkZGluZyxcbiAgICAgICAgICBjdXJyZW50WSArIHBhZGRpbmcsXG4gICAgICAgICAgZm9udFNjYWxlLFxuICAgICAgICAgIHN0eWxlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHB4ID0gdGV4dHVyZVNvdXJjZS53aWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgY29uc3QgcHkgPSB0ZXh0dXJlU291cmNlLmhlaWdodCAqIGZvbnRTY2FsZTtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgIGN1cnJlbnRYIC8gcHggKiB0ZXh0dXJlU291cmNlLndpZHRoLFxuICAgICAgICAgIGN1cnJlbnRZIC8gcHkgKiB0ZXh0dXJlU291cmNlLmhlaWdodCxcbiAgICAgICAgICBwYWRkZWRXaWR0aCAvIHB4ICogdGV4dHVyZVNvdXJjZS53aWR0aCxcbiAgICAgICAgICBwYWRkZWRIZWlnaHQgLyBweSAqIHRleHR1cmVTb3VyY2UuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2hhcnNbY2hhcl0udGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcbiAgICAgICAgICBzb3VyY2U6IHRleHR1cmVTb3VyY2UsXG4gICAgICAgICAgZnJhbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRYICs9IE1hdGguY2VpbChwYWRkZWRXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRleHR1cmVTb3VyY2UudXBkYXRlKCk7XG4gICAgdGhpcy5fY3VycmVudFggPSBjdXJyZW50WDtcbiAgICB0aGlzLl9jdXJyZW50WSA9IGN1cnJlbnRZO1xuICAgIHRoaXMuX3NraXBLZXJuaW5nICYmIHRoaXMuX2FwcGx5S2VybmluZyhjaGFyTGlzdCwgY29udGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wXG4gICAqIFRoZSBtYXAgb2YgYmFzZSBwYWdlIHRleHR1cmVzIChpLmUuLCBzaGVldHMgb2YgZ2x5cGhzKS5cbiAgICovXG4gIGdldCBwYWdlVGV4dHVyZXMoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQucGFnZVRleHR1cmVzIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5wYWdlcyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlcztcbiAgfVxuICBfYXBwbHlLZXJuaW5nKG5ld0NoYXJzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbWVhc3VyZUNhY2hlID0gdGhpcy5fbWVhc3VyZUNhY2hlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gbmV3Q2hhcnNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2N1cnJlbnRDaGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBzZWNvbmQgPSB0aGlzLl9jdXJyZW50Q2hhcnNbal07XG4gICAgICAgIGxldCBjMSA9IG1lYXN1cmVDYWNoZVtmaXJzdF07XG4gICAgICAgIGlmICghYzEpXG4gICAgICAgICAgYzEgPSBtZWFzdXJlQ2FjaGVbZmlyc3RdID0gY29udGV4dC5tZWFzdXJlVGV4dChmaXJzdCkud2lkdGg7XG4gICAgICAgIGxldCBjMiA9IG1lYXN1cmVDYWNoZVtzZWNvbmRdO1xuICAgICAgICBpZiAoIWMyKVxuICAgICAgICAgIGMyID0gbWVhc3VyZUNhY2hlW3NlY29uZF0gPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHNlY29uZCkud2lkdGg7XG4gICAgICAgIGxldCB0b3RhbCA9IGNvbnRleHQubWVhc3VyZVRleHQoZmlyc3QgKyBzZWNvbmQpLndpZHRoO1xuICAgICAgICBsZXQgYW1vdW50ID0gdG90YWwgLSAoYzEgKyBjMik7XG4gICAgICAgIGlmIChhbW91bnQpIHtcbiAgICAgICAgICB0aGlzLmNoYXJzW2ZpcnN0XS5rZXJuaW5nW3NlY29uZF0gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0ICsgc2Vjb25kKS53aWR0aDtcbiAgICAgICAgYW1vdW50ID0gdG90YWwgLSAoYzEgKyBjMik7XG4gICAgICAgIGlmIChhbW91bnQpIHtcbiAgICAgICAgICB0aGlzLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX25leHRQYWdlKCkge1xuICAgIHRoaXMuX2N1cnJlbnRQYWdlSW5kZXgrKztcbiAgICBjb25zdCB0ZXh0dXJlUmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dCg1MTIsIDUxMiwgdGV4dHVyZVJlc29sdXRpb24pO1xuICAgIHRoaXMuX3NldHVwQ29udGV4dChjYW52YXNBbmRDb250ZXh0LmNvbnRleHQsIHRoaXMuX3N0eWxlLCB0ZXh0dXJlUmVzb2x1dGlvbik7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRleHR1cmVSZXNvbHV0aW9uICogKHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgLyB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgc291cmNlOiBuZXcgSW1hZ2VTb3VyY2Uoe1xuICAgICAgICByZXNvdXJjZTogY2FudmFzQW5kQ29udGV4dC5jYW52YXMsXG4gICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgIGFscGhhTW9kZTogXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBwYWdlRGF0YSA9IHtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQsXG4gICAgICB0ZXh0dXJlXG4gICAgfTtcbiAgICB0aGlzLnBhZ2VzW3RoaXMuX2N1cnJlbnRQYWdlSW5kZXhdID0gcGFnZURhdGE7XG4gICAgcmV0dXJuIHBhZ2VEYXRhO1xuICB9XG4gIC8vIGNhbnZhcyBzdHlsZSFcbiAgX3NldHVwQ29udGV4dChjb250ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbikge1xuICAgIHN0eWxlLmZvbnRTaXplID0gdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZTtcbiAgICBjb250ZXh0LnNjYWxlKHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZU1lYXN1cmVtZW50Rm9udFNpemU7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuX3N0cm9rZTtcbiAgICBjb25zdCBzdHJva2VUaGlja25lc3MgPSBzdHJva2U/LndpZHRoID8/IDA7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VUaGlja25lc3M7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gc3Ryb2tlLmpvaW47XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2UubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNGaWxsU3R5bGUoc3Ryb2tlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHN0eWxlLl9maWxsKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdldENhbnZhc0ZpbGxTdHlsZShzdHlsZS5fZmlsbCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICBjb25zdCBzaGFkb3dPcHRpb25zID0gc3R5bGUuZHJvcFNoYWRvdztcbiAgICAgIGNvbnN0IHJnYiA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzaGFkb3dPcHRpb25zLmNvbG9yKS50b0FycmF5KCk7XG4gICAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHNoYWRvd09wdGlvbnMuYmx1ciAqIHJlc29sdXRpb247XG4gICAgICBjb25zdCBkcm9wU2hhZG93RGlzdGFuY2UgPSBzaGFkb3dPcHRpb25zLmRpc3RhbmNlICogcmVzb2x1dGlvbjtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBgcmdiYSgke3JnYlswXSAqIDI1NX0sJHtyZ2JbMV0gKiAyNTV9LCR7cmdiWzJdICogMjU1fSwke3NoYWRvd09wdGlvbnMuYWxwaGF9KWA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHNoYWRvd09wdGlvbnMuYW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc2hhZG93T3B0aW9ucy5hbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgfVxuICB9XG4gIF9kcmF3R2x5cGgoY29udGV4dCwgbWV0cmljcywgeCwgeSwgZm9udFNjYWxlLCBzdHlsZSkge1xuICAgIGNvbnN0IGNoYXIgPSBtZXRyaWNzLnRleHQ7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHN0cm9rZSA9IHN0eWxlLl9zdHJva2U7XG4gICAgY29uc3Qgc3Ryb2tlVGhpY2tuZXNzID0gKHN0cm9rZT8ud2lkdGggPz8gMCkgKiBmb250U2NhbGU7XG4gICAgY29uc3QgdHggPSB4ICsgc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICBjb25zdCB0eSA9IHkgLSBzdHJva2VUaGlja25lc3MgLyAyO1xuICAgIGNvbnN0IGRlc2NlbnQgPSBmb250UHJvcGVydGllcy5kZXNjZW50ICogZm9udFNjYWxlO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBtZXRyaWNzLmxpbmVIZWlnaHQgKiBmb250U2NhbGU7XG4gICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChjaGFyLCB0eCwgdHkgKyBsaW5lSGVpZ2h0IC0gZGVzY2VudCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5fZmlsbCkge1xuICAgICAgY29udGV4dC5maWxsVGV4dChjaGFyLCB0eCwgdHkgKyBsaW5lSGVpZ2h0IC0gZGVzY2VudCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBjYW52YXNBbmRDb250ZXh0LCB0ZXh0dXJlIH0gPSB0aGlzLnBhZ2VzW2ldO1xuICAgICAgQ2FudmFzUG9vbC5yZXR1cm5DYW52YXNBbmRDb250ZXh0KGNhbnZhc0FuZENvbnRleHQpO1xuICAgICAgdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnBhZ2VzID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBEeW5hbWljQml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHluYW1pY0JpdG1hcEZvbnQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRCaXRtYXBUZXh0TGF5b3V0KGNoYXJzLCBzdHlsZSwgZm9udCkge1xuICBjb25zdCBsYXlvdXREYXRhID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBvZmZzZXRZOiAwLFxuICAgIHNjYWxlOiBzdHlsZS5mb250U2l6ZSAvIGZvbnQuYmFzZU1lYXN1cmVtZW50Rm9udFNpemUsXG4gICAgbGluZXM6IFt7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGNoYXJQb3NpdGlvbnM6IFtdLFxuICAgICAgc3BhY2VXaWR0aDogMCxcbiAgICAgIHNwYWNlc0luZGV4OiBbXSxcbiAgICAgIGNoYXJzOiBbXVxuICAgIH1dXG4gIH07XG4gIGxheW91dERhdGEub2Zmc2V0WSA9IGZvbnQuYmFzZUxpbmVPZmZzZXQ7XG4gIGxldCBjdXJyZW50TGluZSA9IGxheW91dERhdGEubGluZXNbMF07XG4gIGxldCBwcmV2aW91c0NoYXIgPSBudWxsO1xuICBsZXQgZmlyc3RXb3JkID0gdHJ1ZTtcbiAgY29uc3QgY3VycmVudFdvcmQgPSB7XG4gICAgc3BhY2VXb3JkOiBmYWxzZSxcbiAgICB3aWR0aDogMCxcbiAgICBzdGFydDogMCxcbiAgICBpbmRleDogMCxcbiAgICAvLyB1c2UgaW5kZXggdG8gbm90IG1vZGlmeSB0aGUgYXJyYXkgYXMgd2UgdXNlIGl0IGEgbG90IVxuICAgIHBvc2l0aW9uczogW10sXG4gICAgY2hhcnM6IFtdXG4gIH07XG4gIGNvbnN0IG5leHRXb3JkID0gKHdvcmQpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IGN1cnJlbnRMaW5lLndpZHRoO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VycmVudFdvcmQuaW5kZXg7IGorKykge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB3b3JkLnBvc2l0aW9uc1tqXTtcbiAgICAgIGN1cnJlbnRMaW5lLmNoYXJzLnB1c2god29yZC5jaGFyc1tqXSk7XG4gICAgICBjdXJyZW50TGluZS5jaGFyUG9zaXRpb25zLnB1c2gocG9zaXRpb24gKyBzdGFydCk7XG4gICAgfVxuICAgIGN1cnJlbnRMaW5lLndpZHRoICs9IHdvcmQud2lkdGg7XG4gICAgZmlyc3RXb3JkID0gZmFsc2U7XG4gICAgY3VycmVudFdvcmQud2lkdGggPSAwO1xuICAgIGN1cnJlbnRXb3JkLmluZGV4ID0gMDtcbiAgICBjdXJyZW50V29yZC5jaGFycy5sZW5ndGggPSAwO1xuICB9O1xuICBjb25zdCBuZXh0TGluZSA9ICgpID0+IHtcbiAgICBsZXQgaW5kZXggPSBjdXJyZW50TGluZS5jaGFycy5sZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Q2hhciA9IGN1cnJlbnRMaW5lLmNoYXJzW2luZGV4XTtcbiAgICB3aGlsZSAobGFzdENoYXIgPT09IFwiIFwiKSB7XG4gICAgICBjdXJyZW50TGluZS53aWR0aCAtPSBmb250LmNoYXJzW2xhc3RDaGFyXS54QWR2YW5jZTtcbiAgICAgIGxhc3RDaGFyID0gY3VycmVudExpbmUuY2hhcnNbLS1pbmRleF07XG4gICAgfVxuICAgIGxheW91dERhdGEud2lkdGggPSBNYXRoLm1heChsYXlvdXREYXRhLndpZHRoLCBjdXJyZW50TGluZS53aWR0aCk7XG4gICAgY3VycmVudExpbmUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGNoYXJQb3NpdGlvbnM6IFtdLFxuICAgICAgY2hhcnM6IFtdLFxuICAgICAgc3BhY2VXaWR0aDogMCxcbiAgICAgIHNwYWNlc0luZGV4OiBbXVxuICAgIH07XG4gICAgZmlyc3RXb3JkID0gdHJ1ZTtcbiAgICBsYXlvdXREYXRhLmxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgIGxheW91dERhdGEuaGVpZ2h0ICs9IGZvbnQubGluZUhlaWdodDtcbiAgfTtcbiAgY29uc3Qgc2NhbGUgPSBmb250LmJhc2VNZWFzdXJlbWVudEZvbnRTaXplIC8gc3R5bGUuZm9udFNpemU7XG4gIGNvbnN0IGFkanVzdGVkTGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmcgKiBzY2FsZTtcbiAgY29uc3QgYWRqdXN0ZWRXb3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCAqIHNjYWxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aCArIDE7IGkrKykge1xuICAgIGxldCBjaGFyO1xuICAgIGNvbnN0IGlzRW5kID0gaSA9PT0gY2hhcnMubGVuZ3RoO1xuICAgIGlmICghaXNFbmQpIHtcbiAgICAgIGNoYXIgPSBjaGFyc1tpXTtcbiAgICB9XG4gICAgY29uc3QgY2hhckRhdGEgPSBmb250LmNoYXJzW2NoYXJdIHx8IGZvbnQuY2hhcnNbXCIgXCJdO1xuICAgIGNvbnN0IGlzU3BhY2UgPSAvKD86XFxzKS8udGVzdChjaGFyKTtcbiAgICBjb25zdCBpc1dvcmRCcmVhayA9IGlzU3BhY2UgfHwgY2hhciA9PT0gXCJcXHJcIiB8fCBjaGFyID09PSBcIlxcblwiIHx8IGlzRW5kO1xuICAgIGlmIChpc1dvcmRCcmVhaykge1xuICAgICAgY29uc3QgYWRkV29yZFRvTmV4dExpbmUgPSAhZmlyc3RXb3JkICYmIHN0eWxlLndvcmRXcmFwICYmIGN1cnJlbnRMaW5lLndpZHRoICsgY3VycmVudFdvcmQud2lkdGggLSBhZGp1c3RlZExldHRlclNwYWNpbmcgPiBhZGp1c3RlZFdvcmRXcmFwV2lkdGg7XG4gICAgICBpZiAoYWRkV29yZFRvTmV4dExpbmUpIHtcbiAgICAgICAgbmV4dExpbmUoKTtcbiAgICAgICAgbmV4dFdvcmQoY3VycmVudFdvcmQpO1xuICAgICAgICBpZiAoIWlzRW5kKSB7XG4gICAgICAgICAgY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50V29yZC5zdGFydCA9IGN1cnJlbnRMaW5lLndpZHRoO1xuICAgICAgICBuZXh0V29yZChjdXJyZW50V29yZCk7XG4gICAgICAgIGlmICghaXNFbmQpIHtcbiAgICAgICAgICBjdXJyZW50TGluZS5jaGFyUG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSBcIlxcclwiIHx8IGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgbmV4dExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNFbmQpIHtcbiAgICAgICAgY29uc3Qgc3BhY2VXaWR0aCA9IGNoYXJEYXRhLnhBZHZhbmNlICsgKGNoYXJEYXRhLmtlcm5pbmdbcHJldmlvdXNDaGFyXSB8fCAwKSArIGFkanVzdGVkTGV0dGVyU3BhY2luZztcbiAgICAgICAgY3VycmVudExpbmUud2lkdGggKz0gc3BhY2VXaWR0aDtcbiAgICAgICAgY3VycmVudExpbmUuc3BhY2VXaWR0aCA9IHNwYWNlV2lkdGg7XG4gICAgICAgIGN1cnJlbnRMaW5lLnNwYWNlc0luZGV4LnB1c2goY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGgpO1xuICAgICAgICBjdXJyZW50TGluZS5jaGFycy5wdXNoKGNoYXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXJuaW5nID0gY2hhckRhdGEua2VybmluZ1twcmV2aW91c0NoYXJdIHx8IDA7XG4gICAgICBjb25zdCBuZXh0Q2hhcldpZHRoID0gY2hhckRhdGEueEFkdmFuY2UgKyBrZXJuaW5nICsgYWRqdXN0ZWRMZXR0ZXJTcGFjaW5nO1xuICAgICAgY3VycmVudFdvcmQucG9zaXRpb25zW2N1cnJlbnRXb3JkLmluZGV4KytdID0gY3VycmVudFdvcmQud2lkdGggKyBrZXJuaW5nO1xuICAgICAgY3VycmVudFdvcmQuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgIGN1cnJlbnRXb3JkLndpZHRoICs9IG5leHRDaGFyV2lkdGg7XG4gICAgfVxuICAgIHByZXZpb3VzQ2hhciA9IGNoYXI7XG4gIH1cbiAgbmV4dExpbmUoKTtcbiAgaWYgKHN0eWxlLmFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgYWxpZ25DZW50ZXIobGF5b3V0RGF0YSk7XG4gIH0gZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgIGFsaWduUmlnaHQobGF5b3V0RGF0YSk7XG4gIH0gZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09IFwianVzdGlmeVwiKSB7XG4gICAgYWxpZ25KdXN0aWZ5KGxheW91dERhdGEpO1xuICB9XG4gIHJldHVybiBsYXlvdXREYXRhO1xufVxuZnVuY3Rpb24gYWxpZ25DZW50ZXIobWVhc3VyZW1lbnREYXRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyZW1lbnREYXRhLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IG1lYXN1cmVtZW50RGF0YS5saW5lc1tpXTtcbiAgICBjb25zdCBvZmZzZXQgPSBtZWFzdXJlbWVudERhdGEud2lkdGggLyAyIC0gbGluZS53aWR0aCAvIDI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxpbmUuY2hhclBvc2l0aW9uc1tqXSArPSBvZmZzZXQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhbGlnblJpZ2h0KG1lYXN1cmVtZW50RGF0YSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmVtZW50RGF0YS5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtZWFzdXJlbWVudERhdGEubGluZXNbaV07XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWVhc3VyZW1lbnREYXRhLndpZHRoIC0gbGluZS53aWR0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgbGluZS5jaGFyUG9zaXRpb25zW2pdICs9IG9mZnNldDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFsaWduSnVzdGlmeShtZWFzdXJlbWVudERhdGEpIHtcbiAgY29uc3Qgd2lkdGggPSBtZWFzdXJlbWVudERhdGEud2lkdGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyZW1lbnREYXRhLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IG1lYXN1cmVtZW50RGF0YS5saW5lc1tpXTtcbiAgICBsZXQgaW5keSA9IDA7XG4gICAgbGV0IHNwYWNlSW5kZXggPSBsaW5lLnNwYWNlc0luZGV4W2luZHkrK107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgdG90YWxTcGFjZXMgPSBsaW5lLnNwYWNlc0luZGV4Lmxlbmd0aDtcbiAgICBjb25zdCBuZXdTcGFjZVdpZHRoID0gKHdpZHRoIC0gbGluZS53aWR0aCkgLyB0b3RhbFNwYWNlcztcbiAgICBjb25zdCBzcGFjZVdpZHRoID0gbmV3U3BhY2VXaWR0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGogPT09IHNwYWNlSW5kZXgpIHtcbiAgICAgICAgc3BhY2VJbmRleCA9IGxpbmUuc3BhY2VzSW5kZXhbaW5keSsrXTtcbiAgICAgICAgb2Zmc2V0ICs9IHNwYWNlV2lkdGg7XG4gICAgICB9XG4gICAgICBsaW5lLmNoYXJQb3NpdGlvbnNbal0gKz0gb2Zmc2V0O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBnZXRCaXRtYXBUZXh0TGF5b3V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRCaXRtYXBUZXh0TGF5b3V0Lm1qcy5tYXBcbiIsImltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi4vLi4vYXNzZXRzL2NhY2hlL0NhY2hlLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi4vdGV4dC9UZXh0U3R5bGUubWpzJztcbmltcG9ydCB7IER5bmFtaWNCaXRtYXBGb250IH0gZnJvbSAnLi9EeW5hbWljQml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9IGZyb20gJy4vdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQml0bWFwRm9udE1hbmFnZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2hhcmFjdGVyIHNldCBpbmNsdWRlcyBhbGwgdGhlIGxldHRlcnMgaW4gdGhlIGFscGhhYmV0IChib3RoIGxvd2VyLSBhbmQgdXBwZXItIGNhc2UpLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogQml0bWFwRm9udC5mcm9tKCdFeGFtcGxlRm9udCcsIHN0eWxlLCB7IGNoYXJzOiBCaXRtYXBGb250LkFMUEhBIH0pXG4gICAgICovXG4gICAgdGhpcy5BTFBIQSA9IFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFwiIFwiXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgaW5jbHVkZXMgYWxsIGRlY2ltYWwgZGlnaXRzIChmcm9tIDAgdG8gOSkuXG4gICAgICogQHR5cGUge3N0cmluZ1tdW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBCaXRtYXBGb250LmZyb20oJ0V4YW1wbGVGb250Jywgc3R5bGUsIHsgY2hhcnM6IEJpdG1hcEZvbnQuTlVNRVJJQyB9KVxuICAgICAqL1xuICAgIHRoaXMuTlVNRVJJQyA9IFtbXCIwXCIsIFwiOVwiXV07XG4gICAgLyoqXG4gICAgICogVGhpcyBjaGFyYWN0ZXIgc2V0IGlzIHRoZSB1bmlvbiBvZiBgQml0bWFwRm9udC5BTFBIQWAgYW5kIGBCaXRtYXBGb250Lk5VTUVSSUNgLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqL1xuICAgIHRoaXMuQUxQSEFOVU1FUklDID0gW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiIFwiXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgY29uc2lzdHMgb2YgYWxsIHRoZSBBU0NJSSB0YWJsZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmdbXVtdfVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy5hc2NpaXRhYmxlLmNvbS9cbiAgICAgKi9cbiAgICB0aGlzLkFTQ0lJID0gW1tcIiBcIiwgXCJ+XCJdXTtcbiAgICAvKiogRGVmYXVsdCBvcHRpb25zIGZvciBpbnN0YWxsaW5nIGEgbmV3IEJpdG1hcEZvbnQuICovXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGNoYXJzOiB0aGlzLkFMUEhBTlVNRVJJQyxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICBwYWRkaW5nOiA0LFxuICAgICAgc2tpcEtlcm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgZm9udCBmb3IgdGhlIHNwZWNpZmllZCB0ZXh0IGFuZCBzdHlsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBnZXQgdGhlIGZvbnQgZm9yXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIGdldEZvbnQodGV4dCwgc3R5bGUpIHtcbiAgICBsZXQgZm9udEZhbWlseUtleSA9IGAke3N0eWxlLmZvbnRGYW1pbHl9LWJpdG1hcGA7XG4gICAgbGV0IG92ZXJyaWRlRmlsbCA9IHRydWU7XG4gICAgaWYgKHN0eWxlLl9maWxsLmZpbGwpIHtcbiAgICAgIGZvbnRGYW1pbHlLZXkgKz0gc3R5bGUuX2ZpbGwuZmlsbC51aWQ7XG4gICAgICBvdmVycmlkZUZpbGwgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFDYWNoZS5oYXMoZm9udEZhbWlseUtleSkpIHtcbiAgICAgIGNvbnN0IGZudCA9IG5ldyBEeW5hbWljQml0bWFwRm9udCh7XG4gICAgICAgIHN0eWxlLFxuICAgICAgICBvdmVycmlkZUZpbGwsXG4gICAgICAgIG92ZXJyaWRlU2l6ZTogdHJ1ZSxcbiAgICAgICAgLi4udGhpcy5kZWZhdWx0T3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBmbnQub25jZShcImRlc3Ryb3lcIiwgKCkgPT4gQ2FjaGUucmVtb3ZlKGZvbnRGYW1pbHlLZXkpKTtcbiAgICAgIENhY2hlLnNldChcbiAgICAgICAgZm9udEZhbWlseUtleSxcbiAgICAgICAgZm50XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkeW5hbWljRm9udCA9IENhY2hlLmdldChmb250RmFtaWx5S2V5KTtcbiAgICBkeW5hbWljRm9udC5lbnN1cmVDaGFyYWN0ZXJzPy4odGV4dCk7XG4gICAgcmV0dXJuIGR5bmFtaWNGb250O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheW91dCBvZiBhIHRleHQgZm9yIHRoZSBzcGVjaWZpZWQgc3R5bGUuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gZ2V0IHRoZSBsYXlvdXQgZm9yXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIGdldExheW91dCh0ZXh0LCBzdHlsZSkge1xuICAgIGNvbnN0IGJpdG1hcEZvbnQgPSB0aGlzLmdldEZvbnQodGV4dCwgc3R5bGUpO1xuICAgIHJldHVybiBnZXRCaXRtYXBUZXh0TGF5b3V0KHRleHQuc3BsaXQoXCJcIiksIHN0eWxlLCBiaXRtYXBGb250KTtcbiAgfVxuICAvKipcbiAgICogTWVhc3VyZSB0aGUgdGV4dCB1c2luZyB0aGUgc3BlY2lmaWVkIHN0eWxlLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIG1lYXN1cmVcbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIHRvIHVzZVxuICAgKi9cbiAgbWVhc3VyZVRleHQodGV4dCwgc3R5bGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXlvdXQodGV4dCwgc3R5bGUpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGluc3RhbGwoLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMsXG4gICAgICAgIHN0eWxlOiBhcmdzWzFdLFxuICAgICAgICBjaGFyczogYXJnc1syXT8uY2hhcnMsXG4gICAgICAgIHJlc29sdXRpb246IGFyZ3NbMl0/LnJlc29sdXRpb24sXG4gICAgICAgIHBhZGRpbmc6IGFyZ3NbMl0/LnBhZGRpbmcsXG4gICAgICAgIHNraXBLZXJuaW5nOiBhcmdzWzJdPy5za2lwS2VybmluZ1xuICAgICAgfTtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250TWFuYWdlci5pbnN0YWxsKG5hbWUsIHN0eWxlLCBvcHRpb25zKSBpcyBkZXByZWNhdGVkLCB1c2UgQml0bWFwRm9udE1hbmFnZXIuaW5zdGFsbCh7bmFtZSwgc3R5bGUsIC4uLm9wdGlvbnN9KVwiKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IG9wdGlvbnM/Lm5hbWU7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udE1hbmFnZXJdIFByb3BlcnR5IGBuYW1lYCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCB0ZXh0U3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlID0gdGV4dFN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlID8gdGV4dFN0eWxlIDogbmV3IFRleHRTdHlsZSh0ZXh0U3R5bGUpO1xuICAgIGNvbnN0IG92ZXJyaWRlRmlsbCA9IHN0eWxlLl9maWxsLmZpbGwgIT09IG51bGwgJiYgc3R5bGUuX2ZpbGwuZmlsbCAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IGZvbnQgPSBuZXcgRHluYW1pY0JpdG1hcEZvbnQoe1xuICAgICAgc3R5bGUsXG4gICAgICBvdmVycmlkZUZpbGwsXG4gICAgICBza2lwS2VybmluZzogb3B0aW9ucy5za2lwS2VybmluZyxcbiAgICAgIHBhZGRpbmc6IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIHJlc29sdXRpb246IG9wdGlvbnMucmVzb2x1dGlvbixcbiAgICAgIG92ZXJyaWRlU2l6ZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBmbGF0Q2hhcnMgPSByZXNvbHZlQ2hhcmFjdGVycyhvcHRpb25zLmNoYXJzKTtcbiAgICBmb250LmVuc3VyZUNoYXJhY3RlcnMoZmxhdENoYXJzLmpvaW4oXCJcIikpO1xuICAgIENhY2hlLnNldChgJHtuYW1lfS1iaXRtYXBgLCBmb250KTtcbiAgICBmb250Lm9uY2UoXCJkZXN0cm95XCIsICgpID0+IENhY2hlLnJlbW92ZShgJHtuYW1lfS1iaXRtYXBgKSk7XG4gICAgcmV0dXJuIGZvbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW5zdGFsbHMgYSBiaXRtYXAgZm9udCBmcm9tIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYml0bWFwIGZvbnQgdG8gdW5pbnN0YWxsLlxuICAgKi9cbiAgdW5pbnN0YWxsKG5hbWUpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke25hbWV9LWJpdG1hcGA7XG4gICAgY29uc3QgZm9udCA9IENhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIENhY2hlLnJlbW92ZShjYWNoZUtleSk7XG4gICAgICBmb250LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IEJpdG1hcEZvbnRNYW5hZ2VyID0gbmV3IEJpdG1hcEZvbnRNYW5hZ2VyQ2xhc3MoKTtcblxuZXhwb3J0IHsgQml0bWFwRm9udE1hbmFnZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcEZvbnRNYW5hZ2VyLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEFic3RyYWN0Qml0bWFwRm9udCB9IGZyb20gJy4vQWJzdHJhY3RCaXRtYXBGb250Lm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBGb250TWFuYWdlciB9IGZyb20gJy4vQml0bWFwRm9udE1hbmFnZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCaXRtYXBGb250IGV4dGVuZHMgQWJzdHJhY3RCaXRtYXBGb250IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgdXJsKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7IHRleHR1cmVzLCBkYXRhIH0gPSBvcHRpb25zO1xuICAgIE9iamVjdC5rZXlzKGRhdGEucGFnZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgcGFnZURhdGEgPSBkYXRhLnBhZ2VzW3BhcnNlSW50KGtleSwgMTApXTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlc1twYWdlRGF0YS5pZF07XG4gICAgICB0aGlzLnBhZ2VzLnB1c2goeyB0ZXh0dXJlIH0pO1xuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKGRhdGEuY2hhcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgY2hhckRhdGEgPSBkYXRhLmNoYXJzW2tleV07XG4gICAgICBjb25zdCB0ZXh0dXJlU291cmNlID0gdGV4dHVyZXNbY2hhckRhdGEucGFnZV0uc291cmNlO1xuICAgICAgY29uc3QgZnJhbWVSZWFsID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgY2hhckRhdGEueCxcbiAgICAgICAgY2hhckRhdGEueSxcbiAgICAgICAgY2hhckRhdGEud2lkdGgsXG4gICAgICAgIGNoYXJEYXRhLmhlaWdodFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSh7XG4gICAgICAgIHNvdXJjZTogdGV4dHVyZVNvdXJjZSxcbiAgICAgICAgZnJhbWU6IGZyYW1lUmVhbFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNoYXJzW2tleV0gPSB7XG4gICAgICAgIGlkOiBrZXkuY29kZVBvaW50QXQoMCksXG4gICAgICAgIHhPZmZzZXQ6IGNoYXJEYXRhLnhPZmZzZXQsXG4gICAgICAgIHlPZmZzZXQ6IGNoYXJEYXRhLnlPZmZzZXQsXG4gICAgICAgIHhBZHZhbmNlOiBjaGFyRGF0YS54QWR2YW5jZSxcbiAgICAgICAga2VybmluZzogY2hhckRhdGEua2VybmluZyA/PyB7fSxcbiAgICAgICAgdGV4dHVyZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICB0aGlzLmZvbnRNZXRyaWNzID0ge1xuICAgICAgYXNjZW50OiAwLFxuICAgICAgZGVzY2VudDogMCxcbiAgICAgIGZvbnRTaXplOiBkYXRhLmZvbnRTaXplXG4gICAgfTtcbiAgICB0aGlzLmJhc2VMaW5lT2Zmc2V0ID0gZGF0YS5iYXNlTGluZU9mZnNldDtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBkYXRhLmxpbmVIZWlnaHQ7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gZGF0YS5mb250RmFtaWx5O1xuICAgIHRoaXMuZGlzdGFuY2VGaWVsZCA9IGRhdGEuZGlzdGFuY2VGaWVsZCA/PyB7XG4gICAgICB0eXBlOiBcIm5vbmVcIixcbiAgICAgIHJhbmdlOiAwXG4gICAgfTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIEJpdG1hcEZvbnQgb2JqZWN0LiAqL1xuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgdGV4dHVyZSB9ID0gdGhpcy5wYWdlc1tpXTtcbiAgICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5wYWdlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGJpdG1hcC1mb250IGZvciB0aGUgZ2l2ZW4gc3R5bGUgYW5kIGNoYXJhY3RlciBzZXRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZXR1cCBvcHRpb25zIGZvciBmb250IGdlbmVyYXRpb24uXG4gICAqIEByZXR1cm5zIEZvbnQgZ2VuZXJhdGVkIGJ5IHN0eWxlIG9wdGlvbnMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEJpdG1hcEZvbnQsIEJpdG1hcFRleHQgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogQml0bWFwRm9udC5pbnN0YWxsKCdUaXRsZUZvbnQnLCB7XG4gICAqICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgKiAgICAgZm9udFNpemU6IDEyLFxuICAgKiAgICAgc3Ryb2tlVGhpY2tuZXNzOiAyLFxuICAgKiAgICAgZmlsbDogJ3B1cnBsZScsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCB0aXRsZSA9IG5ldyBCaXRtYXBUZXh0KHsgdGV4dDogJ1RoaXMgaXMgdGhlIHRpdGxlJywgZm9udEZhbWlseTogJ1RpdGxlRm9udCcgfSk7XG4gICAqL1xuICBzdGF0aWMgaW5zdGFsbChvcHRpb25zKSB7XG4gICAgQml0bWFwRm9udE1hbmFnZXIuaW5zdGFsbChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogVW5pbnN0YWxscyBhIGJpdG1hcCBmb250IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaXRtYXAgZm9udCB0byB1bmluc3RhbGwuXG4gICAqL1xuICBzdGF0aWMgdW5pbnN0YWxsKG5hbWUpIHtcbiAgICBCaXRtYXBGb250TWFuYWdlci51bmluc3RhbGwobmFtZSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwRm9udC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJpdG1hcEZvbnRUZXh0UGFyc2VyID0ge1xuICB0ZXN0KGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgJiYgZGF0YS5zdGFydHNXaXRoKFwiaW5mbyBmYWNlPVwiKTtcbiAgfSxcbiAgcGFyc2UodHh0KSB7XG4gICAgY29uc3QgaXRlbXMgPSB0eHQubWF0Y2goL15bYS16XStcXHMrLiskL2dtKTtcbiAgICBjb25zdCByYXdEYXRhID0ge1xuICAgICAgaW5mbzogW10sXG4gICAgICBjb21tb246IFtdLFxuICAgICAgcGFnZTogW10sXG4gICAgICBjaGFyOiBbXSxcbiAgICAgIGNoYXJzOiBbXSxcbiAgICAgIGtlcm5pbmc6IFtdLFxuICAgICAga2VybmluZ3M6IFtdLFxuICAgICAgZGlzdGFuY2VGaWVsZDogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgaSBpbiBpdGVtcykge1xuICAgICAgY29uc3QgbmFtZSA9IGl0ZW1zW2ldLm1hdGNoKC9eW2Etel0rL2dtKVswXTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBpdGVtc1tpXS5tYXRjaCgvW2EtekEtWl0rPShbXlxcc1wiJ10rfFwiKFteXCJdKilcIikvZ20pO1xuICAgICAgY29uc3QgaXRlbURhdGEgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgaTIgaW4gYXR0cmlidXRlTGlzdCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGF0dHJpYnV0ZUxpc3RbaTJdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgY29uc3Qga2V5ID0gc3BsaXRbMF07XG4gICAgICAgIGNvbnN0IHN0clZhbHVlID0gc3BsaXRbMV0ucmVwbGFjZSgvXCIvZ20sIFwiXCIpO1xuICAgICAgICBjb25zdCBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdChzdHJWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNOYU4oZmxvYXRWYWx1ZSkgPyBzdHJWYWx1ZSA6IGZsb2F0VmFsdWU7XG4gICAgICAgIGl0ZW1EYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJhd0RhdGFbbmFtZV0ucHVzaChpdGVtRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSB7XG4gICAgICBjaGFyczoge30sXG4gICAgICBwYWdlczogW10sXG4gICAgICBsaW5lSGVpZ2h0OiAwLFxuICAgICAgZm9udFNpemU6IDAsXG4gICAgICBmb250RmFtaWx5OiBcIlwiLFxuICAgICAgZGlzdGFuY2VGaWVsZDogbnVsbCxcbiAgICAgIGJhc2VMaW5lT2Zmc2V0OiAwXG4gICAgfTtcbiAgICBjb25zdCBbaW5mb10gPSByYXdEYXRhLmluZm87XG4gICAgY29uc3QgW2NvbW1vbl0gPSByYXdEYXRhLmNvbW1vbjtcbiAgICBjb25zdCBbZGlzdGFuY2VGaWVsZF0gPSByYXdEYXRhLmRpc3RhbmNlRmllbGQgPz8gW107XG4gICAgaWYgKGRpc3RhbmNlRmllbGQpIHtcbiAgICAgIGZvbnQuZGlzdGFuY2VGaWVsZCA9IHtcbiAgICAgICAgcmFuZ2U6IHBhcnNlSW50KGRpc3RhbmNlRmllbGQuZGlzdGFuY2VSYW5nZSwgMTApLFxuICAgICAgICB0eXBlOiBkaXN0YW5jZUZpZWxkLmZpZWxkVHlwZVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9udC5mb250U2l6ZSA9IHBhcnNlSW50KGluZm8uc2l6ZSwgMTApO1xuICAgIGZvbnQuZm9udEZhbWlseSA9IGluZm8uZmFjZTtcbiAgICBmb250LmxpbmVIZWlnaHQgPSBwYXJzZUludChjb21tb24ubGluZUhlaWdodCwgMTApO1xuICAgIGNvbnN0IHBhZ2UgPSByYXdEYXRhLnBhZ2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb250LnBhZ2VzLnB1c2goe1xuICAgICAgICBpZDogcGFyc2VJbnQocGFnZVtpXS5pZCwgMTApIHx8IDAsXG4gICAgICAgIGZpbGU6IHBhZ2VbaV0uZmlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIGZvbnQuYmFzZUxpbmVPZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLSBwYXJzZUludChjb21tb24uYmFzZSwgMTApO1xuICAgIGNvbnN0IGNoYXIgPSByYXdEYXRhLmNoYXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyTm9kZSA9IGNoYXJbaV07XG4gICAgICBjb25zdCBpZCA9IHBhcnNlSW50KGNoYXJOb2RlLmlkLCAxMCk7XG4gICAgICBsZXQgbGV0dGVyID0gY2hhck5vZGUubGV0dGVyID8/IGNoYXJOb2RlLmNoYXIgPz8gU3RyaW5nLmZyb21DaGFyQ29kZShpZCk7XG4gICAgICBpZiAobGV0dGVyID09PSBcInNwYWNlXCIpXG4gICAgICAgIGxldHRlciA9IFwiIFwiO1xuICAgICAgbWFwW2lkXSA9IGxldHRlcjtcbiAgICAgIGZvbnQuY2hhcnNbbGV0dGVyXSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIC8vIHRleHR1cmUgZGVldHMuLlxuICAgICAgICBwYWdlOiBwYXJzZUludChjaGFyTm9kZS5wYWdlLCAxMCkgfHwgMCxcbiAgICAgICAgeDogcGFyc2VJbnQoY2hhck5vZGUueCwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChjaGFyTm9kZS55LCAxMCksXG4gICAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyTm9kZS53aWR0aCwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXJOb2RlLmhlaWdodCwgMTApLFxuICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChjaGFyTm9kZS54b2Zmc2V0LCAxMCksXG4gICAgICAgIHlPZmZzZXQ6IHBhcnNlSW50KGNoYXJOb2RlLnlvZmZzZXQsIDEwKSxcbiAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGNoYXJOb2RlLnhhZHZhbmNlLCAxMCksXG4gICAgICAgIGtlcm5pbmc6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBrZXJuaW5nID0gcmF3RGF0YS5rZXJuaW5nIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlyc3QgPSBwYXJzZUludChrZXJuaW5nW2ldLmZpcnN0LCAxMCk7XG4gICAgICBjb25zdCBzZWNvbmQgPSBwYXJzZUludChrZXJuaW5nW2ldLnNlY29uZCwgMTApO1xuICAgICAgY29uc3QgYW1vdW50ID0gcGFyc2VJbnQoa2VybmluZ1tpXS5hbW91bnQsIDEwKTtcbiAgICAgIGZvbnQuY2hhcnNbbWFwW3NlY29uZF1dLmtlcm5pbmdbbWFwW2ZpcnN0XV0gPSBhbW91bnQ7XG4gICAgfVxuICAgIHJldHVybiBmb250O1xuICB9XG59O1xuXG5leHBvcnQgeyBiaXRtYXBGb250VGV4dFBhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFRleHRQYXJzZXIubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBiaXRtYXBGb250WE1MUGFyc2VyID0ge1xuICB0ZXN0KGRhdGEpIHtcbiAgICBjb25zdCB4bWwgPSBkYXRhO1xuICAgIHJldHVybiB0eXBlb2YgeG1sICE9PSBcInN0cmluZ1wiICYmIFwiZ2V0RWxlbWVudHNCeVRhZ05hbWVcIiBpbiB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFnZVwiKS5sZW5ndGggJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5mb1wiKVswXS5nZXRBdHRyaWJ1dGUoXCJmYWNlXCIpICE9PSBudWxsO1xuICB9LFxuICBwYXJzZSh4bWwpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgY2hhcnM6IHt9LFxuICAgICAgcGFnZXM6IFtdLFxuICAgICAgbGluZUhlaWdodDogMCxcbiAgICAgIGZvbnRTaXplOiAwLFxuICAgICAgZm9udEZhbWlseTogXCJcIixcbiAgICAgIGRpc3RhbmNlRmllbGQ6IG51bGwsXG4gICAgICBiYXNlTGluZU9mZnNldDogMFxuICAgIH07XG4gICAgY29uc3QgaW5mbyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImluZm9cIilbMF07XG4gICAgY29uc3QgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29tbW9uXCIpWzBdO1xuICAgIGNvbnN0IGRpc3RhbmNlRmllbGQgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXN0YW5jZUZpZWxkXCIpWzBdO1xuICAgIGlmIChkaXN0YW5jZUZpZWxkKSB7XG4gICAgICBkYXRhLmRpc3RhbmNlRmllbGQgPSB7XG4gICAgICAgIHR5cGU6IGRpc3RhbmNlRmllbGQuZ2V0QXR0cmlidXRlKFwiZmllbGRUeXBlXCIpLFxuICAgICAgICByYW5nZTogcGFyc2VJbnQoZGlzdGFuY2VGaWVsZC5nZXRBdHRyaWJ1dGUoXCJkaXN0YW5jZVJhbmdlXCIpLCAxMClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBhZ2UgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYWdlXCIpO1xuICAgIGNvbnN0IGNoYXIgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjaGFyXCIpO1xuICAgIGNvbnN0IGtlcm5pbmcgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJrZXJuaW5nXCIpO1xuICAgIGRhdGEuZm9udFNpemUgPSBwYXJzZUludChpbmZvLmdldEF0dHJpYnV0ZShcInNpemVcIiksIDEwKTtcbiAgICBkYXRhLmZvbnRGYW1pbHkgPSBpbmZvLmdldEF0dHJpYnV0ZShcImZhY2VcIik7XG4gICAgZGF0YS5saW5lSGVpZ2h0ID0gcGFyc2VJbnQoY29tbW9uLmdldEF0dHJpYnV0ZShcImxpbmVIZWlnaHRcIiksIDEwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEucGFnZXMucHVzaCh7XG4gICAgICAgIGlkOiBwYXJzZUludChwYWdlW2ldLmdldEF0dHJpYnV0ZShcImlkXCIpLCAxMCkgfHwgMCxcbiAgICAgICAgZmlsZTogcGFnZVtpXS5nZXRBdHRyaWJ1dGUoXCJmaWxlXCIpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgZGF0YS5iYXNlTGluZU9mZnNldCA9IGRhdGEubGluZUhlaWdodCAtIHBhcnNlSW50KGNvbW1vbi5nZXRBdHRyaWJ1dGUoXCJiYXNlXCIpLCAxMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyTm9kZSA9IGNoYXJbaV07XG4gICAgICBjb25zdCBpZCA9IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImlkXCIpLCAxMCk7XG4gICAgICBsZXQgbGV0dGVyID0gY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwibGV0dGVyXCIpID8/IGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImNoYXJcIikgPz8gU3RyaW5nLmZyb21DaGFyQ29kZShpZCk7XG4gICAgICBpZiAobGV0dGVyID09PSBcInNwYWNlXCIpXG4gICAgICAgIGxldHRlciA9IFwiIFwiO1xuICAgICAgbWFwW2lkXSA9IGxldHRlcjtcbiAgICAgIGRhdGEuY2hhcnNbbGV0dGVyXSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIC8vIHRleHR1cmUgZGVldHMuLlxuICAgICAgICBwYWdlOiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJwYWdlXCIpLCAxMCkgfHwgMCxcbiAgICAgICAgeDogcGFyc2VJbnQoY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwieFwiKSwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ5XCIpLCAxMCksXG4gICAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgMTApLFxuICAgICAgICAvLyByZW5kZXIgZGVldHMuLlxuICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ4b2Zmc2V0XCIpLCAxMCksXG4gICAgICAgIHlPZmZzZXQ6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcInlvZmZzZXRcIiksIDEwKSxcbiAgICAgICAgLy8gKyBiYXNlTGluZU9mZnNldCxcbiAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcInhhZHZhbmNlXCIpLCAxMCksXG4gICAgICAgIGtlcm5pbmc6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZ1tpXS5nZXRBdHRyaWJ1dGUoXCJmaXJzdFwiKSwgMTApO1xuICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQoa2VybmluZ1tpXS5nZXRBdHRyaWJ1dGUoXCJzZWNvbmRcIiksIDEwKTtcbiAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiYW1vdW50XCIpLCAxMCk7XG4gICAgICBkYXRhLmNoYXJzW21hcFtzZWNvbmRdXS5rZXJuaW5nW21hcFtmaXJzdF1dID0gYW1vdW50O1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYml0bWFwRm9udFhNTFBhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFhNTFBhcnNlci5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgYml0bWFwRm9udFhNTFBhcnNlciB9IGZyb20gJy4vYml0bWFwRm9udFhNTFBhcnNlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJpdG1hcEZvbnRYTUxTdHJpbmdQYXJzZXIgPSB7XG4gIHRlc3QoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLmluY2x1ZGVzKFwiPGZvbnQ+XCIpKSB7XG4gICAgICByZXR1cm4gYml0bWFwRm9udFhNTFBhcnNlci50ZXN0KERPTUFkYXB0ZXIuZ2V0KCkucGFyc2VYTUwoZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gYml0bWFwRm9udFhNTFBhcnNlci5wYXJzZShET01BZGFwdGVyLmdldCgpLnBhcnNlWE1MKGRhdGEpKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYml0bWFwRm9udFhNTFN0cmluZ1BhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFhNTFN0cmluZ1BhcnNlci5tanMubWFwXG4iLCJpbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIubWpzJztcbmltcG9ydCB7IGNvcHlTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvdXRpbHMvY29weVNlYXJjaFBhcmFtcy5tanMnO1xuaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHBhdGggfSBmcm9tICcuLi8uLi8uLi91dGlscy9wYXRoLm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBGb250IH0gZnJvbSAnLi4vQml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgYml0bWFwRm9udFRleHRQYXJzZXIgfSBmcm9tICcuL2JpdG1hcEZvbnRUZXh0UGFyc2VyLm1qcyc7XG5pbXBvcnQgeyBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9iaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdmFsaWRFeHRlbnNpb25zID0gW1wiLnhtbFwiLCBcIi5mbnRcIl07XG5jb25zdCBiaXRtYXBGb250Q2FjaGVQbHVnaW4gPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5DYWNoZVBhcnNlcixcbiAgdGVzdDogKGFzc2V0KSA9PiBhc3NldCBpbnN0YW5jZW9mIEJpdG1hcEZvbnQsXG4gIGdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCBhc3NldCkge1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBvdXRba2V5XSA9IGFzc2V0O1xuICAgIH0pO1xuICAgIG91dFtgJHthc3NldC5mb250RmFtaWx5fS1iaXRtYXBgXSA9IGFzc2V0O1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07XG5jb25zdCBsb2FkQml0bWFwRm9udCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Ob3JtYWxcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gdmFsaWRFeHRlbnNpb25zLmluY2x1ZGVzKHBhdGguZXh0bmFtZSh1cmwpLnRvTG93ZXJDYXNlKCkpO1xuICB9LFxuICBhc3luYyB0ZXN0UGFyc2UoZGF0YSkge1xuICAgIHJldHVybiBiaXRtYXBGb250VGV4dFBhcnNlci50ZXN0KGRhdGEpIHx8IGJpdG1hcEZvbnRYTUxTdHJpbmdQYXJzZXIudGVzdChkYXRhKTtcbiAgfSxcbiAgYXN5bmMgcGFyc2UoYXNzZXQsIGRhdGEsIGxvYWRlcikge1xuICAgIGNvbnN0IGJpdG1hcEZvbnREYXRhID0gYml0bWFwRm9udFRleHRQYXJzZXIudGVzdChhc3NldCkgPyBiaXRtYXBGb250VGV4dFBhcnNlci5wYXJzZShhc3NldCkgOiBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLnBhcnNlKGFzc2V0KTtcbiAgICBjb25zdCB7IHNyYyB9ID0gZGF0YTtcbiAgICBjb25zdCB7IHBhZ2VzIH0gPSBiaXRtYXBGb250RGF0YTtcbiAgICBjb25zdCB0ZXh0dXJlVXJscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHBhZ2VGaWxlID0gcGFnZXNbaV0uZmlsZTtcbiAgICAgIGxldCBpbWFnZVBhdGggPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKHNyYyksIHBhZ2VGaWxlKTtcbiAgICAgIGltYWdlUGF0aCA9IGNvcHlTZWFyY2hQYXJhbXMoaW1hZ2VQYXRoLCBzcmMpO1xuICAgICAgdGV4dHVyZVVybHMucHVzaChpbWFnZVBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRUZXh0dXJlcyA9IGF3YWl0IGxvYWRlci5sb2FkKHRleHR1cmVVcmxzKTtcbiAgICBjb25zdCB0ZXh0dXJlcyA9IHRleHR1cmVVcmxzLm1hcCgodXJsKSA9PiBsb2FkZWRUZXh0dXJlc1t1cmxdKTtcbiAgICBjb25zdCBiaXRtYXBGb250ID0gbmV3IEJpdG1hcEZvbnQoe1xuICAgICAgZGF0YTogYml0bWFwRm9udERhdGEsXG4gICAgICB0ZXh0dXJlc1xuICAgIH0sIHNyYyk7XG4gICAgcmV0dXJuIGJpdG1hcEZvbnQ7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBfb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgRE9NQWRhcHRlci5nZXQoKS5mZXRjaCh1cmwpO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIH0sXG4gIGFzeW5jIHVubG9hZChiaXRtYXBGb250LCBfcmVzb2x2ZWRBc3NldCwgbG9hZGVyKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoYml0bWFwRm9udC5wYWdlcy5tYXAoKHBhZ2UpID0+IGxvYWRlci51bmxvYWQocGFnZS50ZXh0dXJlLnNvdXJjZS5fc291cmNlT3JpZ2luKSkpO1xuICAgIGJpdG1hcEZvbnQuZGVzdHJveSgpO1xuICB9XG59O1xuXG5leHBvcnQgeyBiaXRtYXBGb250Q2FjaGVQbHVnaW4sIGxvYWRCaXRtYXBGb250IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkQml0bWFwRm9udC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGxvY2FsVW5pZm9ybU1TREZCaXQgPSB7XG4gIG5hbWU6IFwibG9jYWwtdW5pZm9ybS1tc2RmLWJpdFwiLFxuICB2ZXJ0ZXg6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHN0cnVjdCBMb2NhbFVuaWZvcm1zIHtcbiAgICAgICAgICAgICAgICB1Q29sb3I6dmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdURpc3RhbmNlOiBmMzIsXG4gICAgICAgICAgICAgICAgdVJvdW5kOmYzMixcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBsb2NhbFVuaWZvcm1zIDogTG9jYWxVbmlmb3JtcztcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdkNvbG9yICo9IGxvY2FsVW5pZm9ybXMudUNvbG9yO1xuICAgICAgICAgICAgbW9kZWxNYXRyaXggKj0gbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4O1xuICAgICAgICBgXG4gICAgKSxcbiAgICBlbmQ6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIGlmKGxvY2FsVW5pZm9ybXMudVJvdW5kID09IDEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdlBvc2l0aW9uID0gdmVjNChyb3VuZFBpeGVscyh2UG9zaXRpb24ueHksIGdsb2JhbFVuaWZvcm1zLnVSZXNvbHV0aW9uKSwgdlBvc2l0aW9uLnp3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHN0cnVjdCBMb2NhbFVuaWZvcm1zIHtcbiAgICAgICAgICAgICAgICB1Q29sb3I6dmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdURpc3RhbmNlOiBmMzJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBsb2NhbFVuaWZvcm1zIDogTG9jYWxVbmlmb3JtcztcbiAgICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGAgXG4gICAgICAgICAgICBvdXRDb2xvciA9IHZDb2xvciAqIGNhbGN1bGF0ZU1TREZBbHBoYShvdXRDb2xvciwgbG9jYWxVbmlmb3Jtcy51RGlzdGFuY2UpO1xuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuY29uc3QgbG9jYWxVbmlmb3JtTVNERkJpdEdsID0ge1xuICBuYW1lOiBcImxvY2FsLXVuaWZvcm0tbXNkZi1iaXRcIixcbiAgdmVydGV4OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdVRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1Q29sb3I7XG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVSb3VuZDtcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdkNvbG9yICo9IHVDb2xvcjtcbiAgICAgICAgICAgIG1vZGVsTWF0cml4ICo9IHVUcmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIGBcbiAgICApLFxuICAgIGVuZDogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgaWYodVJvdW5kID09IDEuKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uLnh5ID0gcm91bmRQaXhlbHMoZ2xfUG9zaXRpb24ueHksIHVSZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdURpc3RhbmNlO1xuICAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYCBcbiAgICAgICAgICAgIG91dENvbG9yID0gdkNvbG9yICogY2FsY3VsYXRlTVNERkFscGhhKG91dENvbG9yLCB1RGlzdGFuY2UpO1xuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuXG5leHBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsVW5pZm9ybU1TREZCaXQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtU0RGQml0ID0ge1xuICBuYW1lOiBcIm1zZGYtYml0XCIsXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBmbiBjYWxjdWxhdGVNU0RGQWxwaGEobXNkZkNvbG9yOnZlYzQ8ZjMyPiwgZGlzdGFuY2U6ZjMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE1TREZcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWFuID0gbXNkZkNvbG9yLnIgKyBtc2RmQ29sb3IuZyArIG1zZGZDb2xvci5iIC1cbiAgICAgICAgICAgICAgICAgICAgbWluKG1zZGZDb2xvci5yLCBtaW4obXNkZkNvbG9yLmcsIG1zZGZDb2xvci5iKSkgLVxuICAgICAgICAgICAgICAgICAgICBtYXgobXNkZkNvbG9yLnIsIG1heChtc2RmQ29sb3IuZywgbXNkZkNvbG9yLmIpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFNERlxuICAgICAgICAgICAgICAgIG1lZGlhbiA9IG1pbihtZWRpYW4sIG1zZGZDb2xvci5hKTtcblxuICAgICAgICAgICAgICAgIHZhciBzY3JlZW5QeERpc3RhbmNlID0gZGlzdGFuY2UgKiAobWVkaWFuIC0gMC41KTtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBjbGFtcChzY3JlZW5QeERpc3RhbmNlICsgMC41LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhbiA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAwLjA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZWRpYW4gPiAwLjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcbmNvbnN0IG1TREZCaXRHbCA9IHtcbiAgbmFtZTogXCJtc2RmLWJpdFwiLFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgZmxvYXQgY2FsY3VsYXRlTVNERkFscGhhKHZlYzQgbXNkZkNvbG9yLCBmbG9hdCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE1TREZcbiAgICAgICAgICAgICAgICBmbG9hdCBtZWRpYW4gPSBtc2RmQ29sb3IuciArIG1zZGZDb2xvci5nICsgbXNkZkNvbG9yLmIgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4obXNkZkNvbG9yLnIsIG1pbihtc2RmQ29sb3IuZywgbXNkZkNvbG9yLmIpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heChtc2RmQ29sb3IuciwgbWF4KG1zZGZDb2xvci5nLCBtc2RmQ29sb3IuYikpO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU0RGXG4gICAgICAgICAgICAgICAgbWVkaWFuID0gbWluKG1lZGlhbiwgbXNkZkNvbG9yLmEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZmxvYXQgc2NyZWVuUHhEaXN0YW5jZSA9IGRpc3RhbmNlICogKG1lZGlhbiAtIDAuNSk7XG4gICAgICAgICAgICAgICAgZmxvYXQgYWxwaGEgPSBjbGFtcChzY3JlZW5QeERpc3RhbmNlICsgMC41LCAwLjAsIDEuMCk7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtZWRpYW4gPCAwLjAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMC4wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVkaWFuID4gMC45OSkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDEuMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5cbmV4cG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bVNERkJpdC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBNQVhfVEVYVFVSRVMgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvY29uc3QubWpzJztcbmltcG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSwgY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0gfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGNvbG9yQml0LCBjb2xvckJpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2NvbG9yQml0Lm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdCwgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9nZW5lcmF0ZVRleHR1cmVCYXRjaEJpdC5tanMnO1xuaW1wb3J0IHsgcm91bmRQaXhlbHNCaXQsIHJvdW5kUGl4ZWxzQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvcm91bmRQaXhlbHNCaXQubWpzJztcbmltcG9ydCB7IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9iYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfSBmcm9tICcuL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzJztcbmltcG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9IGZyb20gJy4vc2hhZGVyLWJpdHMvbVNERkJpdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFNkZlNoYWRlciBleHRlbmRzIFNoYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1Q29sb3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVEaXN0YW5jZTogeyB2YWx1ZTogNCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwic2RmLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBjb2xvckJpdCxcbiAgICAgICAgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQoTUFYX1RFWFRVUkVTKSxcbiAgICAgICAgbG9jYWxVbmlmb3JtTVNERkJpdCxcbiAgICAgICAgbVNERkJpdCxcbiAgICAgICAgcm91bmRQaXhlbHNCaXRcbiAgICAgIF1cbiAgICB9KTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcInNkZi1zaGFkZXJcIixcbiAgICAgIGJpdHM6IFtcbiAgICAgICAgY29sb3JCaXRHbCxcbiAgICAgICAgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXRHbChNQVhfVEVYVFVSRVMpLFxuICAgICAgICBsb2NhbFVuaWZvcm1NU0RGQml0R2wsXG4gICAgICAgIG1TREZCaXRHbCxcbiAgICAgICAgcm91bmRQaXhlbHNCaXRHbFxuICAgICAgXVxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgbG9jYWxVbmlmb3JtczogdW5pZm9ybXMsXG4gICAgICAgIGJhdGNoU2FtcGxlcnM6IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBTZGZTaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNkZlNoYWRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljcyB9IGZyb20gJy4uL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljcy5tanMnO1xuaW1wb3J0IHsgU2RmU2hhZGVyIH0gZnJvbSAnLi4vdGV4dC9zZGZTaGFkZXIvU2RmU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBGb250TWFuYWdlciB9IGZyb20gJy4vQml0bWFwRm9udE1hbmFnZXIubWpzJztcbmltcG9ydCB7IGdldEJpdG1hcFRleHRMYXlvdXQgfSBmcm9tICcuL3V0aWxzL2dldEJpdG1hcFRleHRMYXlvdXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCaXRtYXBUZXh0UGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1Qml0bWFwVGV4dCA9IHt9O1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKGJpdG1hcFRleHQpIHtcbiAgICBjb25zdCBncmFwaGljc1JlbmRlcmFibGUgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpO1xuICAgIGlmIChiaXRtYXBUZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICBiaXRtYXBUZXh0Ll9kaWRUZXh0VXBkYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLl91cGRhdGVDb250ZXh0KGJpdG1hcFRleHQsIGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5ncmFwaGljcy52YWxpZGF0ZVJlbmRlcmFibGUoZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgfVxuICBhZGRSZW5kZXJhYmxlKGJpdG1hcFRleHQsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NSZW5kZXJhYmxlID0gdGhpcy5fZ2V0R3B1Qml0bWFwVGV4dChiaXRtYXBUZXh0KTtcbiAgICBzeW5jV2l0aFByb3h5KGJpdG1hcFRleHQsIGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gICAgaWYgKGJpdG1hcFRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIGJpdG1hcFRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbnRleHQoYml0bWFwVGV4dCwgZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuZ3JhcGhpY3MuYWRkUmVuZGVyYWJsZShncmFwaGljc1JlbmRlcmFibGUsIGluc3RydWN0aW9uU2V0KTtcbiAgICBpZiAoZ3JhcGhpY3NSZW5kZXJhYmxlLmNvbnRleHQuY3VzdG9tU2hhZGVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXN0YW5jZUZpZWxkKGJpdG1hcFRleHQpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95UmVuZGVyYWJsZShiaXRtYXBUZXh0KSB7XG4gICAgdGhpcy5fZGVzdHJveVJlbmRlcmFibGVCeVVpZChiaXRtYXBUZXh0LnVpZCk7XG4gIH1cbiAgX2Rlc3Ryb3lSZW5kZXJhYmxlQnlVaWQocmVuZGVyYWJsZVVpZCkge1xuICAgIEJpZ1Bvb2wucmV0dXJuKHRoaXMuX2dwdUJpdG1hcFRleHRbcmVuZGVyYWJsZVVpZF0pO1xuICAgIHRoaXMuX2dwdUJpdG1hcFRleHRbcmVuZGVyYWJsZVVpZF0gPSBudWxsO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUoYml0bWFwVGV4dCkge1xuICAgIGNvbnN0IGdyYXBoaWNzUmVuZGVyYWJsZSA9IHRoaXMuX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCk7XG4gICAgc3luY1dpdGhQcm94eShiaXRtYXBUZXh0LCBncmFwaGljc1JlbmRlcmFibGUpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmdyYXBoaWNzLnVwZGF0ZVJlbmRlcmFibGUoZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICBpZiAoZ3JhcGhpY3NSZW5kZXJhYmxlLmNvbnRleHQuY3VzdG9tU2hhZGVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXN0YW5jZUZpZWxkKGJpdG1hcFRleHQpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBwcm94eUdyYXBoaWNzKSB7XG4gICAgY29uc3QgeyBjb250ZXh0IH0gPSBwcm94eUdyYXBoaWNzO1xuICAgIGNvbnN0IGJpdG1hcEZvbnQgPSBCaXRtYXBGb250TWFuYWdlci5nZXRGb250KGJpdG1hcFRleHQudGV4dCwgYml0bWFwVGV4dC5fc3R5bGUpO1xuICAgIGNvbnRleHQuY2xlYXIoKTtcbiAgICBpZiAoYml0bWFwRm9udC5kaXN0YW5jZUZpZWxkLnR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBpZiAoIWNvbnRleHQuY3VzdG9tU2hhZGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2RmU2hhZGVyKSB7XG4gICAgICAgICAgdGhpcy5fc2RmU2hhZGVyID0gbmV3IFNkZlNoYWRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY3VzdG9tU2hhZGVyID0gdGhpcy5fc2RmU2hhZGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IEFycmF5LmZyb20oYml0bWFwVGV4dC50ZXh0KTtcbiAgICBjb25zdCBzdHlsZSA9IGJpdG1hcFRleHQuX3N0eWxlO1xuICAgIGxldCBjdXJyZW50WSA9IChzdHlsZS5fc3Ryb2tlPy53aWR0aCB8fCAwKSAvIDI7XG4gICAgY3VycmVudFkgKz0gYml0bWFwRm9udC5iYXNlTGluZU9mZnNldDtcbiAgICBjb25zdCBiaXRtYXBUZXh0TGF5b3V0ID0gZ2V0Qml0bWFwVGV4dExheW91dChjaGFycywgc3R5bGUsIGJpdG1hcEZvbnQpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmc7XG4gICAgY29uc3Qgc2NhbGUgPSBiaXRtYXBUZXh0TGF5b3V0LnNjYWxlO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgLWJpdG1hcFRleHQuX2FuY2hvci5feCAqIGJpdG1hcFRleHRMYXlvdXQud2lkdGggLSBwYWRkaW5nLFxuICAgICAgLWJpdG1hcFRleHQuX2FuY2hvci5feSAqIChiaXRtYXBUZXh0TGF5b3V0LmhlaWdodCArIGJpdG1hcFRleHRMYXlvdXQub2Zmc2V0WSkgLSBwYWRkaW5nXG4gICAgKS5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgIGNvbnN0IHRpbnQgPSBzdHlsZS5fZmlsbC5jb2xvcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdG1hcFRleHRMYXlvdXQubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBiaXRtYXBUZXh0TGF5b3V0LmxpbmVzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2luZGV4KytdO1xuICAgICAgICBjb25zdCBjaGFyRGF0YSA9IGJpdG1hcEZvbnQuY2hhcnNbY2hhcl07XG4gICAgICAgIGlmIChjaGFyRGF0YT8udGV4dHVyZSkge1xuICAgICAgICAgIGNvbnRleHQudGV4dHVyZShcbiAgICAgICAgICAgIGNoYXJEYXRhLnRleHR1cmUsXG4gICAgICAgICAgICB0aW50ID8gdGludCA6IFwiYmxhY2tcIixcbiAgICAgICAgICAgIE1hdGgucm91bmQobGluZS5jaGFyUG9zaXRpb25zW2pdICsgY2hhckRhdGEueE9mZnNldCksXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGN1cnJlbnRZICsgY2hhckRhdGEueU9mZnNldClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50WSArPSBiaXRtYXBGb250LmxpbmVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIF9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF0gfHwgdGhpcy5pbml0R3B1VGV4dChiaXRtYXBUZXh0KTtcbiAgfVxuICBpbml0R3B1VGV4dChiaXRtYXBUZXh0KSB7XG4gICAgY29uc3QgcHJveHlSZW5kZXJhYmxlID0gQmlnUG9vbC5nZXQoR3JhcGhpY3MpO1xuICAgIHRoaXMuX2dwdUJpdG1hcFRleHRbYml0bWFwVGV4dC51aWRdID0gcHJveHlSZW5kZXJhYmxlO1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRleHQoYml0bWFwVGV4dCwgcHJveHlSZW5kZXJhYmxlKTtcbiAgICBiaXRtYXBUZXh0Lm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUoYml0bWFwVGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2dwdUJpdG1hcFRleHRbYml0bWFwVGV4dC51aWRdO1xuICB9XG4gIF91cGRhdGVEaXN0YW5jZUZpZWxkKGJpdG1hcFRleHQpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fZ2V0R3B1Qml0bWFwVGV4dChiaXRtYXBUZXh0KS5jb250ZXh0O1xuICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBiaXRtYXBUZXh0Ll9zdHlsZS5mb250RmFtaWx5O1xuICAgIGNvbnN0IGR5bmFtaWNGb250ID0gQ2FjaGUuZ2V0KGAke2ZvbnRGYW1pbHl9LWJpdG1hcGApO1xuICAgIGNvbnN0IHsgYSwgYiwgYywgZCB9ID0gYml0bWFwVGV4dC5ncm91cFRyYW5zZm9ybTtcbiAgICBjb25zdCBkeCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICBjb25zdCBkeSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcbiAgICBjb25zdCB3b3JsZFNjYWxlID0gKE1hdGguYWJzKGR4KSArIE1hdGguYWJzKGR5KSkgLyAyO1xuICAgIGNvbnN0IGZvbnRTY2FsZSA9IGR5bmFtaWNGb250LmJhc2VSZW5kZXJlZEZvbnRTaXplIC8gYml0bWFwVGV4dC5fc3R5bGUuZm9udFNpemU7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IGJpdG1hcFRleHQucmVzb2x1dGlvbiA/PyB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gd29ybGRTY2FsZSAqIGR5bmFtaWNGb250LmRpc3RhbmNlRmllbGQucmFuZ2UgKiAoMSAvIGZvbnRTY2FsZSkgKiByZXNvbHV0aW9uO1xuICAgIGNvbnRleHQuY3VzdG9tU2hhZGVyLnJlc291cmNlcy5sb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCB1aWQgaW4gdGhpcy5fZ3B1Qml0bWFwVGV4dCkge1xuICAgICAgdGhpcy5fZGVzdHJveVJlbmRlcmFibGVCeVVpZCh1aWQpO1xuICAgIH1cbiAgICB0aGlzLl9ncHVCaXRtYXBUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9zZGZTaGFkZXI/LmRlc3Ryb3kodHJ1ZSk7XG4gICAgdGhpcy5fc2RmU2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5CaXRtYXBUZXh0UGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiYml0bWFwVGV4dFwiXG59O1xuZnVuY3Rpb24gc3luY1dpdGhQcm94eShjb250YWluZXIsIHByb3h5KSB7XG4gIHByb3h5Lmdyb3VwVHJhbnNmb3JtID0gY29udGFpbmVyLmdyb3VwVHJhbnNmb3JtO1xuICBwcm94eS5ncm91cENvbG9yQWxwaGEgPSBjb250YWluZXIuZ3JvdXBDb2xvckFscGhhO1xuICBwcm94eS5ncm91cENvbG9yID0gY29udGFpbmVyLmdyb3VwQ29sb3I7XG4gIHByb3h5Lmdyb3VwQmxlbmRNb2RlID0gY29udGFpbmVyLmdyb3VwQmxlbmRNb2RlO1xuICBwcm94eS5nbG9iYWxEaXNwbGF5U3RhdHVzID0gY29udGFpbmVyLmdsb2JhbERpc3BsYXlTdGF0dXM7XG4gIHByb3h5Lmdyb3VwVHJhbnNmb3JtID0gY29udGFpbmVyLmdyb3VwVHJhbnNmb3JtO1xuICBwcm94eS5sb2NhbERpc3BsYXlTdGF0dXMgPSBjb250YWluZXIubG9jYWxEaXNwbGF5U3RhdHVzO1xuICBwcm94eS5ncm91cEFscGhhID0gY29udGFpbmVyLmdyb3VwQWxwaGE7XG4gIHByb3h5Ll9yb3VuZFBpeGVscyA9IGNvbnRhaW5lci5fcm91bmRQaXhlbHM7XG59XG5cbmV4cG9ydCB7IEJpdG1hcFRleHRQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBUZXh0UGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBsb2FkQml0bWFwRm9udCwgYml0bWFwRm9udENhY2hlUGx1Z2luIH0gZnJvbSAnLi9hc3NldC9sb2FkQml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgQml0bWFwVGV4dFBpcGUgfSBmcm9tICcuL0JpdG1hcFRleHRQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoQml0bWFwVGV4dFBpcGUsIGxvYWRCaXRtYXBGb250LCBiaXRtYXBGb250Q2FjaGVQbHVnaW4pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6678\n')},1709:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(3747);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(900);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText._getKey();\n    if (gpuText.textureNeedsUploading) {\n      gpuText.textureNeedsUploading = false;\n      return true;\n    }\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(htmlText) {\n    this._destroyRenderableById(htmlText.uid);\n  }\n  _destroyRenderableById(htmlTextUid) {\n    const gpuText = this._gpuText[htmlTextUid];\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[htmlTextUid] = null;\n  }\n  _updateText(htmlText) {\n    const newKey = htmlText._getKey();\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n    }\n    htmlText._didTextUpdate = false;\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const gpuText = this._getGpuText(htmlText);\n    if (gpuText.generatingTexture)\n      return;\n    const newKey = htmlText._getKey();\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    gpuText.generatingTexture = true;\n    gpuText.currentKey = newKey;\n    const resolution = htmlText.resolution ?? this._renderer.resolution;\n    const texture = await this._renderer.htmlText.getManagedTexture(\n      htmlText.text,\n      resolution,\n      htmlText._style,\n      htmlText._getKey()\n    );\n    const batchableSprite = gpuText.batchableSprite;\n    batchableSprite.texture = gpuText.texture = texture;\n    gpuText.generatingTexture = false;\n    gpuText.textureNeedsUploading = true;\n    htmlText.onViewUpdate();\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  _getGpuText(htmlText) {\n    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const gpuTextData = {\n      texture: Texture/* Texture */.x.EMPTY,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.c),\n      textureNeedsUploading: false,\n      generatingTexture: false\n    };\n    const batchableSprite = gpuTextData.batchableSprite;\n    batchableSprite.renderable = htmlText;\n    batchableSprite.texture = Texture/* Texture */.x.EMPTY;\n    batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    this._gpuText[htmlText.uid] = gpuTextData;\n    htmlText.on("destroyed", () => {\n      this.destroyRenderable(htmlText);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "htmlText"\n};\n\n\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isSafari.mjs\n\n\n"use strict";\nfunction isSafari() {\n  const { userAgent } = adapter/* DOMAdapter */.z.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\n\n//# sourceMappingURL=isSafari.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(1647);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs\n\nconst nssvg = "http://www.w3.org/2000/svg";\nconst nsxhtml = "http://www.w3.org/1999/xhtml";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, "svg");\n    this.foreignObject = document.createElementNS(nssvg, "foreignObject");\n    this.domElement = document.createElementNS(nsxhtml, "div");\n    this.styleElement = document.createElementNS(nsxhtml, "style");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute("width", "10000");\n    foreignObject.setAttribute("height", "10000");\n    foreignObject.style.overflow = "hidden";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\n\n\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(3779);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs\nvar generateTextStyleKey = __webpack_require__(740);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs\n\n\n"use strict";\nfunction textStyleToCSS(style) {\n  const stroke = style._stroke;\n  const fill = style._fill;\n  const cssStyleString = [\n    `color: ${Color/* Color */.I.shared.setValue(fill.color).toHex()}`,\n    `font-size: ${style.fontSize}px`,\n    `font-family: ${style.fontFamily}`,\n    `font-weight: ${style.fontWeight}`,\n    `font-style: ${style.fontStyle}`,\n    `font-variant: ${style.fontVariant}`,\n    `letter-spacing: ${style.letterSpacing}px`,\n    `text-align: ${style.align}`,\n    `padding: ${style.padding}px`,\n    `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,\n    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n    ...style.wordWrap ? [\n      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,\n      `max-width: ${style.wordWrapWidth}px`\n    ] : [],\n    ...stroke ? [strokeToCSS(stroke)] : [],\n    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n    ...style.cssOverrides\n  ].join(";");\n  const cssStyles = [`div { ${cssStyleString} }`];\n  tagStyleToCSS(style.tagStyles, cssStyles);\n  return cssStyles.join(" ");\n}\nfunction dropShadowToCSS(dropShadowStyle) {\n  const color = Color/* Color */.I.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const position = `${x}px ${y}px`;\n  if (dropShadowStyle.blur > 0) {\n    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n  }\n  return `text-shadow: ${position} ${color}`;\n}\nfunction strokeToCSS(stroke) {\n  return [\n    `-webkit-text-stroke-width: ${stroke.width}px`,\n    `-webkit-text-stroke-color: ${Color/* Color */.I.shared.setValue(stroke.color).toHex()}`,\n    `text-stroke-width: ${stroke.width}px`,\n    `text-stroke-color: ${Color/* Color */.I.shared.setValue(stroke.color).toHex()}`,\n    "paint-order: stroke"\n  ].join(";");\n}\nconst templates = {\n  fontSize: `font-size: {{VALUE}}px`,\n  fontFamily: `font-family: {{VALUE}}`,\n  fontWeight: `font-weight: {{VALUE}}`,\n  fontStyle: `font-style: {{VALUE}}`,\n  fontVariant: `font-variant: {{VALUE}}`,\n  letterSpacing: `letter-spacing: {{VALUE}}px`,\n  align: `text-align: {{VALUE}}`,\n  padding: `padding: {{VALUE}}px`,\n  whiteSpace: `white-space: {{VALUE}}`,\n  lineHeight: `line-height: {{VALUE}}px`,\n  wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst transform = {\n  fill: (value) => `color: ${Color/* Color */.I.shared.setValue(value).toHex()}`,\n  breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,\n  stroke: strokeToCSS,\n  dropShadow: dropShadowToCSS\n};\nfunction tagStyleToCSS(tagStyles, out) {\n  for (const i in tagStyles) {\n    const tagStyle = tagStyles[i];\n    const cssTagStyle = [];\n    for (const j in tagStyle) {\n      if (transform[j]) {\n        cssTagStyle.push(transform[j](tagStyle[j]));\n      } else if (templates[j]) {\n        cssTagStyle.push(templates[j].replace("{{VALUE}}", tagStyle[j]));\n      }\n    }\n    out.push(`${i} { ${cssTagStyle.join(";")} }`);\n  }\n}\n\n\n//# sourceMappingURL=textStyleToCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs\n\n\n\n\n\n"use strict";\nclass HTMLTextStyle extends TextStyle/* TextStyle */.p {\n  constructor(options = {}) {\n    super(options);\n    this._cssOverrides = [];\n    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);\n    this.tagStyles = options.tagStyles ?? {};\n  }\n  /** List of style overrides that will be applied to the HTML text. */\n  set cssOverrides(value) {\n    this._cssOverrides = value instanceof Array ? value : [value];\n    this.update();\n  }\n  get cssOverrides() {\n    return this._cssOverrides;\n  }\n  _generateKey() {\n    this._styleKey = (0,generateTextStyleKey/* generateTextStyleKey */.L)(this) + this._cssOverrides.join("-");\n    return this._styleKey;\n  }\n  update() {\n    this._cssStyle = null;\n    super.update();\n  }\n  /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * @returns New cloned HTMLTextStyle object\n   */\n  clone() {\n    return new HTMLTextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      cssOverrides: this.cssOverrides\n    });\n  }\n  get cssStyle() {\n    if (!this._cssStyle) {\n      this._cssStyle = textStyleToCSS(this);\n    }\n    return this._cssStyle;\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride(\'background-color: red\');\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n    if (toAdd.length > 0) {\n      this.cssOverrides.push(...toAdd);\n      this.update();\n    }\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride(\'background-color: red\');\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n    if (toRemove.length > 0) {\n      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n      this.update();\n    }\n  }\n  set fill(value) {\n    if (typeof value !== "string" && typeof value !== "number") {\n      (0,warn/* warn */.Z)("[HTMLTextStyle] only color fill is not supported by HTMLText");\n    }\n    super.fill = value;\n  }\n  set stroke(value) {\n    if (value && typeof value !== "string" && typeof value !== "number") {\n      (0,warn/* warn */.Z)("[HTMLTextStyle] only color stroke is not supported by HTMLText");\n    }\n    super.stroke = value;\n  }\n}\n\n\n//# sourceMappingURL=HtmlTextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs\n\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(":")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\n\n//# sourceMappingURL=extractFontFamilies.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs\n\n\n"use strict";\nasync function loadFontAsBase64(url) {\n  const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\n\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs\n\n\n"use strict";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: "${style.fontFamily}";\n        src: url(\'${dataSrc}\');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\n\n//# sourceMappingURL=loadFontCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs\n\n\n\n"use strict";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies, style, defaultOptions) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache/* Cache */.C.has(`${fontFamily}-and-url`)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache/* Cache */.C.get(`${fontFamily}-and-url`);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: defaultOptions.fontWeight,\n          fontStyle: defaultOptions.fontStyle,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join("\\n");\n}\n\n\n//# sourceMappingURL=getFontCss.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs\n\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute("width", width.toString());\n  svgRoot.setAttribute("height", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\n\n//# sourceMappingURL=getSVGUrl.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs\n\n\n"use strict";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n  return canvasAndContext.canvas;\n}\n\n\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs\n\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = "anonymous";\n  });\n}\n\n\n//# sourceMappingURL=loadSVGImage.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs\n\n\n\n"use strict";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const descenderPadding = CanvasTextMetrics/* CanvasTextMetrics */.c.measureFont(style.fontStyle).descent;\n  return {\n    width: contentBounds.width,\n    height: contentBounds.height + descenderPadding\n  };\n}\n\n\n//# sourceMappingURL=measureHtmlText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === types/* RendererType */.g.WEBGPU;\n  }\n  getTexture(options) {\n    return this._buildTexturePromise(\n      options.text,\n      options.resolution,\n      options.style\n    );\n  }\n  getManagedTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text, resolution, style).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  async _buildTexturePromise(text, resolution, style) {\n    const htmlTextData = PoolGroup/* BigPool */.u.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(\n      fontFamilies,\n      style,\n      HTMLTextStyle.defaultTextStyle\n    );\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    image.width = width | 0;\n    image.height = height | 0;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    let resource = image;\n    if (this._createCanvas) {\n      resource = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.H)(resource, image.width, image.height, resolution);\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n    }\n    PoolGroup/* BigPool */.u.return(htmlTextData);\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture);\n        }).catch(() => {\n          (0,warn/* warn */.Z)("HTMLTextSystem: Failed to clean texture");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  _cleanUp(activeTexture) {\n    TexturePool/* TexturePool */.z.returnTexture(activeTexture.texture);\n    activeTexture.texture.source.resource = null;\n    activeTexture.texture.source.uploadMethodId = "unknown";\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "htmlText"\n};\nHTMLTextSystem.defaultFontOptions = {\n  fontFamily: "Arial",\n  fontStyle: "normal",\n  fontWeight: "normal"\n};\n\n\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(HTMLTextSystem);\nExtensions/* extensions */.Rw.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVLG9CQUFJO0FBQ2QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhCQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQjs7O0FDM0g2RDtBQUNYO0FBQ0k7O0FBRXREO0FBQ0EsNkJBQVUsS0FBSyxjQUFjO0FBQzdCLDZCQUFVLEtBQUssWUFBWTtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvSFRNTFRleHRQaXBlLm1qcz84N2Y0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9icm93c2VyL2lzU2FmYXJpLm1qcz9jMTU3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvSFRNTFRleHRSZW5kZXJEYXRhLm1qcz9kMWRkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvdGV4dFN0eWxlVG9DU1MubWpzPzhjZjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC9IdG1sVGV4dFN0eWxlLm1qcz9hZDQ1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZXh0cmFjdEZvbnRGYW1pbGllcy5tanM/YzVlZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2xvYWRGb250QXNCYXNlNjQubWpzPzUyZDIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkRm9udENTUy5tanM/OGI4MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2dldEZvbnRDc3MubWpzPzllYzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRTVkdVcmwubWpzP2I0ZWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzPzc2NDMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkU1ZHSW1hZ2UubWpzPzhlNTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9tZWFzdXJlSHRtbFRleHQubWpzP2E2ZDIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC9IVE1MVGV4dFN5c3RlbS5tanM/NDg3OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL2luaXQubWpzPzVhZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgdXBkYXRlUXVhZEJvdW5kcyB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGEvdXBkYXRlUXVhZEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVTcHJpdGUgfSBmcm9tICcuLi9zcHJpdGUvQmF0Y2hhYmxlU3ByaXRlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgSFRNTFRleHRQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9ncHVUZXh0ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICB2YWxpZGF0ZVJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgbmV3S2V5ID0gaHRtbFRleHQuX2dldEtleSgpO1xuICAgIGlmIChncHVUZXh0LnRleHR1cmVOZWVkc1VwbG9hZGluZykge1xuICAgICAgZ3B1VGV4dC50ZXh0dXJlTmVlZHNVcGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShodG1sVGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoaHRtbFRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHQoaHRtbFRleHQpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5hZGRUb0JhdGNoKGJhdGNoYWJsZVNwcml0ZSk7XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShodG1sVGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoaHRtbFRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHQoaHRtbFRleHQpO1xuICAgIH1cbiAgICBiYXRjaGFibGVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGJhdGNoYWJsZVNwcml0ZSk7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQoaHRtbFRleHQudWlkKTtcbiAgfVxuICBfZGVzdHJveVJlbmRlcmFibGVCeUlkKGh0bWxUZXh0VWlkKSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dwdVRleHRbaHRtbFRleHRVaWRdO1xuICAgIHRoaXMuX3JlbmRlcmVyLmh0bWxUZXh0LmRlY3JlYXNlUmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KTtcbiAgICBCaWdQb29sLnJldHVybihncHVUZXh0LmJhdGNoYWJsZVNwcml0ZSk7XG4gICAgdGhpcy5fZ3B1VGV4dFtodG1sVGV4dFVpZF0gPSBudWxsO1xuICB9XG4gIF91cGRhdGVUZXh0KGh0bWxUZXh0KSB7XG4gICAgY29uc3QgbmV3S2V5ID0gaHRtbFRleHQuX2dldEtleSgpO1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUdwdVRleHQoaHRtbFRleHQpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaHRtbFRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBwYWRkaW5nID0gaHRtbFRleHQuX3N0eWxlLnBhZGRpbmc7XG4gICAgdXBkYXRlUXVhZEJvdW5kcyhiYXRjaGFibGVTcHJpdGUuYm91bmRzLCBodG1sVGV4dC5fYW5jaG9yLCBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSwgcGFkZGluZyk7XG4gIH1cbiAgYXN5bmMgX3VwZGF0ZUdwdVRleHQoaHRtbFRleHQpIHtcbiAgICBodG1sVGV4dC5fZGlkVGV4dFVwZGF0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgICBpZiAoZ3B1VGV4dC5nZW5lcmF0aW5nVGV4dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuZXdLZXkgPSBodG1sVGV4dC5fZ2V0S2V5KCk7XG4gICAgdGhpcy5fcmVuZGVyZXIuaHRtbFRleHQuZGVjcmVhc2VSZWZlcmVuY2VDb3VudChncHVUZXh0LmN1cnJlbnRLZXkpO1xuICAgIGdwdVRleHQuZ2VuZXJhdGluZ1RleHR1cmUgPSB0cnVlO1xuICAgIGdwdVRleHQuY3VycmVudEtleSA9IG5ld0tleTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gaHRtbFRleHQucmVzb2x1dGlvbiA/PyB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHRleHR1cmUgPSBhd2FpdCB0aGlzLl9yZW5kZXJlci5odG1sVGV4dC5nZXRNYW5hZ2VkVGV4dHVyZShcbiAgICAgIGh0bWxUZXh0LnRleHQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgaHRtbFRleHQuX3N0eWxlLFxuICAgICAgaHRtbFRleHQuX2dldEtleSgpXG4gICAgKTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IGdwdVRleHQudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgZ3B1VGV4dC5nZW5lcmF0aW5nVGV4dHVyZSA9IGZhbHNlO1xuICAgIGdwdVRleHQudGV4dHVyZU5lZWRzVXBsb2FkaW5nID0gdHJ1ZTtcbiAgICBodG1sVGV4dC5vblZpZXdVcGRhdGUoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gaHRtbFRleHQuX3N0eWxlLnBhZGRpbmc7XG4gICAgdXBkYXRlUXVhZEJvdW5kcyhiYXRjaGFibGVTcHJpdGUuYm91bmRzLCBodG1sVGV4dC5fYW5jaG9yLCBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSwgcGFkZGluZyk7XG4gIH1cbiAgX2dldEdwdVRleHQoaHRtbFRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1VGV4dFtodG1sVGV4dC51aWRdIHx8IHRoaXMuaW5pdEdwdVRleHQoaHRtbFRleHQpO1xuICB9XG4gIGluaXRHcHVUZXh0KGh0bWxUZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dERhdGEgPSB7XG4gICAgICB0ZXh0dXJlOiBUZXh0dXJlLkVNUFRZLFxuICAgICAgY3VycmVudEtleTogXCItLVwiLFxuICAgICAgYmF0Y2hhYmxlU3ByaXRlOiBCaWdQb29sLmdldChCYXRjaGFibGVTcHJpdGUpLFxuICAgICAgdGV4dHVyZU5lZWRzVXBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIGdlbmVyYXRpbmdUZXh0dXJlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dERhdGEuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGJhdGNoYWJsZVNwcml0ZS5yZW5kZXJhYmxlID0gaHRtbFRleHQ7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSBUZXh0dXJlLkVNUFRZO1xuICAgIGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMgPSB7IG1pblg6IDAsIG1heFg6IDEsIG1pblk6IDAsIG1heFk6IDAgfTtcbiAgICBiYXRjaGFibGVTcHJpdGUucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBodG1sVGV4dC5fcm91bmRQaXhlbHM7XG4gICAgdGhpcy5fZ3B1VGV4dFtodG1sVGV4dC51aWRdID0gZ3B1VGV4dERhdGE7XG4gICAgaHRtbFRleHQub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShodG1sVGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdwdVRleHREYXRhO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dwdVRleHQpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZChpKTtcbiAgICB9XG4gICAgdGhpcy5fZ3B1VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuSFRNTFRleHRQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJodG1sVGV4dFwiXG59O1xuXG5leHBvcnQgeyBIVE1MVGV4dFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0UGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gRE9NQWRhcHRlci5nZXQoKS5nZXROYXZpZ2F0b3IoKTtcbiAgcmV0dXJuIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QodXNlckFnZW50KTtcbn1cblxuZXhwb3J0IHsgaXNTYWZhcmkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2FmYXJpLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbnNzdmcgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jb25zdCBuc3hodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5jbGFzcyBIVE1MVGV4dFJlbmRlckRhdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN2Z1Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwic3ZnXCIpO1xuICAgIHRoaXMuZm9yZWlnbk9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3N2ZywgXCJmb3JlaWduT2JqZWN0XCIpO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcImRpdlwiKTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcInN0eWxlXCIpO1xuICAgIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBjb25zdCB7IGZvcmVpZ25PYmplY3QsIHN2Z1Jvb3QsIHN0eWxlRWxlbWVudCwgZG9tRWxlbWVudCB9ID0gdGhpcztcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwMDBcIik7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIxMDAwMFwiKTtcbiAgICBmb3JlaWduT2JqZWN0LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBzdmdSb290LmFwcGVuZENoaWxkKGZvcmVpZ25PYmplY3QpO1xuICAgIGZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICBmb3JlaWduT2JqZWN0LmFwcGVuZENoaWxkKGRvbUVsZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEhUTUxUZXh0UmVuZGVyRGF0YSwgbnNzdmcsIG5zeGh0bWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0UmVuZGVyRGF0YS5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdGV4dFN0eWxlVG9DU1Moc3R5bGUpIHtcbiAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuX3N0cm9rZTtcbiAgY29uc3QgZmlsbCA9IHN0eWxlLl9maWxsO1xuICBjb25zdCBjc3NTdHlsZVN0cmluZyA9IFtcbiAgICBgY29sb3I6ICR7Q29sb3Iuc2hhcmVkLnNldFZhbHVlKGZpbGwuY29sb3IpLnRvSGV4KCl9YCxcbiAgICBgZm9udC1zaXplOiAke3N0eWxlLmZvbnRTaXplfXB4YCxcbiAgICBgZm9udC1mYW1pbHk6ICR7c3R5bGUuZm9udEZhbWlseX1gLFxuICAgIGBmb250LXdlaWdodDogJHtzdHlsZS5mb250V2VpZ2h0fWAsXG4gICAgYGZvbnQtc3R5bGU6ICR7c3R5bGUuZm9udFN0eWxlfWAsXG4gICAgYGZvbnQtdmFyaWFudDogJHtzdHlsZS5mb250VmFyaWFudH1gLFxuICAgIGBsZXR0ZXItc3BhY2luZzogJHtzdHlsZS5sZXR0ZXJTcGFjaW5nfXB4YCxcbiAgICBgdGV4dC1hbGlnbjogJHtzdHlsZS5hbGlnbn1gLFxuICAgIGBwYWRkaW5nOiAke3N0eWxlLnBhZGRpbmd9cHhgLFxuICAgIGB3aGl0ZS1zcGFjZTogJHtzdHlsZS53aGl0ZVNwYWNlID09PSBcInByZVwiICYmIHN0eWxlLndvcmRXcmFwID8gXCJwcmUtd3JhcFwiIDogc3R5bGUud2hpdGVTcGFjZX1gLFxuICAgIC4uLnN0eWxlLmxpbmVIZWlnaHQgPyBbYGxpbmUtaGVpZ2h0OiAke3N0eWxlLmxpbmVIZWlnaHR9cHhgXSA6IFtdLFxuICAgIC4uLnN0eWxlLndvcmRXcmFwID8gW1xuICAgICAgYHdvcmQtd3JhcDogJHtzdHlsZS5icmVha1dvcmRzID8gXCJicmVhay1hbGxcIiA6IFwiYnJlYWstd29yZFwifWAsXG4gICAgICBgbWF4LXdpZHRoOiAke3N0eWxlLndvcmRXcmFwV2lkdGh9cHhgXG4gICAgXSA6IFtdLFxuICAgIC4uLnN0cm9rZSA/IFtzdHJva2VUb0NTUyhzdHJva2UpXSA6IFtdLFxuICAgIC4uLnN0eWxlLmRyb3BTaGFkb3cgPyBbZHJvcFNoYWRvd1RvQ1NTKHN0eWxlLmRyb3BTaGFkb3cpXSA6IFtdLFxuICAgIC4uLnN0eWxlLmNzc092ZXJyaWRlc1xuICBdLmpvaW4oXCI7XCIpO1xuICBjb25zdCBjc3NTdHlsZXMgPSBbYGRpdiB7ICR7Y3NzU3R5bGVTdHJpbmd9IH1gXTtcbiAgdGFnU3R5bGVUb0NTUyhzdHlsZS50YWdTdHlsZXMsIGNzc1N0eWxlcyk7XG4gIHJldHVybiBjc3NTdHlsZXMuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBkcm9wU2hhZG93VG9DU1MoZHJvcFNoYWRvd1N0eWxlKSB7XG4gIGNvbnN0IGNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGRyb3BTaGFkb3dTdHlsZS5jb2xvcikuc2V0QWxwaGEoZHJvcFNoYWRvd1N0eWxlLmFscGhhKS50b0hleGEoKTtcbiAgY29uc3QgeCA9IE1hdGgucm91bmQoTWF0aC5jb3MoZHJvcFNoYWRvd1N0eWxlLmFuZ2xlKSAqIGRyb3BTaGFkb3dTdHlsZS5kaXN0YW5jZSk7XG4gIGNvbnN0IHkgPSBNYXRoLnJvdW5kKE1hdGguc2luKGRyb3BTaGFkb3dTdHlsZS5hbmdsZSkgKiBkcm9wU2hhZG93U3R5bGUuZGlzdGFuY2UpO1xuICBjb25zdCBwb3NpdGlvbiA9IGAke3h9cHggJHt5fXB4YDtcbiAgaWYgKGRyb3BTaGFkb3dTdHlsZS5ibHVyID4gMCkge1xuICAgIHJldHVybiBgdGV4dC1zaGFkb3c6ICR7cG9zaXRpb259ICR7ZHJvcFNoYWRvd1N0eWxlLmJsdXJ9cHggJHtjb2xvcn1gO1xuICB9XG4gIHJldHVybiBgdGV4dC1zaGFkb3c6ICR7cG9zaXRpb259ICR7Y29sb3J9YDtcbn1cbmZ1bmN0aW9uIHN0cm9rZVRvQ1NTKHN0cm9rZSkge1xuICByZXR1cm4gW1xuICAgIGAtd2Via2l0LXRleHQtc3Ryb2tlLXdpZHRoOiAke3N0cm9rZS53aWR0aH1weGAsXG4gICAgYC13ZWJraXQtdGV4dC1zdHJva2UtY29sb3I6ICR7Q29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0cm9rZS5jb2xvcikudG9IZXgoKX1gLFxuICAgIGB0ZXh0LXN0cm9rZS13aWR0aDogJHtzdHJva2Uud2lkdGh9cHhgLFxuICAgIGB0ZXh0LXN0cm9rZS1jb2xvcjogJHtDb2xvci5zaGFyZWQuc2V0VmFsdWUoc3Ryb2tlLmNvbG9yKS50b0hleCgpfWAsXG4gICAgXCJwYWludC1vcmRlcjogc3Ryb2tlXCJcbiAgXS5qb2luKFwiO1wiKTtcbn1cbmNvbnN0IHRlbXBsYXRlcyA9IHtcbiAgZm9udFNpemU6IGBmb250LXNpemU6IHt7VkFMVUV9fXB4YCxcbiAgZm9udEZhbWlseTogYGZvbnQtZmFtaWx5OiB7e1ZBTFVFfX1gLFxuICBmb250V2VpZ2h0OiBgZm9udC13ZWlnaHQ6IHt7VkFMVUV9fWAsXG4gIGZvbnRTdHlsZTogYGZvbnQtc3R5bGU6IHt7VkFMVUV9fWAsXG4gIGZvbnRWYXJpYW50OiBgZm9udC12YXJpYW50OiB7e1ZBTFVFfX1gLFxuICBsZXR0ZXJTcGFjaW5nOiBgbGV0dGVyLXNwYWNpbmc6IHt7VkFMVUV9fXB4YCxcbiAgYWxpZ246IGB0ZXh0LWFsaWduOiB7e1ZBTFVFfX1gLFxuICBwYWRkaW5nOiBgcGFkZGluZzoge3tWQUxVRX19cHhgLFxuICB3aGl0ZVNwYWNlOiBgd2hpdGUtc3BhY2U6IHt7VkFMVUV9fWAsXG4gIGxpbmVIZWlnaHQ6IGBsaW5lLWhlaWdodDoge3tWQUxVRX19cHhgLFxuICB3b3JkV3JhcFdpZHRoOiBgbWF4LXdpZHRoOiB7e1ZBTFVFfX1weGBcbn07XG5jb25zdCB0cmFuc2Zvcm0gPSB7XG4gIGZpbGw6ICh2YWx1ZSkgPT4gYGNvbG9yOiAke0NvbG9yLnNoYXJlZC5zZXRWYWx1ZSh2YWx1ZSkudG9IZXgoKX1gLFxuICBicmVha1dvcmRzOiAodmFsdWUpID0+IGB3b3JkLXdyYXA6ICR7dmFsdWUgPyBcImJyZWFrLWFsbFwiIDogXCJicmVhay13b3JkXCJ9YCxcbiAgc3Ryb2tlOiBzdHJva2VUb0NTUyxcbiAgZHJvcFNoYWRvdzogZHJvcFNoYWRvd1RvQ1NTXG59O1xuZnVuY3Rpb24gdGFnU3R5bGVUb0NTUyh0YWdTdHlsZXMsIG91dCkge1xuICBmb3IgKGNvbnN0IGkgaW4gdGFnU3R5bGVzKSB7XG4gICAgY29uc3QgdGFnU3R5bGUgPSB0YWdTdHlsZXNbaV07XG4gICAgY29uc3QgY3NzVGFnU3R5bGUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGogaW4gdGFnU3R5bGUpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bal0pIHtcbiAgICAgICAgY3NzVGFnU3R5bGUucHVzaCh0cmFuc2Zvcm1bal0odGFnU3R5bGVbal0pKTtcbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGVzW2pdKSB7XG4gICAgICAgIGNzc1RhZ1N0eWxlLnB1c2godGVtcGxhdGVzW2pdLnJlcGxhY2UoXCJ7e1ZBTFVFfX1cIiwgdGFnU3R5bGVbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0LnB1c2goYCR7aX0geyAke2Nzc1RhZ1N0eWxlLmpvaW4oXCI7XCIpfSB9YCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgdGV4dFN0eWxlVG9DU1MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHRTdHlsZVRvQ1NTLm1qcy5tYXBcbiIsImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJy4uL3RleHQvVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVRleHRTdHlsZUtleSB9IGZyb20gJy4uL3RleHQvdXRpbHMvZ2VuZXJhdGVUZXh0U3R5bGVLZXkubWpzJztcbmltcG9ydCB7IHRleHRTdHlsZVRvQ1NTIH0gZnJvbSAnLi91dGlscy90ZXh0U3R5bGVUb0NTUy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEhUTUxUZXh0U3R5bGUgZXh0ZW5kcyBUZXh0U3R5bGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLl9jc3NPdmVycmlkZXMgPSBbXTtcbiAgICB0aGlzLmNzc092ZXJyaWRlcyA/PyAodGhpcy5jc3NPdmVycmlkZXMgPSBvcHRpb25zLmNzc092ZXJyaWRlcyk7XG4gICAgdGhpcy50YWdTdHlsZXMgPSBvcHRpb25zLnRhZ1N0eWxlcyA/PyB7fTtcbiAgfVxuICAvKiogTGlzdCBvZiBzdHlsZSBvdmVycmlkZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIEhUTUwgdGV4dC4gKi9cbiAgc2V0IGNzc092ZXJyaWRlcyh2YWx1ZSkge1xuICAgIHRoaXMuX2Nzc092ZXJyaWRlcyA9IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICBnZXQgY3NzT3ZlcnJpZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jc3NPdmVycmlkZXM7XG4gIH1cbiAgX2dlbmVyYXRlS2V5KCkge1xuICAgIHRoaXMuX3N0eWxlS2V5ID0gZ2VuZXJhdGVUZXh0U3R5bGVLZXkodGhpcykgKyB0aGlzLl9jc3NPdmVycmlkZXMuam9pbihcIi1cIik7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlS2V5O1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9jc3NTdHlsZSA9IG51bGw7XG4gICAgc3VwZXIudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSFRNTFRleHRTdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIEByZXR1cm5zIE5ldyBjbG9uZWQgSFRNTFRleHRTdHlsZSBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgSFRNTFRleHRTdHlsZSh7XG4gICAgICBhbGlnbjogdGhpcy5hbGlnbixcbiAgICAgIGJyZWFrV29yZHM6IHRoaXMuYnJlYWtXb3JkcyxcbiAgICAgIGRyb3BTaGFkb3c6IHRoaXMuZHJvcFNoYWRvdyxcbiAgICAgIGZpbGw6IHRoaXMuX2ZpbGwsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5mb250U3R5bGUsXG4gICAgICBmb250VmFyaWFudDogdGhpcy5mb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCxcbiAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyxcbiAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCxcbiAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyxcbiAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlLFxuICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgd29yZFdyYXA6IHRoaXMud29yZFdyYXAsXG4gICAgICB3b3JkV3JhcFdpZHRoOiB0aGlzLndvcmRXcmFwV2lkdGgsXG4gICAgICBjc3NPdmVycmlkZXM6IHRoaXMuY3NzT3ZlcnJpZGVzXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGNzc1N0eWxlKCkge1xuICAgIGlmICghdGhpcy5fY3NzU3R5bGUpIHtcbiAgICAgIHRoaXMuX2Nzc1N0eWxlID0gdGV4dFN0eWxlVG9DU1ModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jc3NTdHlsZTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgc3R5bGUgb3ZlcnJpZGUsIHRoaXMgY2FuIGJlIGFueSBDU1MgcHJvcGVydHlcbiAgICogaXQgd2lsbCBvdmVycmlkZSBhbnkgYnVpbHQtaW4gc3R5bGUuIFRoaXMgaXMgdGhlXG4gICAqIHByb3BlcnR5IGFuZCB0aGUgdmFsdWUgYXMgYSBzdHJpbmcgKGUuZy4sIGBjb2xvcjogcmVkYCkuXG4gICAqIFRoaXMgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgaW50ZXJuYWwgc3R5bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIENTUyBzdHlsZShzKSB0byBhZGQuXG4gICAqIEBleGFtcGxlXG4gICAqIHN0eWxlLmFkZE92ZXJyaWRlKCdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnKTtcbiAgICovXG4gIGFkZE92ZXJyaWRlKC4uLnZhbHVlKSB7XG4gICAgY29uc3QgdG9BZGQgPSB2YWx1ZS5maWx0ZXIoKHYpID0+ICF0aGlzLmNzc092ZXJyaWRlcy5pbmNsdWRlcyh2KSk7XG4gICAgaWYgKHRvQWRkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY3NzT3ZlcnJpZGVzLnB1c2goLi4udG9BZGQpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgb3ZlcnJpZGVzIHRoYXQgbWF0Y2ggdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBDU1Mgc3R5bGUgdG8gcmVtb3ZlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBzdHlsZS5yZW1vdmVPdmVycmlkZSgnYmFja2dyb3VuZC1jb2xvcjogcmVkJyk7XG4gICAqL1xuICByZW1vdmVPdmVycmlkZSguLi52YWx1ZSkge1xuICAgIGNvbnN0IHRvUmVtb3ZlID0gdmFsdWUuZmlsdGVyKCh2KSA9PiB0aGlzLmNzc092ZXJyaWRlcy5pbmNsdWRlcyh2KSk7XG4gICAgaWYgKHRvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY3NzT3ZlcnJpZGVzID0gdGhpcy5jc3NPdmVycmlkZXMuZmlsdGVyKCh2KSA9PiAhdG9SZW1vdmUuaW5jbHVkZXModikpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0IGZpbGwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgd2FybihcIltIVE1MVGV4dFN0eWxlXSBvbmx5IGNvbG9yIGZpbGwgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgICB9XG4gICAgc3VwZXIuZmlsbCA9IHZhbHVlO1xuICB9XG4gIHNldCBzdHJva2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgd2FybihcIltIVE1MVGV4dFN0eWxlXSBvbmx5IGNvbG9yIHN0cm9rZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICAgIH1cbiAgICBzdXBlci5zdHJva2UgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBIVE1MVGV4dFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdG1sVGV4dFN0eWxlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZXh0cmFjdEZvbnRGYW1pbGllcyh0ZXh0LCBzdHlsZSkge1xuICBjb25zdCBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgY29uc3QgZm9udEZhbWlsaWVzID0gW107XG4gIGNvbnN0IGRlZHVwZSA9IHt9O1xuICBjb25zdCByZWdleCA9IC9mb250LWZhbWlseTooW147XCJcXHNdKykvZztcbiAgY29uc3QgbWF0Y2hlcyA9IHRleHQubWF0Y2gocmVnZXgpO1xuICBmdW5jdGlvbiBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKSB7XG4gICAgaWYgKCFkZWR1cGVbZm9udEZhbWlseTJdKSB7XG4gICAgICBmb250RmFtaWxpZXMucHVzaChmb250RmFtaWx5Mik7XG4gICAgICBkZWR1cGVbZm9udEZhbWlseTJdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZm9udEZhbWlseSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbnRGYW1pbHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZEZvbnRGYW1pbHkoZm9udEZhbWlseVtpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFkZEZvbnRGYW1pbHkoZm9udEZhbWlseSk7XG4gIH1cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBjb25zdCBmb250RmFtaWx5MiA9IG1hdGNoLnNwbGl0KFwiOlwiKVsxXS50cmltKCk7XG4gICAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IGkgaW4gc3R5bGUudGFnU3R5bGVzKSB7XG4gICAgY29uc3QgZm9udEZhbWlseTIgPSBzdHlsZS50YWdTdHlsZXNbaV0uZm9udEZhbWlseTtcbiAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKTtcbiAgfVxuICByZXR1cm4gZm9udEZhbWlsaWVzO1xufVxuXG5leHBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0Rm9udEZhbWlsaWVzLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuYXN5bmMgZnVuY3Rpb24gbG9hZEZvbnRBc0Jhc2U2NCh1cmwpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBET01BZGFwdGVyLmdldCgpLmZldGNoKHVybCk7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGNvbnN0IGRhdGFTcmMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gIH0pO1xuICByZXR1cm4gZGF0YVNyYztcbn1cblxuZXhwb3J0IHsgbG9hZEZvbnRBc0Jhc2U2NCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEZvbnRBc0Jhc2U2NC5tanMubWFwXG4iLCJpbXBvcnQgeyBsb2FkRm9udEFzQmFzZTY0IH0gZnJvbSAnLi9sb2FkRm9udEFzQmFzZTY0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuYXN5bmMgZnVuY3Rpb24gbG9hZEZvbnRDU1Moc3R5bGUsIHVybCkge1xuICBjb25zdCBkYXRhU3JjID0gYXdhaXQgbG9hZEZvbnRBc0Jhc2U2NCh1cmwpO1xuICByZXR1cm4gYEBmb250LWZhY2Uge1xuICAgICAgICBmb250LWZhbWlseTogXCIke3N0eWxlLmZvbnRGYW1pbHl9XCI7XG4gICAgICAgIHNyYzogdXJsKCcke2RhdGFTcmN9Jyk7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiAke3N0eWxlLmZvbnRXZWlnaHR9O1xuICAgICAgICBmb250LXN0eWxlOiAke3N0eWxlLmZvbnRTdHlsZX07XG4gICAgfWA7XG59XG5cbmV4cG9ydCB7IGxvYWRGb250Q1NTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkRm9udENTUy5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgbG9hZEZvbnRDU1MgfSBmcm9tICcuL2xvYWRGb250Q1NTLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgRm9udFN0eWxlUHJvbWlzZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmFzeW5jIGZ1bmN0aW9uIGdldEZvbnRDc3MoZm9udEZhbWlsaWVzLCBzdHlsZSwgZGVmYXVsdE9wdGlvbnMpIHtcbiAgY29uc3QgZm9udFByb21pc2VzID0gZm9udEZhbWlsaWVzLmZpbHRlcigoZm9udEZhbWlseSkgPT4gQ2FjaGUuaGFzKGAke2ZvbnRGYW1pbHl9LWFuZC11cmxgKSkubWFwKChmb250RmFtaWx5LCBpKSA9PiB7XG4gICAgaWYgKCFGb250U3R5bGVQcm9taXNlQ2FjaGUuaGFzKGZvbnRGYW1pbHkpKSB7XG4gICAgICBjb25zdCB7IHVybCB9ID0gQ2FjaGUuZ2V0KGAke2ZvbnRGYW1pbHl9LWFuZC11cmxgKTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIEZvbnRTdHlsZVByb21pc2VDYWNoZS5zZXQoZm9udEZhbWlseSwgbG9hZEZvbnRDU1Moc3R5bGUsIHVybCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRm9udFN0eWxlUHJvbWlzZUNhY2hlLnNldChmb250RmFtaWx5LCBsb2FkRm9udENTUyh7XG4gICAgICAgICAgZm9udFdlaWdodDogZGVmYXVsdE9wdGlvbnMuZm9udFdlaWdodCxcbiAgICAgICAgICBmb250U3R5bGU6IGRlZmF1bHRPcHRpb25zLmZvbnRTdHlsZSxcbiAgICAgICAgICBmb250RmFtaWx5XG4gICAgICAgIH0sIHVybCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRm9udFN0eWxlUHJvbWlzZUNhY2hlLmdldChmb250RmFtaWx5KTtcbiAgfSk7XG4gIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoZm9udFByb21pc2VzKSkuam9pbihcIlxcblwiKTtcbn1cblxuZXhwb3J0IHsgRm9udFN0eWxlUHJvbWlzZUNhY2hlLCBnZXRGb250Q3NzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGb250Q3NzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0U1ZHVXJsKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBmb250Q1NTLCBodG1sVGV4dERhdGEpIHtcbiAgY29uc3QgeyBkb21FbGVtZW50LCBzdHlsZUVsZW1lbnQsIHN2Z1Jvb3QgfSA9IGh0bWxUZXh0RGF0YTtcbiAgZG9tRWxlbWVudC5pbm5lckhUTUwgPSBgPHN0eWxlPiR7c3R5bGUuY3NzU3R5bGV9PC9zdHlsZT48ZGl2PiR7dGV4dH08L2Rpdj5gO1xuICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB0cmFuc2Zvcm06IHNjYWxlKCR7cmVzb2x1dGlvbn0pO3RyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2tgKTtcbiAgc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gZm9udENTUztcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBodG1sVGV4dERhdGEuaW1hZ2U7XG4gIHN2Z1Jvb3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgudG9TdHJpbmcoKSk7XG4gIHN2Z1Jvb3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodC50b1N0cmluZygpKTtcbiAgcmV0dXJuIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnUm9vdCk7XG59XG5cbmV4cG9ydCB7IGdldFNWR1VybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0U1ZHVXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IENhbnZhc1Bvb2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UoaW1hZ2UsIHJlc29sdXRpb24pIHtcbiAgY29uc3QgY2FudmFzQW5kQ29udGV4dCA9IENhbnZhc1Bvb2wuZ2V0T3B0aW1hbENhbnZhc0FuZENvbnRleHQoXG4gICAgaW1hZ2Uud2lkdGgsXG4gICAgaW1hZ2UuaGVpZ2h0LFxuICAgIHJlc29sdXRpb25cbiAgKTtcbiAgY29uc3QgeyBjb250ZXh0IH0gPSBjYW52YXNBbmRDb250ZXh0O1xuICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICBDYW52YXNQb29sLnJldHVybkNhbnZhc0FuZENvbnRleHQoY2FudmFzQW5kQ29udGV4dCk7XG4gIHJldHVybiBjYW52YXNBbmRDb250ZXh0LmNhbnZhcztcbn1cblxuZXhwb3J0IHsgZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBsb2FkU1ZHSW1hZ2UoaW1hZ2UsIHVybCwgZGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTIpID0+IHNldFRpbWVvdXQocmVzb2x2ZTIsIDEwMCkpO1xuICAgIH1cbiAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmOCwke2VuY29kZVVSSUNvbXBvbmVudCh1cmwpfWA7XG4gICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgbG9hZFNWR0ltYWdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkU1ZHSW1hZ2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuLi8uLi90ZXh0L2NhbnZhcy9DYW52YXNUZXh0TWV0cmljcy5tanMnO1xuaW1wb3J0IHsgSFRNTFRleHRSZW5kZXJEYXRhIH0gZnJvbSAnLi4vSFRNTFRleHRSZW5kZXJEYXRhLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IHRlbXBIVE1MVGV4dFJlbmRlckRhdGE7XG5mdW5jdGlvbiBtZWFzdXJlSHRtbFRleHQodGV4dCwgc3R5bGUsIGZvbnRTdHlsZUNTUywgaHRtbFRleHRSZW5kZXJEYXRhKSB7XG4gIGh0bWxUZXh0UmVuZGVyRGF0YSA9IGh0bWxUZXh0UmVuZGVyRGF0YSB8fCB0ZW1wSFRNTFRleHRSZW5kZXJEYXRhIHx8ICh0ZW1wSFRNTFRleHRSZW5kZXJEYXRhID0gbmV3IEhUTUxUZXh0UmVuZGVyRGF0YSgpKTtcbiAgY29uc3QgeyBkb21FbGVtZW50LCBzdHlsZUVsZW1lbnQsIHN2Z1Jvb3QgfSA9IGh0bWxUZXh0UmVuZGVyRGF0YTtcbiAgZG9tRWxlbWVudC5pbm5lckhUTUwgPSBgPHN0eWxlPiR7c3R5bGUuY3NzU3R5bGV9PC9zdHlsZT48ZGl2PiR7dGV4dH08L2Rpdj5gO1xuICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwidHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7IGRpc3BsYXk6IGlubGluZS1ibG9ja1wiKTtcbiAgaWYgKGZvbnRTdHlsZUNTUykge1xuICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCA9IGZvbnRTdHlsZUNTUztcbiAgfVxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Z1Jvb3QpO1xuICBjb25zdCBjb250ZW50Qm91bmRzID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgc3ZnUm9vdC5yZW1vdmUoKTtcbiAgY29uc3QgZGVzY2VuZGVyUGFkZGluZyA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVGb250KHN0eWxlLmZvbnRTdHlsZSkuZGVzY2VudDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogY29udGVudEJvdW5kcy53aWR0aCxcbiAgICBoZWlnaHQ6IGNvbnRlbnRCb3VuZHMuaGVpZ2h0ICsgZGVzY2VuZGVyUGFkZGluZ1xuICB9O1xufVxuXG5leHBvcnQgeyBtZWFzdXJlSHRtbFRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lYXN1cmVIdG1sVGV4dC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvdHlwZXMubWpzJztcbmltcG9ydCB7IGlzU2FmYXJpIH0gZnJvbSAnLi4vLi4vdXRpbHMvYnJvd3Nlci9pc1NhZmFyaS5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZSB9IGZyb20gJy4uL3RleHQvdXRpbHMvZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzJztcbmltcG9ydCB7IEhUTUxUZXh0UmVuZGVyRGF0YSB9IGZyb20gJy4vSFRNTFRleHRSZW5kZXJEYXRhLm1qcyc7XG5pbXBvcnQgeyBIVE1MVGV4dFN0eWxlIH0gZnJvbSAnLi9IdG1sVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH0gZnJvbSAnLi91dGlscy9leHRyYWN0Rm9udEZhbWlsaWVzLm1qcyc7XG5pbXBvcnQgeyBnZXRGb250Q3NzIH0gZnJvbSAnLi91dGlscy9nZXRGb250Q3NzLm1qcyc7XG5pbXBvcnQgeyBnZXRTVkdVcmwgfSBmcm9tICcuL3V0aWxzL2dldFNWR1VybC5tanMnO1xuaW1wb3J0IHsgZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlIH0gZnJvbSAnLi91dGlscy9nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzJztcbmltcG9ydCB7IGxvYWRTVkdJbWFnZSB9IGZyb20gJy4vdXRpbHMvbG9hZFNWR0ltYWdlLm1qcyc7XG5pbXBvcnQgeyBtZWFzdXJlSHRtbFRleHQgfSBmcm9tICcuL3V0aWxzL21lYXN1cmVIdG1sVGV4dC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEhUTUxUZXh0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fY3JlYXRlQ2FudmFzID0gcmVuZGVyZXIudHlwZSA9PT0gUmVuZGVyZXJUeXBlLldFQkdQVTtcbiAgfVxuICBnZXRUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVpbGRUZXh0dXJlUHJvbWlzZShcbiAgICAgIG9wdGlvbnMudGV4dCxcbiAgICAgIG9wdGlvbnMucmVzb2x1dGlvbixcbiAgICAgIG9wdGlvbnMuc3R5bGVcbiAgICApO1xuICB9XG4gIGdldE1hbmFnZWRUZXh0dXJlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlLCB0ZXh0S2V5KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldKSB7XG4gICAgICB0aGlzLl9pbmNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9idWlsZFRleHR1cmVQcm9taXNlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlKS50aGVuKCh0ZXh0dXJlKSA9PiB7XG4gICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0ge1xuICAgICAgdGV4dHVyZTogbnVsbCxcbiAgICAgIHByb21pc2UsXG4gICAgICB1c2FnZUNvdW50OiAxXG4gICAgfTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBfYnVpbGRUZXh0dXJlUHJvbWlzZSh0ZXh0LCByZXNvbHV0aW9uLCBzdHlsZSkge1xuICAgIGNvbnN0IGh0bWxUZXh0RGF0YSA9IEJpZ1Bvb2wuZ2V0KEhUTUxUZXh0UmVuZGVyRGF0YSk7XG4gICAgY29uc3QgZm9udEZhbWlsaWVzID0gZXh0cmFjdEZvbnRGYW1pbGllcyh0ZXh0LCBzdHlsZSk7XG4gICAgY29uc3QgZm9udENTUyA9IGF3YWl0IGdldEZvbnRDc3MoXG4gICAgICBmb250RmFtaWxpZXMsXG4gICAgICBzdHlsZSxcbiAgICAgIEhUTUxUZXh0U3R5bGUuZGVmYXVsdFRleHRTdHlsZVxuICAgICk7XG4gICAgY29uc3QgbWVhc3VyZWQgPSBtZWFzdXJlSHRtbFRleHQodGV4dCwgc3R5bGUsIGZvbnRDU1MsIGh0bWxUZXh0RGF0YSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLndpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQuaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGltYWdlID0gaHRtbFRleHREYXRhLmltYWdlO1xuICAgIGltYWdlLndpZHRoID0gd2lkdGggfCAwO1xuICAgIGltYWdlLmhlaWdodCA9IGhlaWdodCB8IDA7XG4gICAgY29uc3Qgc3ZnVVJMID0gZ2V0U1ZHVXJsKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBmb250Q1NTLCBodG1sVGV4dERhdGEpO1xuICAgIGF3YWl0IGxvYWRTVkdJbWFnZShpbWFnZSwgc3ZnVVJMLCBpc1NhZmFyaSgpICYmIGZvbnRGYW1pbGllcy5sZW5ndGggPiAwKTtcbiAgICBsZXQgcmVzb3VyY2UgPSBpbWFnZTtcbiAgICBpZiAodGhpcy5fY3JlYXRlQ2FudmFzKSB7XG4gICAgICByZXNvdXJjZSA9IGdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZShpbWFnZSwgcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZShyZXNvdXJjZSwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgaWYgKHRoaXMuX2NyZWF0ZUNhbnZhcykge1xuICAgICAgdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5pbml0U291cmNlKHRleHR1cmUuc291cmNlKTtcbiAgICB9XG4gICAgQmlnUG9vbC5yZXR1cm4oaHRtbFRleHREYXRhKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICBfaW5jcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udXNhZ2VDb3VudCsrO1xuICB9XG4gIGRlY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIGNvbnN0IGFjdGl2ZVRleHR1cmUgPSB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XTtcbiAgICBpZiAoIWFjdGl2ZVRleHR1cmUpXG4gICAgICByZXR1cm47XG4gICAgYWN0aXZlVGV4dHVyZS51c2FnZUNvdW50LS07XG4gICAgaWYgKGFjdGl2ZVRleHR1cmUudXNhZ2VDb3VudCA9PT0gMCkge1xuICAgICAgaWYgKGFjdGl2ZVRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9jbGVhblVwKGFjdGl2ZVRleHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlVGV4dHVyZS5wcm9taXNlLnRoZW4oKHRleHR1cmUpID0+IHtcbiAgICAgICAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICAgIHRoaXMuX2NsZWFuVXAoYWN0aXZlVGV4dHVyZSk7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICB3YXJuKFwiSFRNTFRleHRTeXN0ZW06IEZhaWxlZCB0byBjbGVhbiB0ZXh0dXJlXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgX2NsZWFuVXAoYWN0aXZlVGV4dHVyZSkge1xuICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYWN0aXZlVGV4dHVyZS50ZXh0dXJlKTtcbiAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUuc291cmNlLnJlc291cmNlID0gbnVsbDtcbiAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUuc291cmNlLnVwbG9hZE1ldGhvZElkID0gXCJ1bmtub3duXCI7XG4gIH1cbiAgZ2V0UmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS51c2FnZUNvdW50O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXMgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuSFRNTFRleHRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbVxuICBdLFxuICBuYW1lOiBcImh0bWxUZXh0XCJcbn07XG5IVE1MVGV4dFN5c3RlbS5kZWZhdWx0Rm9udE9wdGlvbnMgPSB7XG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiXG59O1xuXG5leHBvcnQgeyBIVE1MVGV4dFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTFRleHRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgSFRNTFRleHRQaXBlIH0gZnJvbSAnLi9IVE1MVGV4dFBpcGUubWpzJztcbmltcG9ydCB7IEhUTUxUZXh0U3lzdGVtIH0gZnJvbSAnLi9IVE1MVGV4dFN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKEhUTUxUZXh0U3lzdGVtKTtcbmV4dGVuc2lvbnMuYWRkKEhUTUxUZXh0UGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1709\n')},3779:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p: () => (/* binding */ TextStyle)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1580);\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8409);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(156);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(557);\n/* harmony import */ var _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6653);\n/* harmony import */ var _graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4915);\n/* harmony import */ var _utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(740);\n\n\n\n\n\n\n\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Z {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = {\n        ..._TextStyle.defaultDropShadow,\n        ...value\n      };\n    } else {\n      this._dropShadow = value ? {\n        ..._TextStyle.defaultDropShadow\n      } : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value;\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    this._fill = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertFillInputToFillStyle */ .w)(\n      value === 0 ? \"black\" : value,\n      _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__/* .GraphicsContext */ .g.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    this._stroke = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertFillInputToFillStyle */ .w)(value, _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__/* .GraphicsContext */ .g.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = (0,_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__/* .generateTextStyleKey */ .L)(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .v8_0_0 */ .P, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    style.stroke = {\n      color,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fill)) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .v8_0_0 */ .P, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    const gradientFill = new _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__/* .FillGradient */ .f(0, 0, 0, style.fontSize * 1.7);\n    const fills = oldStyle.fill.map((color) => _color_Color_mjs__WEBPACK_IMPORTED_MODULE_6__/* .Color */ .I.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\n\n//# sourceMappingURL=TextStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0Qiw2QkFBNkIseUZBQVk7QUFDekMsK0NBQStDLDREQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L1RleHRTdHlsZS5tanM/NGFkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IEZpbGxHcmFkaWVudCB9IGZyb20gJy4uL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxHcmFkaWVudC5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NDb250ZXh0IH0gZnJvbSAnLi4vZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlIH0gZnJvbSAnLi4vZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL2NvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVUZXh0U3R5bGVLZXkgfSBmcm9tICcuL3V0aWxzL2dlbmVyYXRlVGV4dFN0eWxlS2V5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX1RleHRTdHlsZSA9IGNsYXNzIF9UZXh0U3R5bGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihzdHlsZSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb252ZXJ0VjdUb3Y4U3R5bGUoc3R5bGUpO1xuICAgIGNvbnN0IGZ1bGxTdHlsZSA9IHsgLi4uX1RleHRTdHlsZS5kZWZhdWx0VGV4dFN0eWxlLCAuLi5zdHlsZSB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZ1bGxTdHlsZSkge1xuICAgICAgY29uc3QgdGhpc0tleSA9IGtleTtcbiAgICAgIHRoaXNbdGhpc0tleV0gPSBmdWxsU3R5bGVba2V5XTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHQuXG4gICAqIEBtZW1iZXIgeydsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfCdqdXN0aWZ5J31cbiAgICovXG4gIGdldCBhbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gIH1cbiAgc2V0IGFsaWduKHZhbHVlKSB7XG4gICAgdGhpcy5fYWxpZ24gPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBJbmRpY2F0ZXMgaWYgbGluZXMgY2FuIGJlIHdyYXBwZWQgd2l0aGluIHdvcmRzLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZS4gKi9cbiAgZ2V0IGJyZWFrV29yZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JyZWFrV29yZHM7XG4gIH1cbiAgc2V0IGJyZWFrV29yZHModmFsdWUpIHtcbiAgICB0aGlzLl9icmVha1dvcmRzID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0LiAqL1xuICBnZXQgZHJvcFNoYWRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvdztcbiAgfVxuICBzZXQgZHJvcFNoYWRvdyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRoaXMuX2Ryb3BTaGFkb3cgPSB7XG4gICAgICAgIC4uLl9UZXh0U3R5bGUuZGVmYXVsdERyb3BTaGFkb3csXG4gICAgICAgIC4uLnZhbHVlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93ID0gdmFsdWUgPyB7XG4gICAgICAgIC4uLl9UZXh0U3R5bGUuZGVmYXVsdERyb3BTaGFkb3dcbiAgICAgIH0gOiBudWxsO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBUaGUgZm9udCBmYW1pbHksIGNhbiBiZSBhIHNpbmdsZSBmb250IG5hbWUsIG9yIGEgbGlzdCBvZiBuYW1lcyB3aGVyZSB0aGUgZmlyc3QgaXMgdGhlIHByZWZlcnJlZCBmb250LiAqL1xuICBnZXQgZm9udEZhbWlseSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udEZhbWlseTtcbiAgfVxuICBzZXQgZm9udEZhbWlseSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvbnRGYW1pbHkgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBUaGUgZm9udCBzaXplIChhcyBhIG51bWJlciBpdCBjb252ZXJ0cyB0byBweCwgYnV0IGFzIGEgc3RyaW5nLCBlcXVpdmFsZW50cyBhcmUgJzI2cHgnLCcyMHB0JywnMTYwJScgb3IgJzEuNmVtJykgKi9cbiAgZ2V0IGZvbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgfVxuICBzZXQgZm9udFNpemUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLl9mb250U2l6ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZvbnRTaXplID0gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb250IHN0eWxlLlxuICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnaXRhbGljJ3wnb2JsaXF1ZSd9XG4gICAqL1xuICBnZXQgZm9udFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250U3R5bGU7XG4gIH1cbiAgc2V0IGZvbnRTdHlsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvbnRTdHlsZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb250IHZhcmlhbnQuXG4gICAqIEBtZW1iZXIgeydub3JtYWwnfCdzbWFsbC1jYXBzJ31cbiAgICovXG4gIGdldCBmb250VmFyaWFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFZhcmlhbnQ7XG4gIH1cbiAgc2V0IGZvbnRWYXJpYW50KHZhbHVlKSB7XG4gICAgdGhpcy5fZm9udFZhcmlhbnQgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCB3ZWlnaHQuXG4gICAqIEBtZW1iZXIgeydub3JtYWwnfCdib2xkJ3wnYm9sZGVyJ3wnbGlnaHRlcid8JzEwMCd8JzIwMCd8JzMwMCd8JzQwMCd8JzUwMCd8JzYwMCd8JzcwMCd8JzgwMCd8JzkwMCd9XG4gICAqL1xuICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgfVxuICBzZXQgZm9udFdlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBUaGUgc3BhY2UgYmV0d2VlbiBsaW5lcy4gKi9cbiAgZ2V0IGxlYWRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWRpbmc7XG4gIH1cbiAgc2V0IGxlYWRpbmcodmFsdWUpIHtcbiAgICB0aGlzLl9sZWFkaW5nID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIGFtb3VudCBvZiBzcGFjaW5nIGJldHdlZW4gbGV0dGVycywgZGVmYXVsdCBpcyAwLiAqL1xuICBnZXQgbGV0dGVyU3BhY2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgfVxuICBzZXQgbGV0dGVyU3BhY2luZyh2YWx1ZSkge1xuICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBUaGUgbGluZSBoZWlnaHQsIGEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgc3BhY2UgdGhhdCBhIGxldHRlciB1c2VzLiAqL1xuICBnZXQgbGluZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZUhlaWdodDtcbiAgfVxuICBzZXQgbGluZUhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2xpbmVIZWlnaHQgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBPY2Nhc2lvbmFsbHkgc29tZSBmb250cyBhcmUgY3JvcHBlZC4gQWRkaW5nIHNvbWUgcGFkZGluZyB3aWxsIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZ1xuICAgKiBieSBhZGRpbmcgcGFkZGluZyB0byBhbGwgc2lkZXMgb2YgdGhlIHRleHQuXG4gICAqL1xuICBnZXQgcGFkZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgfVxuICBzZXQgcGFkZGluZyh2YWx1ZSkge1xuICAgIHRoaXMuX3BhZGRpbmcgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBUcmltIHRyYW5zcGFyZW50IGJvcmRlcnMuIFRoaXMgaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyBvbmx5IHVzZSB0aGlzIGlmIHlvdSBoYXZlIHRvISAqL1xuICBnZXQgdHJpbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJpbTtcbiAgfVxuICBzZXQgdHJpbSh2YWx1ZSkge1xuICAgIHRoaXMuX3RyaW0gPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZWxpbmUgb2YgdGhlIHRleHQgdGhhdCBpcyByZW5kZXJlZC5cbiAgICogQG1lbWJlciB7J2FscGhhYmV0aWMnfCd0b3AnfCdoYW5naW5nJ3wnbWlkZGxlJ3wnaWRlb2dyYXBoaWMnfCdib3R0b20nfVxuICAgKi9cbiAgZ2V0IHRleHRCYXNlbGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dEJhc2VsaW5lO1xuICB9XG4gIHNldCB0ZXh0QmFzZWxpbmUodmFsdWUpIHtcbiAgICB0aGlzLl90ZXh0QmFzZWxpbmUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBIb3cgbmV3bGluZXMgYW5kIHNwYWNlcyBzaG91bGQgYmUgaGFuZGxlZC5cbiAgICogRGVmYXVsdCBpcyAncHJlJyAocHJlc2VydmUsIHByZXNlcnZlKS5cbiAgICpcbiAgICogIHZhbHVlICAgICAgIHwgTmV3IGxpbmVzICAgICB8ICAgU3BhY2VzXG4gICAqICAtLS0gICAgICAgICB8IC0tLSAgICAgICAgICAgfCAgIC0tLVxuICAgKiAnbm9ybWFsJyAgICAgfCBDb2xsYXBzZSAgICAgIHwgICBDb2xsYXBzZVxuICAgKiAncHJlJyAgICAgICAgfCBQcmVzZXJ2ZSAgICAgIHwgICBQcmVzZXJ2ZVxuICAgKiAncHJlLWxpbmUnICAgfCBQcmVzZXJ2ZSAgICAgIHwgICBDb2xsYXBzZVxuICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wncHJlJ3wncHJlLWxpbmUnfVxuICAgKi9cbiAgZ2V0IHdoaXRlU3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3doaXRlU3BhY2U7XG4gIH1cbiAgc2V0IHdoaXRlU3BhY2UodmFsdWUpIHtcbiAgICB0aGlzLl93aGl0ZVNwYWNlID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogSW5kaWNhdGVzIGlmIHdvcmQgd3JhcCBzaG91bGQgYmUgdXNlZC4gKi9cbiAgZ2V0IHdvcmRXcmFwKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcbiAgfVxuICBzZXQgd29yZFdyYXAodmFsdWUpIHtcbiAgICB0aGlzLl93b3JkV3JhcCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcCwgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWUuICovXG4gIGdldCB3b3JkV3JhcFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcFdpZHRoO1xuICB9XG4gIHNldCB3b3JkV3JhcFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fd29yZFdyYXBXaWR0aCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIEEgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGUuZy4sICdyZWQnLCAnIzAwRkYwMCcuICovXG4gIGdldCBmaWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbEZpbGw7XG4gIH1cbiAgc2V0IGZpbGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMuX29yaWdpbmFsRmlsbClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9vcmlnaW5hbEZpbGwgPSB2YWx1ZTtcbiAgICB0aGlzLl9maWxsID0gY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlKFxuICAgICAgdmFsdWUgPT09IDAgPyBcImJsYWNrXCIgOiB2YWx1ZSxcbiAgICAgIEdyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlXG4gICAgKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBBIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBzdHJva2UsIGUuZy4sICdibHVlJywgJyNGQ0ZGMDAnLiAqL1xuICBnZXQgc3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFN0cm9rZTtcbiAgfVxuICBzZXQgc3Ryb2tlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLl9vcmlnaW5hbFN0cm9rZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9vcmlnaW5hbFN0cm9rZSA9IHZhbHVlO1xuICAgIHRoaXMuX3N0cm9rZSA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSh2YWx1ZSwgR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICBfZ2VuZXJhdGVLZXkoKSB7XG4gICAgdGhpcy5fc3R5bGVLZXkgPSBnZW5lcmF0ZVRleHRTdHlsZUtleSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVLZXk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3N0eWxlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gIH1cbiAgLyoqIFJlc2V0cyBhbGwgcHJvcGVydGllcyB0byB0aGUgZGVmYXVsdCB2YWx1ZXMgKi9cbiAgcmVzZXQoKSB7XG4gICAgY29uc3QgZGVmYXVsdFN0eWxlID0gX1RleHRTdHlsZS5kZWZhdWx0VGV4dFN0eWxlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRTdHlsZSkge1xuICAgICAgdGhpc1trZXldID0gZGVmYXVsdFN0eWxlW2tleV07XG4gICAgfVxuICB9XG4gIGdldCBzdHlsZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVLZXkgfHwgdGhpcy5fZ2VuZXJhdGVLZXkoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUZXh0U3R5bGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKiBAcmV0dXJucyBOZXcgY2xvbmVkIFRleHRTdHlsZSBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX1RleHRTdHlsZSh7XG4gICAgICBhbGlnbjogdGhpcy5hbGlnbixcbiAgICAgIGJyZWFrV29yZHM6IHRoaXMuYnJlYWtXb3JkcyxcbiAgICAgIGRyb3BTaGFkb3c6IHRoaXMuZHJvcFNoYWRvdyxcbiAgICAgIGZpbGw6IHRoaXMuX2ZpbGwsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5mb250U3R5bGUsXG4gICAgICBmb250VmFyaWFudDogdGhpcy5mb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCxcbiAgICAgIGxlYWRpbmc6IHRoaXMubGVhZGluZyxcbiAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyxcbiAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCxcbiAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyxcbiAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlLFxuICAgICAgdGV4dEJhc2VsaW5lOiB0aGlzLnRleHRCYXNlbGluZSxcbiAgICAgIHdoaXRlU3BhY2U6IHRoaXMud2hpdGVTcGFjZSxcbiAgICAgIHdvcmRXcmFwOiB0aGlzLndvcmRXcmFwLFxuICAgICAgd29yZFdyYXBXaWR0aDogdGhpcy53b3JkV3JhcFdpZHRoXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgdGV4dCBzdHlsZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSB0aGlzIHN0eWxlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZVNvdXJjZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZVNvdXJjZSBvZiB0aGUgdGhpcyBzdHlsZVxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zID0gZmFsc2UpIHtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmU7XG4gICAgaWYgKGRlc3Ryb3lUZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXN0cm95VGV4dHVyZVNvdXJjZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlU291cmNlO1xuICAgICAgaWYgKHRoaXMuX2ZpbGw/LnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fZmlsbC50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRmlsbD8udGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEZpbGwudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdHJva2U/LnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fc3Ryb2tlLnRleHR1cmUuZGVzdHJveShkZXN0cm95VGV4dHVyZVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fb3JpZ2luYWxTdHJva2U/LnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxTdHJva2UudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmlsbCA9IG51bGw7XG4gICAgdGhpcy5fc3Ryb2tlID0gbnVsbDtcbiAgICB0aGlzLmRyb3BTaGFkb3cgPSBudWxsO1xuICAgIHRoaXMuX29yaWdpbmFsU3Ryb2tlID0gbnVsbDtcbiAgICB0aGlzLl9vcmlnaW5hbEZpbGwgPSBudWxsO1xuICB9XG59O1xuLyoqIFRoZSBkZWZhdWx0IGRyb3Agc2hhZG93IHNldHRpbmdzICovXG5fVGV4dFN0eWxlLmRlZmF1bHREcm9wU2hhZG93ID0ge1xuICAvKiogU2V0IGFscGhhIGZvciB0aGUgZHJvcCBzaGFkb3cgKi9cbiAgYWxwaGE6IDEsXG4gIC8qKiBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3cgKi9cbiAgYW5nbGU6IE1hdGguUEkgLyA2LFxuICAvKiogU2V0IGEgc2hhZG93IGJsdXIgcmFkaXVzICovXG4gIGJsdXI6IDAsXG4gIC8qKiBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgIGUuZy4sICdyZWQnLCAnIzAwRkYwMCcgKi9cbiAgY29sb3I6IFwiYmxhY2tcIixcbiAgLyoqIFNldCBhIGRpc3RhbmNlIG9mIHRoZSBkcm9wIHNoYWRvdyAqL1xuICBkaXN0YW5jZTogNVxufTtcbi8qKiBUaGUgZGVmYXVsdCB0ZXh0IHN0eWxlIHNldHRpbmdzICovXG5fVGV4dFN0eWxlLmRlZmF1bHRUZXh0U3R5bGUgPSB7XG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5hbGlnbn1cbiAgICogQHR5cGUgeydsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfCdqdXN0aWZ5J31cbiAgICovXG4gIGFsaWduOiBcImxlZnRcIixcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmJyZWFrV29yZHN9ICovXG4gIGJyZWFrV29yZHM6IGZhbHNlLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUuZHJvcFNoYWRvd30gKi9cbiAgZHJvcFNoYWRvdzogbnVsbCxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZpbGx9XG4gICAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59XG4gICAqL1xuICBmaWxsOiBcImJsYWNrXCIsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5mb250RmFtaWx5fVxuICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuICAgKi9cbiAgZm9udEZhbWlseTogXCJBcmlhbFwiLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuZm9udFNpemV9XG4gICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfVxuICAgKi9cbiAgZm9udFNpemU6IDI2LFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuZm9udFN0eWxlfVxuICAgKiBAdHlwZSB7J25vcm1hbCd8J2l0YWxpYyd8J29ibGlxdWUnfVxuICAgKi9cbiAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuZm9udFZhcmlhbnR9XG4gICAqIEB0eXBlIHsnbm9ybWFsJ3wnc21hbGwtY2Fwcyd9XG4gICAqL1xuICBmb250VmFyaWFudDogXCJub3JtYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZvbnRXZWlnaHR9XG4gICAqIEB0eXBlIHsnbm9ybWFsJ3wnYm9sZCd8J2JvbGRlcid8J2xpZ2h0ZXInfCcxMDAnfCcyMDAnfCczMDAnfCc0MDAnfCc1MDAnfCc2MDAnfCc3MDAnfCc4MDAnfCc5MDAnfVxuICAgKi9cbiAgZm9udFdlaWdodDogXCJub3JtYWxcIixcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmxlYWRpbmd9ICovXG4gIGxlYWRpbmc6IDAsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5sZXR0ZXJTcGFjaW5nfSAqL1xuICBsZXR0ZXJTcGFjaW5nOiAwLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUubGluZUhlaWdodH0gKi9cbiAgbGluZUhlaWdodDogMCxcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLnBhZGRpbmd9ICovXG4gIHBhZGRpbmc6IDAsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5zdHJva2V9XG4gICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxuICAgKi9cbiAgc3Ryb2tlOiBudWxsLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUudGV4dEJhc2VsaW5lfVxuICAgKiBAdHlwZSB7J2FscGhhYmV0aWMnfCd0b3AnfCdoYW5naW5nJ3wnbWlkZGxlJ3wnaWRlb2dyYXBoaWMnfCdib3R0b20nfVxuICAgKi9cbiAgdGV4dEJhc2VsaW5lOiBcImFscGhhYmV0aWNcIixcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLnRyaW19ICovXG4gIHRyaW06IGZhbHNlLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUud2hpdGVTcGFjZX1cbiAgICogQHR5cGUgeydub3JtYWwnfCdwcmUnfCdwcmUtbGluZSd9XG4gICAqL1xuICB3aGl0ZVNwYWNlOiBcInByZVwiLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUud29yZFdyYXB9ICovXG4gIHdvcmRXcmFwOiBmYWxzZSxcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLndvcmRXcmFwV2lkdGh9ICovXG4gIHdvcmRXcmFwV2lkdGg6IDEwMFxufTtcbmxldCBUZXh0U3R5bGUgPSBfVGV4dFN0eWxlO1xuZnVuY3Rpb24gY29udmVydFY3VG92OFN0eWxlKHN0eWxlKSB7XG4gIGNvbnN0IG9sZFN0eWxlID0gc3R5bGU7XG4gIGlmICh0eXBlb2Ygb2xkU3R5bGUuZHJvcFNoYWRvdyA9PT0gXCJib29sZWFuXCIgJiYgb2xkU3R5bGUuZHJvcFNoYWRvdykge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gVGV4dFN0eWxlLmRlZmF1bHREcm9wU2hhZG93O1xuICAgIHN0eWxlLmRyb3BTaGFkb3cgPSB7XG4gICAgICBhbHBoYTogb2xkU3R5bGUuZHJvcFNoYWRvd0FscGhhID8/IGRlZmF1bHRzLmFscGhhLFxuICAgICAgYW5nbGU6IG9sZFN0eWxlLmRyb3BTaGFkb3dBbmdsZSA/PyBkZWZhdWx0cy5hbmdsZSxcbiAgICAgIGJsdXI6IG9sZFN0eWxlLmRyb3BTaGFkb3dCbHVyID8/IGRlZmF1bHRzLmJsdXIsXG4gICAgICBjb2xvcjogb2xkU3R5bGUuZHJvcFNoYWRvd0NvbG9yID8/IGRlZmF1bHRzLmNvbG9yLFxuICAgICAgZGlzdGFuY2U6IG9sZFN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA/PyBkZWZhdWx0cy5kaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgaWYgKG9sZFN0eWxlLnN0cm9rZVRoaWNrbmVzcykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJzdHJva2VUaGlja25lc3MgaXMgbm93IGEgcGFydCBvZiBzdHJva2VcIik7XG4gICAgY29uc3QgY29sb3IgPSBvbGRTdHlsZS5zdHJva2U7XG4gICAgc3R5bGUuc3Ryb2tlID0ge1xuICAgICAgY29sb3IsXG4gICAgICB3aWR0aDogb2xkU3R5bGUuc3Ryb2tlVGhpY2tuZXNzXG4gICAgfTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvbGRTdHlsZS5maWxsKSkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJncmFkaWVudCBmaWxsIGlzIG5vdyBhIGZpbGwgcGF0dGVybjogYG5ldyBGaWxsR3JhZGllbnQoLi4uKWBcIik7XG4gICAgY29uc3QgZ3JhZGllbnRGaWxsID0gbmV3IEZpbGxHcmFkaWVudCgwLCAwLCAwLCBzdHlsZS5mb250U2l6ZSAqIDEuNyk7XG4gICAgY29uc3QgZmlsbHMgPSBvbGRTdHlsZS5maWxsLm1hcCgoY29sb3IpID0+IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShjb2xvcikudG9OdW1iZXIoKSk7XG4gICAgZmlsbHMuZm9yRWFjaCgobnVtYmVyLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcmF0aW8gPSBvbGRTdHlsZS5maWxsR3JhZGllbnRTdG9wc1tpbmRleF0gPz8gaW5kZXggLyBmaWxscy5sZW5ndGg7XG4gICAgICBncmFkaWVudEZpbGwuYWRkQ29sb3JTdG9wKHJhdGlvLCBudW1iZXIpO1xuICAgIH0pO1xuICAgIHN0eWxlLmZpbGwgPSB7XG4gICAgICBmaWxsOiBncmFkaWVudEZpbGxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHRTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFN0eWxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3779\n")},3374:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ CanvasTextMetrics)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);\n\n\n\n"use strict";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = " ", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = (0,_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .fontStringFromTextStyle */ .M)(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object\'s wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext("2d", contextSettings);\n    let width = 0;\n    let line = "";\n    let lines = "";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = "";\n          width = 0;\n          continue;\n        }\n        token = " ";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== "") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = "";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = "";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = "";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== "number") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === "normal" || whiteSpace === "pre-line";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === "normal";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== "string") {\n      return "";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = "";\n    if (typeof text !== "string") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== "") {\n          tokens.push(token);\n          token = "";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== "") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = "") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext("2d", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n      } catch (ex) {\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = "|\\xC9q\\xC5";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = "M";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `\'\\u0065\\u0301\'`, letter e with acute)\n * or emojis with modifiers (e.g. `\'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don\'t support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won\'t use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === "function") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome\'s new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\n\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM3NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUNnQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5RUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLGVBQWU7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQixvR0FBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUVBQVU7QUFDM0IsUUFBUTtBQUNSLGlCQUFpQix5RUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELGtCQUFrQiwrQ0FBK0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRNZXRyaWNzLm1qcz83MzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBmb250U3RyaW5nRnJvbVRleHRTdHlsZSB9IGZyb20gJy4vdXRpbHMvZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjb250ZXh0U2V0dGluZ3MgPSB7XG4gIC8vIFRleHRNZXRyaWNzIHJlcXVpcmVzIGdldEltYWdlRGF0YSByZWFkYmFjayBmb3IgbWVhc3VyaW5nIGZvbnRzLlxuICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbn07XG5jb25zdCBfQ2FudmFzVGV4dE1ldHJpY3MgPSBjbGFzcyBfQ2FudmFzVGV4dE1ldHJpY3Mge1xuICAvKipcbiAgICogQ2hlY2tpbmcgdGhhdCB3ZSBjYW4gdXNlIG1vZGVybiBjYW52YXMgMkQgQVBJLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIGFuIHVuc3RhYmxlIEFQSSwgQ2hyb21lIDwgOTQgdXNlIGB0ZXh0TGV0dGVyU3BhY2luZ2AsIGxhdGVyIHZlcnNpb25zIHVzZSBgbGV0dGVyU3BhY2luZ2AuXG4gICAqIEBzZWUgVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2xldHRlclNwYWNpbmdcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL29yaWdpbnRyaWFscy8jL3ZpZXdfdHJpYWwvMzU4NTk5MTIwMzI5Mzc1NzQ0MVxuICAgKi9cbiAgc3RhdGljIGdldCBleHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkKCkge1xuICAgIGxldCByZXN1bHQgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2V4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQ7XG4gICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBwcm90byA9IERPTUFkYXB0ZXIuZ2V0KCkuZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKCkucHJvdG90eXBlO1xuICAgICAgcmVzdWx0ID0gX0NhbnZhc1RleHRNZXRyaWNzLl9leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkID0gXCJsZXR0ZXJTcGFjaW5nXCIgaW4gcHJvdG8gfHwgXCJ0ZXh0TGV0dGVyU3BhY2luZ1wiIGluIHByb3RvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dCAtIHRoZSB0ZXh0IHRoYXQgd2FzIG1lYXN1cmVkXG4gICAqIEBwYXJhbSBzdHlsZSAtIHRoZSBzdHlsZSB0aGF0IHdhcyBtZWFzdXJlZFxuICAgKiBAcGFyYW0gd2lkdGggLSB0aGUgbWVhc3VyZWQgd2lkdGggb2YgdGhlIHRleHRcbiAgICogQHBhcmFtIGhlaWdodCAtIHRoZSBtZWFzdXJlZCBoZWlnaHQgb2YgdGhlIHRleHRcbiAgICogQHBhcmFtIGxpbmVzIC0gYW4gYXJyYXkgb2YgdGhlIGxpbmVzIG9mIHRleHQgYnJva2VuIGJ5IG5ldyBsaW5lcyBhbmQgd3JhcHBpbmcgaWYgc3BlY2lmaWVkIGluIHN0eWxlXG4gICAqIEBwYXJhbSBsaW5lV2lkdGhzIC0gYW4gYXJyYXkgb2YgdGhlIGxpbmUgd2lkdGhzIGZvciBlYWNoIGxpbmUgbWF0Y2hlZCB0byBgbGluZXNgXG4gICAqIEBwYXJhbSBsaW5lSGVpZ2h0IC0gdGhlIG1lYXN1cmVkIGxpbmUgaGVpZ2h0IGZvciB0aGlzIHN0eWxlXG4gICAqIEBwYXJhbSBtYXhMaW5lV2lkdGggLSB0aGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciBhbGwgbWVhc3VyZWQgbGluZXNcbiAgICogQHBhcmFtIHtGb250TWV0cmljc30gZm9udFByb3BlcnRpZXMgLSB0aGUgZm9udCBwcm9wZXJ0aWVzIG9iamVjdCBmcm9tIFRleHRNZXRyaWNzLm1lYXN1cmVGb250XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdHlsZSwgd2lkdGgsIGhlaWdodCwgbGluZXMsIGxpbmVXaWR0aHMsIGxpbmVIZWlnaHQsIG1heExpbmVXaWR0aCwgZm9udFByb3BlcnRpZXMpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICB0aGlzLm1heExpbmVXaWR0aCA9IG1heExpbmVXaWR0aDtcbiAgICB0aGlzLmZvbnRQcm9wZXJ0aWVzID0gZm9udFByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIE1lYXN1cmVzIHRoZSBzdXBwbGllZCBzdHJpbmcgb2YgdGV4dCBhbmQgcmV0dXJucyBhIFJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBtZWFzdXJlLlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgdGV4dCBzdHlsZSB0byB1c2UgZm9yIG1lYXN1cmluZ1xuICAgKiBAcGFyYW0gY2FudmFzIC0gb3B0aW9uYWwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY2FudmFzIHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICAgKiBAcGFyYW0gd29yZFdyYXBcbiAgICogQHJldHVybnMgTWVhc3VyZWQgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGV4dC5cbiAgICovXG4gIHN0YXRpYyBtZWFzdXJlVGV4dCh0ZXh0ID0gXCIgXCIsIHN0eWxlLCBjYW52YXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NhbnZhcywgd29yZFdyYXAgPSBzdHlsZS53b3JkV3JhcCkge1xuICAgIGNvbnN0IHRleHRLZXkgPSBgJHt0ZXh0fToke3N0eWxlLnN0eWxlS2V5fWA7XG4gICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5fbWVhc3VyZW1lbnRDYWNoZVt0ZXh0S2V5XSlcbiAgICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX21lYXN1cmVtZW50Q2FjaGVbdGV4dEtleV07XG4gICAgY29uc3QgZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBjb25zdCBmb250UHJvcGVydGllcyA9IF9DYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlRm9udChmb250KTtcbiAgICBpZiAoZm9udFByb3BlcnRpZXMuZm9udFNpemUgPT09IDApIHtcbiAgICAgIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplID0gc3R5bGUuZm9udFNpemU7XG4gICAgICBmb250UHJvcGVydGllcy5hc2NlbnQgPSBzdHlsZS5mb250U2l6ZTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IF9DYW52YXNUZXh0TWV0cmljcy5fX2NvbnRleHQ7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBvdXRwdXRUZXh0ID0gd29yZFdyYXAgPyBfQ2FudmFzVGV4dE1ldHJpY3MuX3dvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMpIDogdGV4dDtcbiAgICBjb25zdCBsaW5lcyA9IG91dHB1dFRleHQuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKTtcbiAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBfQ2FudmFzVGV4dE1ldHJpY3MuX21lYXN1cmVUZXh0KGxpbmVzW2ldLCBzdHlsZS5sZXR0ZXJTcGFjaW5nLCBjb250ZXh0KTtcbiAgICAgIGxpbmVXaWR0aHNbaV0gPSBsaW5lV2lkdGg7XG4gICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgfVxuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc3R5bGUuX3N0cm9rZT8ud2lkdGggfHwgMDtcbiAgICBsZXQgd2lkdGggPSBtYXhMaW5lV2lkdGggKyBzdHJva2VXaWR0aDtcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgd2lkdGggKz0gc3R5bGUuZHJvcFNoYWRvdy5kaXN0YW5jZTtcbiAgICB9XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQgfHwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHJva2VXaWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gTWF0aC5tYXgobGluZUhlaWdodCwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHJva2VXaWR0aCAqIDIpICsgKGxpbmVzLmxlbmd0aCAtIDEpICogKGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nKTtcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgaGVpZ2h0ICs9IHN0eWxlLmRyb3BTaGFkb3cuZGlzdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IG5ldyBfQ2FudmFzVGV4dE1ldHJpY3MoXG4gICAgICB0ZXh0LFxuICAgICAgc3R5bGUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxpbmVzLFxuICAgICAgbGluZVdpZHRocyxcbiAgICAgIGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nLFxuICAgICAgbWF4TGluZVdpZHRoLFxuICAgICAgZm9udFByb3BlcnRpZXNcbiAgICApO1xuICAgIHJldHVybiBtZWFzdXJlbWVudHM7XG4gIH1cbiAgc3RhdGljIF9tZWFzdXJlVGV4dCh0ZXh0LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSB7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbiAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIGlmICh1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgIHdpZHRoIC09IGxldHRlclNwYWNpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCArPSAoX0NhbnZhc1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyKHRleHQpLmxlbmd0aCAtIDEpICogbGV0dGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIG5ld2xpbmVzIHRvIGEgc3RyaW5nIHRvIGhhdmUgaXQgb3B0aW1hbGx5IGZpdCBpbnRvIHRoZSBob3Jpem9udGFsXG4gICAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHRleHQgLSBTdHJpbmcgdG8gYXBwbHkgd29yZCB3cmFwcGluZyB0b1xuICAgKiBAcGFyYW0gc3R5bGUgLSB0aGUgc3R5bGUgdG8gdXNlIHdoZW4gd3JhcHBpbmdcbiAgICogQHBhcmFtIGNhbnZhcyAtIG9wdGlvbmFsIHNwZWNpZmljYXRpb24gb2YgdGhlIGNhbnZhcyB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAgICogQHJldHVybnMgTmV3IHN0cmluZyB3aXRoIG5ldyBsaW5lcyBhcHBsaWVkIHdoZXJlIHJlcXVpcmVkXG4gICAqL1xuICBzdGF0aWMgX3dvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NhbnZhcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgbGV0IHdpZHRoID0gMDtcbiAgICBsZXQgbGluZSA9IFwiXCI7XG4gICAgbGV0IGxpbmVzID0gXCJcIjtcbiAgICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHsgbGV0dGVyU3BhY2luZywgd2hpdGVTcGFjZSB9ID0gc3R5bGU7XG4gICAgY29uc3QgY29sbGFwc2VTcGFjZXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NvbGxhcHNlU3BhY2VzKHdoaXRlU3BhY2UpO1xuICAgIGNvbnN0IGNvbGxhcHNlTmV3bGluZXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSk7XG4gICAgbGV0IGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgY29uc3Qgd29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgIGNvbnN0IHRva2VucyA9IF9DYW52YXNUZXh0TWV0cmljcy5fdG9rZW5pemUodGV4dCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuX2lzTmV3bGluZSh0b2tlbikpIHtcbiAgICAgICAgaWYgKCFjb2xsYXBzZU5ld2xpbmVzKSB7XG4gICAgICAgICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gXCIgXCI7XG4gICAgICB9XG4gICAgICBpZiAoY29sbGFwc2VTcGFjZXMpIHtcbiAgICAgICAgY29uc3QgY3VycklzQnJlYWtpbmdTcGFjZSA9IF9DYW52YXNUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pO1xuICAgICAgICBjb25zdCBsYXN0SXNCcmVha2luZ1NwYWNlID0gX0NhbnZhc1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShsaW5lW2xpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAoY3VycklzQnJlYWtpbmdTcGFjZSAmJiBsYXN0SXNCcmVha2luZ1NwYWNlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuV2lkdGggPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2dldEZyb21DYWNoZSh0b2tlbiwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgaWYgKHRva2VuV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgIGlmIChsaW5lICE9PSBcIlwiKSB7XG4gICAgICAgICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IF9DYW52YXNUZXh0TWV0cmljcy53b3JkV3JhcFNwbGl0KHRva2VuKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYXJhY3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gY2hhcmFjdGVyc1tqXTtcbiAgICAgICAgICAgIGxldCBsYXN0Q2hhciA9IGNoYXI7XG4gICAgICAgICAgICBsZXQgayA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyc1tqICsga10pIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyYWN0ZXJzW2ogKyBrXTtcbiAgICAgICAgICAgICAgaWYgKCFfQ2FudmFzVGV4dE1ldHJpY3MuY2FuQnJlYWtDaGFycyhsYXN0Q2hhciwgbmV4dENoYXIsIHRva2VuLCBqLCBzdHlsZS5icmVha1dvcmRzKSkge1xuICAgICAgICAgICAgICAgIGNoYXIgKz0gbmV4dENoYXI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdENoYXIgPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaiArPSBrIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlcldpZHRoID0gX0NhbnZhc1RleHRNZXRyaWNzLl9nZXRGcm9tQ2FjaGUoY2hhciwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNoYXJhY3RlcldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZSArPSBjaGFyO1xuICAgICAgICAgICAgd2lkdGggKz0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZSh0b2tlbiwgIWlzTGFzdFRva2VuKTtcbiAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5XaWR0aCArIHdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBsaW5lcyArPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2FkZExpbmUobGluZSk7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDAgfHwgIV9DYW52YXNUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pIHx8IGNhblByZXBlbmRTcGFjZXMpIHtcbiAgICAgICAgICBsaW5lICs9IHRva2VuO1xuICAgICAgICAgIHdpZHRoICs9IHRva2VuV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUsIGZhbHNlKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZpZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9nZ2luZyBlYWNoIGxpbmUgYWRkZWQgZHVyaW5nIHRoZSB3b3JkV3JhcCBtZXRob2QuXG4gICAqIEBwYXJhbSBsaW5lICAgIC0gVGhlIGxpbmUgb2YgdGV4dCB0byBhZGRcbiAgICogQHBhcmFtIG5ld0xpbmUgLSBBZGQgbmV3IGxpbmUgY2hhcmFjdGVyIHRvIGVuZFxuICAgKiBAcmV0dXJucyBBIGZvcm1hdHRlZCBsaW5lXG4gICAqL1xuICBzdGF0aWMgX2FkZExpbmUobGluZSwgbmV3TGluZSA9IHRydWUpIHtcbiAgICBsaW5lID0gX0NhbnZhc1RleHRNZXRyaWNzLl90cmltUmlnaHQobGluZSk7XG4gICAgbGluZSA9IG5ld0xpbmUgPyBgJHtsaW5lfVxuYCA6IGxpbmU7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgJiBzZXRzIHRoZSB3aWR0aHMgb2YgY2FsY3VsYXRlZCBjaGFyYWN0ZXJzIGluIGEgY2FjaGUgb2JqZWN0XG4gICAqIEBwYXJhbSBrZXkgICAgICAgICAgICAtIFRoZSBrZXlcbiAgICogQHBhcmFtIGxldHRlclNwYWNpbmcgIC0gVGhlIGxldHRlciBzcGFjaW5nXG4gICAqIEBwYXJhbSBjYWNoZSAgICAgICAgICAtIFRoZSBjYWNoZVxuICAgKiBAcGFyYW0gY29udGV4dCAgICAgICAgLSBUaGUgY2FudmFzIGNvbnRleHRcbiAgICogQHJldHVybnMgVGhlIGZyb20gY2FjaGUuXG4gICAqL1xuICBzdGF0aWMgX2dldEZyb21DYWNoZShrZXksIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KSB7XG4gICAgbGV0IHdpZHRoID0gY2FjaGVba2V5XTtcbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB3aWR0aCA9IF9DYW52YXNUZXh0TWV0cmljcy5fbWVhc3VyZVRleHQoa2V5LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSArIGxldHRlclNwYWNpbmc7XG4gICAgICBjYWNoZVtrZXldID0gd2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBjb2xsYXBzZSBicmVha2luZyBzcGFjZXMuXG4gICAqIEBwYXJhbSB3aGl0ZVNwYWNlIC0gVGhlIFRleHRTdHlsZSBwcm9wZXJ0eSB3aGl0ZVNwYWNlXG4gICAqIEByZXR1cm5zIFNob3VsZCBjb2xsYXBzZVxuICAgKi9cbiAgc3RhdGljIF9jb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09IFwibm9ybWFsXCIgfHwgd2hpdGVTcGFjZSA9PT0gXCJwcmUtbGluZVwiO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ld0xpbmUgY2hhcnMuXG4gICAqIEBwYXJhbSB3aGl0ZVNwYWNlIC0gVGhlIHdoaXRlIHNwYWNlXG4gICAqIEByZXR1cm5zIHNob3VsZCBjb2xsYXBzZVxuICAgKi9cbiAgc3RhdGljIF9jb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpIHtcbiAgICByZXR1cm4gd2hpdGVTcGFjZSA9PT0gXCJub3JtYWxcIjtcbiAgfVxuICAvKipcbiAgICogVHJpbXMgYnJlYWtpbmcgd2hpdGVzcGFjZXMgZnJvbSBzdHJpbmcuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHRcbiAgICogQHJldHVybnMgVHJpbW1lZCBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyBfdHJpbVJpZ2h0KHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICBpZiAoIV9DYW52YXNUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhcikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBuZXdsaW5lLlxuICAgKiBAcGFyYW0gY2hhciAtIFRoZSBjaGFyYWN0ZXJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBuZXdsaW5lLCBGYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgX2lzTmV3bGluZShjaGFyKSB7XG4gICAgaWYgKHR5cGVvZiBjaGFyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX25ld2xpbmVzLmluY2x1ZGVzKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgY2hhciBpcyBhIGJyZWFraW5nIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIEl0IGFsbG93cyBvbmUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgY2hhciBzaG91bGQgYmUgYSBicmVha2luZyB3aGl0ZXNwYWNlXG4gICAqIEZvciBleGFtcGxlIGNlcnRhaW4gY2hhcmFjdGVycyBpbiBDSksgbGFuZ3Mgb3IgbnVtYmVycy5cbiAgICogSXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgKiBAcGFyYW0gY2hhciAtIFRoZSBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIFtfbmV4dENoYXJdIC0gVGhlIG5leHQgY2hhcmFjdGVyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgd2hpdGVzcGFjZSwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGlzQnJlYWtpbmdTcGFjZShjaGFyLCBfbmV4dENoYXIpIHtcbiAgICBpZiAodHlwZW9mIGNoYXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fYnJlYWtpbmdTcGFjZXMuaW5jbHVkZXMoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXRzIGEgc3RyaW5nIGludG8gd29yZHMsIGJyZWFraW5nLXNwYWNlcyBhbmQgbmV3TGluZSBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHRcbiAgICogQHJldHVybnMgQSB0b2tlbml6ZWQgYXJyYXlcbiAgICovXG4gIHN0YXRpYyBfdG9rZW5pemUodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGxldCB0b2tlbiA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuICAgICAgY29uc3QgbmV4dENoYXIgPSB0ZXh0W2kgKyAxXTtcbiAgICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIsIG5leHRDaGFyKSB8fCBfQ2FudmFzVGV4dE1ldHJpY3MuX2lzTmV3bGluZShjaGFyKSkge1xuICAgICAgICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgdG9rZW4gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKGNoYXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRva2VuICs9IGNoYXI7XG4gICAgfVxuICAgIGlmICh0b2tlbiAhPT0gXCJcIikge1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBoZWxwZXIgbWV0aG9kIHVzZWQgaW50ZXJuYWxseSBieSBUZXh0TWV0cmljcywgZXhwb3NlZCB0byBhbGxvdyBjdXN0b21pemluZyB0aGUgY2xhc3MncyBiZWhhdmlvci5cbiAgICpcbiAgICogSXQgYWxsb3dzIG9uZSB0byBjdXN0b21pc2Ugd2hpY2ggd29yZHMgc2hvdWxkIGJyZWFrXG4gICAqIEV4YW1wbGVzIGFyZSBpZiB0aGUgdG9rZW4gaXMgQ0pLIG9yIG51bWJlcnMuXG4gICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHBhcmFtIF90b2tlbiAtIFRoZSB0b2tlblxuICAgKiBAcGFyYW0gYnJlYWtXb3JkcyAtIFRoZSBzdHlsZSBhdHRyIGJyZWFrIHdvcmRzXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcbiAgICovXG4gIHN0YXRpYyBjYW5CcmVha1dvcmRzKF90b2tlbiwgYnJlYWtXb3Jkcykge1xuICAgIHJldHVybiBicmVha1dvcmRzO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBoZWxwZXIgbWV0aG9kIHVzZWQgaW50ZXJuYWxseSBieSBUZXh0TWV0cmljcywgZXhwb3NlZCB0byBhbGxvdyBjdXN0b21pemluZyB0aGUgY2xhc3MncyBiZWhhdmlvci5cbiAgICpcbiAgICogSXQgYWxsb3dzIG9uZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIHBhaXIgb2YgY2hhcmFjdGVyc1xuICAgKiBzaG91bGQgYmUgYnJva2VuIGJ5IG5ld2xpbmVzXG4gICAqIEZvciBleGFtcGxlIGNlcnRhaW4gY2hhcmFjdGVycyBpbiBDSksgbGFuZ3Mgb3IgbnVtYmVycy5cbiAgICogSXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgKiBAcGFyYW0gX2NoYXIgLSBUaGUgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBfbmV4dENoYXIgLSBUaGUgbmV4dCBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIF90b2tlbiAtIFRoZSB0b2tlbi93b3JkIHRoZSBjaGFyYWN0ZXJzIGFyZSBmcm9tXG4gICAqIEBwYXJhbSBfaW5kZXggLSBUaGUgaW5kZXggaW4gdGhlIHRva2VuIG9mIHRoZSBjaGFyXG4gICAqIEBwYXJhbSBfYnJlYWtXb3JkcyAtIFRoZSBzdHlsZSBhdHRyIGJyZWFrIHdvcmRzXG4gICAqIEByZXR1cm5zIHdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcbiAgICovXG4gIHN0YXRpYyBjYW5CcmVha0NoYXJzKF9jaGFyLCBfbmV4dENoYXIsIF90b2tlbiwgX2luZGV4LCBfYnJlYWtXb3Jkcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBoZWxwZXIgbWV0aG9kIHVzZWQgaW50ZXJuYWxseSBieSBUZXh0TWV0cmljcywgZXhwb3NlZCB0byBhbGxvdyBjdXN0b21pemluZyB0aGUgY2xhc3MncyBiZWhhdmlvci5cbiAgICpcbiAgICogSXQgaXMgY2FsbGVkIHdoZW4gYSB0b2tlbiAodXN1YWxseSBhIHdvcmQpIGhhcyB0byBiZSBzcGxpdCBpbnRvIHNlcGFyYXRlIHBpZWNlc1xuICAgKiBpbiBvcmRlciB0byBkZXRlcm1pbmUgdGhlIHBvaW50IHRvIGJyZWFrIGEgd29yZC5cbiAgICogSXQgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHRva2VuIC0gVGhlIHRva2VuIHRvIHNwbGl0XG4gICAqIEByZXR1cm5zIFRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB0b2tlblxuICAgKiBAc2VlIENhbnZhc1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyXG4gICAqL1xuICBzdGF0aWMgd29yZFdyYXBTcGxpdCh0b2tlbikge1xuICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIodG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udC1zdHlsZVxuICAgKiBAcGFyYW0gZm9udCAtIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN0eWxlIG9mIHRoZSBmb250XG4gICAqIEByZXR1cm5zIEZvbnQgcHJvcGVydGllcyBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBtZWFzdXJlRm9udChmb250KSB7XG4gICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5fZm9udHNbZm9udF0pIHtcbiAgICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gX0NhbnZhc1RleHRNZXRyaWNzLl9jb250ZXh0O1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29uc3QgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQoX0NhbnZhc1RleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HICsgX0NhbnZhc1RleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgIGFzY2VudDogbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgIGRlc2NlbnQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgZm9udFNpemU6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudFxuICAgIH07XG4gICAgX0NhbnZhc1RleHRNZXRyaWNzLl9mb250c1tmb250XSA9IHByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGZvbnQgbWV0cmljcyBpbiBtZXRyaWNzIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZvbnRdIC0gZm9udCBuYW1lLiBJZiBmb250IG5hbWUgbm90IHNldCB0aGVuIGNsZWFyIGNhY2hlIGZvciBhbGwgZm9udHMuXG4gICAqL1xuICBzdGF0aWMgY2xlYXJNZXRyaWNzKGZvbnQgPSBcIlwiKSB7XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIGRlbGV0ZSBfQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWNoZWQgY2FudmFzIGVsZW1lbnQgZm9yIG1lYXN1cmluZyB0ZXh0XG4gICAqIFRPRE86IHRoaXMgc2hvdWxkIGJlIHByaXZhdGUsIGJ1dCBpc24ndCBiZWNhdXNlIG9mIGJhY2t3YXJkIGNvbXBhdCwgd2lsbCBmaXggbGF0ZXIuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBnZXQgX2NhbnZhcygpIHtcbiAgICBpZiAoIV9DYW52YXNUZXh0TWV0cmljcy5fX2NhbnZhcykge1xuICAgICAgbGV0IGNhbnZhcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKTtcbiAgICAgICAgaWYgKGNvbnRleHQ/Lm1lYXN1cmVUZXh0KSB7XG4gICAgICAgICAgX0NhbnZhc1RleHRNZXRyaWNzLl9fY2FudmFzID0gYztcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxMDtcbiAgICAgIF9DYW52YXNUZXh0TWV0cmljcy5fX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fX2NhbnZhcztcbiAgfVxuICAvKipcbiAgICogVE9ETzogdGhpcyBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IGlzbid0IGJlY2F1c2Ugb2YgYmFja3dhcmQgY29tcGF0LCB3aWxsIGZpeCBsYXRlci5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGdldCBfY29udGV4dCgpIHtcbiAgICBpZiAoIV9DYW52YXNUZXh0TWV0cmljcy5fX2NvbnRleHQpIHtcbiAgICAgIF9DYW52YXNUZXh0TWV0cmljcy5fX2NvbnRleHQgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fX2NvbnRleHQ7XG4gIH1cbn07XG4vKipcbiAqIFN0cmluZyB1c2VkIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLlxuICogVGhlc2UgY2hhcmFjdGVycyBhcmUgYWxsIHRhbGwgdG8gaGVscCBjYWxjdWxhdGUgdGhlIGhlaWdodCByZXF1aXJlZCBmb3IgdGV4dC5cbiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HID0gXCJ8XFx4QzlxXFx4QzVcIjtcbi8qKiBCYXNlbGluZSBzeW1ib2wgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MID0gXCJNXCI7XG4vKiogQmFzZWxpbmUgbXVsdGlwbGllciBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5CQVNFTElORV9NVUxUSVBMSUVSID0gMS40O1xuLyoqIEhlaWdodCBtdWx0aXBsaWVyIGZvciBzZXR0aW5nIGhlaWdodCBvZiBjYW52YXMgdG8gY2FsY3VsYXRlIGZvbnQgbWV0cmljcy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5IRUlHSFRfTVVMVElQTElFUiA9IDI7XG4vKipcbiAqIEEgVW5pY29kZSBcImNoYXJhY3RlclwiLCBvciBcImdyYXBoZW1lIGNsdXN0ZXJcIiwgY2FuIGJlIGNvbXBvc2VkIG9mIG11bHRpcGxlIFVuaWNvZGUgY29kZSBwb2ludHMsXG4gKiBzdWNoIGFzIGxldHRlcnMgd2l0aCBkaWFjcml0aWNhbCBtYXJrcyAoZS5nLiBgJ1xcdTAwNjVcXHUwMzAxJ2AsIGxldHRlciBlIHdpdGggYWN1dGUpXG4gKiBvciBlbW9qaXMgd2l0aCBtb2RpZmllcnMgKGUuZy4gYCdcXHVEODNFXFx1REREMVxcdTIwMERcXHVEODNEXFx1RENCQidgLCB0ZWNobm9sb2dpc3QpLlxuICogVGhlIG5ldyBgSW50bC5TZWdtZW50ZXJgIEFQSSBpbiBFUzIwMjIgY2FuIHNwbGl0IHRoZSBzdHJpbmcgaW50byBncmFwaGVtZSBjbHVzdGVycyBjb3JyZWN0bHkuIElmIGl0IGlzIG5vdCBhdmFpbGFibGUsXG4gKiBQaXhpSlMgd2lsbCBmYWxsYmFjayB0byB1c2UgdGhlIGl0ZXJhdG9yIG9mIFN0cmluZywgd2hpY2ggY2FuIG9ubHkgc3BpbHQgdGhlIHN0cmluZyBpbnRvIGNvZGUgcG9pbnRzLlxuICogSWYgeW91IHdhbnQgdG8gZ2V0IGZ1bGwgZnVuY3Rpb25hbGl0eSBpbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IGBJbnRsLlNlZ21lbnRlcmAgKHN1Y2ggYXMgRmlyZWZveCksXG4gKiB5b3UgY2FuIHVzZSBvdGhlciBsaWJyYXJpZXMgc3VjaCBhcyBbZ3JhcGhlbWUtc3BsaXR0ZXJde0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2dyYXBoZW1lLXNwbGl0dGVyfVxuICogb3IgW2dyYXBoZW1lcl17QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ3JhcGhlbWVyfSB0byBjcmVhdGUgYSBwb2x5ZmlsbC4gU2luY2UgdGhlc2UgbGlicmFyaWVzIGNhbiBiZVxuICogcmVsYXRpdmVseSBsYXJnZSBpbiBzaXplIHRvIGhhbmRsZSB2YXJpb3VzIFVuaWNvZGUgZ3JhcGhlbWUgY2x1c3RlcnMgcHJvcGVybHksIFBpeGlKUyB3b24ndCB1c2UgdGhlbSBkaXJlY3RseS5cbiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBJbnRsPy5TZWdtZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcigpO1xuICAgIHJldHVybiAocykgPT4gWy4uLnNlZ21lbnRlci5zZWdtZW50KHMpXS5tYXAoKHgpID0+IHguc2VnbWVudCk7XG4gIH1cbiAgcmV0dXJuIChzKSA9PiBbLi4uc107XG59KSgpO1xuLyoqXG4gKiBOZXcgcmVuZGVyaW5nIGJlaGF2aW9yIGZvciBsZXR0ZXItc3BhY2luZyB3aGljaCB1c2VzIENocm9tZSdzIG5ldyBuYXRpdmUgQVBJLiBUaGlzIHdpbGxcbiAqIGxlYWQgdG8gbW9yZSBhY2N1cmF0ZSBsZXR0ZXItc3BhY2luZyByZXN1bHRzIGJlY2F1c2UgaXQgZG9lcyBub3QgdHJ5IHRvIG1hbnVhbGx5IGRyYXdcbiAqIGVhY2ggY2hhcmFjdGVyLiBIb3dldmVyLCB0aGlzIENocm9tZSBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgbm90IHNlcnZlIGFsbCBjYXNlcyB5ZXQuXG4gKiBAc2VlIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWRcbiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbi8qKiBDYWNoZSBvZiB7QHNlZSBUZXh0TWV0cmljcy5Gb250TWV0cmljc30gb2JqZWN0cy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcbi8qKiBDYWNoZSBvZiBuZXcgbGluZSBjaGFycy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5fbmV3bGluZXMgPSBbXG4gIDEwLFxuICAvLyBsaW5lIGZlZWRcbiAgMTNcbiAgLy8gY2FycmlhZ2UgcmV0dXJuXG5dO1xuLyoqIENhY2hlIG9mIGJyZWFraW5nIHNwYWNlcy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5fYnJlYWtpbmdTcGFjZXMgPSBbXG4gIDksXG4gIC8vIGNoYXJhY3RlciB0YWJ1bGF0aW9uXG4gIDMyLFxuICAvLyBzcGFjZVxuICA4MTkyLFxuICAvLyBlbiBxdWFkXG4gIDgxOTMsXG4gIC8vIGVtIHF1YWRcbiAgODE5NCxcbiAgLy8gZW4gc3BhY2VcbiAgODE5NSxcbiAgLy8gZW0gc3BhY2VcbiAgODE5NixcbiAgLy8gdGhyZWUtcGVyLWVtIHNwYWNlXG4gIDgxOTcsXG4gIC8vIGZvdXItcGVyLWVtIHNwYWNlXG4gIDgxOTgsXG4gIC8vIHNpeC1wZXItZW0gc3BhY2VcbiAgODIwMCxcbiAgLy8gcHVuY3R1YXRpb24gc3BhY2VcbiAgODIwMSxcbiAgLy8gdGhpbiBzcGFjZVxuICA4MjAyLFxuICAvLyBoYWlyIHNwYWNlXG4gIDgyODcsXG4gIC8vIG1lZGl1bSBtYXRoZW1hdGljYWwgc3BhY2VcbiAgMTIyODhcbiAgLy8gaWRlb2dyYXBoaWMgc3BhY2Vcbl07XG5fQ2FudmFzVGV4dE1ldHJpY3MuX21lYXN1cmVtZW50Q2FjaGUgPSB7fTtcbmxldCBDYW52YXNUZXh0TWV0cmljcyA9IF9DYW52YXNUZXh0TWV0cmljcztcblxuZXhwb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1RleHRNZXRyaWNzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3374\n')},13:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   M: () => (/* binding */ fontStringFromTextStyle)\n/* harmony export */ });\n\nconst genericFontFamilies = [\n  "serif",\n  "sans-serif",\n  "monospace",\n  "cursive",\n  "fantasy",\n  "system-ui"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(",");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\"\\\'])[^\\\'\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `"${fontFamily}"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;\n}\n\n\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLHVCQUF1QjtBQUNqSDs7QUFFbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9jYW52YXMvdXRpbHMvZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzPzYzOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBnZW5lcmljRm9udEZhbWlsaWVzID0gW1xuICBcInNlcmlmXCIsXG4gIFwic2Fucy1zZXJpZlwiLFxuICBcIm1vbm9zcGFjZVwiLFxuICBcImN1cnNpdmVcIixcbiAgXCJmYW50YXN5XCIsXG4gIFwic3lzdGVtLXVpXCJcbl07XG5mdW5jdGlvbiBmb250U3RyaW5nRnJvbVRleHRTdHlsZShzdHlsZSkge1xuICBjb25zdCBmb250U2l6ZVN0cmluZyA9IHR5cGVvZiBzdHlsZS5mb250U2l6ZSA9PT0gXCJudW1iZXJcIiA/IGAke3N0eWxlLmZvbnRTaXplfXB4YCA6IHN0eWxlLmZvbnRTaXplO1xuICBsZXQgZm9udEZhbWlsaWVzID0gc3R5bGUuZm9udEZhbWlseTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLmZvbnRGYW1pbHkpKSB7XG4gICAgZm9udEZhbWlsaWVzID0gc3R5bGUuZm9udEZhbWlseS5zcGxpdChcIixcIik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IGZvbnRGYW1pbGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBmb250RmFtaWx5ID0gZm9udEZhbWlsaWVzW2ldLnRyaW0oKTtcbiAgICBpZiAoIS8oW1xcXCJcXCddKVteXFwnXFxcIl0rXFwxLy50ZXN0KGZvbnRGYW1pbHkpICYmICFnZW5lcmljRm9udEZhbWlsaWVzLmluY2x1ZGVzKGZvbnRGYW1pbHkpKSB7XG4gICAgICBmb250RmFtaWx5ID0gYFwiJHtmb250RmFtaWx5fVwiYDtcbiAgICB9XG4gICAgZm9udEZhbWlsaWVzW2ldID0gZm9udEZhbWlseTtcbiAgfVxuICByZXR1cm4gYCR7c3R5bGUuZm9udFN0eWxlfSAke3N0eWxlLmZvbnRWYXJpYW50fSAke3N0eWxlLmZvbnRXZWlnaHR9ICR7Zm9udFNpemVTdHJpbmd9ICR7Zm9udEZhbWlsaWVzLmpvaW4oXCIsXCIpfWA7XG59XG5cbmV4cG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n')},778:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   m: () => (/* binding */ getCanvasFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8409);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9853);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4796);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(557);\n/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1261);\n\n\n\n\n\n\n\n"use strict";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Texture */ .x.WHITE && !fillStyle.fill) {\n    return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(fillStyle.color).toHex();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");\n    const tempMatrix = fillStyle.matrix.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .y.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillPattern */ .h) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");\n    const tempMatrix = fillPattern.transform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .y.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__/* .FillGradient */ .f) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === "linear") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__/* .warn */ .Z)("FillStyle not recognised", fillStyle);\n  return "red";\n}\n\n\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRDtBQUNTO0FBQ3dCO0FBQzNCO0FBQ29CO0FBQ0Y7O0FBRTVFO0FBQ0E7QUFDQSw0QkFBNEIsNkZBQU87QUFDbkMsV0FBVyw0REFBSztBQUNoQixJQUFJO0FBQ0o7QUFDQSwrQ0FBK0MscUVBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUMsdUZBQVc7QUFDbEQ7QUFDQTtBQUNBLG9EQUFvRCxxRUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQyx5RkFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNERBQUs7QUFDaEQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0VBQUk7QUFDTjtBQUNBOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9nZXRDYW52YXNGaWxsU3R5bGUubWpzPzc2MWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgRmlsbEdyYWRpZW50IH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcyc7XG5pbXBvcnQgeyBGaWxsUGF0dGVybiB9IGZyb20gJy4uLy4uLy4uL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxQYXR0ZXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0Q2FudmFzRmlsbFN0eWxlKGZpbGxTdHlsZSwgY29udGV4dCkge1xuICBpZiAoZmlsbFN0eWxlLnRleHR1cmUgPT09IFRleHR1cmUuV0hJVEUgJiYgIWZpbGxTdHlsZS5maWxsKSB7XG4gICAgcmV0dXJuIENvbG9yLnNoYXJlZC5zZXRWYWx1ZShmaWxsU3R5bGUuY29sb3IpLnRvSGV4KCk7XG4gIH0gZWxzZSBpZiAoIWZpbGxTdHlsZS5maWxsKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihmaWxsU3R5bGUudGV4dHVyZS5zb3VyY2UucmVzb3VyY2UsIFwicmVwZWF0XCIpO1xuICAgIGNvbnN0IHRlbXBNYXRyaXggPSBmaWxsU3R5bGUubWF0cml4LmNvcHlUbyhNYXRyaXguc2hhcmVkKTtcbiAgICB0ZW1wTWF0cml4LnNjYWxlKGZpbGxTdHlsZS50ZXh0dXJlLmZyYW1lLndpZHRoLCBmaWxsU3R5bGUudGV4dHVyZS5mcmFtZS5oZWlnaHQpO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKHRlbXBNYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9IGVsc2UgaWYgKGZpbGxTdHlsZS5maWxsIGluc3RhbmNlb2YgRmlsbFBhdHRlcm4pIHtcbiAgICBjb25zdCBmaWxsUGF0dGVybiA9IGZpbGxTdHlsZS5maWxsO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oZmlsbFBhdHRlcm4udGV4dHVyZS5zb3VyY2UucmVzb3VyY2UsIFwicmVwZWF0XCIpO1xuICAgIGNvbnN0IHRlbXBNYXRyaXggPSBmaWxsUGF0dGVybi50cmFuc2Zvcm0uY29weVRvKE1hdHJpeC5zaGFyZWQpO1xuICAgIHRlbXBNYXRyaXguc2NhbGUoXG4gICAgICBmaWxsUGF0dGVybi50ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgZmlsbFBhdHRlcm4udGV4dHVyZS5mcmFtZS5oZWlnaHRcbiAgICApO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKHRlbXBNYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9IGVsc2UgaWYgKGZpbGxTdHlsZS5maWxsIGluc3RhbmNlb2YgRmlsbEdyYWRpZW50KSB7XG4gICAgY29uc3QgZmlsbEdyYWRpZW50ID0gZmlsbFN0eWxlLmZpbGw7XG4gICAgaWYgKGZpbGxHcmFkaWVudC50eXBlID09PSBcImxpbmVhclwiKSB7XG4gICAgICBjb25zdCBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgIGZpbGxHcmFkaWVudC54MCxcbiAgICAgICAgZmlsbEdyYWRpZW50LnkwLFxuICAgICAgICBmaWxsR3JhZGllbnQueDEsXG4gICAgICAgIGZpbGxHcmFkaWVudC55MVxuICAgICAgKTtcbiAgICAgIGZpbGxHcmFkaWVudC5ncmFkaWVudFN0b3BzLmZvckVhY2goKHN0b3ApID0+IHtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3Aub2Zmc2V0LCBDb2xvci5zaGFyZWQuc2V0VmFsdWUoc3RvcC5jb2xvcikudG9IZXgoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gIH1cbiAgd2FybihcIkZpbGxTdHlsZSBub3QgcmVjb2duaXNlZFwiLCBmaWxsU3R5bGUpO1xuICByZXR1cm4gXCJyZWRcIjtcbn1cblxuZXhwb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDYW52YXNGaWxsU3R5bGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///778\n')},2:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(3747);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(900);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs\n\n\n\n\n\n"use strict";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text._getKey();\n    if (gpuText.currentKey !== newKey) {\n      const resolution = text.resolution ?? this._renderer.resolution;\n      const { width, height } = this._renderer.canvasText.getTextureSize(\n        text.text,\n        resolution,\n        text._style\n      );\n      if (\n        // is only being used by this text:\n        this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  addRenderable(text, _instructionSet) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(text) {\n    this._destroyRenderableById(text.uid);\n  }\n  _destroyRenderableById(textUid) {\n    const gpuText = this._gpuText[textUid];\n    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[textUid] = null;\n  }\n  _updateText(text) {\n    const newKey = text._getKey();\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(text);\n    }\n    text._didTextUpdate = false;\n    const padding = text._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n  }\n  _updateGpuText(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    }\n    const resolution = text.resolution ?? this._renderer.resolution;\n    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n      text.text,\n      resolution,\n      text._style,\n      text._getKey()\n    );\n    gpuText.currentKey = text._getKey();\n    batchableSprite.texture = gpuText.texture;\n  }\n  _getGpuText(text) {\n    return this._gpuText[text.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const gpuTextData = {\n      texture: null,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.c)\n    };\n    gpuTextData.batchableSprite.renderable = text;\n    gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    this._gpuText[text.uid] = gpuTextData;\n    this._updateText(text);\n    text.on("destroyed", () => {\n      this.destroyRenderable(text);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "text"\n};\n\n\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(4181);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs\n\n\n"use strict";\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas, resolution = 1) {\n  const { width, height } = canvas;\n  const context = canvas.getContext("2d", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError("Failed to get canvas 2D context");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle/* Rectangle */.A.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new Rectangle/* Rectangle */.A(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\n\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(1647);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(13);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(778);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass CanvasTextSystem {\n  constructor() {\n    this._activeTextures = {};\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = (0,pow2/* nextPow2 */.a9)(width);\n    height = (0,pow2/* nextPow2 */.a9)(height);\n    return { width, height };\n  }\n  getTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(width, height);\n    const { canvas } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.H)(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool/* CanvasPool */.h.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool/* TexturePool */.z.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = "unknown";\n      source.alphaMode = "no-premultiply-alpha";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to \'pre-generate\' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = "black";\n        context.strokeStyle = "black";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color/* Color */.I.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.globalAlpha = style._fill?.alpha ?? 1;\n        context.fillStyle = style._fill ? (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context) : null;\n        if (style._stroke?.width) {\n          context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._stroke, context);\n        }\n        context.shadowColor = "black";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === "right") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === "center") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it\'s for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics/* CanvasTextMetrics */.c.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics/* CanvasTextMetrics */.c.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics/* CanvasTextMetrics */.c.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = "";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "canvasText"\n};\n\n\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(CanvasTextSystem);\nExtensions/* extensions */.Rw.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVqRTtBQUNBLDZCQUFVLEtBQUssZ0JBQWdCO0FBQy9CLDZCQUFVLEtBQUssY0FBYztBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy9DYW52YXNUZXh0UGlwZS5tanM/MTNlZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvY2FudmFzL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcz80NTliIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy9DYW52YXNUZXh0U3lzdGVtLm1qcz82MmJjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2luaXQubWpzPzc3YjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgdXBkYXRlUXVhZEJvdW5kcyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RhdGEvdXBkYXRlUXVhZEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVTcHJpdGUgfSBmcm9tICcuLi8uLi9zcHJpdGUvQmF0Y2hhYmxlU3ByaXRlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ2FudmFzVGV4dFBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2dwdVRleHQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZSh0ZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgbmV3S2V5ID0gdGV4dC5fZ2V0S2V5KCk7XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdGV4dC5yZXNvbHV0aW9uID8/IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZ2V0VGV4dHVyZVNpemUoXG4gICAgICAgIHRleHQudGV4dCxcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgdGV4dC5fc3R5bGVcbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIGlzIG9ubHkgYmVpbmcgdXNlZCBieSB0aGlzIHRleHQ6XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZ2V0UmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KSA9PT0gMSAmJiB3aWR0aCA9PT0gZ3B1VGV4dC50ZXh0dXJlLl9zb3VyY2Uud2lkdGggJiYgaGVpZ2h0ID09PSBncHVUZXh0LnRleHR1cmUuX3NvdXJjZS5oZWlnaHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUodGV4dCwgX2luc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKHRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHQodGV4dCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmFkZFRvQmF0Y2goYmF0Y2hhYmxlU3ByaXRlKTtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKHRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAodGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dCh0ZXh0KTtcbiAgICB9XG4gICAgYmF0Y2hhYmxlU3ByaXRlLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKHRleHQpIHtcbiAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQodGV4dC51aWQpO1xuICB9XG4gIF9kZXN0cm95UmVuZGVyYWJsZUJ5SWQodGV4dFVpZCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9ncHVUZXh0W3RleHRVaWRdO1xuICAgIHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZGVjcmVhc2VSZWZlcmVuY2VDb3VudChncHVUZXh0LmN1cnJlbnRLZXkpO1xuICAgIEJpZ1Bvb2wucmV0dXJuKGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlKTtcbiAgICB0aGlzLl9ncHVUZXh0W3RleHRVaWRdID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlVGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgbmV3S2V5ID0gdGV4dC5fZ2V0S2V5KCk7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICB0aGlzLl91cGRhdGVHcHVUZXh0KHRleHQpO1xuICAgIH1cbiAgICB0ZXh0Ll9kaWRUZXh0VXBkYXRlID0gZmFsc2U7XG4gICAgY29uc3QgcGFkZGluZyA9IHRleHQuX3N0eWxlLnBhZGRpbmc7XG4gICAgdXBkYXRlUXVhZEJvdW5kcyhiYXRjaGFibGVTcHJpdGUuYm91bmRzLCB0ZXh0Ll9hbmNob3IsIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlLCBwYWRkaW5nKTtcbiAgfVxuICBfdXBkYXRlR3B1VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGdwdVRleHQudGV4dHVyZSkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5kZWNyZWFzZVJlZmVyZW5jZUNvdW50KGdwdVRleHQuY3VycmVudEtleSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0ZXh0LnJlc29sdXRpb24gPz8gdGhpcy5fcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICBncHVUZXh0LnRleHR1cmUgPSBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZ2V0VGV4dHVyZShcbiAgICAgIHRleHQudGV4dCxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICB0ZXh0Ll9zdHlsZSxcbiAgICAgIHRleHQuX2dldEtleSgpXG4gICAgKTtcbiAgICBncHVUZXh0LmN1cnJlbnRLZXkgPSB0ZXh0Ll9nZXRLZXkoKTtcbiAgICBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IGdwdVRleHQudGV4dHVyZTtcbiAgfVxuICBfZ2V0R3B1VGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVRleHRbdGV4dC51aWRdIHx8IHRoaXMuaW5pdEdwdVRleHQodGV4dCk7XG4gIH1cbiAgaW5pdEdwdVRleHQodGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHREYXRhID0ge1xuICAgICAgdGV4dHVyZTogbnVsbCxcbiAgICAgIGN1cnJlbnRLZXk6IFwiLS1cIixcbiAgICAgIGJhdGNoYWJsZVNwcml0ZTogQmlnUG9vbC5nZXQoQmF0Y2hhYmxlU3ByaXRlKVxuICAgIH07XG4gICAgZ3B1VGV4dERhdGEuYmF0Y2hhYmxlU3ByaXRlLnJlbmRlcmFibGUgPSB0ZXh0O1xuICAgIGdwdVRleHREYXRhLmJhdGNoYWJsZVNwcml0ZS5ib3VuZHMgPSB7IG1pblg6IDAsIG1heFg6IDEsIG1pblk6IDAsIG1heFk6IDAgfTtcbiAgICBncHVUZXh0RGF0YS5iYXRjaGFibGVTcHJpdGUucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCB0ZXh0Ll9yb3VuZFBpeGVscztcbiAgICB0aGlzLl9ncHVUZXh0W3RleHQudWlkXSA9IGdwdVRleHREYXRhO1xuICAgIHRoaXMuX3VwZGF0ZVRleHQodGV4dCk7XG4gICAgdGV4dC5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKHRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBncHVUZXh0RGF0YTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVUZXh0KSB7XG4gICAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQoaSk7XG4gICAgfVxuICAgIHRoaXMuX2dwdVRleHQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkNhbnZhc1RleHRQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJ0ZXh0XCJcbn07XG5cbmV4cG9ydCB7IENhbnZhc1RleHRQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNUZXh0UGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY2hlY2tSb3coZGF0YSwgd2lkdGgsIHkpIHtcbiAgZm9yIChsZXQgeCA9IDAsIGluZGV4ID0gNCAqIHkgKiB3aWR0aDsgeCA8IHdpZHRoOyArK3gsIGluZGV4ICs9IDQpIHtcbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIHgsIHRvcCwgYm90dG9tKSB7XG4gIGNvbnN0IHN0cmlkZSA9IDQgKiB3aWR0aDtcbiAgZm9yIChsZXQgeSA9IHRvcCwgaW5kZXggPSB0b3AgKiBzdHJpZGUgKyA0ICogeDsgeSA8PSBib3R0b207ICsreSwgaW5kZXggKz0gc3RyaWRlKSB7XG4gICAgaWYgKGRhdGFbaW5kZXggKyAzXSAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldENhbnZhc0JvdW5kaW5nQm94KGNhbnZhcywgcmVzb2x1dGlvbiA9IDEpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXM7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgfSk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBnZXQgY2FudmFzIDJEIGNvbnRleHRcIik7XG4gIH1cbiAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgdG9wID0gMDtcbiAgbGV0IHJpZ2h0ID0gd2lkdGggLSAxO1xuICBsZXQgYm90dG9tID0gaGVpZ2h0IC0gMTtcbiAgd2hpbGUgKHRvcCA8IGhlaWdodCAmJiBjaGVja1JvdyhkYXRhLCB3aWR0aCwgdG9wKSlcbiAgICArK3RvcDtcbiAgaWYgKHRvcCA9PT0gaGVpZ2h0KVxuICAgIHJldHVybiBSZWN0YW5nbGUuRU1QVFk7XG4gIHdoaWxlIChjaGVja1JvdyhkYXRhLCB3aWR0aCwgYm90dG9tKSlcbiAgICAtLWJvdHRvbTtcbiAgd2hpbGUgKGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCBsZWZ0LCB0b3AsIGJvdHRvbSkpXG4gICAgKytsZWZ0O1xuICB3aGlsZSAoY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIHJpZ2h0LCB0b3AsIGJvdHRvbSkpXG4gICAgLS1yaWdodDtcbiAgKytyaWdodDtcbiAgKytib3R0b207XG4gIHJldHVybiBuZXcgUmVjdGFuZ2xlKGxlZnQgLyByZXNvbHV0aW9uLCB0b3AgLyByZXNvbHV0aW9uLCAocmlnaHQgLSBsZWZ0KSAvIHJlc29sdXRpb24sIChib3R0b20gLSB0b3ApIC8gcmVzb2x1dGlvbik7XG59XG5cbmV4cG9ydCB7IGdldENhbnZhc0JvdW5kaW5nQm94IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDYW52YXNCb3VuZGluZ0JveC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBuZXh0UG93MiB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21pc2MvcG93Mi5tanMnO1xuaW1wb3J0IHsgQ2FudmFzUG9vbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NhbnZhcy9nZXRDYW52YXNCb3VuZGluZ0JveC5tanMnO1xuaW1wb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfSBmcm9tICcuLi91dGlscy9nZXRQbzJUZXh0dXJlRnJvbVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5pbXBvcnQgeyBmb250U3RyaW5nRnJvbVRleHRTdHlsZSB9IGZyb20gJy4vdXRpbHMvZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzJztcbmltcG9ydCB7IGdldENhbnZhc0ZpbGxTdHlsZSB9IGZyb20gJy4vdXRpbHMvZ2V0Q2FudmFzRmlsbFN0eWxlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ2FudmFzVGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzID0ge307XG4gIH1cbiAgZ2V0VGV4dHVyZVNpemUodGV4dCwgcmVzb2x1dGlvbiwgc3R5bGUpIHtcbiAgICBjb25zdCBtZWFzdXJlZCA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRleHQgfHwgXCIgXCIsIHN0eWxlKTtcbiAgICBsZXQgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLndpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLmhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAtIDFlLTYpO1xuICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgLSAxZS02KTtcbiAgICB3aWR0aCA9IG5leHRQb3cyKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBuZXh0UG93MihoZWlnaHQpO1xuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgfVxuICBnZXRUZXh0dXJlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlLCB0ZXh0S2V5KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldKSB7XG4gICAgICB0aGlzLl9pbmNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnRleHR1cmU7XG4gICAgfVxuICAgIGNvbnN0IG1lYXN1cmVkID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGV4dCB8fCBcIiBcIiwgc3R5bGUpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKE1hdGguY2VpbChNYXRoLm1heCgxLCBtZWFzdXJlZC53aWR0aCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLmhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB7IGNhbnZhcyB9ID0gY2FudmFzQW5kQ29udGV4dDtcbiAgICB0aGlzLnJlbmRlclRleHRUb0NhbnZhcyh0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbiwgY2FudmFzQW5kQ29udGV4dCk7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdldFBvMlRleHR1cmVGcm9tU291cmNlKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgaWYgKHN0eWxlLnRyaW0pIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMsIHJlc29sdXRpb24pO1xuICAgICAgdGV4dHVyZS5mcmFtZS5jb3B5RnJvbSh0cmltbWVkKTtcbiAgICAgIHRleHR1cmUudXBkYXRlVXZzKCk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0ge1xuICAgICAgY2FudmFzQW5kQ29udGV4dCxcbiAgICAgIHRleHR1cmUsXG4gICAgICB1c2FnZUNvdW50OiAxXG4gICAgfTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICBfaW5jcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udXNhZ2VDb3VudCsrO1xuICB9XG4gIGRlY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIGNvbnN0IGFjdGl2ZVRleHR1cmUgPSB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XTtcbiAgICBhY3RpdmVUZXh0dXJlLnVzYWdlQ291bnQtLTtcbiAgICBpZiAoYWN0aXZlVGV4dHVyZS51c2FnZUNvdW50ID09PSAwKSB7XG4gICAgICBDYW52YXNQb29sLnJldHVybkNhbnZhc0FuZENvbnRleHQoYWN0aXZlVGV4dHVyZS5jYW52YXNBbmRDb250ZXh0KTtcbiAgICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYWN0aXZlVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGFjdGl2ZVRleHR1cmUudGV4dHVyZS5zb3VyY2U7XG4gICAgICBzb3VyY2UucmVzb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlLnVwbG9hZE1ldGhvZElkID0gXCJ1bmtub3duXCI7XG4gICAgICBzb3VyY2UuYWxwaGFNb2RlID0gXCJuby1wcmVtdWx0aXBseS1hbHBoYVwiO1xuICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXRSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnVzYWdlQ291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGV4dCB0byBpdHMgY2FudmFzLCBhbmQgdXBkYXRlcyBpdHMgdGV4dHVyZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIGlzIHVzZWQgaW50ZXJuYWxseSB0byBlbnN1cmUgdGhlIHRleHR1cmUgaXMgY29ycmVjdCBiZWZvcmUgcmVuZGVyaW5nLFxuICAgKiBidXQgaXQgY2FuIGJlIHVzZWQgY2FsbGVkIGV4dGVybmFsbHksIGZvciBleGFtcGxlIGZyb20gdGhpcyBjbGFzcyB0byAncHJlLWdlbmVyYXRlJyB0aGUgdGV4dHVyZSBmcm9tIGEgcGllY2Ugb2YgdGV4dCxcbiAgICogYW5kIHRoZW4gc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSBTcHJpdGVzLlxuICAgKiBAcGFyYW0gdGV4dFxuICAgKiBAcGFyYW0gc3R5bGVcbiAgICogQHBhcmFtIHJlc29sdXRpb25cbiAgICogQHBhcmFtIGNhbnZhc0FuZENvbnRleHRcbiAgICovXG4gIHJlbmRlclRleHRUb0NhbnZhcyh0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbiwgY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGNvbnN0IHsgY2FudmFzLCBjb250ZXh0IH0gPSBjYW52YXNBbmRDb250ZXh0O1xuICAgIGNvbnN0IGZvbnQgPSBmb250U3RyaW5nRnJvbVRleHRTdHlsZShzdHlsZSk7XG4gICAgY29uc3QgbWVhc3VyZWQgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlVGV4dCh0ZXh0IHx8IFwiIFwiLCBzdHlsZSk7XG4gICAgY29uc3QgbGluZXMgPSBtZWFzdXJlZC5saW5lcztcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gbWVhc3VyZWQubGluZUhlaWdodDtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gbWVhc3VyZWQubGluZVdpZHRocztcbiAgICBjb25zdCBtYXhMaW5lV2lkdGggPSBtZWFzdXJlZC5tYXhMaW5lV2lkdGg7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZWFzdXJlZC5mb250UHJvcGVydGllcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnRleHQucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICBjb250ZXh0LnNjYWxlKHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIG1lYXN1cmVkLndpZHRoICsgNCwgbWVhc3VyZWQuaGVpZ2h0ICsgNCk7XG4gICAgaWYgKHN0eWxlLl9zdHJva2U/LndpZHRoKSB7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZSA9IHN0eWxlLl9zdHJva2U7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZVN0eWxlLndpZHRoO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gc3Ryb2tlU3R5bGUubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSBzdHJva2VTdHlsZS5qb2luO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gc3Ryb2tlU3R5bGUuY2FwO1xuICAgIH1cbiAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgIGxldCBsaW5lUG9zaXRpb25YO1xuICAgIGxldCBsaW5lUG9zaXRpb25ZO1xuICAgIGNvbnN0IHBhc3Nlc0NvdW50ID0gc3R5bGUuZHJvcFNoYWRvdyA/IDIgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFzc2VzQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgaXNTaGFkb3dQYXNzID0gc3R5bGUuZHJvcFNoYWRvdyAmJiBpID09PSAwO1xuICAgICAgY29uc3QgZHNPZmZzZXRUZXh0ID0gaXNTaGFkb3dQYXNzID8gTWF0aC5jZWlsKE1hdGgubWF4KDEsIGhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgOiAwO1xuICAgICAgY29uc3QgZHNPZmZzZXRTaGFkb3cgPSBkc09mZnNldFRleHQgKiByZXNvbHV0aW9uO1xuICAgICAgaWYgKGlzU2hhZG93UGFzcykge1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgY29uc3Qgc2hhZG93T3B0aW9ucyA9IHN0eWxlLmRyb3BTaGFkb3c7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dDb2xvciA9IHNoYWRvd09wdGlvbnMuY29sb3I7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dBbHBoYSA9IHNoYWRvd09wdGlvbnMuYWxwaGE7XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShkcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpO1xuICAgICAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHNoYWRvd09wdGlvbnMuYmx1ciAqIHJlc29sdXRpb247XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dEaXN0YW5jZSA9IHNoYWRvd09wdGlvbnMuZGlzdGFuY2UgKiByZXNvbHV0aW9uO1xuICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gTWF0aC5jb3Moc2hhZG93T3B0aW9ucy5hbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IE1hdGguc2luKHNoYWRvd09wdGlvbnMuYW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlICsgZHNPZmZzZXRTaGFkb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gc3R5bGUuX2ZpbGw/LmFscGhhID8/IDE7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGUuX2ZpbGwgPyBnZXRDYW52YXNGaWxsU3R5bGUoc3R5bGUuX2ZpbGwsIGNvbnRleHQpIDogbnVsbDtcbiAgICAgICAgaWYgKHN0eWxlLl9zdHJva2U/LndpZHRoKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGdldENhbnZhc0ZpbGxTdHlsZShzdHlsZS5fc3Ryb2tlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xuICAgICAgfVxuICAgICAgbGV0IGxpbmVQb3NpdGlvbllTaGlmdCA9IChsaW5lSGVpZ2h0IC0gZm9udFByb3BlcnRpZXMuZm9udFNpemUpIC8gMjtcbiAgICAgIGlmIChsaW5lSGVpZ2h0IC0gZm9udFByb3BlcnRpZXMuZm9udFNpemUgPCAwKSB7XG4gICAgICAgIGxpbmVQb3NpdGlvbllTaGlmdCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IHN0eWxlLl9zdHJva2U/LndpZHRoID8/IDA7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbGluZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgICAgIGxpbmVQb3NpdGlvblkgPSBzdHJva2VXaWR0aCAvIDIgKyBpMiAqIGxpbmVIZWlnaHQgKyBmb250UHJvcGVydGllcy5hc2NlbnQgKyBsaW5lUG9zaXRpb25ZU2hpZnQ7XG4gICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2kyXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaTJdKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLl9zdHJva2UpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3TGV0dGVyU3BhY2luZyhcbiAgICAgICAgICAgIGxpbmVzW2kyXSxcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgY2FudmFzQW5kQ29udGV4dCxcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSArIHN0eWxlLnBhZGRpbmcgLSBkc09mZnNldFRleHQsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuX2ZpbGwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMuX2RyYXdMZXR0ZXJTcGFjaW5nKFxuICAgICAgICAgICAgbGluZXNbaTJdLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBjYW52YXNBbmRDb250ZXh0LFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyAtIGRzT2Zmc2V0VGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgdGV4dCB3aXRoIGxldHRlci1zcGFjaW5nLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIGRyYXdcbiAgICogQHBhcmFtIHN0eWxlXG4gICAqIEBwYXJhbSBjYW52YXNBbmRDb250ZXh0XG4gICAqIEBwYXJhbSB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAqIEBwYXJhbSB5IC0gVmVydGljYWwgcG9zaXRpb24gdG8gZHJhdyB0aGUgdGV4dFxuICAgKiBAcGFyYW0gaXNTdHJva2UgLSBJcyB0aGlzIGRyYXdpbmcgZm9yIHRoZSBvdXRzaWRlIHN0cm9rZSBvZiB0aGVcbiAgICogIHRleHQ/IElmIG5vdCwgaXQncyBmb3IgdGhlIGluc2lkZSBmaWxsXG4gICAqL1xuICBfZHJhd0xldHRlclNwYWNpbmcodGV4dCwgc3R5bGUsIGNhbnZhc0FuZENvbnRleHQsIHgsIHksIGlzU3Ryb2tlID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGNvbnRleHQgfSA9IGNhbnZhc0FuZENvbnRleHQ7XG4gICAgY29uc3QgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmc7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbiAgICBpZiAoQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCkge1xuICAgICAgaWYgKENhbnZhc1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcpIHtcbiAgICAgICAgY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgICBjb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDAgfHwgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB4O1xuICAgIGNvbnN0IHN0cmluZ0FycmF5ID0gQ2FudmFzVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIodGV4dCk7XG4gICAgbGV0IHByZXZpb3VzV2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDaGFyID0gc3RyaW5nQXJyYXlbaV07XG4gICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGN1cnJlbnRDaGFyLCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChjdXJyZW50Q2hhciwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0U3RyID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHN0cmluZ0FycmF5Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHRleHRTdHIgKz0gc3RyaW5nQXJyYXlbal07XG4gICAgICB9XG4gICAgICBjdXJyZW50V2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHRTdHIpLndpZHRoO1xuICAgICAgY3VycmVudFBvc2l0aW9uICs9IHByZXZpb3VzV2lkdGggLSBjdXJyZW50V2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgcHJldmlvdXNXaWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlcyA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5DYW52YXNUZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJjYW52YXNUZXh0XCJcbn07XG5cbmV4cG9ydCB7IENhbnZhc1RleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1RleHRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dFBpcGUgfSBmcm9tICcuL2NhbnZhcy9DYW52YXNUZXh0UGlwZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dFN5c3RlbSB9IGZyb20gJy4vY2FudmFzL0NhbnZhc1RleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChDYW52YXNUZXh0U3lzdGVtKTtcbmV4dGVuc2lvbnMuYWRkKENhbnZhc1RleHRQaXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},740:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ generateTextStyleKey)\n/* harmony export */ });\n\nconst valuesToIterateForKeys = [\n  "_fontFamily",\n  "_fontStyle",\n  "_fontSize",\n  "_fontVariant",\n  "_fontWeight",\n  "_breakWords",\n  "_align",\n  "_leading",\n  "_letterSpacing",\n  "_lineHeight",\n  "_textBaseline",\n  "_whiteSpace",\n  "_wordWrap",\n  "_wordWrapWidth",\n  "_padding",\n  "_cssOverrides",\n  "_trim"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = valuesToIterateForKeys[i];\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  return key.join("-");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.uid;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\n\n\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwLmpzIiwibWFwcGluZ3MiOiI7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvdXRpbHMvZ2VuZXJhdGVUZXh0U3R5bGVLZXkubWpzP2M2N2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB2YWx1ZXNUb0l0ZXJhdGVGb3JLZXlzID0gW1xuICBcIl9mb250RmFtaWx5XCIsXG4gIFwiX2ZvbnRTdHlsZVwiLFxuICBcIl9mb250U2l6ZVwiLFxuICBcIl9mb250VmFyaWFudFwiLFxuICBcIl9mb250V2VpZ2h0XCIsXG4gIFwiX2JyZWFrV29yZHNcIixcbiAgXCJfYWxpZ25cIixcbiAgXCJfbGVhZGluZ1wiLFxuICBcIl9sZXR0ZXJTcGFjaW5nXCIsXG4gIFwiX2xpbmVIZWlnaHRcIixcbiAgXCJfdGV4dEJhc2VsaW5lXCIsXG4gIFwiX3doaXRlU3BhY2VcIixcbiAgXCJfd29yZFdyYXBcIixcbiAgXCJfd29yZFdyYXBXaWR0aFwiLFxuICBcIl9wYWRkaW5nXCIsXG4gIFwiX2Nzc092ZXJyaWRlc1wiLFxuICBcIl90cmltXCJcbl07XG5mdW5jdGlvbiBnZW5lcmF0ZVRleHRTdHlsZUtleShzdHlsZSkge1xuICBjb25zdCBrZXkgPSBbXTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXNUb0l0ZXJhdGVGb3JLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcCA9IHZhbHVlc1RvSXRlcmF0ZUZvcktleXNbaV07XG4gICAga2V5W2luZGV4KytdID0gc3R5bGVbcHJvcF07XG4gIH1cbiAgaW5kZXggPSBhZGRGaWxsU3R5bGVLZXkoc3R5bGUuX2ZpbGwsIGtleSwgaW5kZXgpO1xuICBpbmRleCA9IGFkZFN0b2tlU3R5bGVLZXkoc3R5bGUuX3N0cm9rZSwga2V5LCBpbmRleCk7XG4gIHJldHVybiBrZXkuam9pbihcIi1cIik7XG59XG5mdW5jdGlvbiBhZGRGaWxsU3R5bGVLZXkoZmlsbFN0eWxlLCBrZXksIGluZGV4KSB7XG4gIGlmICghZmlsbFN0eWxlKVxuICAgIHJldHVybiBpbmRleDtcbiAga2V5W2luZGV4KytdID0gZmlsbFN0eWxlLmNvbG9yO1xuICBrZXlbaW5kZXgrK10gPSBmaWxsU3R5bGUuYWxwaGE7XG4gIGtleVtpbmRleCsrXSA9IGZpbGxTdHlsZS5maWxsPy51aWQ7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGFkZFN0b2tlU3R5bGVLZXkoc3Ryb2tlU3R5bGUsIGtleSwgaW5kZXgpIHtcbiAgaWYgKCFzdHJva2VTdHlsZSlcbiAgICByZXR1cm4gaW5kZXg7XG4gIGluZGV4ID0gYWRkRmlsbFN0eWxlS2V5KHN0cm9rZVN0eWxlLCBrZXksIGluZGV4KTtcbiAga2V5W2luZGV4KytdID0gc3Ryb2tlU3R5bGUud2lkdGg7XG4gIGtleVtpbmRleCsrXSA9IHN0cm9rZVN0eWxlLmFsaWdubWVudDtcbiAga2V5W2luZGV4KytdID0gc3Ryb2tlU3R5bGUuY2FwO1xuICBrZXlbaW5kZXgrK10gPSBzdHJva2VTdHlsZS5qb2luO1xuICBrZXlbaW5kZXgrK10gPSBzdHJva2VTdHlsZS5taXRlckxpbWl0O1xuICByZXR1cm4gaW5kZXg7XG59XG5cbmV4cG9ydCB7IGdlbmVyYXRlVGV4dFN0eWxlS2V5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZVRleHRTdHlsZUtleS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///740\n')},1647:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H: () => (/* binding */ getPo2TextureFromSource)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6669);\n/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(535);\n\n\n\n"use strict";\nconst tempBounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Bounds */ .Y();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TexturePool */ .z.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = "image";\n  texture.source.resource = image;\n  texture.source.alphaMode = "premultiply-alpha-on-upload";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit("update", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\n\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRjtBQUMvQjs7QUFFM0Q7QUFDQSx1QkFBdUIseUVBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFHQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvdXRpbHMvZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzP2FiNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZShpbWFnZSwgd2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbikge1xuICBjb25zdCBib3VuZHMgPSB0ZW1wQm91bmRzO1xuICBib3VuZHMubWluWCA9IDA7XG4gIGJvdW5kcy5taW5ZID0gMDtcbiAgYm91bmRzLm1heFggPSBpbWFnZS53aWR0aCAvIHJlc29sdXRpb24gfCAwO1xuICBib3VuZHMubWF4WSA9IGltYWdlLmhlaWdodCAvIHJlc29sdXRpb24gfCAwO1xuICBjb25zdCB0ZXh0dXJlID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgYm91bmRzLndpZHRoLFxuICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgcmVzb2x1dGlvbixcbiAgICBmYWxzZVxuICApO1xuICB0ZXh0dXJlLnNvdXJjZS51cGxvYWRNZXRob2RJZCA9IFwiaW1hZ2VcIjtcbiAgdGV4dHVyZS5zb3VyY2UucmVzb3VyY2UgPSBpbWFnZTtcbiAgdGV4dHVyZS5zb3VyY2UuYWxwaGFNb2RlID0gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgdGV4dHVyZS5mcmFtZS53aWR0aCA9IHdpZHRoIC8gcmVzb2x1dGlvbjtcbiAgdGV4dHVyZS5mcmFtZS5oZWlnaHQgPSBoZWlnaHQgLyByZXNvbHV0aW9uO1xuICB0ZXh0dXJlLnNvdXJjZS5lbWl0KFwidXBkYXRlXCIsIHRleHR1cmUuc291cmNlKTtcbiAgdGV4dHVyZS51cGRhdGVVdnMoKTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmV4cG9ydCB7IGdldFBvMlRleHR1cmVGcm9tU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRQbzJUZXh0dXJlRnJvbVNvdXJjZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1647\n')}}]);