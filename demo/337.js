"use strict";(self.webpackChunk_masatomakino_pixijs_basic_scrollbar=self.webpackChunk_masatomakino_pixijs_basic_scrollbar||[]).push([[337],{2067(e,t,r){r.d(t,{Ls:()=>n,_Q:()=>s,mA:()=>a});const n={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},s={...n,vertex:{...n.vertex,header:n.vertex.header.replace("group(1)","group(2)")}},a={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},3391(e,t,r){r.d(t,{R:()=>n,m:()=>s});const n={name:"texture-bit",vertex:{header:"\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        ",main:"\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        ",main:"\n            outColor = textureSample(uTexture, uSampler, vUV);\n        "}},s={name:"texture-bit",vertex:{header:"\n            uniform mat3 uTextureMatrix;\n        ",main:"\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n        uniform sampler2D uTexture;\n\n\n        ",main:"\n            outColor = texture(uTexture, vUV);\n        "}}},7084(e,t,r){r.d(t,{q:()=>a});var n=r(268),s=r(8306);function a(e,t){for(const r in e.attributes){const s=e.attributes[r],a=t[r];a?(s.format??(s.format=a.format),s.offset??(s.offset=a.offset),s.instance??(s.instance=a.instance)):(0,n.R)(`Attribute ${r} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}!function(e){const{buffers:t,attributes:r}=e,n={},a={};for(const e in t){const r=t[e];n[r.uid]=0,a[r.uid]=0}for(const e in r){const t=r[e];n[t.buffer.uid]+=(0,s.m)(t.format).stride}for(const e in r){const t=r[e];t.stride??(t.stride=n[t.buffer.uid]),t.start??(t.start=a[t.buffer.uid]),a[t.buffer.uid]+=(0,s.m)(t.format).stride}}(e)}},1337(e,t,r){r.d(t,{WebGPURenderer:()=>Re});var n=r(8507),s=r(9313),a=r(341),i=r(5611),o=r(4459),u=r(4e3),c=r(2067),d=r(6665),h=r(8475),l=r(5811);class p{constructor(){this._maxTextures=0}contextChange(e){const t=new l.k({uTransformMatrix:{value:new s.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}});this._maxTextures=e.limits.maxBatchableTextures;const r=(0,i.v)({name:"graphics",bits:[o.F,(0,u._)(this._maxTextures),c._Q,d.b]});this.shader=new h.M({gpuProgram:r,resources:{localUniforms:t}})}execute(e,t){const r=t.context,n=r.customShader||this.shader,s=e.renderer,i=s.graphicsContext,{batcher:o,instructions:u}=i.getContextRenderData(r),c=s.encoder;c.setGeometry(o.geometry,n.gpuProgram);const d=s.globalUniforms.bindGroup;c.setBindGroup(0,d,n.gpuProgram);const h=s.renderPipes.uniformBatch.getUniformBindGroup(n.resources.localUniforms,!0);c.setBindGroup(2,h,n.gpuProgram);const l=u.instructions;let p=null;for(let t=0;t<u.instructionSize;t++){const r=l[t];if(r.topology!==p&&(p=r.topology,c.setPipelineFromGeometryProgramAndState(o.geometry,n.gpuProgram,e.state,r.topology)),n.groups[1]=r.bindGroup,!r.gpuBindGroup){const e=r.textures;r.bindGroup=(0,a.w)(e.textures,e.count,this._maxTextures),r.gpuBindGroup=s.bindGroup.getBindGroup(r.bindGroup,n.gpuProgram,1)}c.setBindGroup(1,r.bindGroup,n.gpuProgram),c.renderPassEncoder.drawIndexed(r.size,1,r.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}p.extension={type:[n.Ag.WebGPUPipesAdaptor],name:"graphics"};var f=r(3391),m=r(5589),g=r(268);class _{init(){const e=(0,i.v)({name:"mesh",bits:[c.Ls,f.R,d.b]});this._shader=new h.M({gpuProgram:e,resources:{uTexture:m.g.EMPTY._source,uSampler:m.g.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new s.u}}}})}execute(e,t){const r=e.renderer;let n=t._shader;if(n){if(!n.gpuProgram)return void(0,g.R)("Mesh shader has no gpuProgram",t.shader)}else n=this._shader,n.groups[2]=r.texture.getTextureBindGroup(t.texture);const s=n.gpuProgram;if(s.autoAssignGlobalUniforms&&(n.groups[0]=r.globalUniforms.bindGroup),s.autoAssignLocalUniforms){const t=e.localUniforms;n.groups[1]=r.renderPipes.uniformBatch.getUniformBindGroup(t,!0)}r.encoder.draw({geometry:t._geometry,shader:n,state:t.state})}destroy(){this._shader.destroy(!0),this._shader=null}}_.extension={type:[n.Ag.WebGPUPipesAdaptor],name:"mesh"};var v=r(7547);const b=v.U.for2d();class x{start(e,t,r){const n=e.renderer,s=n.encoder,a=r.gpuProgram;this._shader=r,this._geometry=t,s.setGeometry(t,a),b.blendMode="normal",n.pipeline.getPipeline(t,a,b);const i=n.globalUniforms.bindGroup;s.resetBindGroup(1),s.setBindGroup(0,i,a)}execute(e,t){const r=this._shader.gpuProgram,n=e.renderer,s=n.encoder;if(!t.bindGroup){const e=t.textures;t.bindGroup=(0,a.w)(e.textures,e.count,n.limits.maxBatchableTextures)}b.blendMode=t.blendMode;const i=n.bindGroup.getBindGroup(t.bindGroup,r,1),o=n.pipeline.getPipeline(this._geometry,r,b,t.topology);t.bindGroup._touch(n.gc.now,n.tick),s.setPipeline(o),s.renderPassEncoder.setBindGroup(1,i),s.renderPassEncoder.drawIndexed(t.size,1,t.start)}}x.extension={type:[n.Ag.WebGPUPipesAdaptor],name:"batch"};var y=r(800),P=r(5362),G=r(5099);class T{constructor(e){this._hash=Object.create(null),this._renderer=e}contextChange(e){this._gpu=e}getBindGroup(e,t,r){return e._updateKey(),this._hash[e._key]||this._createBindGroup(e,t,r)}_createBindGroup(e,t,r){const n=this._gpu.device,s=t.layout[r],a=[],i=this._renderer;for(const t in s){const r=e.resources[t]??e.resources[s[t]];let n;if("uniformGroup"===r._resourceType){const e=r;i.ubo.updateUniformGroup(e);const t=e.buffer;n={buffer:i.buffer.getGPUBuffer(t),offset:0,size:t.descriptor.size}}else if("buffer"===r._resourceType){const e=r;n={buffer:i.buffer.getGPUBuffer(e),offset:0,size:e.descriptor.size}}else if("bufferResource"===r._resourceType){const e=r;n={buffer:i.buffer.getGPUBuffer(e.buffer),offset:e.offset,size:e.size}}else if("textureSampler"===r._resourceType){const e=r;n=i.texture.getGpuSampler(e)}else if("textureSource"===r._resourceType){const e=r;n=i.texture.getTextureView(e)}a.push({binding:s[t],resource:n})}const o=i.shader.getProgramData(t).bindGroups[r],u=n.createBindGroup({layout:o,entries:a});return this._hash[e._key]=u,u}destroy(){this._hash=null,this._renderer=null}}T.extension={type:[n.Ag.WebGPUSystem],name:"bindGroup"};var C=r(4334),S=r(133),B=r(6736);class U{constructor(e){this.gpuBuffer=e}destroy(){this.gpuBuffer.destroy(),this.gpuBuffer=null}}class w{constructor(e){this._renderer=e,this._managedBuffers=new C.s({renderer:e,type:"resource",onUnload:this.onBufferUnload.bind(this),name:"gpuBuffer"})}contextChange(e){this._gpu=e}getGPUBuffer(e){return e._gcLastUsed=this._renderer.gc.now,e._gpuData[this._renderer.uid]?.gpuBuffer||this.createGPUBuffer(e)}updateBuffer(e){const t=this.getGPUBuffer(e),r=e.data;return e._updateID&&r&&(e._updateID=0,this._gpu.device.queue.writeBuffer(t,0,r.buffer,0,(e._updateSize||r.byteLength)+3&-4)),t}destroyAll(){this._managedBuffers.removeAll()}onBufferUnload(e){e.off("update",this.updateBuffer,this),e.off("change",this.onBufferChange,this)}createGPUBuffer(e){const t=this._gpu.device.createBuffer(e.descriptor);return e._updateID=0,e._resourceId=(0,S.L)("resource"),e.data&&((0,B.W)(e.data.buffer,t.getMappedRange(),e.data.byteOffset,e.data.byteLength),t.unmap()),e._gpuData[this._renderer.uid]=new U(t),this._managedBuffers.add(e)&&(e.on("update",this.updateBuffer,this),e.on("change",this.onBufferChange,this)),t}onBufferChange(e){this._managedBuffers.remove(e),e._updateID=0,this.createGPUBuffer(e)}destroy(){this._managedBuffers.destroy(),this._renderer=null,this._gpu=null}}w.extension={type:[n.Ag.WebGPUSystem],name:"buffer"};class M{constructor(e){this._colorMaskCache=15,this._renderer=e}setMask(e){this._colorMaskCache!==e&&(this._colorMaskCache=e,this._renderer.pipeline.setColorMask(e))}destroy(){this._renderer=null,this._colorMaskCache=null}}M.extension={type:[n.Ag.WebGPUSystem],name:"colorMask"};var A=r(1761);class R{constructor(e){this._renderer=e}async init(e){return this._initPromise||(this._initPromise=(e.gpu?Promise.resolve(e.gpu):this._createDeviceAndAdaptor(e)).then(e=>{this.gpu=e,this._renderer.runners.contextChange.emit(this.gpu)})),this._initPromise}contextChange(e){this._renderer.gpu=e}async _createDeviceAndAdaptor(e){const t=await A.e.get().getNavigator().gpu.requestAdapter({powerPreference:e.powerPreference,forceFallbackAdapter:e.forceFallbackAdapter}),r=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(e=>t.features.has(e)),n=await t.requestDevice({requiredFeatures:r});return{adapter:t,device:n}}destroy(){this.gpu=null,this._renderer=null}}R.extension={type:[n.Ag.WebGPUSystem],name:"device"},R.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};class E{constructor(e){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=e}renderStart(){this.commandFinished=new Promise(e=>{this._resolveCommandFinished=e}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(e){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(e.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(e){this.renderPassEncoder.setViewport(e.x,e.y,e.width,e.height,0,1)}setPipelineFromGeometryProgramAndState(e,t,r,n){const s=this._renderer.pipeline.getPipeline(e,t,r,n);this.setPipeline(s)}setPipeline(e){this._boundPipeline!==e&&(this._boundPipeline=e,this.renderPassEncoder.setPipeline(e))}_setVertexBuffer(e,t){this._boundVertexBuffer[e]!==t&&(this._boundVertexBuffer[e]=t,this.renderPassEncoder.setVertexBuffer(e,this._renderer.buffer.updateBuffer(t)))}_setIndexBuffer(e){if(this._boundIndexBuffer===e)return;this._boundIndexBuffer=e;const t=2===e.data.BYTES_PER_ELEMENT?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e),t)}resetBindGroup(e){this._boundBindGroup[e]=null}setBindGroup(e,t,r){if(this._boundBindGroup[e]===t)return;this._boundBindGroup[e]=t,t._touch(this._renderer.gc.now,this._renderer.tick);const n=this._renderer.bindGroup.getBindGroup(t,r,e);this.renderPassEncoder.setBindGroup(e,n)}setGeometry(e,t){const r=this._renderer.pipeline.getBufferNamesToBind(e,t);for(const t in r)this._setVertexBuffer(parseInt(t,10),e.attributes[r[t]].buffer);e.indexBuffer&&this._setIndexBuffer(e.indexBuffer)}_setShaderBindGroups(e,t){for(const r in e.groups){const n=e.groups[r];t||this._syncBindGroup(n),this.setBindGroup(r,n,e.gpuProgram)}}_syncBindGroup(e){for(const t in e.resources){const r=e.resources[t];r.isUniformGroup&&this._renderer.ubo.updateUniformGroup(r)}}draw(e){const{geometry:t,shader:r,state:n,topology:s,size:a,start:i,instanceCount:o,skipSync:u}=e;this.setPipelineFromGeometryProgramAndState(t,r.gpuProgram,n,s),this.setGeometry(t,r.gpuProgram),this._setShaderBindGroups(r,u),t.indexBuffer?this.renderPassEncoder.drawIndexed(a||t.indexBuffer.data.length,o??t.instanceCount,i||0):this.renderPassEncoder.draw(a||t.getSize(),o??t.instanceCount,i||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished(),this.commandEncoder=null}restoreRenderPass(){const e=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1],this._renderer.renderTarget.mipLevel,this._renderer.renderTarget.layer);this.renderPassEncoder=this.commandEncoder.beginRenderPass(e);const t=this._boundPipeline,r={...this._boundVertexBuffer},n=this._boundIndexBuffer,s={...this._boundBindGroup};this._clearCache();const a=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(a.x,a.y,a.width,a.height,0,1),this.setPipeline(t);for(const e in r)this._setVertexBuffer(e,r[e]);for(const e in s)this.setBindGroup(e,s[e],null);this._setIndexBuffer(n)}_clearCache(){for(let e=0;e<16;e++)this._boundBindGroup[e]=null,this._boundVertexBuffer[e]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(e){this._gpu=e}}E.extension={type:[n.Ag.WebGPUSystem],name:"encoder",priority:1};class L{constructor(e){this._renderer=e}contextChange(){this.maxTextures=this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage,this.maxBatchableTextures=this.maxTextures}destroy(){}}L.extension={type:[n.Ag.WebGPUSystem],name:"limits"};var k=r(1957);class O{constructor(e){this._renderTargetStencilState=Object.create(null),this._renderer=e,e.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(e){let t=this._renderTargetStencilState[e.uid];t||(t=this._renderTargetStencilState[e.uid]={stencilMode:k.K.DISABLED,stencilReference:0}),this._activeRenderTarget=e,this.setStencilMode(t.stencilMode,t.stencilReference)}setStencilMode(e,t){const r=this._renderTargetStencilState[this._activeRenderTarget.uid];r.stencilMode=e,r.stencilReference=t;const n=this._renderer;n.pipeline.setStencilMode(e),n.encoder.renderPassEncoder.setStencilReference(t)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}O.extension={type:[n.Ag.WebGPUSystem],name:"stencil"};var F=r(7047);const I={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function z(e){const t=e.map(e=>({data:e,offset:0,size:0}));let r=0;for(let e=0;e<t.length;e++){const n=t[e];let s=I[n.data.type].size;const a=I[n.data.type].align;if(!I[n.data.type])throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${n.data.type}`);n.data.size>1&&(s=Math.max(s,a)*n.data.size),r=Math.ceil(r/a)*a,n.size=s,n.offset=r,r+=s}return r=16*Math.ceil(r/16),{uboElements:t,size:r}}var D=r(6423),H=r(1266);function W(e,t){const{size:r,align:n}=I[e.data.type],s=(n-r)/4,a=e.data.type.indexOf("i32")>=0?"dataInt32":"data";return`\n         v = uv.${e.data.name};\n         ${0!==t?`offset += ${t};`:""}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${e.data.size*(r/4)}; i++)\n         {\n             for(var j = 0; j < ${r/4}; j++)\n             {\n                 ${a}[arrayOffset++] = v[t++];\n             }\n             ${0!==s?`arrayOffset += ${s};`:""}\n         }\n     `}function V(e){return(0,D.E)(e,"uboWgsl",W,H._)}class N extends F.W{constructor(){super({createUboElements:z,generateUboSync:V})}}N.extension={type:[n.Ag.WebGPUSystem],name:"ubo"};var j=r(949),K=r(581),$=r(1132);class q{constructor({minUniformOffsetAlignment:e}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=e,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(e){if(e>this._minUniformOffsetAlignment/4)throw new Error("UniformBufferBatch: array is too large: "+4*e);const t=this.byteIndex;let r=t+4*e;if(r=Math.ceil(r/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,r>4*this.data.length)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=r,t}addGroup(e){const t=this.addEmptyGroup(e.length);for(let r=0;r<e.length;r++)this.data[t/4+r]=e[r];return t}destroy(){this.data=null}}var Y=r(3513);const X=128;class Q{constructor(e){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=e,this._batchBuffer=new q({minUniformOffsetAlignment:X});for(let e=0;e<2;e++){let t=$.S.UNIFORM|$.S.COPY_DST;0===e&&(t|=$.S.COPY_SRC),this._buffers.push(new j.h({data:this._batchBuffer.data,usage:t}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){this._bindGroupHash=Object.create(null),this._batchBuffer.clear()}getUniformBindGroup(e,t){if(!t&&this._bindGroupHash[e.uid])return this._bindGroupHash[e.uid];this._renderer.ubo.ensureUniformGroup(e);const r=e.buffer.data,n=this._batchBuffer.addEmptyGroup(r.length);return this._renderer.ubo.syncUniformGroup(e,this._batchBuffer.data,n/4),this._bindGroupHash[e.uid]=this._getBindGroup(n/X),this._bindGroupHash[e.uid]}getUboResource(e){this._renderer.ubo.updateUniformGroup(e);const t=e.buffer.data,r=this._batchBuffer.addGroup(t);return this._getBufferResource(r/X)}getArrayBindGroup(e){const t=this._batchBuffer.addGroup(e);return this._getBindGroup(t/X)}getArrayBufferResource(e){const t=this._batchBuffer.addGroup(e)/X;return this._getBufferResource(t)}_getBufferResource(e){if(!this._bufferResources[e]){const t=this._buffers[e%2];this._bufferResources[e]=new K.d({buffer:t,offset:256*(e/2|0),size:X})}return this._bufferResources[e]}_getBindGroup(e){if(!this._bindGroups[e]){const t=new Y.T({0:this._getBufferResource(e)});this._bindGroups[e]=t}return this._bindGroups[e]}_uploadBindGroups(){const e=this._renderer.buffer,t=this._buffers[0];t.update(this._batchBuffer.byteIndex),e.updateBuffer(t);const r=this._renderer.gpu.device.createCommandEncoder();for(let n=1;n<this._buffers.length;n++){const s=this._buffers[n];r.copyBufferToBuffer(e.getGPUBuffer(t),X,e.getGPUBuffer(s),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([r.finish()])}destroy(){for(let e=0;e<this._bindGroups.length;e++)this._bindGroups[e]?.destroy();this._bindGroups=null,this._bindGroupHash=null;for(let e=0;e<this._buffers.length;e++)this._buffers[e].destroy();this._buffers=null;for(let e=0;e<this._bufferResources.length;e++)this._bufferResources[e].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._renderer=null}}Q.extension={type:[n.Ag.WebGPUPipes],name:"uniformBatch"};var J=r(7084),Z=r(7952),ee=r(1172);const te={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};class re{constructor(e){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._bindingNamesCache=Object.create(null),this._pipeCache=Object.create(null),this._pipeStateCaches=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._colorTargetCount=1,this._renderer=e}contextChange(e){this._gpu=e,this.setStencilMode(k.K.DISABLED),this._updatePipeHash()}setMultisampleCount(e){this._multisampleCount!==e&&(this._multisampleCount=e,this._updatePipeHash())}setRenderTarget(e){this._multisampleCount=e.msaaSamples,this._depthStencilAttachment=e.descriptor.depthStencilAttachment?1:0,this._colorTargetCount=e.colorTargetCount,this._updatePipeHash()}setColorMask(e){this._colorMask!==e&&(this._colorMask=e,this._updatePipeHash())}setStencilMode(e){this._stencilMode!==e&&(this._stencilMode=e,this._stencilState=ee.g[e],this._updatePipeHash())}setPipeline(e,t,r,n){const s=this.getPipeline(e,t,r);n.setPipeline(s)}getPipeline(e,t,r,n){e._layoutKey||((0,J.q)(e,t.attributeData),this._generateBufferKey(e)),n||(n=e.topology);const s=function(e,t,r,n,s){return e<<24|t<<16|r<<10|n<<5|s}(e._layoutKey,t._layoutKey,r.data,r._blendModeId,te[n]);return this._pipeCache[s]||(this._pipeCache[s]=this._createPipeline(e,t,r,n)),this._pipeCache[s]}_createPipeline(e,t,r,n){const s=this._gpu.device,a=this._createVertexBufferLayouts(e,t),i=this._renderer.state.getColorTargets(r,this._colorTargetCount),o=this._stencilMode===k.K.RENDERING_MASK_ADD?0:this._colorMask;for(let e=0;e<i.length;e++)i[e].writeMask=o;const u=this._renderer.shader.getProgramData(t).pipeline,c={vertex:{module:this._getModule(t.vertex.source),entryPoint:t.vertex.entryPoint,buffers:a},fragment:{module:this._getModule(t.fragment.source),entryPoint:t.fragment.entryPoint,targets:i},primitive:{topology:n,cullMode:r.cullMode},layout:u,multisample:{count:this._multisampleCount},label:"PIXI Pipeline"};return this._depthStencilAttachment&&(c.depthStencil={...this._stencilState,format:"depth24plus-stencil8",depthWriteEnabled:r.depthTest,depthCompare:r.depthTest?"less":"always"}),s.createRenderPipeline(c)}_getModule(e){return this._moduleCache[e]||this._createModule(e)}_createModule(e){const t=this._gpu.device;return this._moduleCache[e]=t.createShaderModule({code:e}),this._moduleCache[e]}_generateBufferKey(e){const t=[];let r=0;const n=Object.keys(e.attributes).sort();for(let s=0;s<n.length;s++){const a=e.attributes[n[s]];t[r++]=a.offset,t[r++]=a.format,t[r++]=a.stride,t[r++]=a.instance}const s=t.join("|");return e._layoutKey=(0,Z.X)(s,"geometry"),e._layoutKey}_generateAttributeLocationsKey(e){const t=[];let r=0;const n=Object.keys(e.attributeData).sort();for(let s=0;s<n.length;s++){const a=e.attributeData[n[s]];t[r++]=a.location}const s=t.join("|");return e._attributeLocationsKey=(0,Z.X)(s,"programAttributes"),e._attributeLocationsKey}getBufferNamesToBind(e,t){const r=e._layoutKey<<16|t._attributeLocationsKey;if(this._bindingNamesCache[r])return this._bindingNamesCache[r];const n=this._createVertexBufferLayouts(e,t),s=Object.create(null),a=t.attributeData;for(let e=0;e<n.length;e++){const t=Object.values(n[e].attributes)[0].shaderLocation;for(const r in a)if(a[r].location===t){s[e]=r;break}}return this._bindingNamesCache[r]=s,s}_createVertexBufferLayouts(e,t){t._attributeLocationsKey||this._generateAttributeLocationsKey(t);const r=e._layoutKey<<16|t._attributeLocationsKey;if(this._bufferLayoutsCache[r])return this._bufferLayoutsCache[r];const n=[];return e.buffers.forEach(r=>{const s={arrayStride:0,stepMode:"vertex",attributes:[]},a=s.attributes;for(const n in t.attributeData){const i=e.attributes[n];1!==(i.divisor??1)&&(0,g.R)(`Attribute ${n} has an invalid divisor value of '${i.divisor}'. WebGPU only supports a divisor value of 1`),i.buffer===r&&(s.arrayStride=i.stride,s.stepMode=i.instance?"instance":"vertex",a.push({shaderLocation:t.attributeData[n].location,offset:i.offset,format:i.format}))}a.length&&n.push(s)}),this._bufferLayoutsCache[r]=n,n}_updatePipeHash(){const e=(t=this._stencilMode,r=this._multisampleCount,this._colorMask<<8|t<<5|this._depthStencilAttachment<<3|this._colorTargetCount<<1|r);var t,r;this._pipeStateCaches[e]||(this._pipeStateCaches[e]=Object.create(null)),this._pipeCache=this._pipeStateCaches[e]}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}re.extension={type:[n.Ag.WebGPUSystem],name:"pipeline"};var ne=r(7238),se=r(1257),ae=r(4884),ie=r(583);class oe{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class ue{init(e,t){this._renderer=e,this._renderTargetSystem=t}copyToTexture(e,t,r,n,s){const a=this._renderer,i=this._getGpuColorTexture(e),o=a.texture.getGpuSource(t.source);return a.encoder.commandEncoder.copyTextureToTexture({texture:i,origin:r},{texture:o,origin:s},n),t}startRenderPass(e,t=!0,r,n,s=0,a=0){const i=this._renderTargetSystem.getGpuRenderTarget(e);if(0!==a&&i.msaaTextures?.length)throw new Error("[RenderTargetSystem] Rendering to array layers is not supported with MSAA render targets.");if(s>0&&i.msaaTextures?.length)throw new Error("[RenderTargetSystem] Rendering to mip levels is not supported with MSAA render targets.");const o=this.getDescriptor(e,t,r,s,a);i.descriptor=o,this._renderer.pipeline.setRenderTarget(i),this._renderer.encoder.beginRenderPass(i),this._renderer.encoder.setViewport(n)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);return t.contexts[0]?t.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(e.colorTextures[0].source)}getDescriptor(e,t,r,n=0,s=0){"boolean"==typeof t&&(t=t?se.u.ALL:se.u.NONE);const a=this._renderTargetSystem,i=a.getGpuRenderTarget(e),o=e.colorTextures.map((e,o)=>{const u=i.contexts[o];let c,d;if(u){if(0!==s)throw new Error("[RenderTargetSystem] Rendering to array layers is not supported for canvas targets.");c=u.getCurrentTexture().createView()}else c=this._renderer.texture.getGpuSource(e).createView({dimension:"2d",baseMipLevel:n,mipLevelCount:1,baseArrayLayer:s,arrayLayerCount:1});i.msaaTextures[o]&&(d=c,c=this._renderer.texture.getTextureView(i.msaaTextures[o]));const h=t&se.u.COLOR?"clear":"load";return r??(r=a.defaultClearColor),{view:c,resolveTarget:d,clearValue:r,storeOp:"store",loadOp:h}});let u;if(!e.stencil&&!e.depth||e.depthStencilTexture||(e.ensureDepthStencilTexture(),e.depthStencilTexture.source.sampleCount=i.msaa?4:1),e.depthStencilTexture){const r=t&se.u.STENCIL?"clear":"load",a=t&se.u.DEPTH?"clear":"load";u={view:this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView({dimension:"2d",baseMipLevel:n,mipLevelCount:1,baseArrayLayer:s,arrayLayerCount:1}),stencilStoreOp:"store",stencilLoadOp:r,depthClearValue:1,depthLoadOp:a,depthStoreOp:"store"}}return{colorAttachments:o,depthStencilAttachment:u}}clear(e,t=!0,r,n,s=0,a=0){if(!t)return;const{gpu:i,encoder:o}=this._renderer,u=i.device;if(null===o.commandEncoder){const i=u.createCommandEncoder(),o=this.getDescriptor(e,t,r,s,a),c=i.beginRenderPass(o);c.setViewport(n.x,n.y,n.width,n.height,0,1),c.end();const d=i.finish();u.queue.submit([d])}else this.startRenderPass(e,t,r,n,s,a)}initGpuRenderTarget(e){e.isRoot=!0;const t=new oe;return t.colorTargetCount=e.colorTextures.length,e.colorTextures.forEach((e,r)=>{if(e instanceof ae.q){const n=e.resource.getContext("webgpu"),s=e.transparent?"premultiplied":"opaque";try{n.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:s})}catch(e){console.error(e)}t.contexts[r]=n}if(t.msaa=e.source.antialias,e.source.antialias){const n=new ie.v({width:0,height:0,sampleCount:4,arrayLayerCount:e.source.arrayLayerCount});t.msaaTextures[r]=n}}),t.msaa&&(t.msaaSamples=4,e.depthStencilTexture&&(e.depthStencilTexture.source.sampleCount=4)),t}destroyGpuRenderTarget(e){e.contexts.forEach(e=>{e.unconfigure()}),e.msaaTextures.forEach(e=>{e.destroy()}),e.msaaTextures.length=0,e.contexts.length=0}ensureDepthStencilTexture(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);e.depthStencilTexture&&t.msaa&&(e.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);t.width=e.width,t.height=e.height,t.msaa&&e.colorTextures.forEach((e,r)=>{const n=t.msaaTextures[r];n?.resize(e.source.width,e.source.height,e.source._resolution)})}}class ce extends ne.l{constructor(e){super(e),this.adaptor=new ue,this.adaptor.init(e,this)}}ce.extension={type:[n.Ag.WebGPUSystem],name:"renderTarget"};class de{constructor(){this._gpuProgramData=Object.create(null)}contextChange(e){this._gpu=e}getProgramData(e){return this._gpuProgramData[e._layoutKey]||this._createGPUProgramData(e)}_createGPUProgramData(e){const t=this._gpu.device,r=e.gpuLayout.map(e=>t.createBindGroupLayout({entries:e})),n={bindGroupLayouts:r};return this._gpuProgramData[e._layoutKey]={bindGroups:r,pipeline:t.createPipelineLayout(n)},this._gpuProgramData[e._layoutKey]}destroy(){this._gpu=null,this._gpuProgramData=null}}de.extension={type:[n.Ag.WebGPUSystem],name:"shader"};const he={normal:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}},add:{alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}},multiply:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}},screen:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},overlay:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},none:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}},"normal-npm":{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},"add-npm":{alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}},"screen-npm":{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}},erase:{alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}},min:{alpha:{srcFactor:"one",dstFactor:"one",operation:"min"},color:{srcFactor:"one",dstFactor:"one",operation:"min"}},max:{alpha:{srcFactor:"one",dstFactor:"one",operation:"max"},color:{srcFactor:"one",dstFactor:"one",operation:"max"}}};class le{constructor(){this.defaultState=new v.U,this.defaultState.blend=!0}contextChange(e){this.gpu=e}getColorTargets(e,t){const r=[],n={format:"bgra8unorm",writeMask:0,blend:he[e.blendMode]||he.normal};for(let e=0;e<t;e++)r[e]=n;return r}destroy(){this.gpu=null}}le.extension={type:[n.Ag.WebGPUSystem],name:"state"};var pe=r(9939),fe=r(6083);const me=new class{constructor(e){this._canvasPool=Object.create(null),this.canvasOptions=e||{},this.enableFullScreen=!1}_createCanvasAndContext(e,t){const r=A.e.get().createCanvas();r.width=e,r.height=t;const n=r.getContext("2d");return{canvas:r,context:n}}getOptimalCanvasAndContext(e,t,r=1){e=Math.ceil(e*r-1e-6),t=Math.ceil(t*r-1e-6);const n=((e=(0,pe.U5)(e))<<17)+((t=(0,pe.U5)(t))<<1);this._canvasPool[n]||(this._canvasPool[n]=[]);let s=this._canvasPool[n].pop();return s||(s=this._createCanvasAndContext(e,t)),s}returnCanvasAndContext(e){const t=e.canvas,{width:r,height:n}=t,s=(r<<17)+(n<<1);e.context.resetTransform(),e.context.clearRect(0,0,r,n),this._canvasPool[s].push(e)}clear(){this._canvasPool={}}};fe.L.register(me);const ge={type:"image",upload(e,t,r,n=0){const s=e.resource,a=(0|e.pixelWidth)*(0|e.pixelHeight),i=s.byteLength/a;r.device.queue.writeTexture({texture:t,origin:{x:0,y:0,z:n}},s,{offset:0,rowsPerImage:e.pixelHeight,bytesPerRow:e.pixelWidth*i},{width:e.pixelWidth,height:e.pixelHeight,depthOrArrayLayers:1})}},_e={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},ve={blockBytes:4,blockWidth:1,blockHeight:1},be={type:"compressed",upload(e,t,r,n=0){let s=e.pixelWidth,a=e.pixelHeight;const i=_e[e.format]||ve;for(let o=0;o<e.resource.length;o++){const u=e.resource[o],c=Math.ceil(s/i.blockWidth)*i.blockBytes;r.device.queue.writeTexture({texture:t,mipLevel:o,origin:{x:0,y:0,z:n}},u,{offset:0,bytesPerRow:c},{width:Math.ceil(s/i.blockWidth)*i.blockWidth,height:Math.ceil(a/i.blockHeight)*i.blockHeight,depthOrArrayLayers:1}),s=Math.max(s>>1,1),a=Math.max(a>>1,1)}}},xe=["right","left","top","bottom","front","back"],ye={type:"image",upload(e,t,r,n=0){const s=e.resource;if(!s)return;if(globalThis.HTMLImageElement&&s instanceof HTMLImageElement){const t=A.e.get().createCanvas(s.width,s.height);t.getContext("2d").drawImage(s,0,0,s.width,s.height),e.resource=t,(0,g.R)("ImageSource: Image element passed, converting to canvas and replacing resource.")}const a=Math.min(t.width,e.resourceWidth||e.pixelWidth),i=Math.min(t.height,e.resourceHeight||e.pixelHeight),o="premultiply-alpha-on-upload"===e.alphaMode;r.device.queue.copyExternalImageToTexture({source:s},{texture:t,origin:{x:0,y:0,z:n},premultipliedAlpha:o},{width:a,height:i})}},Pe={type:"video",upload(e,t,r,n){ye.upload(e,t,r,n)}};class Ge{constructor(e){this.device=e,this.sampler=e.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(e){let t=this.pipelines[e];return t||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:"\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    "})),t=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:e}]}}),this.pipelines[e]=t),t}generateMipmap(e){const t=this._getMipmapPipeline(e.format);if("3d"===e.dimension||"1d"===e.dimension)throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let r=e;const n=e.depthOrArrayLayers||1,s=e.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!s){const t={size:{width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:n},format:e.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:e.mipLevelCount-1};r=this.device.createTexture(t)}const a=this.device.createCommandEncoder({}),i=t.getBindGroupLayout(0);for(let o=0;o<n;++o){let n=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:o,arrayLayerCount:1}),u=s?1:0;for(let s=1;s<e.mipLevelCount;++s){const e=r.createView({baseMipLevel:u++,mipLevelCount:1,dimension:"2d",baseArrayLayer:o,arrayLayerCount:1}),s=a.beginRenderPass({colorAttachments:[{view:e,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),c=this.device.createBindGroup({layout:i,entries:[{binding:0,resource:this.sampler},{binding:1,resource:n}]});s.setPipeline(t),s.setBindGroup(0,c),s.draw(3,1,0,0),s.end(),n=e}}if(!s){const t={width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:n};for(let n=1;n<e.mipLevelCount;++n)a.copyTextureToTexture({texture:r,mipLevel:n-1},{texture:e,mipLevel:n},t),t.width=Math.ceil(t.width/2),t.height=Math.ceil(t.height/2)}return this.device.queue.submit([a.finish()]),s||r.destroy(),e}}class Te{constructor(e){this.textureView=null,this.gpuTexture=e}destroy(){this.gpuTexture.destroy(),this.textureView=null,this.gpuTexture=null}}class Ce{constructor(e){this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._renderer=e,e.gc.addCollection(this,"_bindGroupHash","hash"),this._managedTextures=new C.s({renderer:e,type:"resource",onUnload:this.onSourceUnload.bind(this),name:"gpuTextureSource"});const t={image:ye,buffer:ge,video:Pe,compressed:be};var r;this._uploads={...t,cube:(r=t,{type:"cube",upload(e,t,n){const s=e.faces;for(let e=0;e<xe.length;e++){const a=s[xe[e]];(r[a.uploadMethodId]||r.image).upload(a,t,n,e)}}})}}get managedTextures(){return Object.values(this._managedTextures.items)}contextChange(e){this._gpu=e}initSource(e){return e._gpuData[this._renderer.uid]?.gpuTexture||this._initSource(e)}_initSource(e){if(e.autoGenerateMipmaps){const t=Math.max(e.pixelWidth,e.pixelHeight);e.mipLevelCount=Math.floor(Math.log2(t))+1}let t=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;"compressed"!==e.uploadMethodId&&(t|=GPUTextureUsage.RENDER_ATTACHMENT,t|=GPUTextureUsage.COPY_SRC);const r=_e[e.format]||{blockBytes:4,blockWidth:1,blockHeight:1},n=Math.ceil(e.pixelWidth/r.blockWidth)*r.blockWidth,s=Math.ceil(e.pixelHeight/r.blockHeight)*r.blockHeight,a={label:e.label,size:{width:n,height:s,depthOrArrayLayers:e.arrayLayerCount},format:e.format,sampleCount:e.sampleCount,mipLevelCount:e.mipLevelCount,dimension:e.dimension,usage:t},i=this._gpu.device.createTexture(a);return e._gpuData[this._renderer.uid]=new Te(i),this._managedTextures.add(e)&&(e.on("update",this.onSourceUpdate,this),e.on("resize",this.onSourceResize,this),e.on("updateMipmaps",this.onUpdateMipmaps,this)),this.onSourceUpdate(e),i}onSourceUpdate(e){const t=this.getGpuSource(e);t&&(this._uploads[e.uploadMethodId]&&this._uploads[e.uploadMethodId].upload(e,t,this._gpu),e.autoGenerateMipmaps&&e.mipLevelCount>1&&this.onUpdateMipmaps(e))}onUpdateMipmaps(e){this._mipmapGenerator||(this._mipmapGenerator=new Ge(this._gpu.device));const t=this.getGpuSource(e);this._mipmapGenerator.generateMipmap(t)}onSourceUnload(e){e.off("update",this.onSourceUpdate,this),e.off("resize",this.onSourceResize,this),e.off("updateMipmaps",this.onUpdateMipmaps,this)}onSourceResize(e){e._gcLastUsed=this._renderer.gc.now;const t=e._gpuData[this._renderer.uid],r=t?.gpuTexture;r?r.width===e.pixelWidth&&r.height===e.pixelHeight||(t.destroy(),this._bindGroupHash[e.uid]=null,e._gpuData[this._renderer.uid]=null,this.initSource(e)):this.initSource(e)}_initSampler(e){return this._gpuSamplers[e._resourceId]=this._gpu.device.createSampler(e),this._gpuSamplers[e._resourceId]}getGpuSampler(e){return this._gpuSamplers[e._resourceId]||this._initSampler(e)}getGpuSource(e){return e._gcLastUsed=this._renderer.gc.now,e._gpuData[this._renderer.uid]?.gpuTexture||this.initSource(e)}getTextureBindGroup(e){return this._bindGroupHash[e.uid]||this._createTextureBindGroup(e)}_createTextureBindGroup(e){const t=e.source;return this._bindGroupHash[e.uid]=new Y.T({0:t,1:t.style,2:new l.k({uTextureMatrix:{type:"mat3x3<f32>",value:e.textureMatrix.mapCoord}})}),this._bindGroupHash[e.uid]}getTextureView(e){const t=e.source;t._gcLastUsed=this._renderer.gc.now;let r=t._gpuData[this._renderer.uid];return r||(this.initSource(t),r=t._gpuData[this._renderer.uid]),r.textureView||(r.textureView=r.gpuTexture.createView({dimension:t.viewDimension})),r.textureView}generateCanvas(e){const t=this._renderer,r=t.gpu.device.createCommandEncoder(),n=A.e.get().createCanvas();n.width=e.source.pixelWidth,n.height=e.source.pixelHeight;const s=n.getContext("webgpu");return s.configure({device:t.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:A.e.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),r.copyTextureToTexture({texture:t.texture.getGpuSource(e.source),origin:{x:0,y:0}},{texture:s.getCurrentTexture()},{width:n.width,height:n.height}),t.gpu.device.queue.submit([r.finish()]),n}getPixels(e){const t=this.generateCanvas(e),r=me.getOptimalCanvasAndContext(t.width,t.height),n=r.context;n.drawImage(t,0,0);const{width:s,height:a}=t,i=n.getImageData(0,0,s,a),o=new Uint8ClampedArray(i.data.buffer);return me.returnCanvasAndContext(r),{pixels:o,width:s,height:a}}destroy(){this._managedTextures.destroy();for(const e of Object.keys(this._bindGroupHash)){const t=Number(e),r=this._bindGroupHash[t];r?.destroy()}this._renderer=null,this._gpu=null,this._mipmapGenerator=null,this._gpuSamplers=null,this._bindGroupHash=null}}Ce.extension={type:[n.Ag.WebGPUSystem],name:"texture"};const Se=[...P.i,N,E,R,L,w,Ce,ce,de,le,re,M,O,T],Be=[...P.f,Q],Ue=[x,_,p],we=[],Me=[],Ae=[];n.XO.handleByNamedList(n.Ag.WebGPUSystem,we),n.XO.handleByNamedList(n.Ag.WebGPUPipes,Me),n.XO.handleByNamedList(n.Ag.WebGPUPipesAdaptor,Ae),n.XO.add(...Se,...Be,...Ue);class Re extends y.k{constructor(){super({name:"webgpu",type:G.W.WEBGPU,systems:we,renderPipes:Me,renderPipeAdaptors:Ae})}}},1172(e,t,r){r.d(t,{g:()=>s});var n=r(1957);const s=[];s[n.K.NONE]=void 0,s[n.K.DISABLED]={stencilWriteMask:0,stencilReadMask:0},s[n.K.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}},s[n.K.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}},s[n.K.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}},s[n.K.INVERSE_MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"not-equal",passOp:"keep"},stencilBack:{compare:"not-equal",passOp:"keep"}}},581(e,t,r){r.d(t,{d:()=>a});var n=r(8875),s=r(133);class a extends n.A{constructor({buffer:e,offset:t,size:r}){super(),this.uid=(0,s.L)("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=(0,s.L)("resource"),this._bufferResource=!0,this.destroyed=!1,this.buffer=e,this.offset=0|t,this.size=r,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=(0,s.L)("resource"),this.emit("change",this)}destroy(e=!1){this.destroyed=!0,e&&this.buffer.destroy(),this.emit("change",this),this.buffer=null,this.removeAllListeners()}}},7047(e,t,r){r.d(t,{W:()=>i});var n=r(4577),s=r(949),a=r(1132);class i{constructor(e){this._syncFunctionHash=Object.create(null),this._adaptor=e,this._systemCheck()}_systemCheck(){if(!(0,n.f)())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}ensureUniformGroup(e){const t=this.getUniformGroupData(e);e.buffer||(e.buffer=new s.h({data:new Float32Array(t.layout.size/4),usage:a.S.UNIFORM|a.S.COPY_DST}))}getUniformGroupData(e){return this._syncFunctionHash[e._signature]||this._initUniformGroup(e)}_initUniformGroup(e){const t=e._signature;let r=this._syncFunctionHash[t];if(!r){const n=Object.keys(e.uniformStructures).map(t=>e.uniformStructures[t]),s=this._adaptor.createUboElements(n),a=this._generateUboSync(s.uboElements);r=this._syncFunctionHash[t]={layout:s,syncFunction:a}}return this._syncFunctionHash[t]}_generateUboSync(e){return this._adaptor.generateUboSync(e)}syncUniformGroup(e,t,r){const n=this.getUniformGroupData(e);e.buffer||(e.buffer=new s.h({data:new Float32Array(n.layout.size/4),usage:a.S.UNIFORM|a.S.COPY_DST}));let i=null;return t||(t=e.buffer.data,i=e.buffer.dataInt32),r||(r=0),n.syncFunction(e.uniforms,t,i,r),!0}updateUniformGroup(e){if(e.isStatic&&!e._dirtyId)return!1;e._dirtyId=0;const t=this.syncUniformGroup(e);return e.buffer.update(),t}destroy(){this._syncFunctionHash=null}}},6423(e,t,r){r.d(t,{E:()=>s});var n=r(8166);function s(e,t,r,s){const a=["\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    "];let i=0;for(let o=0;o<e.length;o++){const u=e[o],c=u.data.name;let d=!1,h=0;for(let e=0;e<n.$.length;e++)if(n.$[e].test(u.data)){h=u.offset/4,a.push(`name = "${c}";`,`offset += ${h-i};`,n.$[e][t]||n.$[e].ubo),d=!0;break}if(!d)if(u.data.size>1)h=u.offset/4,a.push(r(u,h-i));else{const e=s[u.data.type];h=u.offset/4,a.push(`\n                    v = uv.${c};\n                    offset += ${h-i};\n                    ${e};\n                `)}i=h}const o=a.join("\n");return new Function("uv","data","dataInt32","offset",o)}},1266(e,t,r){function n(e,t){return`\n        for (let i = 0; i < ${e*t}; i++) {\n            data[offset + (((i / ${e})|0) * 4) + (i % ${e})] = v[i];\n        }\n    `}r.d(t,{_:()=>a,g:()=>s});const s={f32:"\n        data[offset] = v;",i32:"\n        dataInt32[offset] = v;","vec2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];","vec3<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];","vec4<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];","vec2<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];","vec3<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];","vec4<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];","mat2x2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];","mat3x3<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];","mat4x4<f32>":"\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }","mat3x2<f32>":n(3,2),"mat4x2<f32>":n(4,2),"mat2x3<f32>":n(2,3),"mat4x3<f32>":n(4,3),"mat2x4<f32>":n(2,4),"mat3x4<f32>":n(3,4)},a={...s,"mat2x2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    "}},8166(e,t,r){r.d(t,{$:()=>n});const n=[{type:"mat3x3<f32>",test:e=>void 0!==e.value.a,ubo:"\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        ",uniform:"\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        "},{type:"vec4<f32>",test:e=>"vec4<f32>"===e.type&&1===e.size&&void 0!==e.value.width,ubo:"\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        "},{type:"vec2<f32>",test:e=>"vec2<f32>"===e.type&&1===e.size&&void 0!==e.value.x,ubo:"\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        "},{type:"vec4<f32>",test:e=>"vec4<f32>"===e.type&&1===e.size&&void 0!==e.value.red,ubo:"\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        "},{type:"vec3<f32>",test:e=>"vec3<f32>"===e.type&&1===e.size&&void 0!==e.value.red,ubo:"\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        "}]}}]);