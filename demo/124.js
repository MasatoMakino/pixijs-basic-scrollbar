"use strict";(self.webpackChunk_masatomakino_pixijs_basic_scrollbar=self.webpackChunk_masatomakino_pixijs_basic_scrollbar||[]).push([[124],{4687:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/ResizePlugin.mjs\n\n\n"use strict";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      "resizeTo",\n      /**\n       * The HTML element or window to automatically resize the\n       * renderer\'s view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */\n      {\n        set(dom) {\n          globalThis.removeEventListener("resize", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener("resize", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener("resize", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = Extensions/* ExtensionType */.nw.Application;\n\n\n//# sourceMappingURL=ResizePlugin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(901);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(9366);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/TickerPlugin.mjs\n\n\n\n\n"use strict";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      "ticker",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, ticker_const/* UPDATE_PRIORITY */.u.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker/* Ticker */.v.shared : new Ticker/* Ticker */.v();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = Extensions/* ExtensionType */.nw.Application;\n\n\n//# sourceMappingURL=TickerPlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(ResizePlugin);\nExtensions/* extensions */.Rw.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWE7O0FBRWQ7QUFDeEI7Ozs7Ozs7QUN4RjZEO0FBQ1A7QUFDUjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUNBQWU7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFNLGNBQWMsb0JBQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFhOztBQUVkO0FBQ3hCOzs7QUNoRTBEO0FBQ1I7QUFDQTs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxZQUFZO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9SZXNpemVQbHVnaW4ubWpzPzg3MDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9UaWNrZXJQbHVnaW4ubWpzPzMzYmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9pbml0Lm1qcz82MDcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJyZXNpemVUb1wiLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSFRNTCBlbGVtZW50IG9yIHdpbmRvdyB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB0aGVcbiAgICAgICAqIHJlbmRlcmVyJ3MgdmlldyBlbGVtZW50IHRvIG1hdGNoIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgKiBAbWVtYmVyIHtXaW5kb3d8SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAbmFtZSByZXNpemVUb1xuICAgICAgICogQG1lbWJlcm9mIGFwcC5BcHBsaWNhdGlvbiNcbiAgICAgICAqL1xuICAgICAge1xuICAgICAgICBzZXQoZG9tKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gZG9tO1xuICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jYW5jZWxSZXNpemUoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgIH07XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Jlc2l6ZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3Jlc2l6ZUlkKTtcbiAgICAgICAgdGhpcy5fcmVzaXplSWQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc2l6ZVRvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbmNlbFJlc2l6ZSgpO1xuICAgICAgbGV0IHdpZHRoO1xuICAgICAgbGV0IGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpIHtcbiAgICAgICAgd2lkdGggPSBnbG9iYWxUaGlzLmlubmVyV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGdsb2JhbFRoaXMuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB3aWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBvcHRpb25zLnJlc2l6ZVRvIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5xdWV1ZVJlc2l6ZSk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplKCk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZVRvID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5SZXNpemVQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgUmVzaXplUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi4vdGlja2VyL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tICcuLi90aWNrZXIvVGlja2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGlja2VyUGx1Z2luIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHBsdWdpbiB3aXRoIHNjb3BlIG9mIGFwcGxpY2F0aW9uIGluc3RhbmNlXG4gICAqIEBzdGF0aWNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFNlZSBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAqL1xuICBzdGF0aWMgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgICAgc2hhcmVkVGlja2VyOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICBcInRpY2tlclwiLFxuICAgICAge1xuICAgICAgICBzZXQodGlja2VyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5fdGlja2VyLnJlbW92ZSh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICB0aWNrZXIuYWRkKHRoaXMucmVuZGVyLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuTE9XKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnN0b3AgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xuICAgIH07XG4gICAgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xuICAgIH07XG4gICAgdGhpcy5fdGlja2VyID0gbnVsbDtcbiAgICB0aGlzLnRpY2tlciA9IG9wdGlvbnMuc2hhcmVkVGlja2VyID8gVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXIoKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvbi5cbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgY29uc3Qgb2xkVGlja2VyID0gdGhpcy5fdGlja2VyO1xuICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgb2xkVGlja2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgVGlja2VyUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVzaXplUGx1Z2luIH0gZnJvbSAnLi9SZXNpemVQbHVnaW4ubWpzJztcbmltcG9ydCB7IFRpY2tlclBsdWdpbiB9IGZyb20gJy4vVGlja2VyUGx1Z2luLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoUmVzaXplUGx1Z2luKTtcbmV4dGVuc2lvbnMuYWRkKFRpY2tlclBsdWdpbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4687\n')},9249:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterPipe.mjs\n\n\n"use strict";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      canBundle: false,\n      action: "pushFilter",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      action: "popFilter",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === "pushFilter") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === "popFilter") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs + 2 modules\nvar Geometry = __webpack_require__(1980);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(2692);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.y();\nfunction getFastGlobalBounds(target, bounds) {\n  bounds.clear();\n  _getGlobalBoundsRecursive(target, bounds);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  if (!target.isRenderGroupRoot) {\n    bounds.applyMatrix(target.renderGroup.worldTransform);\n  } else {\n    bounds.applyMatrix(target.renderGroup.localTransform);\n  }\n  return bounds;\n}\nfunction _getGlobalBoundsRecursive(target, bounds) {\n  if (target.localDisplayStatus !== 7 || !target.measurable) {\n    return;\n  }\n  const manageEffects = !!target.effects.length;\n  let localBounds = bounds;\n  if (target.isRenderGroupRoot || manageEffects) {\n    localBounds = matrixAndBoundsPool/* boundsPool */.W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, target.worldTransform);\n  } else {\n    if (target.renderPipeId) {\n      const viewBounds = target.bounds;\n      localBounds.addFrame(\n        viewBounds.minX,\n        viewBounds.minY,\n        viewBounds.maxX,\n        viewBounds.maxY,\n        target.groupTransform\n      );\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getGlobalBoundsRecursive(children[i], localBounds);\n    }\n  }\n  if (manageEffects) {\n    let advanced = false;\n    for (let i = 0; i < target.effects.length; i++) {\n      if (target.effects[i].addBounds) {\n        if (!advanced) {\n          advanced = true;\n          localBounds.applyMatrix(target.renderGroup.worldTransform);\n        }\n        target.effects[i].addBounds(localBounds, true);\n      }\n    }\n    if (advanced) {\n      localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n      bounds.addBounds(localBounds, target.relativeGroupTransform);\n    }\n    bounds.addBounds(localBounds);\n    matrixAndBoundsPool/* boundsPool */.W.return(localBounds);\n  } else if (target.isRenderGroupRoot) {\n    bounds.addBounds(localBounds, target.relativeGroupTransform);\n    matrixAndBoundsPool/* boundsPool */.W.return(localBounds);\n  }\n}\n\n\n//# sourceMappingURL=getFastGlobalBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs\n\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    renderable.addBounds(bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getRenderableBounds.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst quadGeometry = new Geometry/* Geometry */.Z({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      location: 0,\n      format: "float32x2",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup/* UniformGroup */.o({\n      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }\n    });\n    this._globalFilterBindGroup = new BindGroup/* BindGroup */.v({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n    let resolution = colorTextureSource._resolution;\n    let padding = 0;\n    let antialias = colorTextureSource.antialias;\n    let blendRequired = false;\n    let enabled = false;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias !== "inherit") {\n        if (filter.antialias === "on") {\n          antialias = true;\n        } else {\n          antialias = false;\n        }\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        (0,warn/* warn */.Z)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    bounds.scale(resolution).fit(renderer.renderTarget.rootViewPort).scale(1 / resolution).pad(padding).ceil();\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool/* TexturePool */.z.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      resolution,\n      antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture/* Texture */.x.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.z.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool/* TexturePool */.z.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.z.returnTexture(flip);\n      TexturePool/* TexturePool */.z.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool/* TexturePool */.z.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool/* TexturePool */.z.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point/* Point */.E.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture/* Texture */.x) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: "triangle-list"\n    });\n    if (renderer.type === types/* RendererType */.g.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds/* Bounds */.Y(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix/* Matrix */.y.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(FilterSystem);\nExtensions/* extensions */.Rw.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQix5QkFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQkFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRXdCO0FBQ3hCOzs7QUN0VjBEO0FBQ1o7QUFDSTs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxVQUFVO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvRmlsdGVyUGlwZS5tanM/NTg5MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRGYXN0R2xvYmFsQm91bmRzLm1qcz9hZWJiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldFJlbmRlcmFibGVCb3VuZHMubWpzPzI4N2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcz81ZTg4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL2luaXQubWpzP2Y3ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEZpbHRlclBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgcHVzaChmaWx0ZXJFZmZlY3QsIGNvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCByZW5kZXJQaXBlcyA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzO1xuICAgIHJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcImZpbHRlclwiLFxuICAgICAgY2FuQnVuZGxlOiBmYWxzZSxcbiAgICAgIGFjdGlvbjogXCJwdXNoRmlsdGVyXCIsXG4gICAgICBjb250YWluZXIsXG4gICAgICBmaWx0ZXJFZmZlY3RcbiAgICB9KTtcbiAgfVxuICBwb3AoX2ZpbHRlckVmZmVjdCwgX2NvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgIHJlbmRlclBpcGVJZDogXCJmaWx0ZXJcIixcbiAgICAgIGFjdGlvbjogXCJwb3BGaWx0ZXJcIixcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBleGVjdXRlKGluc3RydWN0aW9uKSB7XG4gICAgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwdXNoRmlsdGVyXCIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZpbHRlci5wdXNoKGluc3RydWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwb3BGaWx0ZXJcIikge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuRmlsdGVyUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiZmlsdGVyXCJcbn07XG5cbmV4cG9ydCB7IEZpbHRlclBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlclBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgYm91bmRzUG9vbCB9IGZyb20gJy4vdXRpbHMvbWF0cml4QW5kQm91bmRzUG9vbC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5mdW5jdGlvbiBnZXRGYXN0R2xvYmFsQm91bmRzKHRhcmdldCwgYm91bmRzKSB7XG4gIGJvdW5kcy5jbGVhcigpO1xuICBfZ2V0R2xvYmFsQm91bmRzUmVjdXJzaXZlKHRhcmdldCwgYm91bmRzKTtcbiAgaWYgKCFib3VuZHMuaXNWYWxpZCkge1xuICAgIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7XG4gIH1cbiAgaWYgKCF0YXJnZXQuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICBib3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICBib3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnJlbmRlckdyb3VwLmxvY2FsVHJhbnNmb3JtKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuZnVuY3Rpb24gX2dldEdsb2JhbEJvdW5kc1JlY3Vyc2l2ZSh0YXJnZXQsIGJvdW5kcykge1xuICBpZiAodGFyZ2V0LmxvY2FsRGlzcGxheVN0YXR1cyAhPT0gNyB8fCAhdGFyZ2V0Lm1lYXN1cmFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWFuYWdlRWZmZWN0cyA9ICEhdGFyZ2V0LmVmZmVjdHMubGVuZ3RoO1xuICBsZXQgbG9jYWxCb3VuZHMgPSBib3VuZHM7XG4gIGlmICh0YXJnZXQuaXNSZW5kZXJHcm91cFJvb3QgfHwgbWFuYWdlRWZmZWN0cykge1xuICAgIGxvY2FsQm91bmRzID0gYm91bmRzUG9vbC5nZXQoKS5jbGVhcigpO1xuICB9XG4gIGlmICh0YXJnZXQuYm91bmRzQXJlYSkge1xuICAgIGJvdW5kcy5hZGRSZWN0KHRhcmdldC5ib3VuZHNBcmVhLCB0YXJnZXQud29ybGRUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQucmVuZGVyUGlwZUlkKSB7XG4gICAgICBjb25zdCB2aWV3Qm91bmRzID0gdGFyZ2V0LmJvdW5kcztcbiAgICAgIGxvY2FsQm91bmRzLmFkZEZyYW1lKFxuICAgICAgICB2aWV3Qm91bmRzLm1pblgsXG4gICAgICAgIHZpZXdCb3VuZHMubWluWSxcbiAgICAgICAgdmlld0JvdW5kcy5tYXhYLFxuICAgICAgICB2aWV3Qm91bmRzLm1heFksXG4gICAgICAgIHRhcmdldC5ncm91cFRyYW5zZm9ybVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgX2dldEdsb2JhbEJvdW5kc1JlY3Vyc2l2ZShjaGlsZHJlbltpXSwgbG9jYWxCb3VuZHMpO1xuICAgIH1cbiAgfVxuICBpZiAobWFuYWdlRWZmZWN0cykge1xuICAgIGxldCBhZHZhbmNlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YXJnZXQuZWZmZWN0c1tpXS5hZGRCb3VuZHMpIHtcbiAgICAgICAgaWYgKCFhZHZhbmNlZCkge1xuICAgICAgICAgIGFkdmFuY2VkID0gdHJ1ZTtcbiAgICAgICAgICBsb2NhbEJvdW5kcy5hcHBseU1hdHJpeCh0YXJnZXQucmVuZGVyR3JvdXAud29ybGRUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5lZmZlY3RzW2ldLmFkZEJvdW5kcyhsb2NhbEJvdW5kcywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhZHZhbmNlZCkge1xuICAgICAgbG9jYWxCb3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtLmNvcHlUbyh0ZW1wTWF0cml4KS5pbnZlcnQoKSk7XG4gICAgICBib3VuZHMuYWRkQm91bmRzKGxvY2FsQm91bmRzLCB0YXJnZXQucmVsYXRpdmVHcm91cFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGJvdW5kcy5hZGRCb3VuZHMobG9jYWxCb3VuZHMpO1xuICAgIGJvdW5kc1Bvb2wucmV0dXJuKGxvY2FsQm91bmRzKTtcbiAgfSBlbHNlIGlmICh0YXJnZXQuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICBib3VuZHMuYWRkQm91bmRzKGxvY2FsQm91bmRzLCB0YXJnZXQucmVsYXRpdmVHcm91cFRyYW5zZm9ybSk7XG4gICAgYm91bmRzUG9vbC5yZXR1cm4obG9jYWxCb3VuZHMpO1xuICB9XG59XG5cbmV4cG9ydCB7IF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUsIGdldEZhc3RHbG9iYWxCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEZhc3RHbG9iYWxCb3VuZHMubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzKHJlbmRlcmFibGVzLCBib3VuZHMpIHtcbiAgYm91bmRzLmNsZWFyKCk7XG4gIGNvbnN0IHRlbXBNYXRyaXggPSBib3VuZHMubWF0cml4O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVuZGVyYWJsZSA9IHJlbmRlcmFibGVzW2ldO1xuICAgIGlmIChyZW5kZXJhYmxlLmdsb2JhbERpc3BsYXlTdGF0dXMgPCA3KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYm91bmRzLm1hdHJpeCA9IHJlbmRlcmFibGUud29ybGRUcmFuc2Zvcm07XG4gICAgcmVuZGVyYWJsZS5hZGRCb3VuZHMoYm91bmRzKTtcbiAgfVxuICBib3VuZHMubWF0cml4ID0gdGVtcE1hdHJpeDtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZXhwb3J0IHsgZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0UmVuZGVyYWJsZUJvdW5kcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyBCaW5kR3JvdXAgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvQmluZEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvdHlwZXMubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBnZXRGYXN0R2xvYmFsQm91bmRzIH0gZnJvbSAnLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRGYXN0R2xvYmFsQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzIH0gZnJvbSAnLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRSZW5kZXJhYmxlQm91bmRzLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgcXVhZEdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KHtcbiAgYXR0cmlidXRlczoge1xuICAgIGFQb3NpdGlvbjoge1xuICAgICAgYnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSksXG4gICAgICBsb2NhdGlvbjogMCxcbiAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgIHN0cmlkZTogMiAqIDQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9XG4gIH0sXG4gIGluZGV4QnVmZmVyOiBuZXcgVWludDMyQXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKVxufSk7XG5jbGFzcyBGaWx0ZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2ZpbHRlclN0YWNrSW5kZXggPSAwO1xuICAgIHRoaXMuX2ZpbHRlclN0YWNrID0gW107XG4gICAgdGhpcy5fZmlsdGVyR2xvYmFsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVJbnB1dFNpemU6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoNCksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVJbnB1dFBpeGVsOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1SW5wdXRDbGFtcDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdU91dHB1dEZyYW1lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1R2xvYmFsRnJhbWU6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoNCksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVPdXRwdXRUZXh0dXJlOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH1cbiAgICB9KTtcbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAgPSBuZXcgQmluZEdyb3VwKHt9KTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYWNrIHRleHR1cmUgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyLiBSZXF1aXJlcyB0aGUgZmlsdGVyIHRvIGhhdmUgYGJsZW5kUmVxdWlyZWRgIHNldCB0byB0cnVlLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBhY3RpdmVCYWNrVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlRmlsdGVyRGF0YT8uYmFja1RleHR1cmU7XG4gIH1cbiAgcHVzaChpbnN0cnVjdGlvbikge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBmaWx0ZXJzID0gaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0LmZpbHRlcnM7XG4gICAgaWYgKCF0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4XSkge1xuICAgICAgdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF0gPSB0aGlzLl9nZXRGaWx0ZXJEYXRhKCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckRhdGEgPSB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4XTtcbiAgICB0aGlzLl9maWx0ZXJTdGFja0luZGV4Kys7XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmaWx0ZXJEYXRhLnNraXAgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBib3VuZHMgPSBmaWx0ZXJEYXRhLmJvdW5kcztcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ucmVuZGVyYWJsZXMpIHtcbiAgICAgIGdldEdsb2JhbFJlbmRlcmFibGVCb3VuZHMoaW5zdHJ1Y3Rpb24ucmVuZGVyYWJsZXMsIGJvdW5kcyk7XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5maWx0ZXJFZmZlY3QuZmlsdGVyQXJlYSkge1xuICAgICAgYm91bmRzLmNsZWFyKCk7XG4gICAgICBib3VuZHMuYWRkUmVjdChpbnN0cnVjdGlvbi5maWx0ZXJFZmZlY3QuZmlsdGVyQXJlYSk7XG4gICAgICBib3VuZHMuYXBwbHlNYXRyaXgoaW5zdHJ1Y3Rpb24uY29udGFpbmVyLndvcmxkVHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0RmFzdEdsb2JhbEJvdW5kcyhpbnN0cnVjdGlvbi5jb250YWluZXIsIGJvdW5kcyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yVGV4dHVyZVNvdXJjZSA9IHJlbmRlcmVyLnJlbmRlclRhcmdldC5yb290UmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZS5zb3VyY2U7XG4gICAgbGV0IHJlc29sdXRpb24gPSBjb2xvclRleHR1cmVTb3VyY2UuX3Jlc29sdXRpb247XG4gICAgbGV0IHBhZGRpbmcgPSAwO1xuICAgIGxldCBhbnRpYWxpYXMgPSBjb2xvclRleHR1cmVTb3VyY2UuYW50aWFsaWFzO1xuICAgIGxldCBibGVuZFJlcXVpcmVkID0gZmFsc2U7XG4gICAgbGV0IGVuYWJsZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpbHRlciA9IGZpbHRlcnNbaV07XG4gICAgICByZXNvbHV0aW9uID0gTWF0aC5taW4ocmVzb2x1dGlvbiwgZmlsdGVyLnJlc29sdXRpb24pO1xuICAgICAgcGFkZGluZyArPSBmaWx0ZXIucGFkZGluZztcbiAgICAgIGlmIChmaWx0ZXIuYW50aWFsaWFzICE9PSBcImluaGVyaXRcIikge1xuICAgICAgICBpZiAoZmlsdGVyLmFudGlhbGlhcyA9PT0gXCJvblwiKSB7XG4gICAgICAgICAgYW50aWFsaWFzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbnRpYWxpYXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaXNDb21wYXRpYmxlID0gISEoZmlsdGVyLmNvbXBhdGlibGVSZW5kZXJlcnMgJiByZW5kZXJlci50eXBlKTtcbiAgICAgIGlmICghaXNDb21wYXRpYmxlKSB7XG4gICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLmJsZW5kUmVxdWlyZWQgJiYgIShyZW5kZXJlci5iYWNrQnVmZmVyPy51c2VCYWNrQnVmZmVyID8/IHRydWUpKSB7XG4gICAgICAgIHdhcm4oXCJCbGVuZCBmaWx0ZXIgcmVxdWlyZXMgYmFja0J1ZmZlciBvbiBXZWJHTCByZW5kZXJlciB0byBiZSBlbmFibGVkLiBTZXQgYHVzZUJhY2tCdWZmZXI6IHRydWVgIGluIHRoZSByZW5kZXJlciBvcHRpb25zLlwiKTtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVuYWJsZWQgPSBmaWx0ZXIuZW5hYmxlZCB8fCBlbmFibGVkO1xuICAgICAgYmxlbmRSZXF1aXJlZCA9IGJsZW5kUmVxdWlyZWQgfHwgZmlsdGVyLmJsZW5kUmVxdWlyZWQ7XG4gICAgfVxuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgZmlsdGVyRGF0YS5za2lwID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYm91bmRzLnNjYWxlKHJlc29sdXRpb24pLmZpdChyZW5kZXJlci5yZW5kZXJUYXJnZXQucm9vdFZpZXdQb3J0KS5zY2FsZSgxIC8gcmVzb2x1dGlvbikucGFkKHBhZGRpbmcpLmNlaWwoKTtcbiAgICBpZiAoIWJvdW5kcy5pc1Bvc2l0aXZlKSB7XG4gICAgICBmaWx0ZXJEYXRhLnNraXAgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWx0ZXJEYXRhLnNraXAgPSBmYWxzZTtcbiAgICBmaWx0ZXJEYXRhLmJvdW5kcyA9IGJvdW5kcztcbiAgICBmaWx0ZXJEYXRhLmJsZW5kUmVxdWlyZWQgPSBibGVuZFJlcXVpcmVkO1xuICAgIGZpbHRlckRhdGEuY29udGFpbmVyID0gaW5zdHJ1Y3Rpb24uY29udGFpbmVyO1xuICAgIGZpbHRlckRhdGEuZmlsdGVyRWZmZWN0ID0gaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0O1xuICAgIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclN1cmZhY2U7XG4gICAgZmlsdGVyRGF0YS5pbnB1dFRleHR1cmUgPSBUZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgYW50aWFsaWFzXG4gICAgKTtcbiAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuYmluZChmaWx0ZXJEYXRhLmlucHV0VGV4dHVyZSwgdHJ1ZSk7XG4gICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucHVzaCh7XG4gICAgICBvZmZzZXQ6IGJvdW5kc1xuICAgIH0pO1xuICB9XG4gIHBvcCgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5fZmlsdGVyU3RhY2tJbmRleC0tO1xuICAgIGNvbnN0IGZpbHRlckRhdGEgPSB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4XTtcbiAgICBpZiAoZmlsdGVyRGF0YS5za2lwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUZpbHRlckRhdGEgPSBmaWx0ZXJEYXRhO1xuICAgIGNvbnN0IGlucHV0VGV4dHVyZSA9IGZpbHRlckRhdGEuaW5wdXRUZXh0dXJlO1xuICAgIGNvbnN0IGJvdW5kcyA9IGZpbHRlckRhdGEuYm91bmRzO1xuICAgIGxldCBiYWNrVGV4dHVyZSA9IFRleHR1cmUuRU1QVFk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmZpbmlzaFJlbmRlclBhc3MoKTtcbiAgICBpZiAoZmlsdGVyRGF0YS5ibGVuZFJlcXVpcmVkKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0JvdW5kcyA9IHRoaXMuX2ZpbHRlclN0YWNrSW5kZXggPiAwID8gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleCAtIDFdLmJvdW5kcyA6IG51bGw7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQuZ2V0UmVuZGVyVGFyZ2V0KGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlKTtcbiAgICAgIGJhY2tUZXh0dXJlID0gdGhpcy5nZXRCYWNrVGV4dHVyZShyZW5kZXJUYXJnZXQsIGJvdW5kcywgcHJldmlvdXNCb3VuZHMpO1xuICAgIH1cbiAgICBmaWx0ZXJEYXRhLmJhY2tUZXh0dXJlID0gYmFja1RleHR1cmU7XG4gICAgY29uc3QgZmlsdGVycyA9IGZpbHRlckRhdGEuZmlsdGVyRWZmZWN0LmZpbHRlcnM7XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGlucHV0VGV4dHVyZS5zb3VyY2Uuc3R5bGUsIDIpO1xuICAgIHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cC5zZXRSZXNvdXJjZShiYWNrVGV4dHVyZS5zb3VyY2UsIDMpO1xuICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnBvcCgpO1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsdGVyc1swXS5hcHBseSh0aGlzLCBpbnB1dFRleHR1cmUsIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlLCBmYWxzZSk7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGlucHV0VGV4dHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBmbGlwID0gZmlsdGVyRGF0YS5pbnB1dFRleHR1cmU7XG4gICAgICBsZXQgZmxvcCA9IFRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKFxuICAgICAgICBib3VuZHMud2lkdGgsXG4gICAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICAgIGZsaXAuc291cmNlLl9yZXNvbHV0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgICBmaWx0ZXIuYXBwbHkodGhpcywgZmxpcCwgZmxvcCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHQgPSBmbGlwO1xuICAgICAgICBmbGlwID0gZmxvcDtcbiAgICAgICAgZmxvcCA9IHQ7XG4gICAgICB9XG4gICAgICBmaWx0ZXJzW2ldLmFwcGx5KHRoaXMsIGZsaXAsIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlLCBmYWxzZSk7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGZsaXApO1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShmbG9wKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlckRhdGEuYmxlbmRSZXF1aXJlZCkge1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShiYWNrVGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIGdldEJhY2tUZXh0dXJlKGxhc3RSZW5kZXJTdXJmYWNlLCBib3VuZHMsIHByZXZpb3VzQm91bmRzKSB7XG4gICAgY29uc3QgYmFja2dyb3VuZFJlc29sdXRpb24gPSBsYXN0UmVuZGVyU3VyZmFjZS5jb2xvclRleHR1cmUuc291cmNlLl9yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGJhY2tUZXh0dXJlID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgICBib3VuZHMud2lkdGgsXG4gICAgICBib3VuZHMuaGVpZ2h0LFxuICAgICAgYmFja2dyb3VuZFJlc29sdXRpb24sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgbGV0IHggPSBib3VuZHMubWluWDtcbiAgICBsZXQgeSA9IGJvdW5kcy5taW5ZO1xuICAgIGlmIChwcmV2aW91c0JvdW5kcykge1xuICAgICAgeCAtPSBwcmV2aW91c0JvdW5kcy5taW5YO1xuICAgICAgeSAtPSBwcmV2aW91c0JvdW5kcy5taW5ZO1xuICAgIH1cbiAgICB4ID0gTWF0aC5mbG9vcih4ICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIHkgPSBNYXRoLmZsb29yKHkgKiBiYWNrZ3JvdW5kUmVzb2x1dGlvbik7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0ICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGFyZ2V0LmNvcHlUb1RleHR1cmUoXG4gICAgICBsYXN0UmVuZGVyU3VyZmFjZSxcbiAgICAgIGJhY2tUZXh0dXJlLFxuICAgICAgeyB4LCB5IH0sXG4gICAgICB7IHdpZHRoLCBoZWlnaHQgfSxcbiAgICAgIHsgeDogMCwgeTogMCB9XG4gICAgKTtcbiAgICByZXR1cm4gYmFja1RleHR1cmU7XG4gIH1cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBmaWx0ZXJEYXRhID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF07XG4gICAgY29uc3QgYm91bmRzID0gZmlsdGVyRGF0YS5ib3VuZHM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gUG9pbnQuc2hhcmVkO1xuICAgIGNvbnN0IHByZXZpb3VzUmVuZGVyU3VyZmFjZSA9IGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlO1xuICAgIGNvbnN0IGlzRmluYWxUYXJnZXQgPSBwcmV2aW91c1JlbmRlclN1cmZhY2UgPT09IG91dHB1dDtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJvb3RSZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlLnNvdXJjZS5fcmVzb2x1dGlvbjtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5fZmlsdGVyU3RhY2tJbmRleCAtIDE7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA+IDAgJiYgdGhpcy5fZmlsdGVyU3RhY2tbY3VycmVudEluZGV4XS5za2lwKSB7XG4gICAgICAtLWN1cnJlbnRJbmRleDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRJbmRleCA+IDApIHtcbiAgICAgIHJlc29sdXRpb24gPSB0aGlzLl9maWx0ZXJTdGFja1tjdXJyZW50SW5kZXhdLmlucHV0VGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclVuaWZvcm1zID0gdGhpcy5fZmlsdGVyR2xvYmFsVW5pZm9ybXM7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBmaWx0ZXJVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBjb25zdCBvdXRwdXRGcmFtZSA9IHVuaWZvcm1zLnVPdXRwdXRGcmFtZTtcbiAgICBjb25zdCBpbnB1dFNpemUgPSB1bmlmb3Jtcy51SW5wdXRTaXplO1xuICAgIGNvbnN0IGlucHV0UGl4ZWwgPSB1bmlmb3Jtcy51SW5wdXRQaXhlbDtcbiAgICBjb25zdCBpbnB1dENsYW1wID0gdW5pZm9ybXMudUlucHV0Q2xhbXA7XG4gICAgY29uc3QgZ2xvYmFsRnJhbWUgPSB1bmlmb3Jtcy51R2xvYmFsRnJhbWU7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZSA9IHVuaWZvcm1zLnVPdXRwdXRUZXh0dXJlO1xuICAgIGlmIChpc0ZpbmFsVGFyZ2V0KSB7XG4gICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5fZmlsdGVyU3RhY2tJbmRleDtcbiAgICAgIHdoaWxlIChsYXN0SW5kZXggPiAwKSB7XG4gICAgICAgIGxhc3RJbmRleC0tO1xuICAgICAgICBjb25zdCBmaWx0ZXJEYXRhMiA9IHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXggLSAxXTtcbiAgICAgICAgaWYgKCFmaWx0ZXJEYXRhMi5za2lwKSB7XG4gICAgICAgICAgb2Zmc2V0LnggPSBmaWx0ZXJEYXRhMi5ib3VuZHMubWluWDtcbiAgICAgICAgICBvZmZzZXQueSA9IGZpbHRlckRhdGEyLmJvdW5kcy5taW5ZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXRwdXRGcmFtZVswXSA9IGJvdW5kcy5taW5YIC0gb2Zmc2V0Lng7XG4gICAgICBvdXRwdXRGcmFtZVsxXSA9IGJvdW5kcy5taW5ZIC0gb2Zmc2V0Lnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dEZyYW1lWzBdID0gMDtcbiAgICAgIG91dHB1dEZyYW1lWzFdID0gMDtcbiAgICB9XG4gICAgb3V0cHV0RnJhbWVbMl0gPSBpbnB1dC5mcmFtZS53aWR0aDtcbiAgICBvdXRwdXRGcmFtZVszXSA9IGlucHV0LmZyYW1lLmhlaWdodDtcbiAgICBpbnB1dFNpemVbMF0gPSBpbnB1dC5zb3VyY2Uud2lkdGg7XG4gICAgaW5wdXRTaXplWzFdID0gaW5wdXQuc291cmNlLmhlaWdodDtcbiAgICBpbnB1dFNpemVbMl0gPSAxIC8gaW5wdXRTaXplWzBdO1xuICAgIGlucHV0U2l6ZVszXSA9IDEgLyBpbnB1dFNpemVbMV07XG4gICAgaW5wdXRQaXhlbFswXSA9IGlucHV0LnNvdXJjZS5waXhlbFdpZHRoO1xuICAgIGlucHV0UGl4ZWxbMV0gPSBpbnB1dC5zb3VyY2UucGl4ZWxIZWlnaHQ7XG4gICAgaW5wdXRQaXhlbFsyXSA9IDEgLyBpbnB1dFBpeGVsWzBdO1xuICAgIGlucHV0UGl4ZWxbM10gPSAxIC8gaW5wdXRQaXhlbFsxXTtcbiAgICBpbnB1dENsYW1wWzBdID0gMC41ICogaW5wdXRQaXhlbFsyXTtcbiAgICBpbnB1dENsYW1wWzFdID0gMC41ICogaW5wdXRQaXhlbFszXTtcbiAgICBpbnB1dENsYW1wWzJdID0gaW5wdXQuZnJhbWUud2lkdGggKiBpbnB1dFNpemVbMl0gLSAwLjUgKiBpbnB1dFBpeGVsWzJdO1xuICAgIGlucHV0Q2xhbXBbM10gPSBpbnB1dC5mcmFtZS5oZWlnaHQgKiBpbnB1dFNpemVbM10gLSAwLjUgKiBpbnB1dFBpeGVsWzNdO1xuICAgIGNvbnN0IHJvb3RUZXh0dXJlID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUYXJnZXQucm9vdFJlbmRlclRhcmdldC5jb2xvclRleHR1cmU7XG4gICAgZ2xvYmFsRnJhbWVbMF0gPSBvZmZzZXQueCAqIHJlc29sdXRpb247XG4gICAgZ2xvYmFsRnJhbWVbMV0gPSBvZmZzZXQueSAqIHJlc29sdXRpb247XG4gICAgZ2xvYmFsRnJhbWVbMl0gPSByb290VGV4dHVyZS5zb3VyY2Uud2lkdGggKiByZXNvbHV0aW9uO1xuICAgIGdsb2JhbEZyYW1lWzNdID0gcm9vdFRleHR1cmUuc291cmNlLmhlaWdodCAqIHJlc29sdXRpb247XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUYXJnZXQuZ2V0UmVuZGVyVGFyZ2V0KG91dHB1dCk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmJpbmQob3V0cHV0LCAhIWNsZWFyKTtcbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgb3V0cHV0VGV4dHVyZVswXSA9IG91dHB1dC5mcmFtZS53aWR0aDtcbiAgICAgIG91dHB1dFRleHR1cmVbMV0gPSBvdXRwdXQuZnJhbWUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRUZXh0dXJlWzBdID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgICAgb3V0cHV0VGV4dHVyZVsxXSA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG4gICAgfVxuICAgIG91dHB1dFRleHR1cmVbMl0gPSByZW5kZXJUYXJnZXQuaXNSb290ID8gLTEgOiAxO1xuICAgIGZpbHRlclVuaWZvcm1zLnVwZGF0ZSgpO1xuICAgIGlmIChyZW5kZXJlci5yZW5kZXJQaXBlcy51bmlmb3JtQmF0Y2gpIHtcbiAgICAgIGNvbnN0IGJhdGNoVW5pZm9ybXMgPSByZW5kZXJlci5yZW5kZXJQaXBlcy51bmlmb3JtQmF0Y2guZ2V0VWJvUmVzb3VyY2UoZmlsdGVyVW5pZm9ybXMpO1xuICAgICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGJhdGNoVW5pZm9ybXMsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoZmlsdGVyVW5pZm9ybXMsIDApO1xuICAgIH1cbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoaW5wdXQuc291cmNlLCAxKTtcbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoaW5wdXQuc291cmNlLnN0eWxlLCAyKTtcbiAgICBmaWx0ZXIuZ3JvdXBzWzBdID0gdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwO1xuICAgIHJlbmRlcmVyLmVuY29kZXIuZHJhdyh7XG4gICAgICBnZW9tZXRyeTogcXVhZEdlb21ldHJ5LFxuICAgICAgc2hhZGVyOiBmaWx0ZXIsXG4gICAgICBzdGF0ZTogZmlsdGVyLl9zdGF0ZSxcbiAgICAgIHRvcG9sb2d5OiBcInRyaWFuZ2xlLWxpc3RcIlxuICAgIH0pO1xuICAgIGlmIChyZW5kZXJlci50eXBlID09PSBSZW5kZXJlclR5cGUuV0VCR0wpIHtcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5maW5pc2hSZW5kZXJQYXNzKCk7XG4gICAgfVxuICB9XG4gIF9nZXRGaWx0ZXJEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBza2lwOiBmYWxzZSxcbiAgICAgIGlucHV0VGV4dHVyZTogbnVsbCxcbiAgICAgIGJvdW5kczogbmV3IEJvdW5kcygpLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgZmlsdGVyRWZmZWN0OiBudWxsLFxuICAgICAgYmxlbmRSZXF1aXJlZDogZmFsc2UsXG4gICAgICBwcmV2aW91c1JlbmRlclN1cmZhY2U6IG51bGxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSBfaW5wdXQgbm9ybWFsaXplZCBjb29yZGluYXRlc18gdG8gdGhpcyBtYXRyaXggdG8gZ2V0IF9zcHJpdGUgdGV4dHVyZSBub3JtYWxpemVkIGNvb3JkaW5hdGVzXy5cbiAgICpcbiAgICogVXNlIGBvdXRwdXRNYXRyaXggKiB2VGV4dHVyZUNvb3JkYCBpbiB0aGUgc2hhZGVyLlxuICAgKiBAcGFyYW0gb3V0cHV0TWF0cml4IC0gVGhlIG1hdHJpeCB0byBvdXRwdXQgdG8uXG4gICAqIEBwYXJhbSB7U3ByaXRlfSBzcHJpdGUgLSBUaGUgc3ByaXRlIHRvIG1hcCB0by5cbiAgICogQHJldHVybnMgVGhlIG1hcHBlZCBtYXRyaXguXG4gICAqL1xuICBjYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBzcHJpdGUpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fYWN0aXZlRmlsdGVyRGF0YTtcbiAgICBjb25zdCBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguc2V0KFxuICAgICAgZGF0YS5pbnB1dFRleHR1cmUuX3NvdXJjZS53aWR0aCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgZGF0YS5pbnB1dFRleHR1cmUuX3NvdXJjZS5oZWlnaHQsXG4gICAgICBkYXRhLmJvdW5kcy5taW5YLFxuICAgICAgZGF0YS5ib3VuZHMubWluWVxuICAgICk7XG4gICAgY29uc3Qgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm0uY29weVRvKE1hdHJpeC5zaGFyZWQpO1xuICAgIHdvcmxkVHJhbnNmb3JtLmludmVydCgpO1xuICAgIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKTtcbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoXG4gICAgICAxIC8gc3ByaXRlLnRleHR1cmUuZnJhbWUud2lkdGgsXG4gICAgICAxIC8gc3ByaXRlLnRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKHNwcml0ZS5hbmNob3IueCwgc3ByaXRlLmFuY2hvci55KTtcbiAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuRmlsdGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJmaWx0ZXJcIlxufTtcblxuZXhwb3J0IHsgRmlsdGVyU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgRmlsdGVyUGlwZSB9IGZyb20gJy4vRmlsdGVyUGlwZS5tanMnO1xuaW1wb3J0IHsgRmlsdGVyU3lzdGVtIH0gZnJvbSAnLi9GaWx0ZXJTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChGaWx0ZXJTeXN0ZW0pO1xuZXh0ZW5zaW9ucy5hZGQoRmlsdGVyUGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9249\n')},5774:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   y: () => (/* binding */ batchSamplersUniformGroup)\n/* harmony export */ });\n/* harmony import */ var _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4589);\n/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3870);\n\n\n\n"use strict";\nconst sampleValues = new Int32Array(_batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A);\nfor (let i = 0; i < _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A; i++) {\n  sampleValues[i] = i;\n}\nconst batchSamplersUniformGroup = new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__/* .UniformGroup */ .o({\n  uTextures: { value: sampleValues, type: `i32`, size: _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A }\n}, { isStatic: true });\n\n\n//# sourceMappingURL=batchSamplersUniformGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc3NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRTtBQUNHOztBQUVwRTtBQUNBLG9DQUFvQyw0RUFBWTtBQUNoRCxnQkFBZ0IsSUFBSSw0RUFBWSxFQUFFO0FBQ2xDO0FBQ0E7QUFDQSxzQ0FBc0Msa0ZBQVk7QUFDbEQsZUFBZSx3Q0FBd0MsNEVBQVk7QUFDbkUsQ0FBQyxJQUFJLGdCQUFnQjs7QUFFZ0I7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cC5tanM/NDQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNQVhfVEVYVFVSRVMgfSBmcm9tICcuLi8uLi8uLi9iYXRjaGVyL3NoYXJlZC9jb25zdC5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShNQVhfVEVYVFVSRVMpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfVEVYVFVSRVM7IGkrKykge1xuICBzYW1wbGVWYWx1ZXNbaV0gPSBpO1xufVxuY29uc3QgYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cCA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICB1VGV4dHVyZXM6IHsgdmFsdWU6IHNhbXBsZVZhbHVlcywgdHlwZTogYGkzMmAsIHNpemU6IE1BWF9URVhUVVJFUyB9XG59LCB7IGlzU3RhdGljOiB0cnVlIH0pO1xuXG5leHBvcnQgeyBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5774\n')},131:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ CanvasPool)\n/* harmony export */ });\n/* unused harmony export CanvasPoolClass */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4181);\n\n\n\n"use strict";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext("2d");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minWidth);\n    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const { width, height } = canvasAndContext.canvas;\n    const key = (width << 17) + (height << 1);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\n\n//# sourceMappingURL=CanvasPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRTtBQUNOOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0VBQVE7QUFDdkIsZ0JBQWdCLHdFQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanM/NGQwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgbmV4dFBvdzIgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9taXNjL3BvdzIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYW52YXNQb29sQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNPcHRpb25zKSB7XG4gICAgdGhpcy5fY2FudmFzUG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FudmFzT3B0aW9ucyA9IGNhbnZhc09wdGlvbnMgfHwge307XG4gICAgdGhpcy5lbmFibGVGdWxsU2NyZWVuID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGV4dHVyZSB3aXRoIHBhcmFtcyB0aGF0IHdlcmUgc3BlY2lmaWVkIGluIHBvb2wgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBwaXhlbFdpZHRoIC0gV2lkdGggb2YgdGV4dHVyZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSBwaXhlbEhlaWdodCAtIEhlaWdodCBvZiB0ZXh0dXJlIGluIHBpeGVscy5cbiAgICovXG4gIF9jcmVhdGVDYW52YXNBbmRDb250ZXh0KHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0KSB7XG4gICAgY29uc3QgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBwaXhlbFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwaXhlbEhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICByZXR1cm4geyBjYW52YXMsIGNvbnRleHQgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIFBvd2VyLW9mLVR3byByZW5kZXIgdGV4dHVyZSBvciBmdWxsU2NyZWVuIHRleHR1cmVcbiAgICogQHBhcmFtIG1pbldpZHRoIC0gVGhlIG1pbmltdW0gd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gbWluSGVpZ2h0IC0gVGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgcmVuZGVyIHRleHR1cmUuXG4gICAqL1xuICBnZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dChtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uID0gMSkge1xuICAgIG1pbldpZHRoID0gTWF0aC5jZWlsKG1pbldpZHRoICogcmVzb2x1dGlvbiAtIDFlLTYpO1xuICAgIG1pbkhlaWdodCA9IE1hdGguY2VpbChtaW5IZWlnaHQgKiByZXNvbHV0aW9uIC0gMWUtNik7XG4gICAgbWluV2lkdGggPSBuZXh0UG93MihtaW5XaWR0aCk7XG4gICAgbWluSGVpZ2h0ID0gbmV4dFBvdzIobWluSGVpZ2h0KTtcbiAgICBjb25zdCBrZXkgPSAobWluV2lkdGggPDwgMTcpICsgKG1pbkhlaWdodCA8PCAxKTtcbiAgICBpZiAoIXRoaXMuX2NhbnZhc1Bvb2xba2V5XSkge1xuICAgICAgdGhpcy5fY2FudmFzUG9vbFtrZXldID0gW107XG4gICAgfVxuICAgIGxldCBjYW52YXNBbmRDb250ZXh0ID0gdGhpcy5fY2FudmFzUG9vbFtrZXldLnBvcCgpO1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dCkge1xuICAgICAgY2FudmFzQW5kQ29udGV4dCA9IHRoaXMuX2NyZWF0ZUNhbnZhc0FuZENvbnRleHQobWluV2lkdGgsIG1pbkhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNBbmRDb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBQbGFjZSBhIHJlbmRlciB0ZXh0dXJlIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIGNhbnZhc0FuZENvbnRleHRcbiAgICovXG4gIHJldHVybkNhbnZhc0FuZENvbnRleHQoY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzQW5kQ29udGV4dC5jYW52YXM7XG4gICAgY29uc3Qga2V5ID0gKHdpZHRoIDw8IDE3KSArIChoZWlnaHQgPDwgMSk7XG4gICAgdGhpcy5fY2FudmFzUG9vbFtrZXldLnB1c2goY2FudmFzQW5kQ29udGV4dCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2FudmFzUG9vbCA9IHt9O1xuICB9XG59XG5jb25zdCBDYW52YXNQb29sID0gbmV3IENhbnZhc1Bvb2xDbGFzcygpO1xuXG5leHBvcnQgeyBDYW52YXNQb29sLCBDYW52YXNQb29sQ2xhc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1Bvb2wubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///131\n')},9010:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(4108);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs\nvar BatchableGraphics = __webpack_require__(26);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State/* State */.Z.for2d();\n    // batchable graphics list, used to render batches\n    this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics._didGraphicsUpdate) {\n      graphics._didGraphicsUpdate = false;\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const batches = this._graphicsBatchesHash[graphics.uid];\n    if (batches) {\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        batch.batcher.updateElement(batch);\n      }\n    }\n  }\n  destroyRenderable(graphics) {\n    if (this._graphicsBatchesHash[graphics.uid]) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (wasBatched) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n    if (gpuContext.isBatchable) {\n      this._initBatchesForRenderable(graphics);\n    }\n    graphics.batched = gpuContext.isBatchable;\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getBatchesForRenderable(graphics);\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getBatchesForRenderable(graphics) {\n    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n  }\n  _initBatchesForRenderable(graphics) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    const batches = gpuContext.batches.map((batch) => {\n      const batchClone = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n    this._graphicsBatchesHash[graphics.uid] = batches;\n    graphics.on("destroyed", () => {\n      this.destroyRenderable(graphics);\n    });\n    return batches;\n  }\n  _removeBatchForRenderable(graphicsUid) {\n    this._graphicsBatchesHash[graphicsUid].forEach((batch) => {\n      PoolGroup/* BigPool */.u.return(batch);\n    });\n    this._graphicsBatchesHash[graphicsUid] = null;\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n    for (const i in this._graphicsBatchesHash) {\n      this._removeBatchForRenderable(i);\n    }\n    this._graphicsBatchesHash = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "graphics"\n};\n\n\n//# sourceMappingURL=GraphicsPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(GraphicsPipe);\nExtensions/* extensions */.Rw.add(GraphicsContextSystem/* GraphicsContextSystem */.hJ);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFtRTtBQUNTO0FBQ2hCO0FBQ0k7QUFDSjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBTyxLQUFLLDBDQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUFPO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUV3QjtBQUN4Qjs7O0FDNUk2RDtBQUNjO0FBQ2xCOztBQUV6RDtBQUNBLDZCQUFVLEtBQUssWUFBWTtBQUMzQiw2QkFBVSxLQUFLLG1EQUFxQjtBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NQaXBlLm1qcz9lNDJkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9pbml0Lm1qcz9iNDMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSB9IGZyb20gJy4uL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlR3JhcGhpY3MgfSBmcm9tICcuL0JhdGNoYWJsZUdyYXBoaWNzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3JhcGhpY3NQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIsIGFkYXB0b3IpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICAvLyBiYXRjaGFibGUgZ3JhcGhpY3MgbGlzdCwgdXNlZCB0byByZW5kZXIgYmF0Y2hlc1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgdGhpcy5fYWRhcHRvci5pbml0KCk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3Qgd2FzQmF0Y2hlZCA9ICEhdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljcy51aWRdO1xuICAgIGNvbnN0IGdwdUNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dC51cGRhdGVHcHVDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChncHVDb250ZXh0LmlzQmF0Y2hhYmxlIHx8IHdhc0JhdGNoZWQgIT09IGdwdUNvbnRleHQuaXNCYXRjaGFibGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShncmFwaGljcywgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChncmFwaGljcy5jb250ZXh0KTtcbiAgICBpZiAoZ3JhcGhpY3MuX2RpZEdyYXBoaWNzVXBkYXRlKSB7XG4gICAgICBncmFwaGljcy5fZGlkR3JhcGhpY3NVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlYnVpbGQoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICBpZiAoZ3B1Q29udGV4dC5pc0JhdGNoYWJsZSkge1xuICAgICAgdGhpcy5fYWRkVG9CYXRjaGVyKGdyYXBoaWNzLCBpbnN0cnVjdGlvblNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKGdyYXBoaWNzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF07XG4gICAgaWYgKGJhdGNoZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICAgIGJhdGNoLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgaWYgKHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXSkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzLnVpZCk7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGUoZ3JhcGhpY3MpIHtcbiAgICBpZiAoIWdyYXBoaWNzLmlzUmVuZGVyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3QgY29udGV4dFN5c3RlbSA9IHJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dDtcbiAgICBpZiAoIWNvbnRleHRTeXN0ZW0uZ2V0R3B1Q29udGV4dChjb250ZXh0KS5iYXRjaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaGFkZXIgPSBjb250ZXh0LmN1c3RvbVNoYWRlciB8fCB0aGlzLl9hZGFwdG9yLnNoYWRlcjtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IGdyYXBoaWNzLmdyb3VwQmxlbmRNb2RlO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSBzaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gZ3JhcGhpY3MuZ3JvdXBUcmFuc2Zvcm07XG4gICAgbG9jYWxVbmlmb3Jtcy51Um91bmQgPSByZW5kZXJlci5fcm91bmRQaXhlbHMgfCBncmFwaGljcy5fcm91bmRQaXhlbHM7XG4gICAgY29sb3IzMkJpdFRvVW5pZm9ybShcbiAgICAgIGdyYXBoaWNzLmdyb3VwQ29sb3JBbHBoYSxcbiAgICAgIGxvY2FsVW5pZm9ybXMudUNvbG9yLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fYWRhcHRvci5leGVjdXRlKHRoaXMsIGdyYXBoaWNzKTtcbiAgfVxuICBfcmVidWlsZChncmFwaGljcykge1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSAhIXRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXTtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChncmFwaGljcy5jb250ZXh0KTtcbiAgICBpZiAod2FzQmF0Y2hlZCkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzLnVpZCk7XG4gICAgfVxuICAgIGlmIChncHVDb250ZXh0LmlzQmF0Y2hhYmxlKSB7XG4gICAgICB0aGlzLl9pbml0QmF0Y2hlc0ZvclJlbmRlcmFibGUoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICBncmFwaGljcy5iYXRjaGVkID0gZ3B1Q29udGV4dC5pc0JhdGNoYWJsZTtcbiAgfVxuICBfYWRkVG9CYXRjaGVyKGdyYXBoaWNzLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGJhdGNoUGlwZSA9IHRoaXMucmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2g7XG4gICAgY29uc3QgYmF0Y2hlcyA9IHRoaXMuX2dldEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoUGlwZS5hZGRUb0JhdGNoKGJhdGNoLCBpbnN0cnVjdGlvblNldCk7XG4gICAgfVxuICB9XG4gIF9nZXRCYXRjaGVzRm9yUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIHJldHVybiB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF0gfHwgdGhpcy5faW5pdEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKTtcbiAgfVxuICBfaW5pdEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMucmVuZGVyZXIuZ3JhcGhpY3NDb250ZXh0LmdldEdwdUNvbnRleHQoY29udGV4dCk7XG4gICAgY29uc3Qgcm91bmRQaXhlbHMgPSB0aGlzLnJlbmRlcmVyLl9yb3VuZFBpeGVscyB8IGdyYXBoaWNzLl9yb3VuZFBpeGVscztcbiAgICBjb25zdCBiYXRjaGVzID0gZ3B1Q29udGV4dC5iYXRjaGVzLm1hcCgoYmF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IGJhdGNoQ2xvbmUgPSBCaWdQb29sLmdldChCYXRjaGFibGVHcmFwaGljcyk7XG4gICAgICBiYXRjaC5jb3B5VG8oYmF0Y2hDbG9uZSk7XG4gICAgICBiYXRjaENsb25lLnJlbmRlcmFibGUgPSBncmFwaGljcztcbiAgICAgIGJhdGNoQ2xvbmUucm91bmRQaXhlbHMgPSByb3VuZFBpeGVscztcbiAgICAgIHJldHVybiBiYXRjaENsb25lO1xuICAgIH0pO1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXSA9IGJhdGNoZXM7XG4gICAgZ3JhcGhpY3Mub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShncmFwaGljcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJhdGNoZXM7XG4gIH1cbiAgX3JlbW92ZUJhdGNoRm9yUmVuZGVyYWJsZShncmFwaGljc1VpZCkge1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3NVaWRdLmZvckVhY2goKGJhdGNoKSA9PiB7XG4gICAgICBCaWdQb29sLnJldHVybihiYXRjaCk7XG4gICAgfSk7XG4gICAgdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljc1VpZF0gPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fYWRhcHRvci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYWRhcHRvciA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2gpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUJhdGNoRm9yUmVuZGVyYWJsZShpKTtcbiAgICB9XG4gICAgdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaCA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcmFwaGljc1BpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImdyYXBoaWNzXCJcbn07XG5cbmV4cG9ydCB7IEdyYXBoaWNzUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzQ29udGV4dFN5c3RlbSB9IGZyb20gJy4vc2hhcmVkL0dyYXBoaWNzQ29udGV4dFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NQaXBlIH0gZnJvbSAnLi9zaGFyZWQvR3JhcGhpY3NQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoR3JhcGhpY3NQaXBlKTtcbmV4dGVuc2lvbnMuYWRkKEdyYXBoaWNzQ29udGV4dFN5c3RlbSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9010\n')},8540:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup/* UniformGroup */.o({\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uRound: { value: 0, type: "f32" }\n    });\n    this.localUniformsBindGroup = new BindGroup/* BindGroup */.v({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */ Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add({\n        renderPipeId: "mesh",\n        mesh\n      });\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    PoolGroup/* BigPool */.u.return(gpuMesh);\n    this._gpuBatchableMeshHash[mesh.uid] = null;\n  }\n  execute({ mesh }) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = mesh.groupBlendMode;\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on("destroyed", () => {\n      this.destroyRenderable(mesh);\n    });\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = PoolGroup/* BigPool */.u.get(BatchableMesh/* BatchableMesh */.X);\n    gpuMesh.mesh = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    gpuMesh.mesh = mesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        PoolGroup/* BigPool */.u.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "mesh"\n};\n\n\n//# sourceMappingURL=MeshPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU0MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ1Q7QUFDd0I7QUFDUztBQUMvQjtBQUNnQjtBQUN4Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFZO0FBQ3pDLDBCQUEwQixXQUFXLG9CQUFNLHlCQUF5QjtBQUNwRSxnQkFBZ0IsMERBQTBEO0FBQzFFLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsc0NBQXNDLDBCQUFTO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBTztBQUNYO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBTyxLQUFLLGtDQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRW9CO0FBQ3BCOzs7QUNsSjZEO0FBQ1o7O0FBRWpEO0FBQ0EsNkJBQVUsS0FBSyxRQUFRO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL21lc2gvc2hhcmVkL01lc2hQaXBlLm1qcz84ZmExIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL2luaXQubWpzPzUzZmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBjb2xvcjMyQml0VG9Vbmlmb3JtIH0gZnJvbSAnLi4vLi4vZ3JhcGhpY3MvZ3B1L2NvbG9yVG9Vbmlmb3JtLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVNZXNoIH0gZnJvbSAnLi9CYXRjaGFibGVNZXNoLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgTWVzaFBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgYWRhcHRvcikge1xuICAgIHRoaXMubG9jYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1Um91bmQ6IHsgdmFsdWU6IDAsIHR5cGU6IFwiZjMyXCIgfVxuICAgIH0pO1xuICAgIHRoaXMubG9jYWxVbmlmb3Jtc0JpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoe1xuICAgICAgMDogdGhpcy5sb2NhbFVuaWZvcm1zXG4gICAgfSk7XG4gICAgdGhpcy5fbWVzaERhdGFIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgdGhpcy5fYWRhcHRvci5pbml0KCk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKG1lc2gpIHtcbiAgICBjb25zdCBtZXNoRGF0YSA9IHRoaXMuX2dldE1lc2hEYXRhKG1lc2gpO1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSBtZXNoRGF0YS5iYXRjaGVkO1xuICAgIGNvbnN0IGlzQmF0Y2hlZCA9IG1lc2guYmF0Y2hlZDtcbiAgICBtZXNoRGF0YS5iYXRjaGVkID0gaXNCYXRjaGVkO1xuICAgIGlmICh3YXNCYXRjaGVkICE9PSBpc0JhdGNoZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNCYXRjaGVkKSB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IG1lc2guX2dlb21ldHJ5O1xuICAgICAgaWYgKGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICE9PSBtZXNoRGF0YS5pbmRleFNpemUgfHwgZ2VvbWV0cnkucG9zaXRpb25zLmxlbmd0aCAhPT0gbWVzaERhdGEudmVydGV4U2l6ZSkge1xuICAgICAgICBtZXNoRGF0YS5pbmRleFNpemUgPSBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgbWVzaERhdGEudmVydGV4U2l6ZSA9IGdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYmF0Y2hhYmxlTWVzaCA9IHRoaXMuX2dldEJhdGNoYWJsZU1lc2gobWVzaCk7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gbWVzaC50ZXh0dXJlO1xuICAgICAgaWYgKGJhdGNoYWJsZU1lc2gudGV4dHVyZS5fc291cmNlICE9PSB0ZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgICAgaWYgKGJhdGNoYWJsZU1lc2gudGV4dHVyZS5fc291cmNlICE9PSB0ZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gYmF0Y2hhYmxlTWVzaC5iYXRjaGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZShiYXRjaGFibGVNZXNoLCB0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShtZXNoLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGJhdGNoZXIgPSB0aGlzLnJlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoO1xuICAgIGNvbnN0IHsgYmF0Y2hlZCB9ID0gdGhpcy5fZ2V0TWVzaERhdGEobWVzaCk7XG4gICAgaWYgKGJhdGNoZWQpIHtcbiAgICAgIGNvbnN0IGdwdUJhdGNoYWJsZU1lc2ggPSB0aGlzLl9nZXRCYXRjaGFibGVNZXNoKG1lc2gpO1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC50ZXh0dXJlID0gbWVzaC5fdGV4dHVyZTtcbiAgICAgIGdwdUJhdGNoYWJsZU1lc2guZ2VvbWV0cnkgPSBtZXNoLl9nZW9tZXRyeTtcbiAgICAgIGJhdGNoZXIuYWRkVG9CYXRjaChncHVCYXRjaGFibGVNZXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmF0Y2hlci5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgICByZW5kZXJQaXBlSWQ6IFwibWVzaFwiLFxuICAgICAgICBtZXNoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShtZXNoKSB7XG4gICAgaWYgKG1lc2guYmF0Y2hlZCkge1xuICAgICAgY29uc3QgZ3B1QmF0Y2hhYmxlTWVzaCA9IHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW21lc2gudWlkXTtcbiAgICAgIGdwdUJhdGNoYWJsZU1lc2gudGV4dHVyZSA9IG1lc2guX3RleHR1cmU7XG4gICAgICBncHVCYXRjaGFibGVNZXNoLmdlb21ldHJ5ID0gbWVzaC5fZ2VvbWV0cnk7XG4gICAgICBncHVCYXRjaGFibGVNZXNoLmJhdGNoZXIudXBkYXRlRWxlbWVudChncHVCYXRjaGFibGVNZXNoKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUobWVzaCkge1xuICAgIHRoaXMuX21lc2hEYXRhSGFzaFttZXNoLnVpZF0gPSBudWxsO1xuICAgIGNvbnN0IGdwdU1lc2ggPSB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF07XG4gICAgQmlnUG9vbC5yZXR1cm4oZ3B1TWVzaCk7XG4gICAgdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdID0gbnVsbDtcbiAgfVxuICBleGVjdXRlKHsgbWVzaCB9KSB7XG4gICAgaWYgKCFtZXNoLmlzUmVuZGVyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBtZXNoLnN0YXRlLmJsZW5kTW9kZSA9IG1lc2guZ3JvdXBCbGVuZE1vZGU7XG4gICAgY29uc3QgbG9jYWxVbmlmb3JtcyA9IHRoaXMubG9jYWxVbmlmb3JtcztcbiAgICBsb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVUcmFuc2Zvcm1NYXRyaXggPSBtZXNoLmdyb3VwVHJhbnNmb3JtO1xuICAgIGxvY2FsVW5pZm9ybXMudW5pZm9ybXMudVJvdW5kID0gdGhpcy5yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBtZXNoLl9yb3VuZFBpeGVscztcbiAgICBsb2NhbFVuaWZvcm1zLnVwZGF0ZSgpO1xuICAgIGNvbG9yMzJCaXRUb1VuaWZvcm0oXG4gICAgICBtZXNoLmdyb3VwQ29sb3JBbHBoYSxcbiAgICAgIGxvY2FsVW5pZm9ybXMudW5pZm9ybXMudUNvbG9yLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fYWRhcHRvci5leGVjdXRlKHRoaXMsIG1lc2gpO1xuICB9XG4gIF9nZXRNZXNoRGF0YShtZXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc2hEYXRhSGFzaFttZXNoLnVpZF0gfHwgdGhpcy5faW5pdE1lc2hEYXRhKG1lc2gpO1xuICB9XG4gIF9pbml0TWVzaERhdGEobWVzaCkge1xuICAgIHRoaXMuX21lc2hEYXRhSGFzaFttZXNoLnVpZF0gPSB7XG4gICAgICBiYXRjaGVkOiBtZXNoLmJhdGNoZWQsXG4gICAgICBpbmRleFNpemU6IG1lc2guX2dlb21ldHJ5LmluZGljZXM/Lmxlbmd0aCxcbiAgICAgIHZlcnRleFNpemU6IG1lc2guX2dlb21ldHJ5LnBvc2l0aW9ucz8ubGVuZ3RoXG4gICAgfTtcbiAgICBtZXNoLm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUobWVzaCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX21lc2hEYXRhSGFzaFttZXNoLnVpZF07XG4gIH1cbiAgX2dldEJhdGNoYWJsZU1lc2gobWVzaCkge1xuICAgIHJldHVybiB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF0gfHwgdGhpcy5faW5pdEJhdGNoYWJsZU1lc2gobWVzaCk7XG4gIH1cbiAgX2luaXRCYXRjaGFibGVNZXNoKG1lc2gpIHtcbiAgICBjb25zdCBncHVNZXNoID0gQmlnUG9vbC5nZXQoQmF0Y2hhYmxlTWVzaCk7XG4gICAgZ3B1TWVzaC5tZXNoID0gbWVzaDtcbiAgICBncHVNZXNoLnRleHR1cmUgPSBtZXNoLl90ZXh0dXJlO1xuICAgIGdwdU1lc2gucm91bmRQaXhlbHMgPSB0aGlzLnJlbmRlcmVyLl9yb3VuZFBpeGVscyB8IG1lc2guX3JvdW5kUGl4ZWxzO1xuICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW21lc2gudWlkXSA9IGdwdU1lc2g7XG4gICAgZ3B1TWVzaC5tZXNoID0gbWVzaDtcbiAgICByZXR1cm4gZ3B1TWVzaDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaCkge1xuICAgICAgaWYgKHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW2ldKSB7XG4gICAgICAgIEJpZ1Bvb2wucmV0dXJuKHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2ggPSBudWxsO1xuICAgIHRoaXMuX21lc2hEYXRhSGFzaCA9IG51bGw7XG4gICAgdGhpcy5sb2NhbFVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLmxvY2FsVW5pZm9ybXNCaW5kR3JvdXAgPSBudWxsO1xuICAgIHRoaXMuX2FkYXB0b3IuZGVzdHJveSgpO1xuICAgIHRoaXMuX2FkYXB0b3IgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuTWVzaFBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcIm1lc2hcIlxufTtcblxuZXhwb3J0IHsgTWVzaFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IE1lc2hQaXBlIH0gZnJvbSAnLi9zaGFyZWQvTWVzaFBpcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChNZXNoUGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8540\n')},2653:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   X: () => (/* binding */ BatchableMesh)\n/* harmony export */ });\n\nclass BatchableMesh {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.mesh.groupBlendMode;\n  }\n  reset() {\n    this.mesh = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometry.indices;\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const mesh = this.mesh;\n    const geometry = this.geometry;\n    const wt = mesh.groupTransform;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const positions = geometry.positions;\n    const uvs = geometry.uvs;\n    const abgr = mesh.groupColorAlpha;\n    for (let i = 0; i < positions.length; i += 2) {\n      const x = positions[i];\n      const y = positions[i + 1];\n      float32View[index] = a * x + c * y + tx;\n      float32View[index + 1] = b * x + d * y + ty;\n      float32View[index + 2] = uvs[i];\n      float32View[index + 3] = uvs[i + 1];\n      uint32View[index + 4] = abgr;\n      uint32View[index + 5] = textureIdAndRound;\n      index += 6;\n    }\n  }\n  get vertexSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\n\n//# sourceMappingURL=BatchableMesh.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY1My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC9zaGFyZWQvQmF0Y2hhYmxlTWVzaC5tanM/MDMxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJhdGNoYWJsZU1lc2gge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJhdGNoZXIgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2ggPSBudWxsO1xuICAgIHRoaXMucm91bmRQaXhlbHMgPSAwO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzaC5ncm91cEJsZW5kTW9kZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5iYXRjaGVyID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoID0gbnVsbDtcbiAgfVxuICBwYWNrSW5kZXgoaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuZ2VvbWV0cnkuaW5kaWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGV4QnVmZmVyW2luZGV4KytdID0gaW5kaWNlc1tpXSArIGluZGljZXNPZmZzZXQ7XG4gICAgfVxuICB9XG4gIHBhY2tBdHRyaWJ1dGVzKGZsb2F0MzJWaWV3LCB1aW50MzJWaWV3LCBpbmRleCwgdGV4dHVyZUlkKSB7XG4gICAgY29uc3QgbWVzaCA9IHRoaXMubWVzaDtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgY29uc3Qgd3QgPSBtZXNoLmdyb3VwVHJhbnNmb3JtO1xuICAgIGNvbnN0IHRleHR1cmVJZEFuZFJvdW5kID0gdGV4dHVyZUlkIDw8IDE2IHwgdGhpcy5yb3VuZFBpeGVscyAmIDY1NTM1O1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5wb3NpdGlvbnM7XG4gICAgY29uc3QgdXZzID0gZ2VvbWV0cnkudXZzO1xuICAgIGNvbnN0IGFiZ3IgPSBtZXNoLmdyb3VwQ29sb3JBbHBoYTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgIGNvbnN0IHkgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXhdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMl0gPSB1dnNbaV07XG4gICAgICBmbG9hdDMyVmlld1tpbmRleCArIDNdID0gdXZzW2kgKyAxXTtcbiAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyA0XSA9IGFiZ3I7XG4gICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWRBbmRSb3VuZDtcbiAgICAgIGluZGV4ICs9IDY7XG4gICAgfVxuICB9XG4gIGdldCB2ZXJ0ZXhTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGggLyAyO1xuICB9XG4gIGdldCBpbmRleFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGg7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hhYmxlTWVzaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hhYmxlTWVzaC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2653\n")},4428:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   x: () => (/* binding */ MeshGeometry)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7494);\n/* harmony import */ var _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5324);\n/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1980);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(156);\n\n\n\n\n\n"use strict";\nconst _MeshGeometry = class _MeshGeometry extends _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .Z {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .P, "use new MeshGeometry({ positions, uvs, indices }) instead");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: positions,\n      label: "attribute-mesh-positions",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    const uvBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: uvs,\n      label: "attribute-mesh-uvs",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    const indexBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: indices,\n      label: "index-mesh-buffer",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.INDEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = "auto";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: "triangle-list",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\n\n//# sourceMappingURL=MeshGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStFO0FBQ0k7QUFDRTtBQUNSOztBQUU3RTtBQUNBLGtEQUFrRCxnR0FBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9GQUFXLENBQUMsMkVBQU0sMEJBQTBCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEZBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCx5QkFBeUIsMEZBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCw0QkFBNEIsMEZBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxTQUFTLDhGQUFXO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL3NoYXJlZC9NZXNoR2VvbWV0cnkubWpzPzFlODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgQnVmZmVyVXNhZ2UgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvY29uc3QubWpzJztcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX01lc2hHZW9tZXRyeSA9IGNsYXNzIF9NZXNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJ1c2UgbmV3IE1lc2hHZW9tZXRyeSh7IHBvc2l0aW9ucywgdXZzLCBpbmRpY2VzIH0pIGluc3RlYWRcIik7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBwb3NpdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIHV2czogYXJnc1sxXSxcbiAgICAgICAgaW5kaWNlczogYXJnc1syXVxuICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX01lc2hHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IG9wdGlvbnMucG9zaXRpb25zIHx8IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKTtcbiAgICBjb25zdCB1dnMgPSBvcHRpb25zLnV2cyB8fCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSk7XG4gICAgY29uc3QgaW5kaWNlcyA9IG9wdGlvbnMuaW5kaWNlcyB8fCBuZXcgVWludDMyQXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbiAgICBjb25zdCBzaHJpbmtUb0ZpdCA9IG9wdGlvbnMuc2hyaW5rQnVmZmVyc1RvRml0O1xuICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gbmV3IEJ1ZmZlcih7XG4gICAgICBkYXRhOiBwb3NpdGlvbnMsXG4gICAgICBsYWJlbDogXCJhdHRyaWJ1dGUtbWVzaC1wb3NpdGlvbnNcIixcbiAgICAgIHNocmlua1RvRml0LFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgfSk7XG4gICAgY29uc3QgdXZCdWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IHV2cyxcbiAgICAgIGxhYmVsOiBcImF0dHJpYnV0ZS1tZXNoLXV2c1wiLFxuICAgICAgc2hyaW5rVG9GaXQsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuVkVSVEVYIHwgQnVmZmVyVXNhZ2UuQ09QWV9EU1RcbiAgICB9KTtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogaW5kaWNlcyxcbiAgICAgIGxhYmVsOiBcImluZGV4LW1lc2gtYnVmZmVyXCIsXG4gICAgICBzaHJpbmtUb0ZpdCxcbiAgICAgIHVzYWdlOiBCdWZmZXJVc2FnZS5JTkRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBhUG9zaXRpb246IHtcbiAgICAgICAgICBidWZmZXI6IHBvc2l0aW9uQnVmZmVyLFxuICAgICAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBhVVY6IHtcbiAgICAgICAgICBidWZmZXI6IHV2QnVmZmVyLFxuICAgICAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5kZXhCdWZmZXIsXG4gICAgICB0b3BvbG9neTogb3B0aW9ucy50b3BvbG9neVxuICAgIH0pO1xuICAgIHRoaXMuYmF0Y2hNb2RlID0gXCJhdXRvXCI7XG4gIH1cbiAgLyoqIFRoZSBwb3NpdGlvbnMgb2YgdGhlIG1lc2guICovXG4gIGdldCBwb3NpdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5hUG9zaXRpb24uYnVmZmVyLmRhdGE7XG4gIH1cbiAgc2V0IHBvc2l0aW9ucyh2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlcy5hUG9zaXRpb24uYnVmZmVyLmRhdGEgPSB2YWx1ZTtcbiAgfVxuICAvKiogVGhlIFVWcyBvZiB0aGUgbWVzaC4gKi9cbiAgZ2V0IHV2cygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmFVVi5idWZmZXIuZGF0YTtcbiAgfVxuICBzZXQgdXZzKHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzLmFVVi5idWZmZXIuZGF0YSA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgaW5kaWNlcyBvZiB0aGUgbWVzaC4gKi9cbiAgZ2V0IGluZGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXIuZGF0YTtcbiAgfVxuICBzZXQgaW5kaWNlcyh2YWx1ZSkge1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGF0YSA9IHZhbHVlO1xuICB9XG59O1xuX01lc2hHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgdG9wb2xvZ3k6IFwidHJpYW5nbGUtbGlzdFwiLFxuICBzaHJpbmtCdWZmZXJzVG9GaXQ6IGZhbHNlXG59O1xubGV0IE1lc2hHZW9tZXRyeSA9IF9NZXNoR2VvbWV0cnk7XG5cbmV4cG9ydCB7IE1lc2hHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaEdlb21ldHJ5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4428\n')},2092:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(4428);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs\n\n\n\n"use strict";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry/* MeshGeometry */.x {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === "number") {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\n\n//# sourceMappingURL=PlaneGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs\n\n\n\n"use strict";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this._textureMatrix = new Matrix/* Matrix */.y();\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    if (options.textureMatrix) {\n      this._textureMatrix.copyFrom(options.textureMatrix);\n    }\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const positions = this.positions;\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this.width > w ? 1 : this.width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this.height > h ? 1 : this.height / h;\n    const scale = Math.min(scaleW, scaleH);\n    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n    positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n    positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n    this.getBuffer("aPosition").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const textureMatrix = this._textureMatrix;\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    multiplyUvs(textureMatrix, uvs);\n    this.getBuffer("aUV").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\nfunction multiplyUvs(matrix, uvs, out) {\n  out ?? (out = uvs);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  for (let i = 0; i < uvs.length; i += 2) {\n    const x = uvs[i];\n    const y = uvs[i + 1];\n    out[i] = x * a + y * c + tx;\n    out[i + 1] = x * b + y * d + ty;\n  }\n  return out;\n}\n\n\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs\n\n\n\n\n\n"use strict";\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    PoolGroup/* BigPool */.u.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableMesh = new BatchableMesh/* BatchableMesh */.X();\n    batchableMesh.geometry = new NineSliceGeometry();\n    batchableMesh.mesh = sprite;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableMesh;\n    sprite.on("destroyed", () => {\n      this.destroyRenderable(sprite);\n    });\n    return batchableMesh;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      const batchableMesh = this._gpuSpriteHash[i];\n      batchableMesh.geometry.destroy();\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "nineSliceSprite"\n};\n\n\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRTtBQUNYOztBQUUvRDtBQUNBLG9EQUFvRCxnQ0FBWTtBQUNoRTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsTUFBTSxrQ0FBVyxDQUFDLHlCQUFNLGtEQUFrRCxzQ0FBc0M7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCOzs7QUM3RXVEO0FBQ1M7O0FBRWhFO0FBQ0EsNERBQTRELGFBQWE7QUFDekUsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixvQkFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0I7OztBQzNHZ0U7QUFDUDtBQUNRO0FBQ0w7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWE7QUFDM0MsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7OztBQzVFNkQ7QUFDRzs7QUFFaEU7QUFDQSw2QkFBVSxLQUFLLG1CQUFtQjtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoLXBsYW5lL1BsYW5lR2VvbWV0cnkubWpzPzk3N2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS1uaW5lLXNsaWNlL05pbmVTbGljZUdlb21ldHJ5Lm1qcz9kNzBlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtbmluZS1zbGljZS9OaW5lU2xpY2VTcHJpdGVQaXBlLm1qcz83YTE5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtbmluZS1zbGljZS9pbml0Lm1qcz9iNjkzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5pbXBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICcuLi9tZXNoL3NoYXJlZC9NZXNoR2VvbWV0cnkubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfUGxhbmVHZW9tZXRyeSA9IGNsYXNzIF9QbGFuZUdlb21ldHJ5IGV4dGVuZHMgTWVzaEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKHt9KTtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiKSB7XG4gICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiUGxhbmVHZW9tZXRyeSBjb25zdHJ1Y3RvciBjaGFuZ2VkIHBsZWFzZSB1c2UgeyB3aWR0aCwgaGVpZ2h0LCB2ZXJ0aWNlc1gsIHZlcnRpY2VzWSB9IGluc3RlYWRcIik7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICB3aWR0aDogb3B0aW9ucyxcbiAgICAgICAgaGVpZ2h0OiBhcmdzWzFdLFxuICAgICAgICB2ZXJ0aWNlc1g6IGFyZ3NbMl0sXG4gICAgICAgIHZlcnRpY2VzWTogYXJnc1szXVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5idWlsZChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUmVmcmVzaGVzIHBsYW5lIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHBsYW5lIGdlb21ldHJ5XG4gICAqL1xuICBidWlsZChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX1BsYW5lR2VvbWV0cnkuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLnZlcnRpY2VzWCA9IHRoaXMudmVydGljZXNYID8/IG9wdGlvbnMudmVydGljZXNYO1xuICAgIHRoaXMudmVydGljZXNZID0gdGhpcy52ZXJ0aWNlc1kgPz8gb3B0aW9ucy52ZXJ0aWNlc1k7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggPz8gb3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuaGVpZ2h0ID8/IG9wdGlvbnMuaGVpZ2h0O1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy52ZXJ0aWNlc1ggKiB0aGlzLnZlcnRpY2VzWTtcbiAgICBjb25zdCB2ZXJ0cyA9IFtdO1xuICAgIGNvbnN0IHV2cyA9IFtdO1xuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCB2ZXJ0aWNlc1ggPSB0aGlzLnZlcnRpY2VzWCAtIDE7XG4gICAgY29uc3QgdmVydGljZXNZID0gdGhpcy52ZXJ0aWNlc1kgLSAxO1xuICAgIGNvbnN0IHNpemVYID0gdGhpcy53aWR0aCAvIHZlcnRpY2VzWDtcbiAgICBjb25zdCBzaXplWSA9IHRoaXMuaGVpZ2h0IC8gdmVydGljZXNZO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGkgJSB0aGlzLnZlcnRpY2VzWDtcbiAgICAgIGNvbnN0IHkgPSBpIC8gdGhpcy52ZXJ0aWNlc1ggfCAwO1xuICAgICAgdmVydHMucHVzaCh4ICogc2l6ZVgsIHkgKiBzaXplWSk7XG4gICAgICB1dnMucHVzaCh4IC8gdmVydGljZXNYLCB5IC8gdmVydGljZXNZKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxTdWIgPSB2ZXJ0aWNlc1ggKiB2ZXJ0aWNlc1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFN1YjsgaSsrKSB7XG4gICAgICBjb25zdCB4cG9zID0gaSAlIHZlcnRpY2VzWDtcbiAgICAgIGNvbnN0IHlwb3MgPSBpIC8gdmVydGljZXNYIHwgMDtcbiAgICAgIGNvbnN0IHZhbHVlID0geXBvcyAqIHRoaXMudmVydGljZXNYICsgeHBvcztcbiAgICAgIGNvbnN0IHZhbHVlMiA9IHlwb3MgKiB0aGlzLnZlcnRpY2VzWCArIHhwb3MgKyAxO1xuICAgICAgY29uc3QgdmFsdWUzID0gKHlwb3MgKyAxKSAqIHRoaXMudmVydGljZXNYICsgeHBvcztcbiAgICAgIGNvbnN0IHZhbHVlNCA9ICh5cG9zICsgMSkgKiB0aGlzLnZlcnRpY2VzWCArIHhwb3MgKyAxO1xuICAgICAgaW5kaWNlcy5wdXNoKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWUyLFxuICAgICAgICB2YWx1ZTMsXG4gICAgICAgIHZhbHVlMixcbiAgICAgICAgdmFsdWU0LFxuICAgICAgICB2YWx1ZTNcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyc1swXS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0cyk7XG4gICAgdGhpcy5idWZmZXJzWzFdLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHV2cyk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlci5kYXRhID0gbmV3IFVpbnQzMkFycmF5KGluZGljZXMpO1xuICAgIHRoaXMuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMV0udXBkYXRlKCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgfVxufTtcbl9QbGFuZUdlb21ldHJ5LmRlZmF1bHRPcHRpb25zID0ge1xuICB3aWR0aDogMTAwLFxuICBoZWlnaHQ6IDEwMCxcbiAgdmVydGljZXNYOiAxMCxcbiAgdmVydGljZXNZOiAxMFxufTtcbmxldCBQbGFuZUdlb21ldHJ5ID0gX1BsYW5lR2VvbWV0cnk7XG5cbmV4cG9ydCB7IFBsYW5lR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsYW5lR2VvbWV0cnkubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUGxhbmVHZW9tZXRyeSB9IGZyb20gJy4uL21lc2gtcGxhbmUvUGxhbmVHZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9OaW5lU2xpY2VHZW9tZXRyeSA9IGNsYXNzIF9OaW5lU2xpY2VHZW9tZXRyeSBleHRlbmRzIFBsYW5lR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0geyAuLi5fTmluZVNsaWNlR2VvbWV0cnkuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICBzdXBlcih7XG4gICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQsXG4gICAgICB2ZXJ0aWNlc1g6IDQsXG4gICAgICB2ZXJ0aWNlc1k6IDRcbiAgICB9KTtcbiAgICB0aGlzLl90ZXh0dXJlTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMudXBkYXRlKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBOaW5lU2xpY2VHZW9tZXRyeSB3aXRoIHRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9mIHRoZSBOaW5lU2xpY2VHZW9tZXRyeS5cbiAgICovXG4gIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggPz8gdGhpcy53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ID8/IHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuX29yaWdpbmFsV2lkdGggPSBvcHRpb25zLm9yaWdpbmFsV2lkdGggPz8gdGhpcy5fb3JpZ2luYWxXaWR0aDtcbiAgICB0aGlzLl9vcmlnaW5hbEhlaWdodCA9IG9wdGlvbnMub3JpZ2luYWxIZWlnaHQgPz8gdGhpcy5fb3JpZ2luYWxIZWlnaHQ7XG4gICAgdGhpcy5fbGVmdFdpZHRoID0gb3B0aW9ucy5sZWZ0V2lkdGggPz8gdGhpcy5fbGVmdFdpZHRoO1xuICAgIHRoaXMuX3JpZ2h0V2lkdGggPSBvcHRpb25zLnJpZ2h0V2lkdGggPz8gdGhpcy5fcmlnaHRXaWR0aDtcbiAgICB0aGlzLl90b3BIZWlnaHQgPSBvcHRpb25zLnRvcEhlaWdodCA/PyB0aGlzLl90b3BIZWlnaHQ7XG4gICAgdGhpcy5fYm90dG9tSGVpZ2h0ID0gb3B0aW9ucy5ib3R0b21IZWlnaHQgPz8gdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgIGlmIChvcHRpb25zLnRleHR1cmVNYXRyaXgpIHtcbiAgICAgIHRoaXMuX3RleHR1cmVNYXRyaXguY29weUZyb20ob3B0aW9ucy50ZXh0dXJlTWF0cml4KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucygpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2YgdGhlIHZlcnRpY2VzLiAqL1xuICB1cGRhdGVQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7XG4gICAgY29uc3QgdyA9IHRoaXMuX2xlZnRXaWR0aCArIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVXID0gdGhpcy53aWR0aCA+IHcgPyAxIDogdGhpcy53aWR0aCAvIHc7XG4gICAgY29uc3QgaCA9IHRoaXMuX3RvcEhlaWdodCArIHRoaXMuX2JvdHRvbUhlaWdodDtcbiAgICBjb25zdCBzY2FsZUggPSB0aGlzLmhlaWdodCA+IGggPyAxIDogdGhpcy5oZWlnaHQgLyBoO1xuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oc2NhbGVXLCBzY2FsZUgpO1xuICAgIHBvc2l0aW9uc1s5XSA9IHBvc2l0aW9uc1sxMV0gPSBwb3NpdGlvbnNbMTNdID0gcG9zaXRpb25zWzE1XSA9IHRoaXMuX3RvcEhlaWdodCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1sxN10gPSBwb3NpdGlvbnNbMTldID0gcG9zaXRpb25zWzIxXSA9IHBvc2l0aW9uc1syM10gPSB0aGlzLmhlaWdodCAtIHRoaXMuX2JvdHRvbUhlaWdodCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1syNV0gPSBwb3NpdGlvbnNbMjddID0gcG9zaXRpb25zWzI5XSA9IHBvc2l0aW9uc1szMV0gPSB0aGlzLmhlaWdodDtcbiAgICBwb3NpdGlvbnNbMl0gPSBwb3NpdGlvbnNbMTBdID0gcG9zaXRpb25zWzE4XSA9IHBvc2l0aW9uc1syNl0gPSB0aGlzLl9sZWZ0V2lkdGggKiBzY2FsZTtcbiAgICBwb3NpdGlvbnNbNF0gPSBwb3NpdGlvbnNbMTJdID0gcG9zaXRpb25zWzIwXSA9IHBvc2l0aW9uc1syOF0gPSB0aGlzLndpZHRoIC0gdGhpcy5fcmlnaHRXaWR0aCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1s2XSA9IHBvc2l0aW9uc1sxNF0gPSBwb3NpdGlvbnNbMjJdID0gcG9zaXRpb25zWzMwXSA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy5nZXRCdWZmZXIoXCJhUG9zaXRpb25cIikudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIFVWcyBvZiB0aGUgdmVydGljZXMuICovXG4gIHVwZGF0ZVV2cygpIHtcbiAgICBjb25zdCB0ZXh0dXJlTWF0cml4ID0gdGhpcy5fdGV4dHVyZU1hdHJpeDtcbiAgICBjb25zdCB1dnMgPSB0aGlzLnV2cztcbiAgICB1dnNbMF0gPSB1dnNbOF0gPSB1dnNbMTZdID0gdXZzWzI0XSA9IDA7XG4gICAgdXZzWzFdID0gdXZzWzNdID0gdXZzWzVdID0gdXZzWzddID0gMDtcbiAgICB1dnNbNl0gPSB1dnNbMTRdID0gdXZzWzIyXSA9IHV2c1szMF0gPSAxO1xuICAgIHV2c1syNV0gPSB1dnNbMjddID0gdXZzWzI5XSA9IHV2c1szMV0gPSAxO1xuICAgIGNvbnN0IF91dncgPSAxIC8gdGhpcy5fb3JpZ2luYWxXaWR0aDtcbiAgICBjb25zdCBfdXZoID0gMSAvIHRoaXMuX29yaWdpbmFsSGVpZ2h0O1xuICAgIHV2c1syXSA9IHV2c1sxMF0gPSB1dnNbMThdID0gdXZzWzI2XSA9IF91dncgKiB0aGlzLl9sZWZ0V2lkdGg7XG4gICAgdXZzWzldID0gdXZzWzExXSA9IHV2c1sxM10gPSB1dnNbMTVdID0gX3V2aCAqIHRoaXMuX3RvcEhlaWdodDtcbiAgICB1dnNbNF0gPSB1dnNbMTJdID0gdXZzWzIwXSA9IHV2c1syOF0gPSAxIC0gX3V2dyAqIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgdXZzWzE3XSA9IHV2c1sxOV0gPSB1dnNbMjFdID0gdXZzWzIzXSA9IDEgLSBfdXZoICogdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgIG11bHRpcGx5VXZzKHRleHR1cmVNYXRyaXgsIHV2cyk7XG4gICAgdGhpcy5nZXRCdWZmZXIoXCJhVVZcIikudXBkYXRlKCk7XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIE5pbmVTbGljZUdlb21ldHJ5LiAqL1xuX05pbmVTbGljZUdlb21ldHJ5LmRlZmF1bHRPcHRpb25zID0ge1xuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBOaW5lU2xpY2VQbGFuZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSB2ZXJ0aWNlcyBhbmQgVVYncyBvZiB0aGlzIHBsYW5lLiAqL1xuICB3aWR0aDogMTAwLFxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgTmluZVNsaWNlUGxhbmUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgdmVydGljZXMgYW5kIFVWJ3Mgb2YgdGhpcyBwbGFuZS4gKi9cbiAgaGVpZ2h0OiAxMDAsXG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIGxlZnQgY29sdW1uLiAqL1xuICBsZWZ0V2lkdGg6IDEwLFxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgdG9wIHJvdy4gKi9cbiAgdG9wSGVpZ2h0OiAxMCxcbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgcmlnaHQgY29sdW1uLiAqL1xuICByaWdodFdpZHRoOiAxMCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIGJvdHRvbSByb3cuICovXG4gIGJvdHRvbUhlaWdodDogMTAsXG4gIC8qKiBUaGUgb3JpZ2luYWwgd2lkdGggb2YgdGhlIHRleHR1cmUgKi9cbiAgb3JpZ2luYWxXaWR0aDogMTAwLFxuICAvKiogVGhlIG9yaWdpbmFsIGhlaWdodCBvZiB0aGUgdGV4dHVyZSAqL1xuICBvcmlnaW5hbEhlaWdodDogMTAwXG59O1xubGV0IE5pbmVTbGljZUdlb21ldHJ5ID0gX05pbmVTbGljZUdlb21ldHJ5O1xuZnVuY3Rpb24gbXVsdGlwbHlVdnMobWF0cml4LCB1dnMsIG91dCkge1xuICBvdXQgPz8gKG91dCA9IHV2cyk7XG4gIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgY29uc3QgYiA9IG1hdHJpeC5iO1xuICBjb25zdCBjID0gbWF0cml4LmM7XG4gIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgY29uc3QgdHggPSBtYXRyaXgudHg7XG4gIGNvbnN0IHR5ID0gbWF0cml4LnR5O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IHggPSB1dnNbaV07XG4gICAgY29uc3QgeSA9IHV2c1tpICsgMV07XG4gICAgb3V0W2ldID0geCAqIGEgKyB5ICogYyArIHR4O1xuICAgIG91dFtpICsgMV0gPSB4ICogYiArIHkgKiBkICsgdHk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IHsgTmluZVNsaWNlR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5pbmVTbGljZUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4uL21lc2gvc2hhcmVkL0JhdGNoYWJsZU1lc2gubWpzJztcbmltcG9ydCB7IE5pbmVTbGljZUdlb21ldHJ5IH0gZnJvbSAnLi9OaW5lU2xpY2VHZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE5pbmVTbGljZVNwcml0ZVBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2dwdVNwcml0ZUhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoc3ByaXRlLCBfaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVTcHJpdGUgPSB0aGlzLl9nZXRHcHVTcHJpdGUoc3ByaXRlKTtcbiAgICBpZiAoc3ByaXRlLl9kaWRTcHJpdGVVcGRhdGUpXG4gICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBncHVTcHJpdGUpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmFkZFRvQmF0Y2goZ3B1U3ByaXRlKTtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGdwdVNwcml0ZSA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF07XG4gICAgaWYgKHNwcml0ZS5fZGlkU3ByaXRlVXBkYXRlKVxuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hhYmxlU3ByaXRlKHNwcml0ZSwgZ3B1U3ByaXRlKTtcbiAgICBncHVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGdwdVNwcml0ZSk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgY29uc3QgZ3B1U3ByaXRlID0gdGhpcy5fZ2V0R3B1U3ByaXRlKHNwcml0ZSk7XG4gICAgaWYgKGdwdVNwcml0ZS50ZXh0dXJlLl9zb3VyY2UgIT09IHRleHR1cmUuX3NvdXJjZSkge1xuICAgICAgcmV0dXJuICFncHVTcHJpdGUuYmF0Y2hlci5jaGVja0FuZFVwZGF0ZVRleHR1cmUoZ3B1U3ByaXRlLCB0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF07XG4gICAgQmlnUG9vbC5yZXR1cm4oYmF0Y2hhYmxlU3ByaXRlKTtcbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlQmF0Y2hhYmxlU3ByaXRlKHNwcml0ZSwgYmF0Y2hhYmxlU3ByaXRlKSB7XG4gICAgc3ByaXRlLl9kaWRTcHJpdGVVcGRhdGUgPSBmYWxzZTtcbiAgICBiYXRjaGFibGVTcHJpdGUuZ2VvbWV0cnkudXBkYXRlKHNwcml0ZSk7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gIH1cbiAgX2dldEdwdVNwcml0ZShzcHJpdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXSB8fCB0aGlzLl9pbml0R1BVU3ByaXRlKHNwcml0ZSk7XG4gIH1cbiAgX2luaXRHUFVTcHJpdGUoc3ByaXRlKSB7XG4gICAgY29uc3QgYmF0Y2hhYmxlTWVzaCA9IG5ldyBCYXRjaGFibGVNZXNoKCk7XG4gICAgYmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IG5ldyBOaW5lU2xpY2VHZW9tZXRyeSgpO1xuICAgIGJhdGNoYWJsZU1lc2gubWVzaCA9IHNwcml0ZTtcbiAgICBiYXRjaGFibGVNZXNoLnRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgYmF0Y2hhYmxlTWVzaC5yb3VuZFBpeGVscyA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IHNwcml0ZS5fcm91bmRQaXhlbHM7XG4gICAgdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXSA9IGJhdGNoYWJsZU1lc2g7XG4gICAgc3ByaXRlLm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUoc3ByaXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmF0Y2hhYmxlTWVzaDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVTcHJpdGVIYXNoKSB7XG4gICAgICBjb25zdCBiYXRjaGFibGVNZXNoID0gdGhpcy5fZ3B1U3ByaXRlSGFzaFtpXTtcbiAgICAgIGJhdGNoYWJsZU1lc2guZ2VvbWV0cnkuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5OaW5lU2xpY2VTcHJpdGVQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJuaW5lU2xpY2VTcHJpdGVcIlxufTtcblxuZXhwb3J0IHsgTmluZVNsaWNlU3ByaXRlUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmluZVNsaWNlU3ByaXRlUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBOaW5lU2xpY2VTcHJpdGVQaXBlIH0gZnJvbSAnLi9OaW5lU2xpY2VTcHJpdGVQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoTmluZVNsaWNlU3ByaXRlUGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2092\n')},1015:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(4428);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs\nvar localUniformBit = __webpack_require__(8070);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs\n\nconst tilingBit = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vUV = (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vUV = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=tilingBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader/* Shader */.e {\n  constructor() {\n    gpuProgram ?? (gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBit */.XH,\n        tilingBit,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    }));\n    glProgram ?? (glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBitGl */.$g,\n        tilingBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    }));\n    const tilingUniforms = new UniformGroup/* UniformGroup */.o({\n      uMapCoord: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },\n      uTextureTransform: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup/* UniformGroup */.o({\n          uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n          uRound: { value: 0, type: "f32" }\n        }),\n        tilingUniforms,\n        uTexture: Texture/* Texture */.x.EMPTY.source,\n        uSampler: Texture/* Texture */.x.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\n\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs\n\n\n"use strict";\nclass QuadGeometry extends MeshGeometry/* MeshGeometry */.x {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\n\n//# sourceMappingURL=QuadGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs\n\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\n\n//# sourceMappingURL=setPositions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs\n\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=applyMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs\n\n\n\n"use strict";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite._applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix/* Matrix */.y.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\n\n//# sourceMappingURL=setUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (batchableMesh.texture._source !== renderable.texture._source) {\n        return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n      }\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh/* BatchableMesh */.X());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite._didTilingSpriteUpdate) {\n        tilingSprite._didTilingSpriteUpdate = false;\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.mesh = tilingSprite;\n        batchableMesh.texture = tilingSprite._texture;\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: State/* State */.Z.default2d\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite._didTilingSpriteUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh.batcher.updateElement(batchableMesh);\n    } else if (tilingSprite._didTilingSpriteUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n    tilingSprite._didTilingSpriteUpdate = false;\n  }\n  destroyRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    tilingSpriteData.batchableMesh = null;\n    tilingSpriteData.shader?.destroy();\n    this._tilingSpriteDataHash[tilingSprite.uid] = null;\n  }\n  _getTilingSpriteData(renderable) {\n    return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const geometry = new MeshGeometry/* MeshGeometry */.x({\n      indices: sharedQuad.indices,\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n    this._tilingSpriteDataHash[tilingSprite.uid] = {\n      canBatch: true,\n      renderable: tilingSprite,\n      geometry\n    };\n    tilingSprite.on("destroyed", () => {\n      this.destroyRenderable(tilingSprite);\n    });\n    return this._tilingSpriteDataHash[tilingSprite.uid];\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== "repeat") {\n      style.addressMode = "repeat";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    for (const i in this._tilingSpriteDataHash) {\n      this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n    }\n    this._tilingSpriteDataHash = null;\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === types/* RendererType */.g.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "tilingSprite"\n};\n\n\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDO0FBQ2xDOzs7QUNsSDBEO0FBQzhFO0FBQ3BCO0FBQ0g7QUFDbEM7QUFDWTtBQUNUO0FBQ3pCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQU07QUFDdkM7QUFDQSxnQ0FBZ0MsaUVBQTJCO0FBQzNEO0FBQ0E7QUFDQSxRQUFRLHVDQUFlO0FBQ3ZCLFFBQVEsU0FBUztBQUNqQixRQUFRLG9DQUFjO0FBQ3RCO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixnRUFBMEI7QUFDeEQ7QUFDQTtBQUNBLFFBQVEseUNBQWlCO0FBQ3pCLFFBQVEsV0FBVztBQUNuQixRQUFRLHNDQUFnQjtBQUN4QjtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsZ0NBQVk7QUFDM0MsbUJBQW1CLFdBQVcsb0JBQU0seUJBQXlCO0FBQzdELHFCQUFxQiwwREFBMEQ7QUFDL0Usc0JBQXNCLG9EQUFvRDtBQUMxRSwyQkFBMkIsV0FBVyxvQkFBTSx5QkFBeUI7QUFDckUscUJBQXFCO0FBQ3JCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBWTtBQUN2Qyw4QkFBOEIsV0FBVyxvQkFBTSx5QkFBeUI7QUFDeEUsb0JBQW9CLDBEQUEwRDtBQUM5RSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLHNCQUFPO0FBQ3pCLGtCQUFrQixzQkFBTztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCO0FBQzlCOzs7QUNuRmtFOztBQUVsRTtBQUNBLDJCQUEyQixnQ0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRXdCO0FBQ3hCOzs7QUNkYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEI7OztBQ2ZhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVCO0FBQ3ZCOzs7QUN0QjBEO0FBQ1Y7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxXQUFXO0FBQ2I7O0FBRWtCO0FBQ2xCOzs7QUM1QmdFO0FBQ1M7QUFDTjtBQUNNO0FBQ1I7QUFDRjtBQUNNO0FBQ2I7QUFDQTtBQUNaOztBQUU1QztBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsOEVBQThFLGtDQUFhO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFLO0FBQ2xCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksTUFBTTtBQUNWLElBQUksWUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUU0QjtBQUM1Qjs7O0FDOUo2RDtBQUNIOztBQUUxRDtBQUNBLDZCQUFVLEtBQUssZ0JBQWdCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvc2hhZGVyL3RpbGluZ0JpdC5tanM/YTM2NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy9zaGFkZXIvVGlsaW5nU3ByaXRlU2hhZGVyLm1qcz9iZjRjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL1F1YWRHZW9tZXRyeS5tanM/ODAyNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy91dGlscy9zZXRQb3NpdGlvbnMubWpzP2FhNmQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvYXBwbHlNYXRyaXgubWpzP2NmNmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvc2V0VXZzLm1qcz85ZjUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL1RpbGluZ1Nwcml0ZVBpcGUubWpzP2Q0MGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvaW5pdC5tanM/NTVjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRpbGluZ0JpdCA9IHtcbiAgbmFtZTogXCJ0aWxpbmctYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IFRpbGluZ1VuaWZvcm1zIHtcbiAgICAgICAgICAgICAgICB1TWFwQ29vcmQ6bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdUNsYW1wRnJhbWU6dmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIHVDbGFtcE9mZnNldDp2ZWMyPGYzMj4sXG4gICAgICAgICAgICAgICAgdVRleHR1cmVUcmFuc2Zvcm06bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdVNpemVBbmNob3I6dmVjNDxmMzI+XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHRpbGluZ1VuaWZvcm1zOiBUaWxpbmdVbmlmb3JtcztcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHZVViA9ICh0aWxpbmdVbmlmb3Jtcy51VGV4dHVyZVRyYW5zZm9ybSAqIHZlYzMoYVVWLCAxLjApKS54eTtcblxuICAgICAgICAgICAgcG9zaXRpb24gPSAocG9zaXRpb24gLSB0aWxpbmdVbmlmb3Jtcy51U2l6ZUFuY2hvci56dykgKiB0aWxpbmdVbmlmb3Jtcy51U2l6ZUFuY2hvci54eTtcbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHN0cnVjdCBUaWxpbmdVbmlmb3JtcyB7XG4gICAgICAgICAgICAgICAgdU1hcENvb3JkOm1hdDN4MzxmMzI+LFxuICAgICAgICAgICAgICAgIHVDbGFtcEZyYW1lOnZlYzQ8ZjMyPixcbiAgICAgICAgICAgICAgICB1Q2xhbXBPZmZzZXQ6dmVjMjxmMzI+LFxuICAgICAgICAgICAgICAgIHVUZXh0dXJlVHJhbnNmb3JtOm1hdDN4MzxmMzI+LFxuICAgICAgICAgICAgICAgIHVTaXplQW5jaG9yOnZlYzQ8ZjMyPlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiB0aWxpbmdVbmlmb3JtczogVGlsaW5nVW5pZm9ybXM7XG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG5cbiAgICAgICAgICAgIHZhciBjb29yZCA9IHZVViArIGNlaWwodGlsaW5nVW5pZm9ybXMudUNsYW1wT2Zmc2V0IC0gdlVWKTtcbiAgICAgICAgICAgIGNvb3JkID0gKHRpbGluZ1VuaWZvcm1zLnVNYXBDb29yZCAqIHZlYzMoY29vcmQsIDEuMCkpLnh5O1xuICAgICAgICAgICAgdmFyIHVuY2xhbXBlZCA9IGNvb3JkO1xuICAgICAgICAgICAgY29vcmQgPSBjbGFtcChjb29yZCwgdGlsaW5nVW5pZm9ybXMudUNsYW1wRnJhbWUueHksIHRpbGluZ1VuaWZvcm1zLnVDbGFtcEZyYW1lLnp3KTtcblxuICAgICAgICAgICAgdmFyIGJpYXMgPSAwLjtcblxuICAgICAgICAgICAgaWYodW5jbGFtcGVkLnggPT0gY29vcmQueCAmJiB1bmNsYW1wZWQueSA9PSBjb29yZC55KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpYXMgPSAtMzIuO1xuICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgb3V0Q29sb3IgPSB0ZXh0dXJlU2FtcGxlQmlhcyh1VGV4dHVyZSwgdVNhbXBsZXIsIGNvb3JkLCBiaWFzKTtcbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcbmNvbnN0IHRpbGluZ0JpdEdsID0ge1xuICBuYW1lOiBcInRpbGluZy1iaXRcIixcbiAgdmVydGV4OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdVRleHR1cmVUcmFuc2Zvcm07XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgdVNpemVBbmNob3I7XG4gICAgICAgIFxuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB2VVYgPSAodVRleHR1cmVUcmFuc2Zvcm0gKiB2ZWMzKGFVViwgMS4wKSkueHk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gKHBvc2l0aW9uIC0gdVNpemVBbmNob3IuencpICogdVNpemVBbmNob3IueHk7XG4gICAgICAgIGBcbiAgICApXG4gIH0sXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1TWFwQ29vcmQ7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgdUNsYW1wRnJhbWU7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG5cbiAgICAgICAgdmVjMiBjb29yZCA9IHZVViArIGNlaWwodUNsYW1wT2Zmc2V0IC0gdlVWKTtcbiAgICAgICAgY29vcmQgPSAodU1hcENvb3JkICogdmVjMyhjb29yZCwgMS4wKSkueHk7XG4gICAgICAgIHZlYzIgdW5jbGFtcGVkID0gY29vcmQ7XG4gICAgICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVDbGFtcEZyYW1lLnh5LCB1Q2xhbXBGcmFtZS56dyk7XG4gICAgICAgIFxuICAgICAgICBvdXRDb2xvciA9IHRleHR1cmUodVRleHR1cmUsIGNvb3JkLCB1bmNsYW1wZWQgPT0gY29vcmQgPyAwLjAgOiAtMzIuMCk7Ly8gbG9kLWJpYXMgdmVyeSBuZWdhdGl2ZSB0byBmb3JjZSBsb2QgMFxuICAgIFxuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuXG5leHBvcnQgeyB0aWxpbmdCaXQsIHRpbGluZ0JpdEdsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWxpbmdCaXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtLCBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlSGlnaFNoYWRlclRvUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgbG9jYWxVbmlmb3JtQml0LCBsb2NhbFVuaWZvcm1CaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9sb2NhbFVuaWZvcm1CaXQubWpzJztcbmltcG9ydCB7IHJvdW5kUGl4ZWxzQml0LCByb3VuZFBpeGVsc0JpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL3JvdW5kUGl4ZWxzQml0Lm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB0aWxpbmdCaXQsIHRpbGluZ0JpdEdsIH0gZnJvbSAnLi90aWxpbmdCaXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgZ3B1UHJvZ3JhbTtcbmxldCBnbFByb2dyYW07XG5jbGFzcyBUaWxpbmdTcHJpdGVTaGFkZXIgZXh0ZW5kcyBTaGFkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBncHVQcm9ncmFtID8/IChncHVQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwidGlsaW5nLXNwcml0ZS1zaGFkZXJcIixcbiAgICAgIGJpdHM6IFtcbiAgICAgICAgbG9jYWxVbmlmb3JtQml0LFxuICAgICAgICB0aWxpbmdCaXQsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0XG4gICAgICBdXG4gICAgfSkpO1xuICAgIGdsUHJvZ3JhbSA/PyAoZ2xQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0oe1xuICAgICAgbmFtZTogXCJ0aWxpbmctc3ByaXRlLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBsb2NhbFVuaWZvcm1CaXRHbCxcbiAgICAgICAgdGlsaW5nQml0R2wsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0R2xcbiAgICAgIF1cbiAgICB9KSk7XG4gICAgY29uc3QgdGlsaW5nVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVNYXBDb29yZDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVDbGFtcEZyYW1lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAxXSksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVDbGFtcE9mZnNldDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICB1VGV4dHVyZVRyYW5zZm9ybTogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVTaXplQW5jaG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxMDAsIDEwMCwgMC41LCAwLjVdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9XG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBsb2NhbFVuaWZvcm1zOiBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgICAgICB1VHJhbnNmb3JtTWF0cml4OiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICAgICAgfSksXG4gICAgICAgIHRpbGluZ1VuaWZvcm1zLFxuICAgICAgICB1VGV4dHVyZTogVGV4dHVyZS5FTVBUWS5zb3VyY2UsXG4gICAgICAgIHVTYW1wbGVyOiBUZXh0dXJlLkVNUFRZLnNvdXJjZS5zdHlsZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVVuaWZvcm1zKHdpZHRoLCBoZWlnaHQsIG1hdHJpeCwgYW5jaG9yWCwgYW5jaG9yWSwgdGV4dHVyZSkge1xuICAgIGNvbnN0IHRpbGluZ1VuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMudGlsaW5nVW5pZm9ybXM7XG4gICAgY29uc3QgdGV4dHVyZVdpZHRoID0gdGV4dHVyZS53aWR0aDtcbiAgICBjb25zdCB0ZXh0dXJlSGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XG4gICAgY29uc3QgdGV4dHVyZU1hdHJpeCA9IHRleHR1cmUudGV4dHVyZU1hdHJpeDtcbiAgICBjb25zdCB1VGV4dHVyZVRyYW5zZm9ybSA9IHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVUZXh0dXJlVHJhbnNmb3JtO1xuICAgIHVUZXh0dXJlVHJhbnNmb3JtLnNldChcbiAgICAgIG1hdHJpeC5hICogdGV4dHVyZVdpZHRoIC8gd2lkdGgsXG4gICAgICBtYXRyaXguYiAqIHRleHR1cmVXaWR0aCAvIGhlaWdodCxcbiAgICAgIG1hdHJpeC5jICogdGV4dHVyZUhlaWdodCAvIHdpZHRoLFxuICAgICAgbWF0cml4LmQgKiB0ZXh0dXJlSGVpZ2h0IC8gaGVpZ2h0LFxuICAgICAgbWF0cml4LnR4IC8gd2lkdGgsXG4gICAgICBtYXRyaXgudHkgLyBoZWlnaHRcbiAgICApO1xuICAgIHVUZXh0dXJlVHJhbnNmb3JtLmludmVydCgpO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVNYXBDb29yZCA9IHRleHR1cmVNYXRyaXgubWFwQ29vcmQ7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudUNsYW1wRnJhbWUgPSB0ZXh0dXJlTWF0cml4LnVDbGFtcEZyYW1lO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVDbGFtcE9mZnNldCA9IHRleHR1cmVNYXRyaXgudUNsYW1wT2Zmc2V0O1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVUZXh0dXJlVHJhbnNmb3JtID0gdVRleHR1cmVUcmFuc2Zvcm07XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVNpemVBbmNob3JbMF0gPSB3aWR0aDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZUFuY2hvclsxXSA9IGhlaWdodDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZUFuY2hvclsyXSA9IGFuY2hvclg7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVNpemVBbmNob3JbM10gPSBhbmNob3JZO1xuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB0aGlzLnJlc291cmNlcy51VGV4dHVyZSA9IHRleHR1cmUuc291cmNlO1xuICAgICAgdGhpcy5yZXNvdXJjZXMudVNhbXBsZXIgPSB0ZXh0dXJlLnNvdXJjZS5zdHlsZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgVGlsaW5nU3ByaXRlU2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxpbmdTcHJpdGVTaGFkZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vbWVzaC9zaGFyZWQvTWVzaEdlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgUXVhZEdlb21ldHJ5IGV4dGVuZHMgTWVzaEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSksXG4gICAgICB1dnM6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKSxcbiAgICAgIGluZGljZXM6IG5ldyBVaW50MzJBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgUXVhZEdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkR2VvbWV0cnkubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBzZXRQb3NpdGlvbnModGlsaW5nU3ByaXRlLCBwb3NpdGlvbnMpIHtcbiAgY29uc3QgYW5jaG9yWCA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueDtcbiAgY29uc3QgYW5jaG9yWSA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueTtcbiAgcG9zaXRpb25zWzBdID0gLWFuY2hvclggKiB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHBvc2l0aW9uc1sxXSA9IC1hbmNob3JZICogdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgcG9zaXRpb25zWzJdID0gKDEgLSBhbmNob3JYKSAqIHRpbGluZ1Nwcml0ZS53aWR0aDtcbiAgcG9zaXRpb25zWzNdID0gLWFuY2hvclkgKiB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xuICBwb3NpdGlvbnNbNF0gPSAoMSAtIGFuY2hvclgpICogdGlsaW5nU3ByaXRlLndpZHRoO1xuICBwb3NpdGlvbnNbNV0gPSAoMSAtIGFuY2hvclkpICogdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgcG9zaXRpb25zWzZdID0gLWFuY2hvclggKiB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHBvc2l0aW9uc1s3XSA9ICgxIC0gYW5jaG9yWSkgKiB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xufVxuXG5leHBvcnQgeyBzZXRQb3NpdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldFBvc2l0aW9ucy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFwcGx5TWF0cml4KGFycmF5LCBzdHJpZGUsIG9mZnNldCwgbWF0cml4KSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IHNpemUgPSBhcnJheS5sZW5ndGggLyAoc3RyaWRlIHx8IDIpO1xuICBjb25zdCBhID0gbWF0cml4LmE7XG4gIGNvbnN0IGIgPSBtYXRyaXguYjtcbiAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICBjb25zdCBkID0gbWF0cml4LmQ7XG4gIGNvbnN0IHR4ID0gbWF0cml4LnR4O1xuICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgb2Zmc2V0ICo9IHN0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgIGNvbnN0IHggPSBhcnJheVtvZmZzZXRdO1xuICAgIGNvbnN0IHkgPSBhcnJheVtvZmZzZXQgKyAxXTtcbiAgICBhcnJheVtvZmZzZXRdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIGFycmF5W29mZnNldCArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgaW5kZXgrKztcbiAgfVxufVxuXG5leHBvcnQgeyBhcHBseU1hdHJpeCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHlNYXRyaXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgYXBwbHlNYXRyaXggfSBmcm9tICcuL2FwcGx5TWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc2V0VXZzKHRpbGluZ1Nwcml0ZSwgdXZzKSB7XG4gIGNvbnN0IHRleHR1cmUgPSB0aWxpbmdTcHJpdGUudGV4dHVyZTtcbiAgY29uc3Qgd2lkdGggPSB0ZXh0dXJlLmZyYW1lLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSB0ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgbGV0IGFuY2hvclggPSAwO1xuICBsZXQgYW5jaG9yWSA9IDA7XG4gIGlmICh0aWxpbmdTcHJpdGUuX2FwcGx5QW5jaG9yVG9UZXh0dXJlKSB7XG4gICAgYW5jaG9yWCA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueDtcbiAgICBhbmNob3JZID0gdGlsaW5nU3ByaXRlLmFuY2hvci55O1xuICB9XG4gIHV2c1swXSA9IHV2c1s2XSA9IC1hbmNob3JYO1xuICB1dnNbMl0gPSB1dnNbNF0gPSAxIC0gYW5jaG9yWDtcbiAgdXZzWzFdID0gdXZzWzNdID0gLWFuY2hvclk7XG4gIHV2c1s1XSA9IHV2c1s3XSA9IDEgLSBhbmNob3JZO1xuICBjb25zdCB0ZXh0dXJlTWF0cml4ID0gTWF0cml4LnNoYXJlZDtcbiAgdGV4dHVyZU1hdHJpeC5jb3B5RnJvbSh0aWxpbmdTcHJpdGUuX3RpbGVUcmFuc2Zvcm0ubWF0cml4KTtcbiAgdGV4dHVyZU1hdHJpeC50eCAvPSB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHRleHR1cmVNYXRyaXgudHkgLz0gdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgdGV4dHVyZU1hdHJpeC5pbnZlcnQoKTtcbiAgdGV4dHVyZU1hdHJpeC5zY2FsZSh0aWxpbmdTcHJpdGUud2lkdGggLyB3aWR0aCwgdGlsaW5nU3ByaXRlLmhlaWdodCAvIGhlaWdodCk7XG4gIGFwcGx5TWF0cml4KHV2cywgMiwgMCwgdGV4dHVyZU1hdHJpeCk7XG59XG5cbmV4cG9ydCB7IHNldFV2cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0VXZzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvdHlwZXMubWpzJztcbmltcG9ydCB7IGNvbG9yMzJCaXRUb1VuaWZvcm0gfSBmcm9tICcuLi9ncmFwaGljcy9ncHUvY29sb3JUb1VuaWZvcm0ubWpzJztcbmltcG9ydCB7IEJhdGNoYWJsZU1lc2ggfSBmcm9tICcuLi9tZXNoL3NoYXJlZC9CYXRjaGFibGVNZXNoLm1qcyc7XG5pbXBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICcuLi9tZXNoL3NoYXJlZC9NZXNoR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IFRpbGluZ1Nwcml0ZVNoYWRlciB9IGZyb20gJy4vc2hhZGVyL1RpbGluZ1Nwcml0ZVNoYWRlci5tanMnO1xuaW1wb3J0IHsgUXVhZEdlb21ldHJ5IH0gZnJvbSAnLi91dGlscy9RdWFkR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IHNldFBvc2l0aW9ucyB9IGZyb20gJy4vdXRpbHMvc2V0UG9zaXRpb25zLm1qcyc7XG5pbXBvcnQgeyBzZXRVdnMgfSBmcm9tICcuL3V0aWxzL3NldFV2cy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHNoYXJlZFF1YWQgPSBuZXcgUXVhZEdlb21ldHJ5KCk7XG5jbGFzcyBUaWxpbmdTcHJpdGVQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHJlbmRlcmFibGUpIHtcbiAgICBjb25zdCB0aWxpbmdTcHJpdGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YShyZW5kZXJhYmxlKTtcbiAgICBjb25zdCBjb3VsZEJhdGNoID0gdGlsaW5nU3ByaXRlRGF0YS5jYW5CYXRjaDtcbiAgICB0aGlzLl91cGRhdGVDYW5CYXRjaChyZW5kZXJhYmxlKTtcbiAgICBjb25zdCBjYW5CYXRjaCA9IHRpbGluZ1Nwcml0ZURhdGEuY2FuQmF0Y2g7XG4gICAgaWYgKGNhbkJhdGNoICYmIGNhbkJhdGNoID09PSBjb3VsZEJhdGNoKSB7XG4gICAgICBjb25zdCB7IGJhdGNoYWJsZU1lc2ggfSA9IHRpbGluZ1Nwcml0ZURhdGE7XG4gICAgICBpZiAoYmF0Y2hhYmxlTWVzaC50ZXh0dXJlLl9zb3VyY2UgIT09IHJlbmRlcmFibGUudGV4dHVyZS5fc291cmNlKSB7XG4gICAgICAgIHJldHVybiAhYmF0Y2hhYmxlTWVzaC5iYXRjaGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZShiYXRjaGFibGVNZXNoLCByZW5kZXJhYmxlLnRleHR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bGRCYXRjaCAhPT0gY2FuQmF0Y2g7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgYmF0Y2hlciA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoO1xuICAgIHRoaXMuX3VwZGF0ZUNhbkJhdGNoKHRpbGluZ1Nwcml0ZSk7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGdlb21ldHJ5LCBjYW5CYXRjaCB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICBpZiAoY2FuQmF0Y2gpIHtcbiAgICAgIHRpbGluZ1Nwcml0ZURhdGEuYmF0Y2hhYmxlTWVzaCB8fCAodGlsaW5nU3ByaXRlRGF0YS5iYXRjaGFibGVNZXNoID0gbmV3IEJhdGNoYWJsZU1lc2goKSk7XG4gICAgICBjb25zdCBiYXRjaGFibGVNZXNoID0gdGlsaW5nU3ByaXRlRGF0YS5iYXRjaGFibGVNZXNoO1xuICAgICAgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKSB7XG4gICAgICAgIHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoYWJsZU1lc2godGlsaW5nU3ByaXRlKTtcbiAgICAgICAgYmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICBiYXRjaGFibGVNZXNoLm1lc2ggPSB0aWxpbmdTcHJpdGU7XG4gICAgICAgIGJhdGNoYWJsZU1lc2gudGV4dHVyZSA9IHRpbGluZ1Nwcml0ZS5fdGV4dHVyZTtcbiAgICAgIH1cbiAgICAgIGJhdGNoYWJsZU1lc2gucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCB0aWxpbmdTcHJpdGUuX3JvdW5kUGl4ZWxzO1xuICAgICAgYmF0Y2hlci5hZGRUb0JhdGNoKGJhdGNoYWJsZU1lc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXRjaGVyLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICAgIHRpbGluZ1Nwcml0ZURhdGEuc2hhZGVyIHx8ICh0aWxpbmdTcHJpdGVEYXRhLnNoYWRlciA9IG5ldyBUaWxpbmdTcHJpdGVTaGFkZXIoKSk7XG4gICAgICB0aGlzLnVwZGF0ZVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKTtcbiAgICAgIGluc3RydWN0aW9uU2V0LmFkZCh0aWxpbmdTcHJpdGUpO1xuICAgIH1cbiAgfVxuICBleGVjdXRlKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHsgc2hhZGVyIH0gPSB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFt0aWxpbmdTcHJpdGUudWlkXTtcbiAgICBzaGFkZXIuZ3JvdXBzWzBdID0gdGhpcy5fcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMuYmluZEdyb3VwO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSBzaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gdGlsaW5nU3ByaXRlLmdyb3VwVHJhbnNmb3JtO1xuICAgIGxvY2FsVW5pZm9ybXMudVJvdW5kID0gdGhpcy5fcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgdGlsaW5nU3ByaXRlLl9yb3VuZFBpeGVscztcbiAgICBjb2xvcjMyQml0VG9Vbmlmb3JtKFxuICAgICAgdGlsaW5nU3ByaXRlLmdyb3VwQ29sb3JBbHBoYSxcbiAgICAgIGxvY2FsVW5pZm9ybXMudUNvbG9yLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZW5jb2Rlci5kcmF3KHtcbiAgICAgIGdlb21ldHJ5OiBzaGFyZWRRdWFkLFxuICAgICAgc2hhZGVyLFxuICAgICAgc3RhdGU6IFN0YXRlLmRlZmF1bHQyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGNhbkJhdGNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgIGlmIChjYW5CYXRjaCkge1xuICAgICAgY29uc3QgeyBiYXRjaGFibGVNZXNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgICAgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKVxuICAgICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVNZXNoKHRpbGluZ1Nwcml0ZSk7XG4gICAgICBiYXRjaGFibGVNZXNoLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaGFibGVNZXNoKTtcbiAgICB9IGVsc2UgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKSB7XG4gICAgICBjb25zdCB7IHNoYWRlciB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICAgIHNoYWRlci51cGRhdGVVbmlmb3JtcyhcbiAgICAgICAgdGlsaW5nU3ByaXRlLndpZHRoLFxuICAgICAgICB0aWxpbmdTcHJpdGUuaGVpZ2h0LFxuICAgICAgICB0aWxpbmdTcHJpdGUuX3RpbGVUcmFuc2Zvcm0ubWF0cml4LFxuICAgICAgICB0aWxpbmdTcHJpdGUuYW5jaG9yLngsXG4gICAgICAgIHRpbGluZ1Nwcml0ZS5hbmNob3IueSxcbiAgICAgICAgdGlsaW5nU3ByaXRlLnRleHR1cmVcbiAgICAgICk7XG4gICAgfVxuICAgIHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICB0aWxpbmdTcHJpdGVEYXRhLmJhdGNoYWJsZU1lc2ggPSBudWxsO1xuICAgIHRpbGluZ1Nwcml0ZURhdGEuc2hhZGVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbdGlsaW5nU3ByaXRlLnVpZF0gPSBudWxsO1xuICB9XG4gIF9nZXRUaWxpbmdTcHJpdGVEYXRhKHJlbmRlcmFibGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbcmVuZGVyYWJsZS51aWRdIHx8IHRoaXMuX2luaXRUaWxpbmdTcHJpdGVEYXRhKHJlbmRlcmFibGUpO1xuICB9XG4gIF9pbml0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBNZXNoR2VvbWV0cnkoe1xuICAgICAgaW5kaWNlczogc2hhcmVkUXVhZC5pbmRpY2VzLFxuICAgICAgcG9zaXRpb25zOiBzaGFyZWRRdWFkLnBvc2l0aW9ucy5zbGljZSgpLFxuICAgICAgdXZzOiBzaGFyZWRRdWFkLnV2cy5zbGljZSgpXG4gICAgfSk7XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbdGlsaW5nU3ByaXRlLnVpZF0gPSB7XG4gICAgICBjYW5CYXRjaDogdHJ1ZSxcbiAgICAgIHJlbmRlcmFibGU6IHRpbGluZ1Nwcml0ZSxcbiAgICAgIGdlb21ldHJ5XG4gICAgfTtcbiAgICB0aWxpbmdTcHJpdGUub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFt0aWxpbmdTcHJpdGUudWlkXTtcbiAgfVxuICBfdXBkYXRlQmF0Y2hhYmxlTWVzaCh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCByZW5kZXJhYmxlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGdlb21ldHJ5IH0gPSByZW5kZXJhYmxlRGF0YTtcbiAgICBjb25zdCBzdHlsZSA9IHRpbGluZ1Nwcml0ZS50ZXh0dXJlLnNvdXJjZS5zdHlsZTtcbiAgICBpZiAoc3R5bGUuYWRkcmVzc01vZGUgIT09IFwicmVwZWF0XCIpIHtcbiAgICAgIHN0eWxlLmFkZHJlc3NNb2RlID0gXCJyZXBlYXRcIjtcbiAgICAgIHN0eWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBzZXRVdnModGlsaW5nU3ByaXRlLCBnZW9tZXRyeS51dnMpO1xuICAgIHNldFBvc2l0aW9ucyh0aWxpbmdTcHJpdGUsIGdlb21ldHJ5LnBvc2l0aW9ucyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2gpIHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUodGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbaV0ucmVuZGVyYWJsZSk7XG4gICAgfVxuICAgIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbiAgX3VwZGF0ZUNhbkJhdGNoKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHJlbmRlcmFibGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aWxpbmdTcHJpdGUudGV4dHVyZTtcbiAgICBsZXQgX25vblBvd09mMndyYXBwaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fcmVuZGVyZXIudHlwZSA9PT0gUmVuZGVyZXJUeXBlLldFQkdMKSB7XG4gICAgICBfbm9uUG93T2Yyd3JhcHBpbmcgPSB0aGlzLl9yZW5kZXJlci5jb250ZXh0LnN1cHBvcnRzLm5vblBvd09mMndyYXBwaW5nO1xuICAgIH1cbiAgICByZW5kZXJhYmxlRGF0YS5jYW5CYXRjaCA9IHRleHR1cmUudGV4dHVyZU1hdHJpeC5pc1NpbXBsZSAmJiAoX25vblBvd09mMndyYXBwaW5nIHx8IHRleHR1cmUuc291cmNlLmlzUG93ZXJPZlR3byk7XG4gICAgcmV0dXJuIHJlbmRlcmFibGVEYXRhLmNhbkJhdGNoO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuVGlsaW5nU3ByaXRlUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwidGlsaW5nU3ByaXRlXCJcbn07XG5cbmV4cG9ydCB7IFRpbGluZ1Nwcml0ZVBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGluZ1Nwcml0ZVBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGlsaW5nU3ByaXRlUGlwZSB9IGZyb20gJy4vVGlsaW5nU3ByaXRlUGlwZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKFRpbGluZ1Nwcml0ZVBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1015\n')},8201:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(4334);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\nvar copySearchParams = __webpack_require__(8479);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(1718);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs\n\n\n\n"use strict";\nclass AbstractBitmapFont extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = "";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: "none", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or "none".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");\n    return this.distanceField.type;\n  }\n  destroy() {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture.destroy();\n    }\n    this.chars = null;\n  }\n}\n\n\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs\nvar FillGradient = __webpack_require__(557);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs + 15 modules\nvar GraphicsContext = __webpack_require__(6653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs\nvar convertFillInputToFillStyle = __webpack_require__(4915);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs\n\nconst valuesToIterateForKeys = [\n  "_fontFamily",\n  "_fontStyle",\n  "_fontSize",\n  "_fontVariant",\n  "_fontWeight",\n  "_breakWords",\n  "_align",\n  "_leading",\n  "_letterSpacing",\n  "_lineHeight",\n  "_textBaseline",\n  "_whiteSpace",\n  "_wordWrap",\n  "_wordWrapWidth",\n  "_padding",\n  "_cssOverrides",\n  "_trim"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = valuesToIterateForKeys[i];\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  return key.join("-");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.uid;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\n\n\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst _TextStyle = class _TextStyle extends eventemitter3/* default */.Z {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {\'left\'|\'center\'|\'right\'|\'justify\'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === "object") {\n      this._dropShadow = {\n        ..._TextStyle.defaultDropShadow,\n        ...value\n      };\n    } else {\n      this._dropShadow = value ? {\n        ..._TextStyle.defaultDropShadow\n      } : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are \'26px\',\'20pt\',\'160%\' or \'1.6em\') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === "string") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {\'normal\'|\'italic\'|\'oblique\'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value;\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {\'normal\'|\'small-caps\'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {\'normal\'|\'bold\'|\'bolder\'|\'lighter\'|\'100\'|\'200\'|\'300\'|\'400\'|\'500\'|\'600\'|\'700\'|\'800\'|\'900\'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {\'alphabetic\'|\'top\'|\'hanging\'|\'middle\'|\'ideographic\'|\'bottom\'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is \'pre\' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * \'normal\'     | Collapse      |   Collapse\n   * \'pre\'        | Preserve      |   Preserve\n   * \'pre-line\'   | Preserve      |   Collapse\n   * @member {\'normal\'|\'pre\'|\'pre-line\'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., \'red\', \'#00FF00\'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    this._fill = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(\n      value === 0 ? "black" : value,\n      GraphicsContext/* GraphicsContext */.g.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., \'blue\', \'#FCFF00\'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    this._stroke = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(value, GraphicsContext/* GraphicsContext */.g.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit("update", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., \'red\', \'#00FF00\' */\n  color: "black",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {\'left\'|\'center\'|\'right\'|\'justify\'}\n   */\n  align: "left",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: "black",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: "Arial",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {\'normal\'|\'italic\'|\'oblique\'}\n   */\n  fontStyle: "normal",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {\'normal\'|\'small-caps\'}\n   */\n  fontVariant: "normal",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {\'normal\'|\'bold\'|\'bolder\'|\'lighter\'|\'100\'|\'200\'|\'300\'|\'400\'|\'500\'|\'600\'|\'700\'|\'800\'|\'900\'}\n   */\n  fontWeight: "normal",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {\'alphabetic\'|\'top\'|\'hanging\'|\'middle\'|\'ideographic\'|\'bottom\'}\n   */\n  textBaseline: "alphabetic",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {\'normal\'|\'pre\'|\'pre-line\'}\n   */\n  whiteSpace: "pre",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "strokeThickness is now a part of stroke");\n    const color = oldStyle.stroke;\n    style.stroke = {\n      color,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fill)) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "gradient fill is now a fill pattern: `new FillGradient(...)`");\n    const gradientFill = new FillGradient/* FillGradient */.f(0, 0, 0, style.fontSize * 1.7);\n    const fills = oldStyle.fill.map((color) => Color/* Color */.I.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\n\n//# sourceMappingURL=TextStyle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(9160);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(13);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(778);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs\n\nfunction resolveCharacters(chars) {\n  if (chars === "") {\n    return [];\n  }\n  if (typeof chars === "string") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error("[BitmapFont]: Invalid character delimiter.");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error("[BitmapFont]: Invalid character range.");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 4;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = options;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture/* Texture */.x.WHITE;\n      style._fill.fill = null;\n    }\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics/* CanvasTextMetrics */.c.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === "italic" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== "\\n" && char !== "\\r" && char !== "\t" && char !== " ") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > 512) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > 512) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle/* Rectangle */.A(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture/* Texture */.x({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(512, 512, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture/* Texture */.x({\n      source: new ImageSource/* ImageSource */.c({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: "premultiply-alpha-on-upload"\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color/* Color */.I.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = "black";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n}\n\n\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs\n\nfunction getBitmapTextLayout(chars, style, font) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    let lastChar = currentLine.chars[index];\n    while (lastChar === " ") {\n      currentLine.width -= font.chars[lastChar].xAdvance;\n      lastChar = currentLine.chars[--index];\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[" "];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === "\\r" || char === "\\n" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === "\\r" || char === "\\n") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === "center") {\n    alignCenter(layoutData);\n  } else if (style.align === "right") {\n    alignRight(layoutData);\n  } else if (style.align === "justify") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\n\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs\n\n\n\n\n\n\n\n"use strict";\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [["a", "z"], ["A", "Z"], " "];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [["0", "9"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[" ", "~"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill) {\n      fontFamilyKey += style._fill.fill.uid;\n      overrideFill = false;\n    }\n    if (!Cache/* Cache */.C.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fnt.once("destroy", () => Cache/* Cache */.C.remove(fontFamilyKey));\n      Cache/* Cache */.C.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache/* Cache */.C.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */\n  getLayout(text, style) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout(text.split(""), style, bitmapFont);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */\n  measureText(text, style) {\n    return this.getLayout(text, style);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === "string") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error("[BitmapFontManager] Property `name` is required.");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(""));\n    Cache/* Cache */.C.set(`${name}-bitmap`, font);\n    font.once("destroy", () => Cache/* Cache */.C.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache/* Cache */.C.get(cacheKey);\n    if (font) {\n      Cache/* Cache */.C.remove(cacheKey);\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\n\n//# sourceMappingURL=BitmapFontManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs\n\n\n\n\n\n"use strict";\nclass BitmapFont extends AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const textureSource = textures[charData.page].source;\n      const frameReal = new Rectangle/* Rectangle */.A(\n        charData.x,\n        charData.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture/* Texture */.x({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: "none",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from \'pixi.js\';\n   *\n   * BitmapFont.install(\'TitleFont\', {\n   *     fontFamily: \'Arial\',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: \'purple\',\n   * });\n   *\n   * const title = new BitmapText({ text: \'This is the title\', fontFamily: \'TitleFont\' });\n   */\n  static install(options) {\n    BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager.uninstall(name);\n  }\n}\n\n\n//# sourceMappingURL=BitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs\n\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === "string" && data.startsWith("info face=");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s"\']+|"([^"]*)")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split("=");\n        const key = split[0];\n        const strValue = split[1].replace(/"/gm, "");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs\n\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName("info")[0];\n    const common = xml.getElementsByTagName("common")[0];\n    const distanceField = xml.getElementsByTagName("distanceField")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute("fieldType"),\n        range: parseInt(distanceField.getAttribute("distanceRange"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName("page");\n    const char = xml.getElementsByTagName("char");\n    const kerning = xml.getElementsByTagName("kerning");\n    data.fontSize = parseInt(info.getAttribute("size"), 10);\n    data.fontFamily = info.getAttribute("face");\n    data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute("id"), 10) || 0,\n        file: page[i].getAttribute("file")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute("id"), 10);\n      let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute("page"), 10) || 0,\n        x: parseInt(charNode.getAttribute("x"), 10),\n        y: parseInt(charNode.getAttribute("y"), 10),\n        width: parseInt(charNode.getAttribute("width"), 10),\n        height: parseInt(charNode.getAttribute("height"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute("xoffset"), 10),\n        yOffset: parseInt(charNode.getAttribute("yoffset"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute("first"), 10);\n      const second = parseInt(kerning[i].getAttribute("second"), 10);\n      const amount = parseInt(kerning[i].getAttribute("amount"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs\n\n\n\n"use strict";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === "string" && data.includes("<font>")) {\n      return bitmapFontXMLParser.test(adapter/* DOMAdapter */.z.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(adapter/* DOMAdapter */.z.get().parseXML(data));\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validExtensions = [".xml", ".fnt"];\nconst bitmapFontCachePlugin = {\n  extension: Extensions/* ExtensionType */.nw.CacheParser,\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.Normal\n  },\n  test(url) {\n    return validExtensions.includes(path/* path */.E.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path/* path */.E.join(path/* path */.E.dirname(src), pageFile);\n      imagePath = (0,copySearchParams/* copySearchParams */.u)(imagePath, src);\n      textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n    return await response.text();\n  },\n  unload(bitmapFont) {\n    bitmapFont.destroy();\n  }\n};\n\n\n//# sourceMappingURL=loadBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\nvar Graphics = __webpack_require__(6475);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs\nvar shared_const = __webpack_require__(4589);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(2110);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(6600);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs\nvar batchSamplersUniformGroup = __webpack_require__(5774);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs\n\nconst localUniformMSDFBit = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs\n\nconst mSDFBit = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=mSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass SdfShader extends Shader/* Shader */.e {\n  constructor() {\n    const uniforms = new UniformGroup/* UniformGroup */.o({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uDistance: { value: 4, type: "f32" },\n      uRound: { value: 0, type: "f32" }\n    });\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBit */.M,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */.m)(shared_const/* MAX_TEXTURES */.A),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    });\n    const glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBitGl */.T,\n        (0,generateTextureBatchBit/* generateTextureBatchBitGl */.h)(shared_const/* MAX_TEXTURES */.A),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: batchSamplersUniformGroup/* batchSamplersUniformGroup */.y\n      }\n    });\n  }\n}\n\n\n//# sourceMappingURL=SdfShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._gpuBitmapText = {};\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  destroyRenderable(bitmapText) {\n    this._destroyRenderableByUid(bitmapText.uid);\n  }\n  _destroyRenderableByUid(renderableUid) {\n    PoolGroup/* BigPool */.u.return(this._gpuBitmapText[renderableUid]);\n    this._gpuBitmapText[renderableUid] = null;\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== "none") {\n      if (!context.customShader) {\n        if (!this._sdfShader) {\n          this._sdfShader = new SdfShader();\n        }\n        context.customShader = this._sdfShader;\n      }\n    }\n    const chars = Array.from(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = (style._stroke?.width || 0) / 2;\n    currentY += bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    context.translate(\n      -bitmapText._anchor._x * bitmapTextLayout.width - padding,\n      -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding\n    ).scale(scale, scale);\n    const tint = style._fill.color;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint,\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = PoolGroup/* BigPool */.u.get(Graphics/* Graphics */.T);\n    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    bitmapText.on("destroyed", () => {\n      this.destroyRenderable(bitmapText);\n    });\n    return this._gpuBitmapText[bitmapText.uid];\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache/* Cache */.C.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const resolution = bitmapText.resolution ?? this._renderer.resolution;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    for (const uid in this._gpuBitmapText) {\n      this._destroyRenderableByUid(uid);\n    }\n    this._gpuBitmapText = null;\n    this._sdfShader?.destroy(true);\n    this._sdfShader = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "bitmapText"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\n\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIwMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNpQzs7QUFFMUU7QUFDQSxpQ0FBaUMsNEJBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCO0FBQzlCOzs7Ozs7Ozs7Ozs7O0FDckZhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdDO0FBQ2hDOzs7QUNwRHlDO0FBQ0s7QUFDNEI7QUFDRjtBQUNDO0FBQzhCO0FBQy9COztBQUV4RTtBQUNBLDRDQUE0Qyw0QkFBWTtBQUN4RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtB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QUFvQixtQ0FBbUM7QUFDdkQ7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBTyxLQUFLLHdCQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQUssUUFBUSxXQUFXO0FBQ2hELFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQjs7O0FDcEo2RDtBQUNzQjtBQUM3Qjs7QUFFdEQ7QUFDQSw2QkFBVSxLQUFLLGNBQWMsRUFBRSxjQUFjLEVBQUUscUJBQXFCO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL0Fic3RyYWN0Qml0bWFwRm9udC5tanM/OTFhZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC91dGlscy9nZW5lcmF0ZVRleHRTdHlsZUtleS5tanM/YzY3YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9UZXh0U3R5bGUubWpzPzRhZDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcz9hYzNjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9EeW5hbWljQml0bWFwRm9udC5tanM/NWU4NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanM/NDRiYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwRm9udE1hbmFnZXIubWpzP2VkMDIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL0JpdG1hcEZvbnQubWpzPzI3NzkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL2Fzc2V0L2JpdG1hcEZvbnRUZXh0UGFyc2VyLm1qcz8zZTUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MUGFyc2VyLm1qcz81ZTBiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLm1qcz8wNWQyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9sb2FkQml0bWFwRm9udC5tanM/NWYwYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtTVNERkJpdC5tanM/OWRhYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbVNERkJpdC5tanM/MGM1MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9zZGZTaGFkZXIvU2RmU2hhZGVyLm1qcz9hMDMwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9CaXRtYXBUZXh0UGlwZS5tanM/NWRiNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvaW5pdC5tanM/ZWU3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBBYnN0cmFjdEJpdG1hcEZvbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKiBUaGUgbWFwIG9mIGNoYXJhY3RlcnMgYnkgY2hhcmFjdGVyIGNvZGUuICovXG4gICAgdGhpcy5jaGFycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lLWhlaWdodCBvZiB0aGUgZm9udCBmYWNlIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGluZUhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZvbnQgZmFjZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJcIjtcbiAgICAvKiogVGhlIG1ldHJpY3Mgb2YgdGhlIGZvbnQgZmFjZS4gKi9cbiAgICB0aGlzLmZvbnRNZXRyaWNzID0geyBmb250U2l6ZTogMCwgYXNjZW50OiAwLCBkZXNjZW50OiAwIH07XG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCBvZiB0aGUgZm9udCBmYWNlIGZyb20gdGhlIGJhc2VsaW5lLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5iYXNlTGluZU9mZnNldCA9IDA7XG4gICAgLyoqIFRoZSByYW5nZSBhbmQgdHlwZSBvZiB0aGUgZGlzdGFuY2UgZmllbGQgZm9yIHRoaXMgZm9udC4gKi9cbiAgICB0aGlzLmRpc3RhbmNlRmllbGQgPSB7IHR5cGU6IFwibm9uZVwiLCByYW5nZTogMCB9O1xuICAgIC8qKiBUaGUgbWFwIG9mIGJhc2UgcGFnZSB0ZXh0dXJlcyAoaS5lLiwgc2hlZXRzIG9mIGdseXBocykuICovXG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZm9udCBmYWNlIGluIHBpeGVscy4gKi9cbiAgICB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplID0gMTAwO1xuICAgIHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgPSAxMDA7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmb250IGZhY2UuXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSBgZm9udEZhbWlseWAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBmb250KCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LmZvbnQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LmZvbnRGYW1pbHkgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuZm9udEZhbWlseTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hcCBvZiBiYXNlIHBhZ2UgdGV4dHVyZXMgKGkuZS4sIHNoZWV0cyBvZiBnbHlwaHMpLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYHBhZ2VzYCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHBhZ2VUZXh0dXJlcygpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5wYWdlVGV4dHVyZXMgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LnBhZ2VzIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLnBhZ2VzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZm9udCBmYWNlIGluIHBpeGVscy5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBmb250TWV0cmljcy5mb250U2l6ZWAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LnNpemUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LmZvbnRNZXRyaWNzLmZvbnRTaXplIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmZvbnRNZXRyaWNzLmZvbnRTaXplO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2luZCBvZiBkaXN0YW5jZSBmaWVsZCBmb3IgdGhpcyBmb250IG9yIFwibm9uZVwiLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYGRpc3RhbmNlRmllbGQudHlwZWAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBkaXN0YW5jZUZpZWxkUmFuZ2UoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQuZGlzdGFuY2VGaWVsZFJhbmdlIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5kaXN0YW5jZUZpZWxkLnJhbmdlIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlRmllbGQucmFuZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByYW5nZSBvZiB0aGUgZGlzdGFuY2UgZmllbGQgaW4gcGl4ZWxzLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYGRpc3RhbmNlRmllbGQucmFuZ2VgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgZGlzdGFuY2VGaWVsZFR5cGUoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQuZGlzdGFuY2VGaWVsZFR5cGUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LmRpc3RhbmNlRmllbGQudHlwZSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZUZpZWxkLnR5cGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuY2hhcnMpIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0udGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuY2hhcnMgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB7IEFic3RyYWN0Qml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RCaXRtYXBGb250Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdmFsdWVzVG9JdGVyYXRlRm9yS2V5cyA9IFtcbiAgXCJfZm9udEZhbWlseVwiLFxuICBcIl9mb250U3R5bGVcIixcbiAgXCJfZm9udFNpemVcIixcbiAgXCJfZm9udFZhcmlhbnRcIixcbiAgXCJfZm9udFdlaWdodFwiLFxuICBcIl9icmVha1dvcmRzXCIsXG4gIFwiX2FsaWduXCIsXG4gIFwiX2xlYWRpbmdcIixcbiAgXCJfbGV0dGVyU3BhY2luZ1wiLFxuICBcIl9saW5lSGVpZ2h0XCIsXG4gIFwiX3RleHRCYXNlbGluZVwiLFxuICBcIl93aGl0ZVNwYWNlXCIsXG4gIFwiX3dvcmRXcmFwXCIsXG4gIFwiX3dvcmRXcmFwV2lkdGhcIixcbiAgXCJfcGFkZGluZ1wiLFxuICBcIl9jc3NPdmVycmlkZXNcIixcbiAgXCJfdHJpbVwiXG5dO1xuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0U3R5bGVLZXkoc3R5bGUpIHtcbiAgY29uc3Qga2V5ID0gW107XG4gIGxldCBpbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzVG9JdGVyYXRlRm9yS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3AgPSB2YWx1ZXNUb0l0ZXJhdGVGb3JLZXlzW2ldO1xuICAgIGtleVtpbmRleCsrXSA9IHN0eWxlW3Byb3BdO1xuICB9XG4gIGluZGV4ID0gYWRkRmlsbFN0eWxlS2V5KHN0eWxlLl9maWxsLCBrZXksIGluZGV4KTtcbiAgaW5kZXggPSBhZGRTdG9rZVN0eWxlS2V5KHN0eWxlLl9zdHJva2UsIGtleSwgaW5kZXgpO1xuICByZXR1cm4ga2V5LmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gYWRkRmlsbFN0eWxlS2V5KGZpbGxTdHlsZSwga2V5LCBpbmRleCkge1xuICBpZiAoIWZpbGxTdHlsZSlcbiAgICByZXR1cm4gaW5kZXg7XG4gIGtleVtpbmRleCsrXSA9IGZpbGxTdHlsZS5jb2xvcjtcbiAga2V5W2luZGV4KytdID0gZmlsbFN0eWxlLmFscGhhO1xuICBrZXlbaW5kZXgrK10gPSBmaWxsU3R5bGUuZmlsbD8udWlkO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBhZGRTdG9rZVN0eWxlS2V5KHN0cm9rZVN0eWxlLCBrZXksIGluZGV4KSB7XG4gIGlmICghc3Ryb2tlU3R5bGUpXG4gICAgcmV0dXJuIGluZGV4O1xuICBpbmRleCA9IGFkZEZpbGxTdHlsZUtleShzdHJva2VTdHlsZSwga2V5LCBpbmRleCk7XG4gIGtleVtpbmRleCsrXSA9IHN0cm9rZVN0eWxlLndpZHRoO1xuICBrZXlbaW5kZXgrK10gPSBzdHJva2VTdHlsZS5hbGlnbm1lbnQ7XG4gIGtleVtpbmRleCsrXSA9IHN0cm9rZVN0eWxlLmNhcDtcbiAga2V5W2luZGV4KytdID0gc3Ryb2tlU3R5bGUuam9pbjtcbiAga2V5W2luZGV4KytdID0gc3Ryb2tlU3R5bGUubWl0ZXJMaW1pdDtcbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgeyBnZW5lcmF0ZVRleHRTdHlsZUtleSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVUZXh0U3R5bGVLZXkubWpzLm1hcFxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5pbXBvcnQgeyBGaWxsR3JhZGllbnQgfSBmcm9tICcuLi9ncmFwaGljcy9zaGFyZWQvZmlsbC9GaWxsR3JhZGllbnQubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzQ29udGV4dCB9IGZyb20gJy4uL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc0NvbnRleHQubWpzJztcbmltcG9ydCB7IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSB9IGZyb20gJy4uL2dyYXBoaWNzL3NoYXJlZC91dGlscy9jb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlVGV4dFN0eWxlS2V5IH0gZnJvbSAnLi91dGlscy9nZW5lcmF0ZVRleHRTdHlsZUtleS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9UZXh0U3R5bGUgPSBjbGFzcyBfVGV4dFN0eWxlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioc3R5bGUgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29udmVydFY3VG92OFN0eWxlKHN0eWxlKTtcbiAgICBjb25zdCBmdWxsU3R5bGUgPSB7IC4uLl9UZXh0U3R5bGUuZGVmYXVsdFRleHRTdHlsZSwgLi4uc3R5bGUgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmdWxsU3R5bGUpIHtcbiAgICAgIGNvbnN0IHRoaXNLZXkgPSBrZXk7XG4gICAgICB0aGlzW3RoaXNLZXldID0gZnVsbFN0eWxlW2tleV07XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQsIGRvZXMgbm90IGFmZmVjdCBzaW5nbGUgbGluZSB0ZXh0LlxuICAgKiBAbWVtYmVyIHsnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J3wnanVzdGlmeSd9XG4gICAqL1xuICBnZXQgYWxpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICB9XG4gIHNldCBhbGlnbih2YWx1ZSkge1xuICAgIHRoaXMuX2FsaWduID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogSW5kaWNhdGVzIGlmIGxpbmVzIGNhbiBiZSB3cmFwcGVkIHdpdGhpbiB3b3JkcywgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWUuICovXG4gIGdldCBicmVha1dvcmRzKCkge1xuICAgIHJldHVybiB0aGlzLl9icmVha1dvcmRzO1xuICB9XG4gIHNldCBicmVha1dvcmRzKHZhbHVlKSB7XG4gICAgdGhpcy5fYnJlYWtXb3JkcyA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFNldCBhIGRyb3Agc2hhZG93IGZvciB0aGUgdGV4dC4gKi9cbiAgZ2V0IGRyb3BTaGFkb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3c7XG4gIH1cbiAgc2V0IGRyb3BTaGFkb3codmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93ID0ge1xuICAgICAgICAuLi5fVGV4dFN0eWxlLmRlZmF1bHREcm9wU2hhZG93LFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvdyA9IHZhbHVlID8ge1xuICAgICAgICAuLi5fVGV4dFN0eWxlLmRlZmF1bHREcm9wU2hhZG93XG4gICAgICB9IDogbnVsbDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIGZvbnQgZmFtaWx5LCBjYW4gYmUgYSBzaW5nbGUgZm9udCBuYW1lLCBvciBhIGxpc3Qgb2YgbmFtZXMgd2hlcmUgdGhlIGZpcnN0IGlzIHRoZSBwcmVmZXJyZWQgZm9udC4gKi9cbiAgZ2V0IGZvbnRGYW1pbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRGYW1pbHk7XG4gIH1cbiAgc2V0IGZvbnRGYW1pbHkodmFsdWUpIHtcbiAgICB0aGlzLl9mb250RmFtaWx5ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIGZvbnQgc2l6ZSAoYXMgYSBudW1iZXIgaXQgY29udmVydHMgdG8gcHgsIGJ1dCBhcyBhIHN0cmluZywgZXF1aXZhbGVudHMgYXJlICcyNnB4JywnMjBwdCcsJzE2MCUnIG9yICcxLjZlbScpICovXG4gIGdldCBmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFNpemU7XG4gIH1cbiAgc2V0IGZvbnRTaXplKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5fZm9udFNpemUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb250U2l6ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCBzdHlsZS5cbiAgICogQG1lbWJlciB7J25vcm1hbCd8J2l0YWxpYyd8J29ibGlxdWUnfVxuICAgKi9cbiAgZ2V0IGZvbnRTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFN0eWxlO1xuICB9XG4gIHNldCBmb250U3R5bGUodmFsdWUpIHtcbiAgICB0aGlzLl9mb250U3R5bGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCB2YXJpYW50LlxuICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnc21hbGwtY2Fwcyd9XG4gICAqL1xuICBnZXQgZm9udFZhcmlhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRWYXJpYW50O1xuICB9XG4gIHNldCBmb250VmFyaWFudCh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvbnRWYXJpYW50ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvbnQgd2VpZ2h0LlxuICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnYm9sZCd8J2JvbGRlcid8J2xpZ2h0ZXInfCcxMDAnfCcyMDAnfCczMDAnfCc0MDAnfCc1MDAnfCc2MDAnfCc3MDAnfCc4MDAnfCc5MDAnfVxuICAgKi9cbiAgZ2V0IGZvbnRXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRXZWlnaHQ7XG4gIH1cbiAgc2V0IGZvbnRXZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9mb250V2VpZ2h0ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIHNwYWNlIGJldHdlZW4gbGluZXMuICovXG4gIGdldCBsZWFkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZWFkaW5nO1xuICB9XG4gIHNldCBsZWFkaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5fbGVhZGluZyA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRoZSBhbW91bnQgb2Ygc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMsIGRlZmF1bHQgaXMgMC4gKi9cbiAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gIH1cbiAgc2V0IGxldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIGxpbmUgaGVpZ2h0LCBhIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsIHNwYWNlIHRoYXQgYSBsZXR0ZXIgdXNlcy4gKi9cbiAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gIH1cbiAgc2V0IGxpbmVIZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9saW5lSGVpZ2h0ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogT2NjYXNpb25hbGx5IHNvbWUgZm9udHMgYXJlIGNyb3BwZWQuIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbCBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmdcbiAgICogYnkgYWRkaW5nIHBhZGRpbmcgdG8gYWxsIHNpZGVzIG9mIHRoZSB0ZXh0LlxuICAgKi9cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gIH1cbiAgc2V0IHBhZGRpbmcodmFsdWUpIHtcbiAgICB0aGlzLl9wYWRkaW5nID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVHJpbSB0cmFuc3BhcmVudCBib3JkZXJzLiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gb25seSB1c2UgdGhpcyBpZiB5b3UgaGF2ZSB0byEgKi9cbiAgZ2V0IHRyaW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyaW07XG4gIH1cbiAgc2V0IHRyaW0odmFsdWUpIHtcbiAgICB0aGlzLl90cmltID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXG4gICAqIEBtZW1iZXIgeydhbHBoYWJldGljJ3wndG9wJ3wnaGFuZ2luZyd8J21pZGRsZSd8J2lkZW9ncmFwaGljJ3wnYm90dG9tJ31cbiAgICovXG4gIGdldCB0ZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgfVxuICBzZXQgdGV4dEJhc2VsaW5lKHZhbHVlKSB7XG4gICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogSG93IG5ld2xpbmVzIGFuZCBzcGFjZXMgc2hvdWxkIGJlIGhhbmRsZWQuXG4gICAqIERlZmF1bHQgaXMgJ3ByZScgKHByZXNlcnZlLCBwcmVzZXJ2ZSkuXG4gICAqXG4gICAqICB2YWx1ZSAgICAgICB8IE5ldyBsaW5lcyAgICAgfCAgIFNwYWNlc1xuICAgKiAgLS0tICAgICAgICAgfCAtLS0gICAgICAgICAgIHwgICAtLS1cbiAgICogJ25vcm1hbCcgICAgIHwgQ29sbGFwc2UgICAgICB8ICAgQ29sbGFwc2VcbiAgICogJ3ByZScgICAgICAgIHwgUHJlc2VydmUgICAgICB8ICAgUHJlc2VydmVcbiAgICogJ3ByZS1saW5lJyAgIHwgUHJlc2VydmUgICAgICB8ICAgQ29sbGFwc2VcbiAgICogQG1lbWJlciB7J25vcm1hbCd8J3ByZSd8J3ByZS1saW5lJ31cbiAgICovXG4gIGdldCB3aGl0ZVNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICB9XG4gIHNldCB3aGl0ZVNwYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5fd2hpdGVTcGFjZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWQuICovXG4gIGdldCB3b3JkV3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd29yZFdyYXA7XG4gIH1cbiAgc2V0IHdvcmRXcmFwKHZhbHVlKSB7XG4gICAgdGhpcy5fd29yZFdyYXAgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggYXQgd2hpY2ggdGV4dCB3aWxsIHdyYXAsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlLiAqL1xuICBnZXQgd29yZFdyYXBXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd29yZFdyYXBXaWR0aDtcbiAgfVxuICBzZXQgd29yZFdyYXBXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3dvcmRXcmFwV2lkdGggPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBBIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBlLmcuLCAncmVkJywgJyMwMEZGMDAnLiAqL1xuICBnZXQgZmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxGaWxsO1xuICB9XG4gIHNldCBmaWxsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLl9vcmlnaW5hbEZpbGwpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fb3JpZ2luYWxGaWxsID0gdmFsdWU7XG4gICAgdGhpcy5fZmlsbCA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZShcbiAgICAgIHZhbHVlID09PSAwID8gXCJibGFja1wiIDogdmFsdWUsXG4gICAgICBHcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZVxuICAgICk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogQSBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlLCBlLmcuLCAnYmx1ZScsICcjRkNGRjAwJy4gKi9cbiAgZ2V0IHN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxTdHJva2U7XG4gIH1cbiAgc2V0IHN0cm9rZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fb3JpZ2luYWxTdHJva2UpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fb3JpZ2luYWxTdHJva2UgPSB2YWx1ZTtcbiAgICB0aGlzLl9zdHJva2UgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUodmFsdWUsIEdyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgX2dlbmVyYXRlS2V5KCkge1xuICAgIHRoaXMuX3N0eWxlS2V5ID0gZ2VuZXJhdGVUZXh0U3R5bGVLZXkodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlS2V5O1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zdHlsZUtleSA9IG51bGw7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKiBSZXNldHMgYWxsIHByb3BlcnRpZXMgdG8gdGhlIGRlZmF1bHQgdmFsdWVzICovXG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IF9UZXh0U3R5bGUuZGVmYXVsdFRleHRTdHlsZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0U3R5bGUpIHtcbiAgICAgIHRoaXNba2V5XSA9IGRlZmF1bHRTdHlsZVtrZXldO1xuICAgIH1cbiAgfVxuICBnZXQgc3R5bGVLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlS2V5IHx8IHRoaXMuX2dlbmVyYXRlS2V5KCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVGV4dFN0eWxlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICogQHJldHVybnMgTmV3IGNsb25lZCBUZXh0U3R5bGUgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9UZXh0U3R5bGUoe1xuICAgICAgYWxpZ246IHRoaXMuYWxpZ24sXG4gICAgICBicmVha1dvcmRzOiB0aGlzLmJyZWFrV29yZHMsXG4gICAgICBkcm9wU2hhZG93OiB0aGlzLmRyb3BTaGFkb3csXG4gICAgICBmaWxsOiB0aGlzLl9maWxsLFxuICAgICAgZm9udEZhbWlseTogdGhpcy5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUsXG4gICAgICBmb250U3R5bGU6IHRoaXMuZm9udFN0eWxlLFxuICAgICAgZm9udFZhcmlhbnQ6IHRoaXMuZm9udFZhcmlhbnQsXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQsXG4gICAgICBsZWFkaW5nOiB0aGlzLmxlYWRpbmcsXG4gICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcsXG4gICAgICBsaW5lSGVpZ2h0OiB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICBwYWRkaW5nOiB0aGlzLnBhZGRpbmcsXG4gICAgICBzdHJva2U6IHRoaXMuX3N0cm9rZSxcbiAgICAgIHRleHRCYXNlbGluZTogdGhpcy50ZXh0QmFzZWxpbmUsXG4gICAgICB3aGl0ZVNwYWNlOiB0aGlzLndoaXRlU3BhY2UsXG4gICAgICB3b3JkV3JhcDogdGhpcy53b3JkV3JhcCxcbiAgICAgIHdvcmRXcmFwV2lkdGg6IHRoaXMud29yZFdyYXBXaWR0aFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHRleHQgc3R5bGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgdGhpcyBzdHlsZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmVTb3VyY2Ugb2YgdGhlIHRoaXMgc3R5bGVcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBkZXN0cm95VGV4dHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlO1xuICAgIGlmIChkZXN0cm95VGV4dHVyZSkge1xuICAgICAgY29uc3QgZGVzdHJveVRleHR1cmVTb3VyY2UgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8udGV4dHVyZVNvdXJjZTtcbiAgICAgIGlmICh0aGlzLl9maWxsPy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX2ZpbGwudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEZpbGw/LnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxGaWxsLnRleHR1cmUuZGVzdHJveShkZXN0cm95VGV4dHVyZVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3Ryb2tlPy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3N0cm9rZS50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX29yaWdpbmFsU3Ryb2tlPy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsU3Ryb2tlLnRleHR1cmUuZGVzdHJveShkZXN0cm95VGV4dHVyZVNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ZpbGwgPSBudWxsO1xuICAgIHRoaXMuX3N0cm9rZSA9IG51bGw7XG4gICAgdGhpcy5kcm9wU2hhZG93ID0gbnVsbDtcbiAgICB0aGlzLl9vcmlnaW5hbFN0cm9rZSA9IG51bGw7XG4gICAgdGhpcy5fb3JpZ2luYWxGaWxsID0gbnVsbDtcbiAgfVxufTtcbi8qKiBUaGUgZGVmYXVsdCBkcm9wIHNoYWRvdyBzZXR0aW5ncyAqL1xuX1RleHRTdHlsZS5kZWZhdWx0RHJvcFNoYWRvdyA9IHtcbiAgLyoqIFNldCBhbHBoYSBmb3IgdGhlIGRyb3Agc2hhZG93ICovXG4gIGFscGhhOiAxLFxuICAvKiogU2V0IGEgYW5nbGUgb2YgdGhlIGRyb3Agc2hhZG93ICovXG4gIGFuZ2xlOiBNYXRoLlBJIC8gNixcbiAgLyoqIFNldCBhIHNoYWRvdyBibHVyIHJhZGl1cyAqL1xuICBibHVyOiAwLFxuICAvKiogQSBmaWxsIHN0eWxlIHRvIGJlIHVzZWQgb24gdGhlICBlLmcuLCAncmVkJywgJyMwMEZGMDAnICovXG4gIGNvbG9yOiBcImJsYWNrXCIsXG4gIC8qKiBTZXQgYSBkaXN0YW5jZSBvZiB0aGUgZHJvcCBzaGFkb3cgKi9cbiAgZGlzdGFuY2U6IDVcbn07XG4vKiogVGhlIGRlZmF1bHQgdGV4dCBzdHlsZSBzZXR0aW5ncyAqL1xuX1RleHRTdHlsZS5kZWZhdWx0VGV4dFN0eWxlID0ge1xuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuYWxpZ259XG4gICAqIEB0eXBlIHsnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J3wnanVzdGlmeSd9XG4gICAqL1xuICBhbGlnbjogXCJsZWZ0XCIsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5icmVha1dvcmRzfSAqL1xuICBicmVha1dvcmRzOiBmYWxzZSxcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmRyb3BTaGFkb3d9ICovXG4gIGRyb3BTaGFkb3c6IG51bGwsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5maWxsfVxuICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfG51bWJlcnxudW1iZXJbXXxDYW52YXNHcmFkaWVudHxDYW52YXNQYXR0ZXJufVxuICAgKi9cbiAgZmlsbDogXCJibGFja1wiLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuZm9udEZhbWlseX1cbiAgICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXX1cbiAgICovXG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZvbnRTaXplfVxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cbiAgICovXG4gIGZvbnRTaXplOiAyNixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZvbnRTdHlsZX1cbiAgICogQHR5cGUgeydub3JtYWwnfCdpdGFsaWMnfCdvYmxpcXVlJ31cbiAgICovXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZvbnRWYXJpYW50fVxuICAgKiBAdHlwZSB7J25vcm1hbCd8J3NtYWxsLWNhcHMnfVxuICAgKi9cbiAgZm9udFZhcmlhbnQ6IFwibm9ybWFsXCIsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5mb250V2VpZ2h0fVxuICAgKiBAdHlwZSB7J25vcm1hbCd8J2JvbGQnfCdib2xkZXInfCdsaWdodGVyJ3wnMTAwJ3wnMjAwJ3wnMzAwJ3wnNDAwJ3wnNTAwJ3wnNjAwJ3wnNzAwJ3wnODAwJ3wnOTAwJ31cbiAgICovXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5sZWFkaW5nfSAqL1xuICBsZWFkaW5nOiAwLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUubGV0dGVyU3BhY2luZ30gKi9cbiAgbGV0dGVyU3BhY2luZzogMCxcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmxpbmVIZWlnaHR9ICovXG4gIGxpbmVIZWlnaHQ6IDAsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5wYWRkaW5nfSAqL1xuICBwYWRkaW5nOiAwLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuc3Ryb2tlfVxuICAgKiBAdHlwZSB7c3RyaW5nfG51bWJlcn1cbiAgICovXG4gIHN0cm9rZTogbnVsbCxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLnRleHRCYXNlbGluZX1cbiAgICogQHR5cGUgeydhbHBoYWJldGljJ3wndG9wJ3wnaGFuZ2luZyd8J21pZGRsZSd8J2lkZW9ncmFwaGljJ3wnYm90dG9tJ31cbiAgICovXG4gIHRleHRCYXNlbGluZTogXCJhbHBoYWJldGljXCIsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS50cmltfSAqL1xuICB0cmltOiBmYWxzZSxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLndoaXRlU3BhY2V9XG4gICAqIEB0eXBlIHsnbm9ybWFsJ3wncHJlJ3wncHJlLWxpbmUnfVxuICAgKi9cbiAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLndvcmRXcmFwfSAqL1xuICB3b3JkV3JhcDogZmFsc2UsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS53b3JkV3JhcFdpZHRofSAqL1xuICB3b3JkV3JhcFdpZHRoOiAxMDBcbn07XG5sZXQgVGV4dFN0eWxlID0gX1RleHRTdHlsZTtcbmZ1bmN0aW9uIGNvbnZlcnRWN1RvdjhTdHlsZShzdHlsZSkge1xuICBjb25zdCBvbGRTdHlsZSA9IHN0eWxlO1xuICBpZiAodHlwZW9mIG9sZFN0eWxlLmRyb3BTaGFkb3cgPT09IFwiYm9vbGVhblwiICYmIG9sZFN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IFRleHRTdHlsZS5kZWZhdWx0RHJvcFNoYWRvdztcbiAgICBzdHlsZS5kcm9wU2hhZG93ID0ge1xuICAgICAgYWxwaGE6IG9sZFN0eWxlLmRyb3BTaGFkb3dBbHBoYSA/PyBkZWZhdWx0cy5hbHBoYSxcbiAgICAgIGFuZ2xlOiBvbGRTdHlsZS5kcm9wU2hhZG93QW5nbGUgPz8gZGVmYXVsdHMuYW5nbGUsXG4gICAgICBibHVyOiBvbGRTdHlsZS5kcm9wU2hhZG93Qmx1ciA/PyBkZWZhdWx0cy5ibHVyLFxuICAgICAgY29sb3I6IG9sZFN0eWxlLmRyb3BTaGFkb3dDb2xvciA/PyBkZWZhdWx0cy5jb2xvcixcbiAgICAgIGRpc3RhbmNlOiBvbGRTdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgPz8gZGVmYXVsdHMuZGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGlmIChvbGRTdHlsZS5zdHJva2VUaGlja25lc3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwic3Ryb2tlVGhpY2tuZXNzIGlzIG5vdyBhIHBhcnQgb2Ygc3Ryb2tlXCIpO1xuICAgIGNvbnN0IGNvbG9yID0gb2xkU3R5bGUuc3Ryb2tlO1xuICAgIHN0eWxlLnN0cm9rZSA9IHtcbiAgICAgIGNvbG9yLFxuICAgICAgd2lkdGg6IG9sZFN0eWxlLnN0cm9rZVRoaWNrbmVzc1xuICAgIH07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2xkU3R5bGUuZmlsbCkpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiZ3JhZGllbnQgZmlsbCBpcyBub3cgYSBmaWxsIHBhdHRlcm46IGBuZXcgRmlsbEdyYWRpZW50KC4uLilgXCIpO1xuICAgIGNvbnN0IGdyYWRpZW50RmlsbCA9IG5ldyBGaWxsR3JhZGllbnQoMCwgMCwgMCwgc3R5bGUuZm9udFNpemUgKiAxLjcpO1xuICAgIGNvbnN0IGZpbGxzID0gb2xkU3R5bGUuZmlsbC5tYXAoKGNvbG9yKSA9PiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvTnVtYmVyKCkpO1xuICAgIGZpbGxzLmZvckVhY2goKG51bWJlciwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJhdGlvID0gb2xkU3R5bGUuZmlsbEdyYWRpZW50U3RvcHNbaW5kZXhdID8/IGluZGV4IC8gZmlsbHMubGVuZ3RoO1xuICAgICAgZ3JhZGllbnRGaWxsLmFkZENvbG9yU3RvcChyYXRpbywgbnVtYmVyKTtcbiAgICB9KTtcbiAgICBzdHlsZS5maWxsID0ge1xuICAgICAgZmlsbDogZ3JhZGllbnRGaWxsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgeyBUZXh0U3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRTdHlsZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHJlc29sdmVDaGFyYWN0ZXJzKGNoYXJzKSB7XG4gIGlmIChjaGFycyA9PT0gXCJcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAodHlwZW9mIGNoYXJzID09PSBcInN0cmluZ1wiKSB7XG4gICAgY2hhcnMgPSBbY2hhcnNdO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGNoYXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBjaGFyc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW0JpdG1hcEZvbnRdOiBJbnZhbGlkIGNoYXJhY3RlciByYW5nZSBsZW5ndGgsIGV4cGVjdGluZyAyIGdvdCAke2l0ZW0ubGVuZ3RofS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzBdLmxlbmd0aCA9PT0gMCB8fCBpdGVtWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIGRlbGltaXRlci5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydENvZGUgPSBpdGVtWzBdLmNoYXJDb2RlQXQoMCk7XG4gICAgICBjb25zdCBlbmRDb2RlID0gaXRlbVsxXS5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGVuZENvZGUgPCBzdGFydENvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRdOiBJbnZhbGlkIGNoYXJhY3RlciByYW5nZS5cIik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpMiA9IHN0YXJ0Q29kZSwgajIgPSBlbmRDb2RlOyBpMiA8PSBqMjsgaTIrKykge1xuICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKC4uLkFycmF5LmZyb20oaXRlbSkpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogRW1wdHkgc2V0IHdoZW4gcmVzb2x2aW5nIGNoYXJhY3RlcnMuXCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ2hhcmFjdGVycy5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNQb29sIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9DYW52YXNQb29sLm1qcyc7XG5pbXBvcnQgeyBJbWFnZVNvdXJjZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9JbWFnZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IENhbnZhc1RleHRNZXRyaWNzIH0gZnJvbSAnLi4vdGV4dC9jYW52YXMvQ2FudmFzVGV4dE1ldHJpY3MubWpzJztcbmltcG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH0gZnJvbSAnLi4vdGV4dC9jYW52YXMvdXRpbHMvZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzJztcbmltcG9ydCB7IGdldENhbnZhc0ZpbGxTdHlsZSB9IGZyb20gJy4uL3RleHQvY2FudmFzL3V0aWxzL2dldENhbnZhc0ZpbGxTdHlsZS5tanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RCaXRtYXBGb250IH0gZnJvbSAnLi9BYnN0cmFjdEJpdG1hcEZvbnQubWpzJztcbmltcG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH0gZnJvbSAnLi91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIER5bmFtaWNCaXRtYXBGb250IGV4dGVuZHMgQWJzdHJhY3RCaXRtYXBGb250IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBkeW5hbWljIGJpdG1hcCBmb250LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogdGhpcyBpcyBhIHJlc29sdXRpb24gbW9kaWZpZXIgZm9yIHRoZSBmb250IHNpemUuLlxuICAgICAqIHRleHR1cmUgcmVzb2x1dGlvbiB3aWxsIGFsc28gYmUgdXNlZCB0byBzY2FsZSB0ZXh0dXJlIGFjY29yZGluZyB0byBpdHMgZm9udCBzaXplIGFsc29cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xuICAgIC8qKiBUaGUgcGFnZXMgb2YgdGhlIGZvbnQuICovXG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIHRoaXMuX3BhZGRpbmcgPSA0O1xuICAgIHRoaXMuX21lYXN1cmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2N1cnJlbnRDaGFycyA9IFtdO1xuICAgIHRoaXMuX2N1cnJlbnRYID0gMDtcbiAgICB0aGlzLl9jdXJyZW50WSA9IDA7XG4gICAgdGhpcy5fY3VycmVudFBhZ2VJbmRleCA9IC0xO1xuICAgIHRoaXMuX3NraXBLZXJuaW5nID0gZmFsc2U7XG4gICAgY29uc3QgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zO1xuICAgIGNvbnN0IHN0eWxlID0gZHluYW1pY09wdGlvbnMuc3R5bGUuY2xvbmUoKTtcbiAgICBpZiAoZHluYW1pY09wdGlvbnMub3ZlcnJpZGVGaWxsKSB7XG4gICAgICBzdHlsZS5fZmlsbC5jb2xvciA9IDE2Nzc3MjE1O1xuICAgICAgc3R5bGUuX2ZpbGwuYWxwaGEgPSAxO1xuICAgICAgc3R5bGUuX2ZpbGwudGV4dHVyZSA9IFRleHR1cmUuV0hJVEU7XG4gICAgICBzdHlsZS5fZmlsbC5maWxsID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdGVkRm9udFNpemUgPSBzdHlsZS5mb250U2l6ZTtcbiAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZU1lYXN1cmVtZW50Rm9udFNpemU7XG4gICAgY29uc3QgZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBpZiAoZHluYW1pY09wdGlvbnMub3ZlcnJpZGVTaXplKSB7XG4gICAgICBpZiAoc3R5bGUuX3N0cm9rZSkge1xuICAgICAgICBzdHlsZS5fc3Ryb2tlLndpZHRoICo9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgLyByZXF1ZXN0ZWRGb250U2l6ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuZm9udFNpemUgPSB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplID0gcmVxdWVzdGVkRm9udFNpemU7XG4gICAgfVxuICAgIHRoaXMuX3N0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5fc2tpcEtlcm5pbmcgPSBkeW5hbWljT3B0aW9ucy5za2lwS2VybmluZyA/PyBmYWxzZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBkeW5hbWljT3B0aW9ucy5yZXNvbHV0aW9uID8/IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IGR5bmFtaWNPcHRpb25zLnBhZGRpbmcgPz8gNDtcbiAgICB0aGlzLmZvbnRNZXRyaWNzID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gc3R5bGUubGluZUhlaWdodCB8fCB0aGlzLmZvbnRNZXRyaWNzLmZvbnRTaXplIHx8IHN0eWxlLmZvbnRTaXplO1xuICB9XG4gIGVuc3VyZUNoYXJhY3RlcnMoY2hhcnMpIHtcbiAgICBjb25zdCBjaGFyTGlzdCA9IHJlc29sdmVDaGFyYWN0ZXJzKGNoYXJzKS5maWx0ZXIoKGNoYXIpID0+ICF0aGlzLl9jdXJyZW50Q2hhcnMuaW5jbHVkZXMoY2hhcikpLmZpbHRlcigoY2hhciwgaW5kZXgsIHNlbGYpID0+IHNlbGYuaW5kZXhPZihjaGFyKSA9PT0gaW5kZXgpO1xuICAgIGlmICghY2hhckxpc3QubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2N1cnJlbnRDaGFycyA9IFsuLi50aGlzLl9jdXJyZW50Q2hhcnMsIC4uLmNoYXJMaXN0XTtcbiAgICBsZXQgcGFnZURhdGE7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYWdlSW5kZXggPT09IC0xKSB7XG4gICAgICBwYWdlRGF0YSA9IHRoaXMuX25leHRQYWdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2VEYXRhID0gdGhpcy5wYWdlc1t0aGlzLl9jdXJyZW50UGFnZUluZGV4XTtcbiAgICB9XG4gICAgbGV0IHsgY2FudmFzLCBjb250ZXh0IH0gPSBwYWdlRGF0YS5jYW52YXNBbmRDb250ZXh0O1xuICAgIGxldCB0ZXh0dXJlU291cmNlID0gcGFnZURhdGEudGV4dHVyZS5zb3VyY2U7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl9zdHlsZTtcbiAgICBsZXQgY3VycmVudFggPSB0aGlzLl9jdXJyZW50WDtcbiAgICBsZXQgY3VycmVudFkgPSB0aGlzLl9jdXJyZW50WTtcbiAgICBjb25zdCBmb250U2NhbGUgPSB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplIC8gdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyAqIGZvbnRTY2FsZTtcbiAgICBjb25zdCB3aWR0aFNjYWxlID0gc3R5bGUuZm9udFN0eWxlID09PSBcIml0YWxpY1wiID8gMiA6IDE7XG4gICAgbGV0IG1heENoYXJIZWlnaHQgPSAwO1xuICAgIGxldCBza2lwVGV4dHVyZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBjaGFyTGlzdFtpXTtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlVGV4dChjaGFyLCBzdHlsZSwgY2FudmFzLCBmYWxzZSk7XG4gICAgICBtZXRyaWNzLmxpbmVIZWlnaHQgPSBtZXRyaWNzLmhlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gd2lkdGhTY2FsZSAqIG1ldHJpY3Mud2lkdGggKiBmb250U2NhbGU7XG4gICAgICBjb25zdCBoZWlnaHQgPSBtZXRyaWNzLmhlaWdodCAqIGZvbnRTY2FsZTtcbiAgICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBwYWRkaW5nICogMjtcbiAgICAgIGNvbnN0IHBhZGRlZEhlaWdodCA9IGhlaWdodCArIHBhZGRpbmcgKiAyO1xuICAgICAgc2tpcFRleHR1cmUgPSBmYWxzZTtcbiAgICAgIGlmIChjaGFyICE9PSBcIlxcblwiICYmIGNoYXIgIT09IFwiXFxyXCIgJiYgY2hhciAhPT0gXCJcdFwiICYmIGNoYXIgIT09IFwiIFwiKSB7XG4gICAgICAgIHNraXBUZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IE1hdGguY2VpbChNYXRoLm1heChwYWRkZWRIZWlnaHQsIG1heENoYXJIZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50WCArIHBhZGRlZFdpZHRoID4gNTEyKSB7XG4gICAgICAgIGN1cnJlbnRZICs9IG1heENoYXJIZWlnaHQ7XG4gICAgICAgIG1heENoYXJIZWlnaHQgPSBwYWRkZWRIZWlnaHQ7XG4gICAgICAgIGN1cnJlbnRYID0gMDtcbiAgICAgICAgaWYgKGN1cnJlbnRZICsgbWF4Q2hhckhlaWdodCA+IDUxMikge1xuICAgICAgICAgIHRleHR1cmVTb3VyY2UudXBkYXRlKCk7XG4gICAgICAgICAgY29uc3QgcGFnZURhdGEyID0gdGhpcy5fbmV4dFBhZ2UoKTtcbiAgICAgICAgICBjYW52YXMgPSBwYWdlRGF0YTIuY2FudmFzQW5kQ29udGV4dC5jYW52YXM7XG4gICAgICAgICAgY29udGV4dCA9IHBhZ2VEYXRhMi5jYW52YXNBbmRDb250ZXh0LmNvbnRleHQ7XG4gICAgICAgICAgdGV4dHVyZVNvdXJjZSA9IHBhZ2VEYXRhMi50ZXh0dXJlLnNvdXJjZTtcbiAgICAgICAgICBjdXJyZW50WSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHhBZHZhbmNlID0gd2lkdGggLyBmb250U2NhbGUgLSAoc3R5bGUuZHJvcFNoYWRvdz8uZGlzdGFuY2UgPz8gMCkgLSAoc3R5bGUuX3N0cm9rZT8ud2lkdGggPz8gMCk7XG4gICAgICB0aGlzLmNoYXJzW2NoYXJdID0ge1xuICAgICAgICBpZDogY2hhci5jb2RlUG9pbnRBdCgwKSxcbiAgICAgICAgeE9mZnNldDogLXRoaXMuX3BhZGRpbmcsXG4gICAgICAgIHlPZmZzZXQ6IC10aGlzLl9wYWRkaW5nLFxuICAgICAgICB4QWR2YW5jZSxcbiAgICAgICAga2VybmluZzoge31cbiAgICAgIH07XG4gICAgICBpZiAoc2tpcFRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fZHJhd0dseXBoKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbWV0cmljcyxcbiAgICAgICAgICBjdXJyZW50WCArIHBhZGRpbmcsXG4gICAgICAgICAgY3VycmVudFkgKyBwYWRkaW5nLFxuICAgICAgICAgIGZvbnRTY2FsZSxcbiAgICAgICAgICBzdHlsZVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBweCA9IHRleHR1cmVTb3VyY2Uud2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgIGNvbnN0IHB5ID0gdGV4dHVyZVNvdXJjZS5oZWlnaHQgKiBmb250U2NhbGU7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICBjdXJyZW50WCAvIHB4ICogdGV4dHVyZVNvdXJjZS53aWR0aCxcbiAgICAgICAgICBjdXJyZW50WSAvIHB5ICogdGV4dHVyZVNvdXJjZS5oZWlnaHQsXG4gICAgICAgICAgcGFkZGVkV2lkdGggLyBweCAqIHRleHR1cmVTb3VyY2Uud2lkdGgsXG4gICAgICAgICAgcGFkZGVkSGVpZ2h0IC8gcHkgKiB0ZXh0dXJlU291cmNlLmhlaWdodFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNoYXJzW2NoYXJdLnRleHR1cmUgPSBuZXcgVGV4dHVyZSh7XG4gICAgICAgICAgc291cmNlOiB0ZXh0dXJlU291cmNlLFxuICAgICAgICAgIGZyYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50WCArPSBNYXRoLmNlaWwocGFkZGVkV2lkdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0ZXh0dXJlU291cmNlLnVwZGF0ZSgpO1xuICAgIHRoaXMuX2N1cnJlbnRYID0gY3VycmVudFg7XG4gICAgdGhpcy5fY3VycmVudFkgPSBjdXJyZW50WTtcbiAgICB0aGlzLl9za2lwS2VybmluZyAmJiB0aGlzLl9hcHBseUtlcm5pbmcoY2hhckxpc3QsIGNvbnRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMFxuICAgKiBUaGUgbWFwIG9mIGJhc2UgcGFnZSB0ZXh0dXJlcyAoaS5lLiwgc2hlZXRzIG9mIGdseXBocykuXG4gICAqL1xuICBnZXQgcGFnZVRleHR1cmVzKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LnBhZ2VUZXh0dXJlcyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJpdG1hcEZvbnQucGFnZXMgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMucGFnZXM7XG4gIH1cbiAgX2FwcGx5S2VybmluZyhuZXdDaGFycywgY29udGV4dCkge1xuICAgIGNvbnN0IG1lYXN1cmVDYWNoZSA9IHRoaXMuX21lYXN1cmVDYWNoZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaXJzdCA9IG5ld0NoYXJzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9jdXJyZW50Q2hhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gdGhpcy5fY3VycmVudENoYXJzW2pdO1xuICAgICAgICBsZXQgYzEgPSBtZWFzdXJlQ2FjaGVbZmlyc3RdO1xuICAgICAgICBpZiAoIWMxKVxuICAgICAgICAgIGMxID0gbWVhc3VyZUNhY2hlW2ZpcnN0XSA9IGNvbnRleHQubWVhc3VyZVRleHQoZmlyc3QpLndpZHRoO1xuICAgICAgICBsZXQgYzIgPSBtZWFzdXJlQ2FjaGVbc2Vjb25kXTtcbiAgICAgICAgaWYgKCFjMilcbiAgICAgICAgICBjMiA9IG1lYXN1cmVDYWNoZVtzZWNvbmRdID0gY29udGV4dC5tZWFzdXJlVGV4dChzZWNvbmQpLndpZHRoO1xuICAgICAgICBsZXQgdG90YWwgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0ICsgc2Vjb25kKS53aWR0aDtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRvdGFsIC0gKGMxICsgYzIpO1xuICAgICAgICBpZiAoYW1vdW50KSB7XG4gICAgICAgICAgdGhpcy5jaGFyc1tmaXJzdF0ua2VybmluZ1tzZWNvbmRdID0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIHRvdGFsID0gY29udGV4dC5tZWFzdXJlVGV4dChmaXJzdCArIHNlY29uZCkud2lkdGg7XG4gICAgICAgIGFtb3VudCA9IHRvdGFsIC0gKGMxICsgYzIpO1xuICAgICAgICBpZiAoYW1vdW50KSB7XG4gICAgICAgICAgdGhpcy5jaGFyc1tzZWNvbmRdLmtlcm5pbmdbZmlyc3RdID0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9uZXh0UGFnZSgpIHtcbiAgICB0aGlzLl9jdXJyZW50UGFnZUluZGV4Kys7XG4gICAgY29uc3QgdGV4dHVyZVJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgY29uc3QgY2FudmFzQW5kQ29udGV4dCA9IENhbnZhc1Bvb2wuZ2V0T3B0aW1hbENhbnZhc0FuZENvbnRleHQoNTEyLCA1MTIsIHRleHR1cmVSZXNvbHV0aW9uKTtcbiAgICB0aGlzLl9zZXR1cENvbnRleHQoY2FudmFzQW5kQ29udGV4dC5jb250ZXh0LCB0aGlzLl9zdHlsZSwgdGV4dHVyZVJlc29sdXRpb24pO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0ZXh0dXJlUmVzb2x1dGlvbiAqICh0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplIC8gdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZSk7XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcbiAgICAgIHNvdXJjZTogbmV3IEltYWdlU291cmNlKHtcbiAgICAgICAgcmVzb3VyY2U6IGNhbnZhc0FuZENvbnRleHQuY2FudmFzLFxuICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICBhbHBoYU1vZGU6IFwicHJlbXVsdGlwbHktYWxwaGEtb24tdXBsb2FkXCJcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgY29uc3QgcGFnZURhdGEgPSB7XG4gICAgICBjYW52YXNBbmRDb250ZXh0LFxuICAgICAgdGV4dHVyZVxuICAgIH07XG4gICAgdGhpcy5wYWdlc1t0aGlzLl9jdXJyZW50UGFnZUluZGV4XSA9IHBhZ2VEYXRhO1xuICAgIHJldHVybiBwYWdlRGF0YTtcbiAgfVxuICAvLyBjYW52YXMgc3R5bGUhXG4gIF9zZXR1cENvbnRleHQoY29udGV4dCwgc3R5bGUsIHJlc29sdXRpb24pIHtcbiAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemU7XG4gICAgY29udGV4dC5zY2FsZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgICBjb250ZXh0LmZvbnQgPSBmb250U3RyaW5nRnJvbVRleHRTdHlsZShzdHlsZSk7XG4gICAgc3R5bGUuZm9udFNpemUgPSB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgIGNvbnN0IHN0cm9rZSA9IHN0eWxlLl9zdHJva2U7XG4gICAgY29uc3Qgc3Ryb2tlVGhpY2tuZXNzID0gc3Ryb2tlPy53aWR0aCA/PyAwO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlVGhpY2tuZXNzO1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9IHN0cm9rZS5qb2luO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gc3Ryb2tlLm1pdGVyTGltaXQ7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzRmlsbFN0eWxlKHN0cm9rZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5fZmlsbCkge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBnZXRDYW52YXNGaWxsU3R5bGUoc3R5bGUuX2ZpbGwsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgY29uc3Qgc2hhZG93T3B0aW9ucyA9IHN0eWxlLmRyb3BTaGFkb3c7XG4gICAgICBjb25zdCByZ2IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoc2hhZG93T3B0aW9ucy5jb2xvcikudG9BcnJheSgpO1xuICAgICAgY29uc3QgZHJvcFNoYWRvd0JsdXIgPSBzaGFkb3dPcHRpb25zLmJsdXIgKiByZXNvbHV0aW9uO1xuICAgICAgY29uc3QgZHJvcFNoYWRvd0Rpc3RhbmNlID0gc2hhZG93T3B0aW9ucy5kaXN0YW5jZSAqIHJlc29sdXRpb247XG4gICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gYHJnYmEoJHtyZ2JbMF0gKiAyNTV9LCR7cmdiWzFdICogMjU1fSwke3JnYlsyXSAqIDI1NX0sJHtzaGFkb3dPcHRpb25zLmFscGhhfSlgO1xuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gZHJvcFNoYWRvd0JsdXI7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBNYXRoLmNvcyhzaGFkb3dPcHRpb25zLmFuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IE1hdGguc2luKHNoYWRvd09wdGlvbnMuYW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICAgIH1cbiAgfVxuICBfZHJhd0dseXBoKGNvbnRleHQsIG1ldHJpY3MsIHgsIHksIGZvbnRTY2FsZSwgc3R5bGUpIHtcbiAgICBjb25zdCBjaGFyID0gbWV0cmljcy50ZXh0O1xuICAgIGNvbnN0IGZvbnRQcm9wZXJ0aWVzID0gbWV0cmljcy5mb250UHJvcGVydGllcztcbiAgICBjb25zdCBzdHJva2UgPSBzdHlsZS5fc3Ryb2tlO1xuICAgIGNvbnN0IHN0cm9rZVRoaWNrbmVzcyA9IChzdHJva2U/LndpZHRoID8/IDApICogZm9udFNjYWxlO1xuICAgIGNvbnN0IHR4ID0geCArIHN0cm9rZVRoaWNrbmVzcyAvIDI7XG4gICAgY29uc3QgdHkgPSB5IC0gc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICBjb25zdCBkZXNjZW50ID0gZm9udFByb3BlcnRpZXMuZGVzY2VudCAqIGZvbnRTY2FsZTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gbWV0cmljcy5saW5lSGVpZ2h0ICogZm9udFNjYWxlO1xuICAgIGlmIChzdHlsZS5zdHJva2UgJiYgc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZVRleHQoY2hhciwgdHgsIHR5ICsgbGluZUhlaWdodCAtIGRlc2NlbnQpO1xuICAgIH1cbiAgICBpZiAoc3R5bGUuX2ZpbGwpIHtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQoY2hhciwgdHgsIHR5ICsgbGluZUhlaWdodCAtIGRlc2NlbnQpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgY2FudmFzQW5kQ29udGV4dCwgdGV4dHVyZSB9ID0gdGhpcy5wYWdlc1tpXTtcbiAgICAgIENhbnZhc1Bvb2wucmV0dXJuQ2FudmFzQW5kQ29udGV4dChjYW52YXNBbmRDb250ZXh0KTtcbiAgICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5wYWdlcyA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgRHluYW1pY0JpdG1hcEZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUR5bmFtaWNCaXRtYXBGb250Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0Qml0bWFwVGV4dExheW91dChjaGFycywgc3R5bGUsIGZvbnQpIHtcbiAgY29uc3QgbGF5b3V0RGF0YSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgb2Zmc2V0WTogMCxcbiAgICBzY2FsZTogc3R5bGUuZm9udFNpemUgLyBmb250LmJhc2VNZWFzdXJlbWVudEZvbnRTaXplLFxuICAgIGxpbmVzOiBbe1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBjaGFyUG9zaXRpb25zOiBbXSxcbiAgICAgIHNwYWNlV2lkdGg6IDAsXG4gICAgICBzcGFjZXNJbmRleDogW10sXG4gICAgICBjaGFyczogW11cbiAgICB9XVxuICB9O1xuICBsYXlvdXREYXRhLm9mZnNldFkgPSBmb250LmJhc2VMaW5lT2Zmc2V0O1xuICBsZXQgY3VycmVudExpbmUgPSBsYXlvdXREYXRhLmxpbmVzWzBdO1xuICBsZXQgcHJldmlvdXNDaGFyID0gbnVsbDtcbiAgbGV0IGZpcnN0V29yZCA9IHRydWU7XG4gIGNvbnN0IGN1cnJlbnRXb3JkID0ge1xuICAgIHNwYWNlV29yZDogZmFsc2UsXG4gICAgd2lkdGg6IDAsXG4gICAgc3RhcnQ6IDAsXG4gICAgaW5kZXg6IDAsXG4gICAgLy8gdXNlIGluZGV4IHRvIG5vdCBtb2RpZnkgdGhlIGFycmF5IGFzIHdlIHVzZSBpdCBhIGxvdCFcbiAgICBwb3NpdGlvbnM6IFtdLFxuICAgIGNoYXJzOiBbXVxuICB9O1xuICBjb25zdCBuZXh0V29yZCA9ICh3b3JkKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBjdXJyZW50TGluZS53aWR0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJlbnRXb3JkLmluZGV4OyBqKyspIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gd29yZC5wb3NpdGlvbnNbal07XG4gICAgICBjdXJyZW50TGluZS5jaGFycy5wdXNoKHdvcmQuY2hhcnNbal0pO1xuICAgICAgY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uICsgc3RhcnQpO1xuICAgIH1cbiAgICBjdXJyZW50TGluZS53aWR0aCArPSB3b3JkLndpZHRoO1xuICAgIGZpcnN0V29yZCA9IGZhbHNlO1xuICAgIGN1cnJlbnRXb3JkLndpZHRoID0gMDtcbiAgICBjdXJyZW50V29yZC5pbmRleCA9IDA7XG4gICAgY3VycmVudFdvcmQuY2hhcnMubGVuZ3RoID0gMDtcbiAgfTtcbiAgY29uc3QgbmV4dExpbmUgPSAoKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gY3VycmVudExpbmUuY2hhcnMubGVuZ3RoIC0gMTtcbiAgICBsZXQgbGFzdENoYXIgPSBjdXJyZW50TGluZS5jaGFyc1tpbmRleF07XG4gICAgd2hpbGUgKGxhc3RDaGFyID09PSBcIiBcIikge1xuICAgICAgY3VycmVudExpbmUud2lkdGggLT0gZm9udC5jaGFyc1tsYXN0Q2hhcl0ueEFkdmFuY2U7XG4gICAgICBsYXN0Q2hhciA9IGN1cnJlbnRMaW5lLmNoYXJzWy0taW5kZXhdO1xuICAgIH1cbiAgICBsYXlvdXREYXRhLndpZHRoID0gTWF0aC5tYXgobGF5b3V0RGF0YS53aWR0aCwgY3VycmVudExpbmUud2lkdGgpO1xuICAgIGN1cnJlbnRMaW5lID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBjaGFyUG9zaXRpb25zOiBbXSxcbiAgICAgIGNoYXJzOiBbXSxcbiAgICAgIHNwYWNlV2lkdGg6IDAsXG4gICAgICBzcGFjZXNJbmRleDogW11cbiAgICB9O1xuICAgIGZpcnN0V29yZCA9IHRydWU7XG4gICAgbGF5b3V0RGF0YS5saW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICBsYXlvdXREYXRhLmhlaWdodCArPSBmb250LmxpbmVIZWlnaHQ7XG4gIH07XG4gIGNvbnN0IHNjYWxlID0gZm9udC5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZSAvIHN0eWxlLmZvbnRTaXplO1xuICBjb25zdCBhZGp1c3RlZExldHRlclNwYWNpbmcgPSBzdHlsZS5sZXR0ZXJTcGFjaW5nICogc2NhbGU7XG4gIGNvbnN0IGFkanVzdGVkV29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKiBzY2FsZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGggKyAxOyBpKyspIHtcbiAgICBsZXQgY2hhcjtcbiAgICBjb25zdCBpc0VuZCA9IGkgPT09IGNoYXJzLmxlbmd0aDtcbiAgICBpZiAoIWlzRW5kKSB7XG4gICAgICBjaGFyID0gY2hhcnNbaV07XG4gICAgfVxuICAgIGNvbnN0IGNoYXJEYXRhID0gZm9udC5jaGFyc1tjaGFyXSB8fCBmb250LmNoYXJzW1wiIFwiXTtcbiAgICBjb25zdCBpc1NwYWNlID0gLyg/OlxccykvLnRlc3QoY2hhcik7XG4gICAgY29uc3QgaXNXb3JkQnJlYWsgPSBpc1NwYWNlIHx8IGNoYXIgPT09IFwiXFxyXCIgfHwgY2hhciA9PT0gXCJcXG5cIiB8fCBpc0VuZDtcbiAgICBpZiAoaXNXb3JkQnJlYWspIHtcbiAgICAgIGNvbnN0IGFkZFdvcmRUb05leHRMaW5lID0gIWZpcnN0V29yZCAmJiBzdHlsZS53b3JkV3JhcCAmJiBjdXJyZW50TGluZS53aWR0aCArIGN1cnJlbnRXb3JkLndpZHRoIC0gYWRqdXN0ZWRMZXR0ZXJTcGFjaW5nID4gYWRqdXN0ZWRXb3JkV3JhcFdpZHRoO1xuICAgICAgaWYgKGFkZFdvcmRUb05leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lKCk7XG4gICAgICAgIG5leHRXb3JkKGN1cnJlbnRXb3JkKTtcbiAgICAgICAgaWYgKCFpc0VuZCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lLmNoYXJQb3NpdGlvbnMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFdvcmQuc3RhcnQgPSBjdXJyZW50TGluZS53aWR0aDtcbiAgICAgICAgbmV4dFdvcmQoY3VycmVudFdvcmQpO1xuICAgICAgICBpZiAoIWlzRW5kKSB7XG4gICAgICAgICAgY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gXCJcXHJcIiB8fCBjaGFyID09PSBcIlxcblwiKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGluZS53aWR0aCAhPT0gMCkge1xuICAgICAgICAgIG5leHRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzRW5kKSB7XG4gICAgICAgIGNvbnN0IHNwYWNlV2lkdGggPSBjaGFyRGF0YS54QWR2YW5jZSArIChjaGFyRGF0YS5rZXJuaW5nW3ByZXZpb3VzQ2hhcl0gfHwgMCkgKyBhZGp1c3RlZExldHRlclNwYWNpbmc7XG4gICAgICAgIGN1cnJlbnRMaW5lLndpZHRoICs9IHNwYWNlV2lkdGg7XG4gICAgICAgIGN1cnJlbnRMaW5lLnNwYWNlV2lkdGggPSBzcGFjZVdpZHRoO1xuICAgICAgICBjdXJyZW50TGluZS5zcGFjZXNJbmRleC5wdXNoKGN1cnJlbnRMaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgY3VycmVudExpbmUuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2VybmluZyA9IGNoYXJEYXRhLmtlcm5pbmdbcHJldmlvdXNDaGFyXSB8fCAwO1xuICAgICAgY29uc3QgbmV4dENoYXJXaWR0aCA9IGNoYXJEYXRhLnhBZHZhbmNlICsga2VybmluZyArIGFkanVzdGVkTGV0dGVyU3BhY2luZztcbiAgICAgIGN1cnJlbnRXb3JkLnBvc2l0aW9uc1tjdXJyZW50V29yZC5pbmRleCsrXSA9IGN1cnJlbnRXb3JkLndpZHRoICsga2VybmluZztcbiAgICAgIGN1cnJlbnRXb3JkLmNoYXJzLnB1c2goY2hhcik7XG4gICAgICBjdXJyZW50V29yZC53aWR0aCArPSBuZXh0Q2hhcldpZHRoO1xuICAgIH1cbiAgICBwcmV2aW91c0NoYXIgPSBjaGFyO1xuICB9XG4gIG5leHRMaW5lKCk7XG4gIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgIGFsaWduQ2VudGVyKGxheW91dERhdGEpO1xuICB9IGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICBhbGlnblJpZ2h0KGxheW91dERhdGEpO1xuICB9IGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSBcImp1c3RpZnlcIikge1xuICAgIGFsaWduSnVzdGlmeShsYXlvdXREYXRhKTtcbiAgfVxuICByZXR1cm4gbGF5b3V0RGF0YTtcbn1cbmZ1bmN0aW9uIGFsaWduQ2VudGVyKG1lYXN1cmVtZW50RGF0YSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmVtZW50RGF0YS5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtZWFzdXJlbWVudERhdGEubGluZXNbaV07XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWVhc3VyZW1lbnREYXRhLndpZHRoIC8gMiAtIGxpbmUud2lkdGggLyAyO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5jaGFyUG9zaXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICBsaW5lLmNoYXJQb3NpdGlvbnNbal0gKz0gb2Zmc2V0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWxpZ25SaWdodChtZWFzdXJlbWVudERhdGEpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJlbWVudERhdGEubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbWVhc3VyZW1lbnREYXRhLmxpbmVzW2ldO1xuICAgIGNvbnN0IG9mZnNldCA9IG1lYXN1cmVtZW50RGF0YS53aWR0aCAtIGxpbmUud2lkdGg7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxpbmUuY2hhclBvc2l0aW9uc1tqXSArPSBvZmZzZXQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhbGlnbkp1c3RpZnkobWVhc3VyZW1lbnREYXRhKSB7XG4gIGNvbnN0IHdpZHRoID0gbWVhc3VyZW1lbnREYXRhLndpZHRoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmVtZW50RGF0YS5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtZWFzdXJlbWVudERhdGEubGluZXNbaV07XG4gICAgbGV0IGluZHkgPSAwO1xuICAgIGxldCBzcGFjZUluZGV4ID0gbGluZS5zcGFjZXNJbmRleFtpbmR5KytdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IHRvdGFsU3BhY2VzID0gbGluZS5zcGFjZXNJbmRleC5sZW5ndGg7XG4gICAgY29uc3QgbmV3U3BhY2VXaWR0aCA9ICh3aWR0aCAtIGxpbmUud2lkdGgpIC8gdG90YWxTcGFjZXM7XG4gICAgY29uc3Qgc3BhY2VXaWR0aCA9IG5ld1NwYWNlV2lkdGg7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChqID09PSBzcGFjZUluZGV4KSB7XG4gICAgICAgIHNwYWNlSW5kZXggPSBsaW5lLnNwYWNlc0luZGV4W2luZHkrK107XG4gICAgICAgIG9mZnNldCArPSBzcGFjZVdpZHRoO1xuICAgICAgfVxuICAgICAgbGluZS5jaGFyUG9zaXRpb25zW2pdICs9IG9mZnNldDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Qml0bWFwVGV4dExheW91dC5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJy4uL3RleHQvVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBEeW5hbWljQml0bWFwRm9udCB9IGZyb20gJy4vRHluYW1pY0JpdG1hcEZvbnQubWpzJztcbmltcG9ydCB7IGdldEJpdG1hcFRleHRMYXlvdXQgfSBmcm9tICcuL3V0aWxzL2dldEJpdG1hcFRleHRMYXlvdXQubWpzJztcbmltcG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH0gZnJvbSAnLi91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJpdG1hcEZvbnRNYW5hZ2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgaW5jbHVkZXMgYWxsIHRoZSBsZXR0ZXJzIGluIHRoZSBhbHBoYWJldCAoYm90aCBsb3dlci0gYW5kIHVwcGVyLSBjYXNlKS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW11bXX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEJpdG1hcEZvbnQuZnJvbSgnRXhhbXBsZUZvbnQnLCBzdHlsZSwgeyBjaGFyczogQml0bWFwRm9udC5BTFBIQSB9KVxuICAgICAqL1xuICAgIHRoaXMuQUxQSEEgPSBbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdLCBcIiBcIl07XG4gICAgLyoqXG4gICAgICogVGhpcyBjaGFyYWN0ZXIgc2V0IGluY2x1ZGVzIGFsbCBkZWNpbWFsIGRpZ2l0cyAoZnJvbSAwIHRvIDkpLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogQml0bWFwRm9udC5mcm9tKCdFeGFtcGxlRm9udCcsIHN0eWxlLCB7IGNoYXJzOiBCaXRtYXBGb250Lk5VTUVSSUMgfSlcbiAgICAgKi9cbiAgICB0aGlzLk5VTUVSSUMgPSBbW1wiMFwiLCBcIjlcIl1dO1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2hhcmFjdGVyIHNldCBpcyB0aGUgdW5pb24gb2YgYEJpdG1hcEZvbnQuQUxQSEFgIGFuZCBgQml0bWFwRm9udC5OVU1FUklDYC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW11bXX1cbiAgICAgKi9cbiAgICB0aGlzLkFMUEhBTlVNRVJJQyA9IFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFtcIjBcIiwgXCI5XCJdLCBcIiBcIl07XG4gICAgLyoqXG4gICAgICogVGhpcyBjaGFyYWN0ZXIgc2V0IGNvbnNpc3RzIG9mIGFsbCB0aGUgQVNDSUkgdGFibGUuXG4gICAgICogQG1lbWJlciB7c3RyaW5nW11bXX1cbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cuYXNjaWl0YWJsZS5jb20vXG4gICAgICovXG4gICAgdGhpcy5BU0NJSSA9IFtbXCIgXCIsIFwiflwiXV07XG4gICAgLyoqIERlZmF1bHQgb3B0aW9ucyBmb3IgaW5zdGFsbGluZyBhIG5ldyBCaXRtYXBGb250LiAqL1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBjaGFyczogdGhpcy5BTFBIQU5VTUVSSUMsXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgcGFkZGluZzogNCxcbiAgICAgIHNraXBLZXJuaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGZvbnQgZm9yIHRoZSBzcGVjaWZpZWQgdGV4dCBhbmQgc3R5bGUuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gZ2V0IHRoZSBmb250IGZvclxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3R5bGUgdG8gdXNlXG4gICAqL1xuICBnZXRGb250KHRleHQsIHN0eWxlKSB7XG4gICAgbGV0IGZvbnRGYW1pbHlLZXkgPSBgJHtzdHlsZS5mb250RmFtaWx5fS1iaXRtYXBgO1xuICAgIGxldCBvdmVycmlkZUZpbGwgPSB0cnVlO1xuICAgIGlmIChzdHlsZS5fZmlsbC5maWxsKSB7XG4gICAgICBmb250RmFtaWx5S2V5ICs9IHN0eWxlLl9maWxsLmZpbGwudWlkO1xuICAgICAgb3ZlcnJpZGVGaWxsID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghQ2FjaGUuaGFzKGZvbnRGYW1pbHlLZXkpKSB7XG4gICAgICBjb25zdCBmbnQgPSBuZXcgRHluYW1pY0JpdG1hcEZvbnQoe1xuICAgICAgICBzdHlsZSxcbiAgICAgICAgb3ZlcnJpZGVGaWxsLFxuICAgICAgICBvdmVycmlkZVNpemU6IHRydWUsXG4gICAgICAgIC4uLnRoaXMuZGVmYXVsdE9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgZm50Lm9uY2UoXCJkZXN0cm95XCIsICgpID0+IENhY2hlLnJlbW92ZShmb250RmFtaWx5S2V5KSk7XG4gICAgICBDYWNoZS5zZXQoXG4gICAgICAgIGZvbnRGYW1pbHlLZXksXG4gICAgICAgIGZudFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZHluYW1pY0ZvbnQgPSBDYWNoZS5nZXQoZm9udEZhbWlseUtleSk7XG4gICAgZHluYW1pY0ZvbnQuZW5zdXJlQ2hhcmFjdGVycz8uKHRleHQpO1xuICAgIHJldHVybiBkeW5hbWljRm9udDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBsYXlvdXQgb2YgYSB0ZXh0IGZvciB0aGUgc3BlY2lmaWVkIHN0eWxlLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIGdldCB0aGUgbGF5b3V0IGZvclxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3R5bGUgdG8gdXNlXG4gICAqL1xuICBnZXRMYXlvdXQodGV4dCwgc3R5bGUpIHtcbiAgICBjb25zdCBiaXRtYXBGb250ID0gdGhpcy5nZXRGb250KHRleHQsIHN0eWxlKTtcbiAgICByZXR1cm4gZ2V0Qml0bWFwVGV4dExheW91dCh0ZXh0LnNwbGl0KFwiXCIpLCBzdHlsZSwgYml0bWFwRm9udCk7XG4gIH1cbiAgLyoqXG4gICAqIE1lYXN1cmUgdGhlIHRleHQgdXNpbmcgdGhlIHNwZWNpZmllZCBzdHlsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBtZWFzdXJlXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIG1lYXN1cmVUZXh0KHRleHQsIHN0eWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF5b3V0KHRleHQsIHN0eWxlKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBpbnN0YWxsKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBuYW1lOiBvcHRpb25zLFxuICAgICAgICBzdHlsZTogYXJnc1sxXSxcbiAgICAgICAgY2hhcnM6IGFyZ3NbMl0/LmNoYXJzLFxuICAgICAgICByZXNvbHV0aW9uOiBhcmdzWzJdPy5yZXNvbHV0aW9uLFxuICAgICAgICBwYWRkaW5nOiBhcmdzWzJdPy5wYWRkaW5nLFxuICAgICAgICBza2lwS2VybmluZzogYXJnc1syXT8uc2tpcEtlcm5pbmdcbiAgICAgIH07XG4gICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udE1hbmFnZXIuaW5zdGFsbChuYW1lLCBzdHlsZSwgb3B0aW9ucykgaXMgZGVwcmVjYXRlZCwgdXNlIEJpdG1hcEZvbnRNYW5hZ2VyLmluc3RhbGwoe25hbWUsIHN0eWxlLCAuLi5vcHRpb25zfSlcIik7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zPy5uYW1lO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRNYW5hZ2VyXSBQcm9wZXJ0eSBgbmFtZWAgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi50aGlzLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgdGV4dFN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICBjb25zdCBzdHlsZSA9IHRleHRTdHlsZSBpbnN0YW5jZW9mIFRleHRTdHlsZSA/IHRleHRTdHlsZSA6IG5ldyBUZXh0U3R5bGUodGV4dFN0eWxlKTtcbiAgICBjb25zdCBvdmVycmlkZUZpbGwgPSBzdHlsZS5fZmlsbC5maWxsICE9PSBudWxsICYmIHN0eWxlLl9maWxsLmZpbGwgIT09IHZvaWQgMDtcbiAgICBjb25zdCBmb250ID0gbmV3IER5bmFtaWNCaXRtYXBGb250KHtcbiAgICAgIHN0eWxlLFxuICAgICAgb3ZlcnJpZGVGaWxsLFxuICAgICAgc2tpcEtlcm5pbmc6IG9wdGlvbnMuc2tpcEtlcm5pbmcsXG4gICAgICBwYWRkaW5nOiBvcHRpb25zLnBhZGRpbmcsXG4gICAgICByZXNvbHV0aW9uOiBvcHRpb25zLnJlc29sdXRpb24sXG4gICAgICBvdmVycmlkZVNpemU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgZmxhdENoYXJzID0gcmVzb2x2ZUNoYXJhY3RlcnMob3B0aW9ucy5jaGFycyk7XG4gICAgZm9udC5lbnN1cmVDaGFyYWN0ZXJzKGZsYXRDaGFycy5qb2luKFwiXCIpKTtcbiAgICBDYWNoZS5zZXQoYCR7bmFtZX0tYml0bWFwYCwgZm9udCk7XG4gICAgZm9udC5vbmNlKFwiZGVzdHJveVwiLCAoKSA9PiBDYWNoZS5yZW1vdmUoYCR7bmFtZX0tYml0bWFwYCkpO1xuICAgIHJldHVybiBmb250O1xuICB9XG4gIC8qKlxuICAgKiBVbmluc3RhbGxzIGEgYml0bWFwIGZvbnQgZnJvbSB0aGUgY2FjaGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJpdG1hcCBmb250IHRvIHVuaW5zdGFsbC5cbiAgICovXG4gIHVuaW5zdGFsbChuYW1lKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtuYW1lfS1iaXRtYXBgO1xuICAgIGNvbnN0IGZvbnQgPSBDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChmb250KSB7XG4gICAgICBDYWNoZS5yZW1vdmUoY2FjaGVLZXkpO1xuICAgICAgZm9udC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBCaXRtYXBGb250TWFuYWdlciA9IG5ldyBCaXRtYXBGb250TWFuYWdlckNsYXNzKCk7XG5cbmV4cG9ydCB7IEJpdG1hcEZvbnRNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBGb250TWFuYWdlci5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdEJpdG1hcEZvbnQgfSBmcm9tICcuL0Fic3RyYWN0Qml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgQml0bWFwRm9udE1hbmFnZXIgfSBmcm9tICcuL0JpdG1hcEZvbnRNYW5hZ2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQml0bWFwRm9udCBleHRlbmRzIEFic3RyYWN0Qml0bWFwRm9udCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHVybCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgeyB0ZXh0dXJlcywgZGF0YSB9ID0gb3B0aW9ucztcbiAgICBPYmplY3Qua2V5cyhkYXRhLnBhZ2VzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2VEYXRhID0gZGF0YS5wYWdlc1twYXJzZUludChrZXksIDEwKV07XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbcGFnZURhdGEuaWRdO1xuICAgICAgdGhpcy5wYWdlcy5wdXNoKHsgdGV4dHVyZSB9KTtcbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyhkYXRhLmNoYXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGNoYXJEYXRhID0gZGF0YS5jaGFyc1trZXldO1xuICAgICAgY29uc3QgdGV4dHVyZVNvdXJjZSA9IHRleHR1cmVzW2NoYXJEYXRhLnBhZ2VdLnNvdXJjZTtcbiAgICAgIGNvbnN0IGZyYW1lUmVhbCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgIGNoYXJEYXRhLngsXG4gICAgICAgIGNoYXJEYXRhLnksXG4gICAgICAgIGNoYXJEYXRhLndpZHRoLFxuICAgICAgICBjaGFyRGF0YS5oZWlnaHRcbiAgICAgICk7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgICBzb3VyY2U6IHRleHR1cmVTb3VyY2UsXG4gICAgICAgIGZyYW1lOiBmcmFtZVJlYWxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGFyc1trZXldID0ge1xuICAgICAgICBpZDoga2V5LmNvZGVQb2ludEF0KDApLFxuICAgICAgICB4T2Zmc2V0OiBjaGFyRGF0YS54T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0OiBjaGFyRGF0YS55T2Zmc2V0LFxuICAgICAgICB4QWR2YW5jZTogY2hhckRhdGEueEFkdmFuY2UsXG4gICAgICAgIGtlcm5pbmc6IGNoYXJEYXRhLmtlcm5pbmcgPz8ge30sXG4gICAgICAgIHRleHR1cmVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZSA9IGRhdGEuZm9udFNpemU7XG4gICAgdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZSA9IGRhdGEuZm9udFNpemU7XG4gICAgdGhpcy5mb250TWV0cmljcyA9IHtcbiAgICAgIGFzY2VudDogMCxcbiAgICAgIGRlc2NlbnQ6IDAsXG4gICAgICBmb250U2l6ZTogZGF0YS5mb250U2l6ZVxuICAgIH07XG4gICAgdGhpcy5iYXNlTGluZU9mZnNldCA9IGRhdGEuYmFzZUxpbmVPZmZzZXQ7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gZGF0YS5saW5lSGVpZ2h0O1xuICAgIHRoaXMuZm9udEZhbWlseSA9IGRhdGEuZm9udEZhbWlseTtcbiAgICB0aGlzLmRpc3RhbmNlRmllbGQgPSBkYXRhLmRpc3RhbmNlRmllbGQgPz8ge1xuICAgICAgdHlwZTogXCJub25lXCIsXG4gICAgICByYW5nZTogMFxuICAgIH07XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBCaXRtYXBGb250IG9iamVjdC4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IHRleHR1cmUgfSA9IHRoaXMucGFnZXNbaV07XG4gICAgICB0ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMucGFnZXMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBiaXRtYXAtZm9udCBmb3IgdGhlIGdpdmVuIHN0eWxlIGFuZCBjaGFyYWN0ZXIgc2V0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2V0dXAgb3B0aW9ucyBmb3IgZm9udCBnZW5lcmF0aW9uLlxuICAgKiBAcmV0dXJucyBGb250IGdlbmVyYXRlZCBieSBzdHlsZSBvcHRpb25zLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBCaXRtYXBGb250LCBCaXRtYXBUZXh0IH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIEJpdG1hcEZvbnQuaW5zdGFsbCgnVGl0bGVGb250Jywge1xuICAgKiAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICogICAgIGZvbnRTaXplOiAxMixcbiAgICogICAgIHN0cm9rZVRoaWNrbmVzczogMixcbiAgICogICAgIGZpbGw6ICdwdXJwbGUnLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgdGl0bGUgPSBuZXcgQml0bWFwVGV4dCh7IHRleHQ6ICdUaGlzIGlzIHRoZSB0aXRsZScsIGZvbnRGYW1pbHk6ICdUaXRsZUZvbnQnIH0pO1xuICAgKi9cbiAgc3RhdGljIGluc3RhbGwob3B0aW9ucykge1xuICAgIEJpdG1hcEZvbnRNYW5hZ2VyLmluc3RhbGwob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW5zdGFsbHMgYSBiaXRtYXAgZm9udCBmcm9tIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYml0bWFwIGZvbnQgdG8gdW5pbnN0YWxsLlxuICAgKi9cbiAgc3RhdGljIHVuaW5zdGFsbChuYW1lKSB7XG4gICAgQml0bWFwRm9udE1hbmFnZXIudW5pbnN0YWxsKG5hbWUpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJpdG1hcEZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcEZvbnQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBiaXRtYXBGb250VGV4dFBhcnNlciA9IHtcbiAgdGVzdChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmIGRhdGEuc3RhcnRzV2l0aChcImluZm8gZmFjZT1cIik7XG4gIH0sXG4gIHBhcnNlKHR4dCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdHh0Lm1hdGNoKC9eW2Etel0rXFxzKy4rJC9nbSk7XG4gICAgY29uc3QgcmF3RGF0YSA9IHtcbiAgICAgIGluZm86IFtdLFxuICAgICAgY29tbW9uOiBbXSxcbiAgICAgIHBhZ2U6IFtdLFxuICAgICAgY2hhcjogW10sXG4gICAgICBjaGFyczogW10sXG4gICAgICBrZXJuaW5nOiBbXSxcbiAgICAgIGtlcm5pbmdzOiBbXSxcbiAgICAgIGRpc3RhbmNlRmllbGQ6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gaXRlbXMpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpdGVtc1tpXS5tYXRjaCgvXlthLXpdKy9nbSlbMF07XG4gICAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gaXRlbXNbaV0ubWF0Y2goL1thLXpBLVpdKz0oW15cXHNcIiddK3xcIihbXlwiXSopXCIpL2dtKTtcbiAgICAgIGNvbnN0IGl0ZW1EYXRhID0ge307XG4gICAgICBmb3IgKGNvbnN0IGkyIGluIGF0dHJpYnV0ZUxpc3QpIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBhdHRyaWJ1dGVMaXN0W2kyXS5zcGxpdChcIj1cIik7XG4gICAgICAgIGNvbnN0IGtleSA9IHNwbGl0WzBdO1xuICAgICAgICBjb25zdCBzdHJWYWx1ZSA9IHNwbGl0WzFdLnJlcGxhY2UoL1wiL2dtLCBcIlwiKTtcbiAgICAgICAgY29uc3QgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQoc3RyVmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGlzTmFOKGZsb2F0VmFsdWUpID8gc3RyVmFsdWUgOiBmbG9hdFZhbHVlO1xuICAgICAgICBpdGVtRGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByYXdEYXRhW25hbWVdLnB1c2goaXRlbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0ge1xuICAgICAgY2hhcnM6IHt9LFxuICAgICAgcGFnZXM6IFtdLFxuICAgICAgbGluZUhlaWdodDogMCxcbiAgICAgIGZvbnRTaXplOiAwLFxuICAgICAgZm9udEZhbWlseTogXCJcIixcbiAgICAgIGRpc3RhbmNlRmllbGQ6IG51bGwsXG4gICAgICBiYXNlTGluZU9mZnNldDogMFxuICAgIH07XG4gICAgY29uc3QgW2luZm9dID0gcmF3RGF0YS5pbmZvO1xuICAgIGNvbnN0IFtjb21tb25dID0gcmF3RGF0YS5jb21tb247XG4gICAgY29uc3QgW2Rpc3RhbmNlRmllbGRdID0gcmF3RGF0YS5kaXN0YW5jZUZpZWxkID8/IFtdO1xuICAgIGlmIChkaXN0YW5jZUZpZWxkKSB7XG4gICAgICBmb250LmRpc3RhbmNlRmllbGQgPSB7XG4gICAgICAgIHJhbmdlOiBwYXJzZUludChkaXN0YW5jZUZpZWxkLmRpc3RhbmNlUmFuZ2UsIDEwKSxcbiAgICAgICAgdHlwZTogZGlzdGFuY2VGaWVsZC5maWVsZFR5cGVcbiAgICAgIH07XG4gICAgfVxuICAgIGZvbnQuZm9udFNpemUgPSBwYXJzZUludChpbmZvLnNpemUsIDEwKTtcbiAgICBmb250LmZvbnRGYW1pbHkgPSBpbmZvLmZhY2U7XG4gICAgZm9udC5saW5lSGVpZ2h0ID0gcGFyc2VJbnQoY29tbW9uLmxpbmVIZWlnaHQsIDEwKTtcbiAgICBjb25zdCBwYWdlID0gcmF3RGF0YS5wYWdlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgZm9udC5wYWdlcy5wdXNoKHtcbiAgICAgICAgaWQ6IHBhcnNlSW50KHBhZ2VbaV0uaWQsIDEwKSB8fCAwLFxuICAgICAgICBmaWxlOiBwYWdlW2ldLmZpbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSB7fTtcbiAgICBmb250LmJhc2VMaW5lT2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC0gcGFyc2VJbnQoY29tbW9uLmJhc2UsIDEwKTtcbiAgICBjb25zdCBjaGFyID0gcmF3RGF0YS5jaGFyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhck5vZGUgPSBjaGFyW2ldO1xuICAgICAgY29uc3QgaWQgPSBwYXJzZUludChjaGFyTm9kZS5pZCwgMTApO1xuICAgICAgbGV0IGxldHRlciA9IGNoYXJOb2RlLmxldHRlciA/PyBjaGFyTm9kZS5jaGFyID8/IFN0cmluZy5mcm9tQ2hhckNvZGUoaWQpO1xuICAgICAgaWYgKGxldHRlciA9PT0gXCJzcGFjZVwiKVxuICAgICAgICBsZXR0ZXIgPSBcIiBcIjtcbiAgICAgIG1hcFtpZF0gPSBsZXR0ZXI7XG4gICAgICBmb250LmNoYXJzW2xldHRlcl0gPSB7XG4gICAgICAgIGlkLFxuICAgICAgICAvLyB0ZXh0dXJlIGRlZXRzLi5cbiAgICAgICAgcGFnZTogcGFyc2VJbnQoY2hhck5vZGUucGFnZSwgMTApIHx8IDAsXG4gICAgICAgIHg6IHBhcnNlSW50KGNoYXJOb2RlLngsIDEwKSxcbiAgICAgICAgeTogcGFyc2VJbnQoY2hhck5vZGUueSwgMTApLFxuICAgICAgICB3aWR0aDogcGFyc2VJbnQoY2hhck5vZGUud2lkdGgsIDEwKSxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludChjaGFyTm9kZS5oZWlnaHQsIDEwKSxcbiAgICAgICAgeE9mZnNldDogcGFyc2VJbnQoY2hhck5vZGUueG9mZnNldCwgMTApLFxuICAgICAgICB5T2Zmc2V0OiBwYXJzZUludChjaGFyTm9kZS55b2Zmc2V0LCAxMCksXG4gICAgICAgIHhBZHZhbmNlOiBwYXJzZUludChjaGFyTm9kZS54YWR2YW5jZSwgMTApLFxuICAgICAgICBrZXJuaW5nOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qga2VybmluZyA9IHJhd0RhdGEua2VybmluZyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZ1tpXS5maXJzdCwgMTApO1xuICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQoa2VybmluZ1tpXS5zZWNvbmQsIDEwKTtcbiAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlSW50KGtlcm5pbmdbaV0uYW1vdW50LCAxMCk7XG4gICAgICBmb250LmNoYXJzW21hcFtzZWNvbmRdXS5rZXJuaW5nW21hcFtmaXJzdF1dID0gYW1vdW50O1xuICAgIH1cbiAgICByZXR1cm4gZm9udDtcbiAgfVxufTtcblxuZXhwb3J0IHsgYml0bWFwRm9udFRleHRQYXJzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdG1hcEZvbnRUZXh0UGFyc2VyLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgYml0bWFwRm9udFhNTFBhcnNlciA9IHtcbiAgdGVzdChkYXRhKSB7XG4gICAgY29uc3QgeG1sID0gZGF0YTtcbiAgICByZXR1cm4gdHlwZW9mIHhtbCAhPT0gXCJzdHJpbmdcIiAmJiBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCIgaW4geG1sICYmIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhZ2VcIikubGVuZ3RoICYmIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImluZm9cIilbMF0uZ2V0QXR0cmlidXRlKFwiZmFjZVwiKSAhPT0gbnVsbDtcbiAgfSxcbiAgcGFyc2UoeG1sKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGNoYXJzOiB7fSxcbiAgICAgIHBhZ2VzOiBbXSxcbiAgICAgIGxpbmVIZWlnaHQ6IDAsXG4gICAgICBmb250U2l6ZTogMCxcbiAgICAgIGZvbnRGYW1pbHk6IFwiXCIsXG4gICAgICBkaXN0YW5jZUZpZWxkOiBudWxsLFxuICAgICAgYmFzZUxpbmVPZmZzZXQ6IDBcbiAgICB9O1xuICAgIGNvbnN0IGluZm8gPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbmZvXCIpWzBdO1xuICAgIGNvbnN0IGNvbW1vbiA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvbW1vblwiKVswXTtcbiAgICBjb25zdCBkaXN0YW5jZUZpZWxkID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGlzdGFuY2VGaWVsZFwiKVswXTtcbiAgICBpZiAoZGlzdGFuY2VGaWVsZCkge1xuICAgICAgZGF0YS5kaXN0YW5jZUZpZWxkID0ge1xuICAgICAgICB0eXBlOiBkaXN0YW5jZUZpZWxkLmdldEF0dHJpYnV0ZShcImZpZWxkVHlwZVwiKSxcbiAgICAgICAgcmFuZ2U6IHBhcnNlSW50KGRpc3RhbmNlRmllbGQuZ2V0QXR0cmlidXRlKFwiZGlzdGFuY2VSYW5nZVwiKSwgMTApXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwYWdlID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFnZVwiKTtcbiAgICBjb25zdCBjaGFyID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2hhclwiKTtcbiAgICBjb25zdCBrZXJuaW5nID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwia2VybmluZ1wiKTtcbiAgICBkYXRhLmZvbnRTaXplID0gcGFyc2VJbnQoaW5mby5nZXRBdHRyaWJ1dGUoXCJzaXplXCIpLCAxMCk7XG4gICAgZGF0YS5mb250RmFtaWx5ID0gaW5mby5nZXRBdHRyaWJ1dGUoXCJmYWNlXCIpO1xuICAgIGRhdGEubGluZUhlaWdodCA9IHBhcnNlSW50KGNvbW1vbi5nZXRBdHRyaWJ1dGUoXCJsaW5lSGVpZ2h0XCIpLCAxMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhLnBhZ2VzLnB1c2goe1xuICAgICAgICBpZDogcGFyc2VJbnQocGFnZVtpXS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSwgMTApIHx8IDAsXG4gICAgICAgIGZpbGU6IHBhZ2VbaV0uZ2V0QXR0cmlidXRlKFwiZmlsZVwiKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIGRhdGEuYmFzZUxpbmVPZmZzZXQgPSBkYXRhLmxpbmVIZWlnaHQgLSBwYXJzZUludChjb21tb24uZ2V0QXR0cmlidXRlKFwiYmFzZVwiKSwgMTApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhck5vZGUgPSBjaGFyW2ldO1xuICAgICAgY29uc3QgaWQgPSBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSwgMTApO1xuICAgICAgbGV0IGxldHRlciA9IGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImxldHRlclwiKSA/PyBjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJjaGFyXCIpID8/IFN0cmluZy5mcm9tQ2hhckNvZGUoaWQpO1xuICAgICAgaWYgKGxldHRlciA9PT0gXCJzcGFjZVwiKVxuICAgICAgICBsZXR0ZXIgPSBcIiBcIjtcbiAgICAgIG1hcFtpZF0gPSBsZXR0ZXI7XG4gICAgICBkYXRhLmNoYXJzW2xldHRlcl0gPSB7XG4gICAgICAgIGlkLFxuICAgICAgICAvLyB0ZXh0dXJlIGRlZXRzLi5cbiAgICAgICAgcGFnZTogcGFyc2VJbnQoY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwicGFnZVwiKSwgMTApIHx8IDAsXG4gICAgICAgIHg6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcInhcIiksIDEwKSxcbiAgICAgICAgeTogcGFyc2VJbnQoY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwieVwiKSwgMTApLFxuICAgICAgICB3aWR0aDogcGFyc2VJbnQoY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksIDEwKSxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiksIDEwKSxcbiAgICAgICAgLy8gcmVuZGVyIGRlZXRzLi5cbiAgICAgICAgeE9mZnNldDogcGFyc2VJbnQoY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwieG9mZnNldFwiKSwgMTApLFxuICAgICAgICB5T2Zmc2V0OiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ5b2Zmc2V0XCIpLCAxMCksXG4gICAgICAgIC8vICsgYmFzZUxpbmVPZmZzZXQsXG4gICAgICAgIHhBZHZhbmNlOiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ4YWR2YW5jZVwiKSwgMTApLFxuICAgICAgICBrZXJuaW5nOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaXJzdCA9IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiZmlyc3RcIiksIDEwKTtcbiAgICAgIGNvbnN0IHNlY29uZCA9IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwic2Vjb25kXCIpLCAxMCk7XG4gICAgICBjb25zdCBhbW91bnQgPSBwYXJzZUludChrZXJuaW5nW2ldLmdldEF0dHJpYnV0ZShcImFtb3VudFwiKSwgMTApO1xuICAgICAgZGF0YS5jaGFyc1ttYXBbc2Vjb25kXV0ua2VybmluZ1ttYXBbZmlyc3RdXSA9IGFtb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJpdG1hcEZvbnRYTUxQYXJzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdG1hcEZvbnRYTUxQYXJzZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IGJpdG1hcEZvbnRYTUxQYXJzZXIgfSBmcm9tICcuL2JpdG1hcEZvbnRYTUxQYXJzZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyID0ge1xuICB0ZXN0KGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgJiYgZGF0YS5pbmNsdWRlcyhcIjxmb250PlwiKSkge1xuICAgICAgcmV0dXJuIGJpdG1hcEZvbnRYTUxQYXJzZXIudGVzdChET01BZGFwdGVyLmdldCgpLnBhcnNlWE1MKGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwYXJzZShkYXRhKSB7XG4gICAgcmV0dXJuIGJpdG1hcEZvbnRYTUxQYXJzZXIucGFyc2UoRE9NQWRhcHRlci5nZXQoKS5wYXJzZVhNTChkYXRhKSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJpdG1hcEZvbnRYTUxTdHJpbmdQYXJzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdG1hcEZvbnRYTUxTdHJpbmdQYXJzZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvTG9hZGVyUGFyc2VyLm1qcyc7XG5pbXBvcnQgeyBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vYXNzZXRzL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMubWpzJztcbmltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcGF0aC5tanMnO1xuaW1wb3J0IHsgQml0bWFwRm9udCB9IGZyb20gJy4uL0JpdG1hcEZvbnQubWpzJztcbmltcG9ydCB7IGJpdG1hcEZvbnRUZXh0UGFyc2VyIH0gZnJvbSAnLi9iaXRtYXBGb250VGV4dFBhcnNlci5tanMnO1xuaW1wb3J0IHsgYml0bWFwRm9udFhNTFN0cmluZ1BhcnNlciB9IGZyb20gJy4vYml0bWFwRm9udFhNTFN0cmluZ1BhcnNlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHZhbGlkRXh0ZW5zaW9ucyA9IFtcIi54bWxcIiwgXCIuZm50XCJdO1xuY29uc3QgYml0bWFwRm9udENhY2hlUGx1Z2luID0ge1xuICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsXG4gIHRlc3Q6IChhc3NldCkgPT4gYXNzZXQgaW5zdGFuY2VvZiBCaXRtYXBGb250LFxuICBnZXRDYWNoZWFibGVBc3NldHMoa2V5cywgYXNzZXQpIHtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgb3V0W2tleV0gPSBhc3NldDtcbiAgICB9KTtcbiAgICBvdXRbYCR7YXNzZXQuZm9udEZhbWlseX0tYml0bWFwYF0gPSBhc3NldDtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xuY29uc3QgbG9hZEJpdG1hcEZvbnQgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyUHJpb3JpdHkuTm9ybWFsXG4gIH0sXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIHZhbGlkRXh0ZW5zaW9ucy5pbmNsdWRlcyhwYXRoLmV4dG5hbWUodXJsKS50b0xvd2VyQ2FzZSgpKTtcbiAgfSxcbiAgYXN5bmMgdGVzdFBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gYml0bWFwRm9udFRleHRQYXJzZXIudGVzdChkYXRhKSB8fCBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLnRlc3QoZGF0YSk7XG4gIH0sXG4gIGFzeW5jIHBhcnNlKGFzc2V0LCBkYXRhLCBsb2FkZXIpIHtcbiAgICBjb25zdCBiaXRtYXBGb250RGF0YSA9IGJpdG1hcEZvbnRUZXh0UGFyc2VyLnRlc3QoYXNzZXQpID8gYml0bWFwRm9udFRleHRQYXJzZXIucGFyc2UoYXNzZXQpIDogYml0bWFwRm9udFhNTFN0cmluZ1BhcnNlci5wYXJzZShhc3NldCk7XG4gICAgY29uc3QgeyBzcmMgfSA9IGRhdGE7XG4gICAgY29uc3QgeyBwYWdlcyB9ID0gYml0bWFwRm9udERhdGE7XG4gICAgY29uc3QgdGV4dHVyZVVybHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwYWdlRmlsZSA9IHBhZ2VzW2ldLmZpbGU7XG4gICAgICBsZXQgaW1hZ2VQYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShzcmMpLCBwYWdlRmlsZSk7XG4gICAgICBpbWFnZVBhdGggPSBjb3B5U2VhcmNoUGFyYW1zKGltYWdlUGF0aCwgc3JjKTtcbiAgICAgIHRleHR1cmVVcmxzLnB1c2goaW1hZ2VQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVkVGV4dHVyZXMgPSBhd2FpdCBsb2FkZXIubG9hZCh0ZXh0dXJlVXJscyk7XG4gICAgY29uc3QgdGV4dHVyZXMgPSB0ZXh0dXJlVXJscy5tYXAoKHVybCkgPT4gbG9hZGVkVGV4dHVyZXNbdXJsXSk7XG4gICAgY29uc3QgYml0bWFwRm9udCA9IG5ldyBCaXRtYXBGb250KHtcbiAgICAgIGRhdGE6IGJpdG1hcEZvbnREYXRhLFxuICAgICAgdGV4dHVyZXNcbiAgICB9LCBzcmMpO1xuICAgIHJldHVybiBiaXRtYXBGb250O1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgX29wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IERPTUFkYXB0ZXIuZ2V0KCkuZmV0Y2godXJsKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICB9LFxuICB1bmxvYWQoYml0bWFwRm9udCkge1xuICAgIGJpdG1hcEZvbnQuZGVzdHJveSgpO1xuICB9XG59O1xuXG5leHBvcnQgeyBiaXRtYXBGb250Q2FjaGVQbHVnaW4sIGxvYWRCaXRtYXBGb250IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkQml0bWFwRm9udC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGxvY2FsVW5pZm9ybU1TREZCaXQgPSB7XG4gIG5hbWU6IFwibG9jYWwtdW5pZm9ybS1tc2RmLWJpdFwiLFxuICB2ZXJ0ZXg6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHN0cnVjdCBMb2NhbFVuaWZvcm1zIHtcbiAgICAgICAgICAgICAgICB1Q29sb3I6dmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdURpc3RhbmNlOiBmMzIsXG4gICAgICAgICAgICAgICAgdVJvdW5kOmYzMixcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBsb2NhbFVuaWZvcm1zIDogTG9jYWxVbmlmb3JtcztcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdkNvbG9yICo9IGxvY2FsVW5pZm9ybXMudUNvbG9yO1xuICAgICAgICAgICAgbW9kZWxNYXRyaXggKj0gbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4O1xuICAgICAgICBgXG4gICAgKSxcbiAgICBlbmQ6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIGlmKGxvY2FsVW5pZm9ybXMudVJvdW5kID09IDEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdlBvc2l0aW9uID0gdmVjNChyb3VuZFBpeGVscyh2UG9zaXRpb24ueHksIGdsb2JhbFVuaWZvcm1zLnVSZXNvbHV0aW9uKSwgdlBvc2l0aW9uLnp3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHN0cnVjdCBMb2NhbFVuaWZvcm1zIHtcbiAgICAgICAgICAgICAgICB1Q29sb3I6dmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdURpc3RhbmNlOiBmMzJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBsb2NhbFVuaWZvcm1zIDogTG9jYWxVbmlmb3JtcztcbiAgICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGAgXG4gICAgICAgICAgICBvdXRDb2xvciA9IHZDb2xvciAqIGNhbGN1bGF0ZU1TREZBbHBoYShvdXRDb2xvciwgbG9jYWxVbmlmb3Jtcy51RGlzdGFuY2UpO1xuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuY29uc3QgbG9jYWxVbmlmb3JtTVNERkJpdEdsID0ge1xuICBuYW1lOiBcImxvY2FsLXVuaWZvcm0tbXNkZi1iaXRcIixcbiAgdmVydGV4OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdVRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1Q29sb3I7XG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVSb3VuZDtcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdkNvbG9yICo9IHVDb2xvcjtcbiAgICAgICAgICAgIG1vZGVsTWF0cml4ICo9IHVUcmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIGBcbiAgICApLFxuICAgIGVuZDogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgaWYodVJvdW5kID09IDEuKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uLnh5ID0gcm91bmRQaXhlbHMoZ2xfUG9zaXRpb24ueHksIHVSZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdURpc3RhbmNlO1xuICAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYCBcbiAgICAgICAgICAgIG91dENvbG9yID0gdkNvbG9yICogY2FsY3VsYXRlTVNERkFscGhhKG91dENvbG9yLCB1RGlzdGFuY2UpO1xuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuXG5leHBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsVW5pZm9ybU1TREZCaXQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtU0RGQml0ID0ge1xuICBuYW1lOiBcIm1zZGYtYml0XCIsXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBmbiBjYWxjdWxhdGVNU0RGQWxwaGEobXNkZkNvbG9yOnZlYzQ8ZjMyPiwgZGlzdGFuY2U6ZjMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE1TREZcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWFuID0gbXNkZkNvbG9yLnIgKyBtc2RmQ29sb3IuZyArIG1zZGZDb2xvci5iIC1cbiAgICAgICAgICAgICAgICAgICAgbWluKG1zZGZDb2xvci5yLCBtaW4obXNkZkNvbG9yLmcsIG1zZGZDb2xvci5iKSkgLVxuICAgICAgICAgICAgICAgICAgICBtYXgobXNkZkNvbG9yLnIsIG1heChtc2RmQ29sb3IuZywgbXNkZkNvbG9yLmIpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFNERlxuICAgICAgICAgICAgICAgIG1lZGlhbiA9IG1pbihtZWRpYW4sIG1zZGZDb2xvci5hKTtcblxuICAgICAgICAgICAgICAgIHZhciBzY3JlZW5QeERpc3RhbmNlID0gZGlzdGFuY2UgKiAobWVkaWFuIC0gMC41KTtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBjbGFtcChzY3JlZW5QeERpc3RhbmNlICsgMC41LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhbiA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAwLjA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZWRpYW4gPiAwLjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcbmNvbnN0IG1TREZCaXRHbCA9IHtcbiAgbmFtZTogXCJtc2RmLWJpdFwiLFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgZmxvYXQgY2FsY3VsYXRlTVNERkFscGhhKHZlYzQgbXNkZkNvbG9yLCBmbG9hdCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE1TREZcbiAgICAgICAgICAgICAgICBmbG9hdCBtZWRpYW4gPSBtc2RmQ29sb3IuciArIG1zZGZDb2xvci5nICsgbXNkZkNvbG9yLmIgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4obXNkZkNvbG9yLnIsIG1pbihtc2RmQ29sb3IuZywgbXNkZkNvbG9yLmIpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heChtc2RmQ29sb3IuciwgbWF4KG1zZGZDb2xvci5nLCBtc2RmQ29sb3IuYikpO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU0RGXG4gICAgICAgICAgICAgICAgbWVkaWFuID0gbWluKG1lZGlhbiwgbXNkZkNvbG9yLmEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZmxvYXQgc2NyZWVuUHhEaXN0YW5jZSA9IGRpc3RhbmNlICogKG1lZGlhbiAtIDAuNSk7XG4gICAgICAgICAgICAgICAgZmxvYXQgYWxwaGEgPSBjbGFtcChzY3JlZW5QeERpc3RhbmNlICsgMC41LCAwLjAsIDEuMCk7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtZWRpYW4gPCAwLjAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMC4wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVkaWFuID4gMC45OSkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDEuMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5cbmV4cG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bVNERkJpdC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBNQVhfVEVYVFVSRVMgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvY29uc3QubWpzJztcbmltcG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSwgY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0gfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGNvbG9yQml0LCBjb2xvckJpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2NvbG9yQml0Lm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdCwgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9nZW5lcmF0ZVRleHR1cmVCYXRjaEJpdC5tanMnO1xuaW1wb3J0IHsgcm91bmRQaXhlbHNCaXQsIHJvdW5kUGl4ZWxzQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvcm91bmRQaXhlbHNCaXQubWpzJztcbmltcG9ydCB7IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9iYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfSBmcm9tICcuL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzJztcbmltcG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9IGZyb20gJy4vc2hhZGVyLWJpdHMvbVNERkJpdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFNkZlNoYWRlciBleHRlbmRzIFNoYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1Q29sb3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVEaXN0YW5jZTogeyB2YWx1ZTogNCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwic2RmLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBjb2xvckJpdCxcbiAgICAgICAgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQoTUFYX1RFWFRVUkVTKSxcbiAgICAgICAgbG9jYWxVbmlmb3JtTVNERkJpdCxcbiAgICAgICAgbVNERkJpdCxcbiAgICAgICAgcm91bmRQaXhlbHNCaXRcbiAgICAgIF1cbiAgICB9KTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcInNkZi1zaGFkZXJcIixcbiAgICAgIGJpdHM6IFtcbiAgICAgICAgY29sb3JCaXRHbCxcbiAgICAgICAgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXRHbChNQVhfVEVYVFVSRVMpLFxuICAgICAgICBsb2NhbFVuaWZvcm1NU0RGQml0R2wsXG4gICAgICAgIG1TREZCaXRHbCxcbiAgICAgICAgcm91bmRQaXhlbHNCaXRHbFxuICAgICAgXVxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgbG9jYWxVbmlmb3JtczogdW5pZm9ybXMsXG4gICAgICAgIGJhdGNoU2FtcGxlcnM6IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBTZGZTaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNkZlNoYWRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljcyB9IGZyb20gJy4uL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljcy5tanMnO1xuaW1wb3J0IHsgU2RmU2hhZGVyIH0gZnJvbSAnLi4vdGV4dC9zZGZTaGFkZXIvU2RmU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBGb250TWFuYWdlciB9IGZyb20gJy4vQml0bWFwRm9udE1hbmFnZXIubWpzJztcbmltcG9ydCB7IGdldEJpdG1hcFRleHRMYXlvdXQgfSBmcm9tICcuL3V0aWxzL2dldEJpdG1hcFRleHRMYXlvdXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCaXRtYXBUZXh0UGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1Qml0bWFwVGV4dCA9IHt9O1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKGJpdG1hcFRleHQpIHtcbiAgICBjb25zdCBncmFwaGljc1JlbmRlcmFibGUgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpO1xuICAgIGlmIChiaXRtYXBUZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICBiaXRtYXBUZXh0Ll9kaWRUZXh0VXBkYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLl91cGRhdGVDb250ZXh0KGJpdG1hcFRleHQsIGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5ncmFwaGljcy52YWxpZGF0ZVJlbmRlcmFibGUoZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgfVxuICBhZGRSZW5kZXJhYmxlKGJpdG1hcFRleHQsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NSZW5kZXJhYmxlID0gdGhpcy5fZ2V0R3B1Qml0bWFwVGV4dChiaXRtYXBUZXh0KTtcbiAgICBzeW5jV2l0aFByb3h5KGJpdG1hcFRleHQsIGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gICAgaWYgKGJpdG1hcFRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIGJpdG1hcFRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbnRleHQoYml0bWFwVGV4dCwgZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuZ3JhcGhpY3MuYWRkUmVuZGVyYWJsZShncmFwaGljc1JlbmRlcmFibGUsIGluc3RydWN0aW9uU2V0KTtcbiAgICBpZiAoZ3JhcGhpY3NSZW5kZXJhYmxlLmNvbnRleHQuY3VzdG9tU2hhZGVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXN0YW5jZUZpZWxkKGJpdG1hcFRleHQpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95UmVuZGVyYWJsZShiaXRtYXBUZXh0KSB7XG4gICAgdGhpcy5fZGVzdHJveVJlbmRlcmFibGVCeVVpZChiaXRtYXBUZXh0LnVpZCk7XG4gIH1cbiAgX2Rlc3Ryb3lSZW5kZXJhYmxlQnlVaWQocmVuZGVyYWJsZVVpZCkge1xuICAgIEJpZ1Bvb2wucmV0dXJuKHRoaXMuX2dwdUJpdG1hcFRleHRbcmVuZGVyYWJsZVVpZF0pO1xuICAgIHRoaXMuX2dwdUJpdG1hcFRleHRbcmVuZGVyYWJsZVVpZF0gPSBudWxsO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUoYml0bWFwVGV4dCkge1xuICAgIGNvbnN0IGdyYXBoaWNzUmVuZGVyYWJsZSA9IHRoaXMuX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCk7XG4gICAgc3luY1dpdGhQcm94eShiaXRtYXBUZXh0LCBncmFwaGljc1JlbmRlcmFibGUpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmdyYXBoaWNzLnVwZGF0ZVJlbmRlcmFibGUoZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICBpZiAoZ3JhcGhpY3NSZW5kZXJhYmxlLmNvbnRleHQuY3VzdG9tU2hhZGVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXN0YW5jZUZpZWxkKGJpdG1hcFRleHQpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBwcm94eUdyYXBoaWNzKSB7XG4gICAgY29uc3QgeyBjb250ZXh0IH0gPSBwcm94eUdyYXBoaWNzO1xuICAgIGNvbnN0IGJpdG1hcEZvbnQgPSBCaXRtYXBGb250TWFuYWdlci5nZXRGb250KGJpdG1hcFRleHQudGV4dCwgYml0bWFwVGV4dC5fc3R5bGUpO1xuICAgIGNvbnRleHQuY2xlYXIoKTtcbiAgICBpZiAoYml0bWFwRm9udC5kaXN0YW5jZUZpZWxkLnR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBpZiAoIWNvbnRleHQuY3VzdG9tU2hhZGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2RmU2hhZGVyKSB7XG4gICAgICAgICAgdGhpcy5fc2RmU2hhZGVyID0gbmV3IFNkZlNoYWRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY3VzdG9tU2hhZGVyID0gdGhpcy5fc2RmU2hhZGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IEFycmF5LmZyb20oYml0bWFwVGV4dC50ZXh0KTtcbiAgICBjb25zdCBzdHlsZSA9IGJpdG1hcFRleHQuX3N0eWxlO1xuICAgIGxldCBjdXJyZW50WSA9IChzdHlsZS5fc3Ryb2tlPy53aWR0aCB8fCAwKSAvIDI7XG4gICAgY3VycmVudFkgKz0gYml0bWFwRm9udC5iYXNlTGluZU9mZnNldDtcbiAgICBjb25zdCBiaXRtYXBUZXh0TGF5b3V0ID0gZ2V0Qml0bWFwVGV4dExheW91dChjaGFycywgc3R5bGUsIGJpdG1hcEZvbnQpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmc7XG4gICAgY29uc3Qgc2NhbGUgPSBiaXRtYXBUZXh0TGF5b3V0LnNjYWxlO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgLWJpdG1hcFRleHQuX2FuY2hvci5feCAqIGJpdG1hcFRleHRMYXlvdXQud2lkdGggLSBwYWRkaW5nLFxuICAgICAgLWJpdG1hcFRleHQuX2FuY2hvci5feSAqIChiaXRtYXBUZXh0TGF5b3V0LmhlaWdodCArIGJpdG1hcFRleHRMYXlvdXQub2Zmc2V0WSkgLSBwYWRkaW5nXG4gICAgKS5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgIGNvbnN0IHRpbnQgPSBzdHlsZS5fZmlsbC5jb2xvcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdG1hcFRleHRMYXlvdXQubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBiaXRtYXBUZXh0TGF5b3V0LmxpbmVzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2luZGV4KytdO1xuICAgICAgICBjb25zdCBjaGFyRGF0YSA9IGJpdG1hcEZvbnQuY2hhcnNbY2hhcl07XG4gICAgICAgIGlmIChjaGFyRGF0YT8udGV4dHVyZSkge1xuICAgICAgICAgIGNvbnRleHQudGV4dHVyZShcbiAgICAgICAgICAgIGNoYXJEYXRhLnRleHR1cmUsXG4gICAgICAgICAgICB0aW50LFxuICAgICAgICAgICAgTWF0aC5yb3VuZChsaW5lLmNoYXJQb3NpdGlvbnNbal0gKyBjaGFyRGF0YS54T2Zmc2V0KSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoY3VycmVudFkgKyBjaGFyRGF0YS55T2Zmc2V0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRZICs9IGJpdG1hcEZvbnQubGluZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9ncHVCaXRtYXBUZXh0W2JpdG1hcFRleHQudWlkXSB8fCB0aGlzLmluaXRHcHVUZXh0KGJpdG1hcFRleHQpO1xuICB9XG4gIGluaXRHcHVUZXh0KGJpdG1hcFRleHQpIHtcbiAgICBjb25zdCBwcm94eVJlbmRlcmFibGUgPSBCaWdQb29sLmdldChHcmFwaGljcyk7XG4gICAgdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF0gPSBwcm94eVJlbmRlcmFibGU7XG4gICAgdGhpcy5fdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBwcm94eVJlbmRlcmFibGUpO1xuICAgIGJpdG1hcFRleHQub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShiaXRtYXBUZXh0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF07XG4gIH1cbiAgX3VwZGF0ZURpc3RhbmNlRmllbGQoYml0bWFwVGV4dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpLmNvbnRleHQ7XG4gICAgY29uc3QgZm9udEZhbWlseSA9IGJpdG1hcFRleHQuX3N0eWxlLmZvbnRGYW1pbHk7XG4gICAgY29uc3QgZHluYW1pY0ZvbnQgPSBDYWNoZS5nZXQoYCR7Zm9udEZhbWlseX0tYml0bWFwYCk7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSBiaXRtYXBUZXh0Lmdyb3VwVHJhbnNmb3JtO1xuICAgIGNvbnN0IGR4ID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSAoTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKSAvIDI7XG4gICAgY29uc3QgZm9udFNjYWxlID0gZHluYW1pY0ZvbnQuYmFzZVJlbmRlcmVkRm9udFNpemUgLyBiaXRtYXBUZXh0Ll9zdHlsZS5mb250U2l6ZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gYml0bWFwVGV4dC5yZXNvbHV0aW9uID8/IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgY29uc3QgZGlzdGFuY2UgPSB3b3JsZFNjYWxlICogZHluYW1pY0ZvbnQuZGlzdGFuY2VGaWVsZC5yYW5nZSAqICgxIC8gZm9udFNjYWxlKSAqIHJlc29sdXRpb247XG4gICAgY29udGV4dC5jdXN0b21TaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXMudURpc3RhbmNlID0gZGlzdGFuY2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IHVpZCBpbiB0aGlzLl9ncHVCaXRtYXBUZXh0KSB7XG4gICAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5VWlkKHVpZCk7XG4gICAgfVxuICAgIHRoaXMuX2dwdUJpdG1hcFRleHQgPSBudWxsO1xuICAgIHRoaXMuX3NkZlNoYWRlcj8uZGVzdHJveSh0cnVlKTtcbiAgICB0aGlzLl9zZGZTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkJpdG1hcFRleHRQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJiaXRtYXBUZXh0XCJcbn07XG5mdW5jdGlvbiBzeW5jV2l0aFByb3h5KGNvbnRhaW5lciwgcHJveHkpIHtcbiAgcHJveHkuZ3JvdXBUcmFuc2Zvcm0gPSBjb250YWluZXIuZ3JvdXBUcmFuc2Zvcm07XG4gIHByb3h5Lmdyb3VwQ29sb3JBbHBoYSA9IGNvbnRhaW5lci5ncm91cENvbG9yQWxwaGE7XG4gIHByb3h5Lmdyb3VwQ29sb3IgPSBjb250YWluZXIuZ3JvdXBDb2xvcjtcbiAgcHJveHkuZ3JvdXBCbGVuZE1vZGUgPSBjb250YWluZXIuZ3JvdXBCbGVuZE1vZGU7XG4gIHByb3h5Lmdsb2JhbERpc3BsYXlTdGF0dXMgPSBjb250YWluZXIuZ2xvYmFsRGlzcGxheVN0YXR1cztcbiAgcHJveHkuZ3JvdXBUcmFuc2Zvcm0gPSBjb250YWluZXIuZ3JvdXBUcmFuc2Zvcm07XG4gIHByb3h5LmxvY2FsRGlzcGxheVN0YXR1cyA9IGNvbnRhaW5lci5sb2NhbERpc3BsYXlTdGF0dXM7XG4gIHByb3h5Lmdyb3VwQWxwaGEgPSBjb250YWluZXIuZ3JvdXBBbHBoYTtcbiAgcHJveHkuX3JvdW5kUGl4ZWxzID0gY29udGFpbmVyLl9yb3VuZFBpeGVscztcbn1cblxuZXhwb3J0IHsgQml0bWFwVGV4dFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcFRleHRQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGxvYWRCaXRtYXBGb250LCBiaXRtYXBGb250Q2FjaGVQbHVnaW4gfSBmcm9tICcuL2Fzc2V0L2xvYWRCaXRtYXBGb250Lm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBUZXh0UGlwZSB9IGZyb20gJy4vQml0bWFwVGV4dFBpcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChCaXRtYXBUZXh0UGlwZSwgbG9hZEJpdG1hcEZvbnQsIGJpdG1hcEZvbnRDYWNoZVBsdWdpbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8201\n')},3115:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(3747);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(900);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText._getKey();\n    if (gpuText.textureNeedsUploading) {\n      gpuText.textureNeedsUploading = false;\n      return true;\n    }\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(htmlText) {\n    this._destroyRenderableById(htmlText.uid);\n  }\n  _destroyRenderableById(htmlTextUid) {\n    const gpuText = this._gpuText[htmlTextUid];\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[htmlTextUid] = null;\n  }\n  _updateText(htmlText) {\n    const newKey = htmlText._getKey();\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n    }\n    htmlText._didTextUpdate = false;\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const gpuText = this._getGpuText(htmlText);\n    if (gpuText.generatingTexture)\n      return;\n    const newKey = htmlText._getKey();\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    gpuText.generatingTexture = true;\n    gpuText.currentKey = newKey;\n    const resolution = htmlText.resolution ?? this._renderer.resolution;\n    const texture = await this._renderer.htmlText.getManagedTexture(\n      htmlText.text,\n      resolution,\n      htmlText._style,\n      htmlText._getKey()\n    );\n    const batchableSprite = gpuText.batchableSprite;\n    batchableSprite.texture = gpuText.texture = texture;\n    gpuText.generatingTexture = false;\n    gpuText.textureNeedsUploading = true;\n    htmlText._onUpdate();\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  _getGpuText(htmlText) {\n    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const gpuTextData = {\n      texture: Texture/* Texture */.x.EMPTY,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.c),\n      textureNeedsUploading: false,\n      generatingTexture: false\n    };\n    const batchableSprite = gpuTextData.batchableSprite;\n    batchableSprite.renderable = htmlText;\n    batchableSprite.texture = Texture/* Texture */.x.EMPTY;\n    batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    this._gpuText[htmlText.uid] = gpuTextData;\n    htmlText.on("destroyed", () => {\n      this.destroyRenderable(htmlText);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "htmlText"\n};\n\n\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isSafari.mjs\n\n\n"use strict";\nfunction isSafari() {\n  const { userAgent } = adapter/* DOMAdapter */.z.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\n\n//# sourceMappingURL=isSafari.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(1647);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs\n\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(":")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\n\n//# sourceMappingURL=extractFontFamilies.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs\n\n\n"use strict";\nasync function loadFontAsBase64(url) {\n  const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\n\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs\n\n\n"use strict";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: "${style.fontFamily}";\n        src: url(\'${dataSrc}\');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\n\n//# sourceMappingURL=loadFontCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs\n\n\n\n\n"use strict";\nasync function getFontCss(fontFamilies, style) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache/* Cache */.C.has(fontFamily)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache/* Cache */.C.get(fontFamily);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          ...HTMLTextSystem.defaultFontOptions,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join("\\n");\n}\n\n\n//# sourceMappingURL=getFontCss.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs\n\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute("width", width.toString());\n  svgRoot.setAttribute("height", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\n\n//# sourceMappingURL=getSVGUrl.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs\n\n\n"use strict";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n  return canvasAndContext.canvas;\n}\n\n\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs\n\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = "anonymous";\n  });\n}\n\n\n//# sourceMappingURL=loadSVGImage.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs\n\n\n\n"use strict";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const descenderPadding = CanvasTextMetrics/* CanvasTextMetrics */.c.measureFont(style.fontStyle).descent;\n  return {\n    width: contentBounds.width,\n    height: contentBounds.height + descenderPadding\n  };\n}\n\n\n//# sourceMappingURL=measureHtmlText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst nssvg = "http://www.w3.org/2000/svg";\nconst nsxhtml = "http://www.w3.org/1999/xhtml";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, "svg");\n    this.foreignObject = document.createElementNS(nssvg, "foreignObject");\n    this.domElement = document.createElementNS(nsxhtml, "div");\n    this.styleElement = document.createElementNS(nsxhtml, "style");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute("width", "10000");\n    foreignObject.setAttribute("height", "10000");\n    foreignObject.style.overflow = "hidden";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === types/* RendererType */.g.WEBGPU;\n  }\n  getTexture(options) {\n    return this._buildTexturePromise(\n      options.text,\n      options.resolution,\n      options.style\n    );\n  }\n  getManagedTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text, resolution, style).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  async _buildTexturePromise(text, resolution, style) {\n    const htmlTextData = PoolGroup/* BigPool */.u.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(fontFamilies, style);\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    image.width = width | 0;\n    image.height = height | 0;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    let resource = image;\n    if (this._createCanvas) {\n      resource = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.H)(resource, image.width, image.height, resolution);\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n    }\n    PoolGroup/* BigPool */.u.return(htmlTextData);\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture);\n        }).catch(() => {\n          (0,warn/* warn */.Z)("HTMLTextSystem: Failed to clean texture");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  _cleanUp(activeTexture) {\n    TexturePool/* TexturePool */.z.returnTexture(activeTexture.texture);\n    activeTexture.texture.source.resource = null;\n    activeTexture.texture.source.uploadMethodId = "unknown";\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "htmlText"\n};\nHTMLTextSystem.defaultFontOptions = {\n  fontFamily: "Arial",\n  fontStyle: "normal",\n  fontWeight: "normal"\n};\n\n\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(HTMLTextSystem);\nExtensions/* extensions */.Rw.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWdCLFFBQVE7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQSxvQkFBb0IsMERBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSxvQkFBSTtBQUNkLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4QkFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUU7QUFDckU7OztBQ3hJNkQ7QUFDWDtBQUNJOztBQUV0RDtBQUNBLDZCQUFVLEtBQUssY0FBYztBQUM3Qiw2QkFBVSxLQUFLLFlBQVk7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0UGlwZS5tanM/ODdmNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci9pc1NhZmFyaS5tanM/YzE1NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2V4dHJhY3RGb250RmFtaWxpZXMubWpzP2M1ZWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkRm9udEFzQmFzZTY0Lm1qcz81MmQyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvbG9hZEZvbnRDU1MubWpzPzhiODIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRGb250Q3NzLm1qcz85ZWM1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0U1ZHVXJsLm1qcz9iNGVlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlLm1qcz83NjQzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvbG9hZFNWR0ltYWdlLm1qcz84ZTUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvbWVhc3VyZUh0bWxUZXh0Lm1qcz9hNmQyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvSFRNTFRleHRTeXN0ZW0ubWpzPzQ4NzkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC9pbml0Lm1qcz81YWU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHVwZGF0ZVF1YWRCb3VuZHMgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi4vc3ByaXRlL0JhdGNoYWJsZVNwcml0ZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEhUTUxUZXh0UGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1VGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKGh0bWxUZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQoaHRtbFRleHQpO1xuICAgIGNvbnN0IG5ld0tleSA9IGh0bWxUZXh0Ll9nZXRLZXkoKTtcbiAgICBpZiAoZ3B1VGV4dC50ZXh0dXJlTmVlZHNVcGxvYWRpbmcpIHtcbiAgICAgIGdwdVRleHQudGV4dHVyZU5lZWRzVXBsb2FkaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGh0bWxUZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0KGh0bWxUZXh0KTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYWRkVG9CYXRjaChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGh0bWxUZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0KGh0bWxUZXh0KTtcbiAgICB9XG4gICAgYmF0Y2hhYmxlU3ByaXRlLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKGh0bWxUZXh0KSB7XG4gICAgdGhpcy5fZGVzdHJveVJlbmRlcmFibGVCeUlkKGh0bWxUZXh0LnVpZCk7XG4gIH1cbiAgX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZChodG1sVGV4dFVpZCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9ncHVUZXh0W2h0bWxUZXh0VWlkXTtcbiAgICB0aGlzLl9yZW5kZXJlci5odG1sVGV4dC5kZWNyZWFzZVJlZmVyZW5jZUNvdW50KGdwdVRleHQuY3VycmVudEtleSk7XG4gICAgQmlnUG9vbC5yZXR1cm4oZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGUpO1xuICAgIHRoaXMuX2dwdVRleHRbaHRtbFRleHRVaWRdID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlVGV4dChodG1sVGV4dCkge1xuICAgIGNvbnN0IG5ld0tleSA9IGh0bWxUZXh0Ll9nZXRLZXkoKTtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICB0aGlzLl91cGRhdGVHcHVUZXh0KGh0bWxUZXh0KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGh0bWxUZXh0Ll9kaWRUZXh0VXBkYXRlID0gZmFsc2U7XG4gICAgY29uc3QgcGFkZGluZyA9IGh0bWxUZXh0Ll9zdHlsZS5wYWRkaW5nO1xuICAgIHVwZGF0ZVF1YWRCb3VuZHMoYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcywgaHRtbFRleHQuX2FuY2hvciwgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUsIHBhZGRpbmcpO1xuICB9XG4gIGFzeW5jIF91cGRhdGVHcHVUZXh0KGh0bWxUZXh0KSB7XG4gICAgaHRtbFRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgaWYgKGdwdVRleHQuZ2VuZXJhdGluZ1RleHR1cmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3S2V5ID0gaHRtbFRleHQuX2dldEtleSgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmh0bWxUZXh0LmRlY3JlYXNlUmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KTtcbiAgICBncHVUZXh0LmdlbmVyYXRpbmdUZXh0dXJlID0gdHJ1ZTtcbiAgICBncHVUZXh0LmN1cnJlbnRLZXkgPSBuZXdLZXk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IGh0bWxUZXh0LnJlc29sdXRpb24gPz8gdGhpcy5fcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICBjb25zdCB0ZXh0dXJlID0gYXdhaXQgdGhpcy5fcmVuZGVyZXIuaHRtbFRleHQuZ2V0TWFuYWdlZFRleHR1cmUoXG4gICAgICBodG1sVGV4dC50ZXh0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGh0bWxUZXh0Ll9zdHlsZSxcbiAgICAgIGh0bWxUZXh0Ll9nZXRLZXkoKVxuICAgICk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSBncHVUZXh0LnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIGdwdVRleHQuZ2VuZXJhdGluZ1RleHR1cmUgPSBmYWxzZTtcbiAgICBncHVUZXh0LnRleHR1cmVOZWVkc1VwbG9hZGluZyA9IHRydWU7XG4gICAgaHRtbFRleHQuX29uVXBkYXRlKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IGh0bWxUZXh0Ll9zdHlsZS5wYWRkaW5nO1xuICAgIHVwZGF0ZVF1YWRCb3VuZHMoYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcywgaHRtbFRleHQuX2FuY2hvciwgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUsIHBhZGRpbmcpO1xuICB9XG4gIF9nZXRHcHVUZXh0KGh0bWxUZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVRleHRbaHRtbFRleHQudWlkXSB8fCB0aGlzLmluaXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgfVxuICBpbml0R3B1VGV4dChodG1sVGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHREYXRhID0ge1xuICAgICAgdGV4dHVyZTogVGV4dHVyZS5FTVBUWSxcbiAgICAgIGN1cnJlbnRLZXk6IFwiLS1cIixcbiAgICAgIGJhdGNoYWJsZVNwcml0ZTogQmlnUG9vbC5nZXQoQmF0Y2hhYmxlU3ByaXRlKSxcbiAgICAgIHRleHR1cmVOZWVkc1VwbG9hZGluZzogZmFsc2UsXG4gICAgICBnZW5lcmF0aW5nVGV4dHVyZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHREYXRhLmJhdGNoYWJsZVNwcml0ZTtcbiAgICBiYXRjaGFibGVTcHJpdGUucmVuZGVyYWJsZSA9IGh0bWxUZXh0O1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gVGV4dHVyZS5FTVBUWTtcbiAgICBiYXRjaGFibGVTcHJpdGUuYm91bmRzID0geyBtaW5YOiAwLCBtYXhYOiAxLCBtaW5ZOiAwLCBtYXhZOiAwIH07XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnJvdW5kUGl4ZWxzID0gdGhpcy5fcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgaHRtbFRleHQuX3JvdW5kUGl4ZWxzO1xuICAgIHRoaXMuX2dwdVRleHRbaHRtbFRleHQudWlkXSA9IGdwdVRleHREYXRhO1xuICAgIGh0bWxUZXh0Lm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUoaHRtbFRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBncHVUZXh0RGF0YTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVUZXh0KSB7XG4gICAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQoaSk7XG4gICAgfVxuICAgIHRoaXMuX2dwdVRleHQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkhUTUxUZXh0UGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiaHRtbFRleHRcIlxufTtcblxuZXhwb3J0IHsgSFRNTFRleHRQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MVGV4dFBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IERPTUFkYXB0ZXIuZ2V0KCkuZ2V0TmF2aWdhdG9yKCk7XG4gIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCk7XG59XG5cbmV4cG9ydCB7IGlzU2FmYXJpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1NhZmFyaS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGV4dHJhY3RGb250RmFtaWxpZXModGV4dCwgc3R5bGUpIHtcbiAgY29uc3QgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHk7XG4gIGNvbnN0IGZvbnRGYW1pbGllcyA9IFtdO1xuICBjb25zdCBkZWR1cGUgPSB7fTtcbiAgY29uc3QgcmVnZXggPSAvZm9udC1mYW1pbHk6KFteO1wiXFxzXSspL2c7XG4gIGNvbnN0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKHJlZ2V4KTtcbiAgZnVuY3Rpb24gYWRkRm9udEZhbWlseShmb250RmFtaWx5Mikge1xuICAgIGlmICghZGVkdXBlW2ZvbnRGYW1pbHkyXSkge1xuICAgICAgZm9udEZhbWlsaWVzLnB1c2goZm9udEZhbWlseTIpO1xuICAgICAgZGVkdXBlW2ZvbnRGYW1pbHkyXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGZvbnRGYW1pbHkpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb250RmFtaWx5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHlbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkpO1xuICB9XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgY29uc3QgZm9udEZhbWlseTIgPSBtYXRjaC5zcGxpdChcIjpcIilbMV0udHJpbSgpO1xuICAgICAgYWRkRm9udEZhbWlseShmb250RmFtaWx5Mik7XG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBpIGluIHN0eWxlLnRhZ1N0eWxlcykge1xuICAgIGNvbnN0IGZvbnRGYW1pbHkyID0gc3R5bGUudGFnU3R5bGVzW2ldLmZvbnRGYW1pbHk7XG4gICAgYWRkRm9udEZhbWlseShmb250RmFtaWx5Mik7XG4gIH1cbiAgcmV0dXJuIGZvbnRGYW1pbGllcztcbn1cblxuZXhwb3J0IHsgZXh0cmFjdEZvbnRGYW1pbGllcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdEZvbnRGYW1pbGllcy5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmFzeW5jIGZ1bmN0aW9uIGxvYWRGb250QXNCYXNlNjQodXJsKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgRE9NQWRhcHRlci5nZXQoKS5mZXRjaCh1cmwpO1xuICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBjb25zdCBkYXRhU3JjID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICB9KTtcbiAgcmV0dXJuIGRhdGFTcmM7XG59XG5cbmV4cG9ydCB7IGxvYWRGb250QXNCYXNlNjQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRGb250QXNCYXNlNjQubWpzLm1hcFxuIiwiaW1wb3J0IHsgbG9hZEZvbnRBc0Jhc2U2NCB9IGZyb20gJy4vbG9hZEZvbnRBc0Jhc2U2NC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmFzeW5jIGZ1bmN0aW9uIGxvYWRGb250Q1NTKHN0eWxlLCB1cmwpIHtcbiAgY29uc3QgZGF0YVNyYyA9IGF3YWl0IGxvYWRGb250QXNCYXNlNjQodXJsKTtcbiAgcmV0dXJuIGBAZm9udC1mYWNlIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IFwiJHtzdHlsZS5mb250RmFtaWx5fVwiO1xuICAgICAgICBzcmM6IHVybCgnJHtkYXRhU3JjfScpO1xuICAgICAgICBmb250LXdlaWdodDogJHtzdHlsZS5mb250V2VpZ2h0fTtcbiAgICAgICAgZm9udC1zdHlsZTogJHtzdHlsZS5mb250U3R5bGV9O1xuICAgIH1gO1xufVxuXG5leHBvcnQgeyBsb2FkRm9udENTUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEZvbnRDU1MubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvY2FjaGUvQ2FjaGUubWpzJztcbmltcG9ydCB7IEZvbnRTdHlsZVByb21pc2VDYWNoZSwgSFRNTFRleHRTeXN0ZW0gfSBmcm9tICcuLi9IVE1MVGV4dFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgbG9hZEZvbnRDU1MgfSBmcm9tICcuL2xvYWRGb250Q1NTLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuYXN5bmMgZnVuY3Rpb24gZ2V0Rm9udENzcyhmb250RmFtaWxpZXMsIHN0eWxlKSB7XG4gIGNvbnN0IGZvbnRQcm9taXNlcyA9IGZvbnRGYW1pbGllcy5maWx0ZXIoKGZvbnRGYW1pbHkpID0+IENhY2hlLmhhcyhmb250RmFtaWx5KSkubWFwKChmb250RmFtaWx5LCBpKSA9PiB7XG4gICAgaWYgKCFGb250U3R5bGVQcm9taXNlQ2FjaGUuaGFzKGZvbnRGYW1pbHkpKSB7XG4gICAgICBjb25zdCB7IHVybCB9ID0gQ2FjaGUuZ2V0KGZvbnRGYW1pbHkpO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgRm9udFN0eWxlUHJvbWlzZUNhY2hlLnNldChmb250RmFtaWx5LCBsb2FkRm9udENTUyhzdHlsZSwgdXJsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBGb250U3R5bGVQcm9taXNlQ2FjaGUuc2V0KGZvbnRGYW1pbHksIGxvYWRGb250Q1NTKHtcbiAgICAgICAgICAuLi5IVE1MVGV4dFN5c3RlbS5kZWZhdWx0Rm9udE9wdGlvbnMsXG4gICAgICAgICAgZm9udEZhbWlseVxuICAgICAgICB9LCB1cmwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZvbnRTdHlsZVByb21pc2VDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gIH0pO1xuICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKGZvbnRQcm9taXNlcykpLmpvaW4oXCJcXG5cIik7XG59XG5cbmV4cG9ydCB7IGdldEZvbnRDc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEZvbnRDc3MubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRTVkdVcmwodGV4dCwgc3R5bGUsIHJlc29sdXRpb24sIGZvbnRDU1MsIGh0bWxUZXh0RGF0YSkge1xuICBjb25zdCB7IGRvbUVsZW1lbnQsIHN0eWxlRWxlbWVudCwgc3ZnUm9vdCB9ID0gaHRtbFRleHREYXRhO1xuICBkb21FbGVtZW50LmlubmVySFRNTCA9IGA8c3R5bGU+JHtzdHlsZS5jc3NTdHlsZX08L3N0eWxlPjxkaXY+JHt0ZXh0fTwvZGl2PmA7XG4gIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHRyYW5zZm9ybTogc2NhbGUoJHtyZXNvbHV0aW9ufSk7dHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7IGRpc3BsYXk6IGlubGluZS1ibG9ja2ApO1xuICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBmb250Q1NTO1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGh0bWxUZXh0RGF0YS5pbWFnZTtcbiAgc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aC50b1N0cmluZygpKTtcbiAgc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0LnRvU3RyaW5nKCkpO1xuICByZXR1cm4gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmdSb290KTtcbn1cblxuZXhwb3J0IHsgZ2V0U1ZHVXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRTVkdVcmwubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ2FudmFzUG9vbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZShpbWFnZSwgcmVzb2x1dGlvbikge1xuICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dChcbiAgICBpbWFnZS53aWR0aCxcbiAgICBpbWFnZS5oZWlnaHQsXG4gICAgcmVzb2x1dGlvblxuICApO1xuICBjb25zdCB7IGNvbnRleHQgfSA9IGNhbnZhc0FuZENvbnRleHQ7XG4gIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gIENhbnZhc1Bvb2wucmV0dXJuQ2FudmFzQW5kQ29udGV4dChjYW52YXNBbmRDb250ZXh0KTtcbiAgcmV0dXJuIGNhbnZhc0FuZENvbnRleHQuY2FudmFzO1xufVxuXG5leHBvcnQgeyBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGxvYWRTVkdJbWFnZShpbWFnZSwgdXJsLCBkZWxheSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlMikgPT4gc2V0VGltZW91dChyZXNvbHZlMiwgMTAwKSk7XG4gICAgfVxuICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGltYWdlLnNyYyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGY4LCR7ZW5jb2RlVVJJQ29tcG9uZW50KHVybCl9YDtcbiAgICBpbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBsb2FkU1ZHSW1hZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRTVkdJbWFnZS5tanMubWFwXG4iLCJpbXBvcnQgeyBDYW52YXNUZXh0TWV0cmljcyB9IGZyb20gJy4uLy4uL3RleHQvY2FudmFzL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5pbXBvcnQgeyBIVE1MVGV4dFJlbmRlckRhdGEgfSBmcm9tICcuLi9IVE1MVGV4dFN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCB0ZW1wSFRNTFRleHRSZW5kZXJEYXRhO1xuZnVuY3Rpb24gbWVhc3VyZUh0bWxUZXh0KHRleHQsIHN0eWxlLCBmb250U3R5bGVDU1MsIGh0bWxUZXh0UmVuZGVyRGF0YSkge1xuICBodG1sVGV4dFJlbmRlckRhdGEgPSBodG1sVGV4dFJlbmRlckRhdGEgfHwgdGVtcEhUTUxUZXh0UmVuZGVyRGF0YSB8fCAodGVtcEhUTUxUZXh0UmVuZGVyRGF0YSA9IG5ldyBIVE1MVGV4dFJlbmRlckRhdGEoKSk7XG4gIGNvbnN0IHsgZG9tRWxlbWVudCwgc3R5bGVFbGVtZW50LCBzdmdSb290IH0gPSBodG1sVGV4dFJlbmRlckRhdGE7XG4gIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0gYDxzdHlsZT4ke3N0eWxlLmNzc1N0eWxlfTwvc3R5bGU+PGRpdj4ke3RleHR9PC9kaXY+YDtcbiAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2tcIik7XG4gIGlmIChmb250U3R5bGVDU1MpIHtcbiAgICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBmb250U3R5bGVDU1M7XG4gIH1cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmdSb290KTtcbiAgY29uc3QgY29udGVudEJvdW5kcyA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHN2Z1Jvb3QucmVtb3ZlKCk7XG4gIGNvbnN0IGRlc2NlbmRlclBhZGRpbmcgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlRm9udChzdHlsZS5mb250U3R5bGUpLmRlc2NlbnQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNvbnRlbnRCb3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBjb250ZW50Qm91bmRzLmhlaWdodCArIGRlc2NlbmRlclBhZGRpbmdcbiAgfTtcbn1cblxuZXhwb3J0IHsgbWVhc3VyZUh0bWxUZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWFzdXJlSHRtbFRleHQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBpc1NhZmFyaSB9IGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXIvaXNTYWZhcmkubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfSBmcm9tICcuLi90ZXh0L3V0aWxzL2dldFBvMlRleHR1cmVGcm9tU291cmNlLm1qcyc7XG5pbXBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH0gZnJvbSAnLi91dGlscy9leHRyYWN0Rm9udEZhbWlsaWVzLm1qcyc7XG5pbXBvcnQgeyBnZXRGb250Q3NzIH0gZnJvbSAnLi91dGlscy9nZXRGb250Q3NzLm1qcyc7XG5pbXBvcnQgeyBnZXRTVkdVcmwgfSBmcm9tICcuL3V0aWxzL2dldFNWR1VybC5tanMnO1xuaW1wb3J0IHsgZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlIH0gZnJvbSAnLi91dGlscy9nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzJztcbmltcG9ydCB7IGxvYWRTVkdJbWFnZSB9IGZyb20gJy4vdXRpbHMvbG9hZFNWR0ltYWdlLm1qcyc7XG5pbXBvcnQgeyBtZWFzdXJlSHRtbFRleHQgfSBmcm9tICcuL3V0aWxzL21lYXN1cmVIdG1sVGV4dC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IG5zc3ZnID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY29uc3QgbnN4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuY29uc3QgRm9udFN0eWxlUHJvbWlzZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmNsYXNzIEhUTUxUZXh0UmVuZGVyRGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3ZnUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3N2ZywgXCJzdmdcIik7XG4gICAgdGhpcy5mb3JlaWduT2JqZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zc3ZnLCBcImZvcmVpZ25PYmplY3RcIik7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zeGh0bWwsIFwiZGl2XCIpO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zeGh0bWwsIFwic3R5bGVcIik7XG4gICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGNvbnN0IHsgZm9yZWlnbk9iamVjdCwgc3ZnUm9vdCwgc3R5bGVFbGVtZW50LCBkb21FbGVtZW50IH0gPSB0aGlzO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxMDAwMFwiKTtcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjEwMDAwXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIHN2Z1Jvb3QuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIGZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQoZG9tRWxlbWVudCk7XG4gIH1cbn1cbmNsYXNzIEhUTUxUZXh0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fY3JlYXRlQ2FudmFzID0gcmVuZGVyZXIudHlwZSA9PT0gUmVuZGVyZXJUeXBlLldFQkdQVTtcbiAgfVxuICBnZXRUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVpbGRUZXh0dXJlUHJvbWlzZShcbiAgICAgIG9wdGlvbnMudGV4dCxcbiAgICAgIG9wdGlvbnMucmVzb2x1dGlvbixcbiAgICAgIG9wdGlvbnMuc3R5bGVcbiAgICApO1xuICB9XG4gIGdldE1hbmFnZWRUZXh0dXJlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlLCB0ZXh0S2V5KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldKSB7XG4gICAgICB0aGlzLl9pbmNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9idWlsZFRleHR1cmVQcm9taXNlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlKS50aGVuKCh0ZXh0dXJlKSA9PiB7XG4gICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0ge1xuICAgICAgdGV4dHVyZTogbnVsbCxcbiAgICAgIHByb21pc2UsXG4gICAgICB1c2FnZUNvdW50OiAxXG4gICAgfTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBfYnVpbGRUZXh0dXJlUHJvbWlzZSh0ZXh0LCByZXNvbHV0aW9uLCBzdHlsZSkge1xuICAgIGNvbnN0IGh0bWxUZXh0RGF0YSA9IEJpZ1Bvb2wuZ2V0KEhUTUxUZXh0UmVuZGVyRGF0YSk7XG4gICAgY29uc3QgZm9udEZhbWlsaWVzID0gZXh0cmFjdEZvbnRGYW1pbGllcyh0ZXh0LCBzdHlsZSk7XG4gICAgY29uc3QgZm9udENTUyA9IGF3YWl0IGdldEZvbnRDc3MoZm9udEZhbWlsaWVzLCBzdHlsZSk7XG4gICAgY29uc3QgbWVhc3VyZWQgPSBtZWFzdXJlSHRtbFRleHQodGV4dCwgc3R5bGUsIGZvbnRDU1MsIGh0bWxUZXh0RGF0YSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLndpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQuaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGltYWdlID0gaHRtbFRleHREYXRhLmltYWdlO1xuICAgIGltYWdlLndpZHRoID0gd2lkdGggfCAwO1xuICAgIGltYWdlLmhlaWdodCA9IGhlaWdodCB8IDA7XG4gICAgY29uc3Qgc3ZnVVJMID0gZ2V0U1ZHVXJsKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBmb250Q1NTLCBodG1sVGV4dERhdGEpO1xuICAgIGF3YWl0IGxvYWRTVkdJbWFnZShpbWFnZSwgc3ZnVVJMLCBpc1NhZmFyaSgpICYmIGZvbnRGYW1pbGllcy5sZW5ndGggPiAwKTtcbiAgICBsZXQgcmVzb3VyY2UgPSBpbWFnZTtcbiAgICBpZiAodGhpcy5fY3JlYXRlQ2FudmFzKSB7XG4gICAgICByZXNvdXJjZSA9IGdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZShpbWFnZSwgcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZShyZXNvdXJjZSwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgaWYgKHRoaXMuX2NyZWF0ZUNhbnZhcykge1xuICAgICAgdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5pbml0U291cmNlKHRleHR1cmUuc291cmNlKTtcbiAgICB9XG4gICAgQmlnUG9vbC5yZXR1cm4oaHRtbFRleHREYXRhKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICBfaW5jcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udXNhZ2VDb3VudCsrO1xuICB9XG4gIGRlY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIGNvbnN0IGFjdGl2ZVRleHR1cmUgPSB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XTtcbiAgICBpZiAoIWFjdGl2ZVRleHR1cmUpXG4gICAgICByZXR1cm47XG4gICAgYWN0aXZlVGV4dHVyZS51c2FnZUNvdW50LS07XG4gICAgaWYgKGFjdGl2ZVRleHR1cmUudXNhZ2VDb3VudCA9PT0gMCkge1xuICAgICAgaWYgKGFjdGl2ZVRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9jbGVhblVwKGFjdGl2ZVRleHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlVGV4dHVyZS5wcm9taXNlLnRoZW4oKHRleHR1cmUpID0+IHtcbiAgICAgICAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICAgIHRoaXMuX2NsZWFuVXAoYWN0aXZlVGV4dHVyZSk7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICB3YXJuKFwiSFRNTFRleHRTeXN0ZW06IEZhaWxlZCB0byBjbGVhbiB0ZXh0dXJlXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgX2NsZWFuVXAoYWN0aXZlVGV4dHVyZSkge1xuICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYWN0aXZlVGV4dHVyZS50ZXh0dXJlKTtcbiAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUuc291cmNlLnJlc291cmNlID0gbnVsbDtcbiAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUuc291cmNlLnVwbG9hZE1ldGhvZElkID0gXCJ1bmtub3duXCI7XG4gIH1cbiAgZ2V0UmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS51c2FnZUNvdW50O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXMgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuSFRNTFRleHRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbVxuICBdLFxuICBuYW1lOiBcImh0bWxUZXh0XCJcbn07XG5IVE1MVGV4dFN5c3RlbS5kZWZhdWx0Rm9udE9wdGlvbnMgPSB7XG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiXG59O1xuXG5leHBvcnQgeyBGb250U3R5bGVQcm9taXNlQ2FjaGUsIEhUTUxUZXh0UmVuZGVyRGF0YSwgSFRNTFRleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEhUTUxUZXh0UGlwZSB9IGZyb20gJy4vSFRNTFRleHRQaXBlLm1qcyc7XG5pbXBvcnQgeyBIVE1MVGV4dFN5c3RlbSB9IGZyb20gJy4vSFRNTFRleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChIVE1MVGV4dFN5c3RlbSk7XG5leHRlbnNpb25zLmFkZChIVE1MVGV4dFBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3115\n')},3374:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ CanvasTextMetrics)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);\n\n\n\n"use strict";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = " ", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = (0,_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .fontStringFromTextStyle */ .M)(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object\'s wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext("2d", contextSettings);\n    let width = 0;\n    let line = "";\n    let lines = "";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = "";\n          width = 0;\n          continue;\n        }\n        token = " ";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== "") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = "";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = "";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = "";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== "number") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === "normal" || whiteSpace === "pre-line";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === "normal";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== "string") {\n      return "";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = "";\n    if (typeof text !== "string") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== "") {\n          tokens.push(token);\n          token = "";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== "") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = "") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext("2d", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n      } catch (ex) {\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = "|\\xC9q\\xC5";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = "M";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `\'\\u0065\\u0301\'`, letter e with acute)\n * or emojis with modifiers (e.g. `\'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don\'t support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won\'t use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === "function") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome\'s new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\n\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM3NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUNnQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5RUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLGVBQWU7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQixvR0FBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUVBQVU7QUFDM0IsUUFBUTtBQUNSLGlCQUFpQix5RUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELGtCQUFrQiwrQ0FBK0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRNZXRyaWNzLm1qcz83MzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBmb250U3RyaW5nRnJvbVRleHRTdHlsZSB9IGZyb20gJy4vdXRpbHMvZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjb250ZXh0U2V0dGluZ3MgPSB7XG4gIC8vIFRleHRNZXRyaWNzIHJlcXVpcmVzIGdldEltYWdlRGF0YSByZWFkYmFjayBmb3IgbWVhc3VyaW5nIGZvbnRzLlxuICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbn07XG5jb25zdCBfQ2FudmFzVGV4dE1ldHJpY3MgPSBjbGFzcyBfQ2FudmFzVGV4dE1ldHJpY3Mge1xuICAvKipcbiAgICogQ2hlY2tpbmcgdGhhdCB3ZSBjYW4gdXNlIG1vZGVybiBjYW52YXMgMkQgQVBJLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIGFuIHVuc3RhYmxlIEFQSSwgQ2hyb21lIDwgOTQgdXNlIGB0ZXh0TGV0dGVyU3BhY2luZ2AsIGxhdGVyIHZlcnNpb25zIHVzZSBgbGV0dGVyU3BhY2luZ2AuXG4gICAqIEBzZWUgVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2xldHRlclNwYWNpbmdcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL29yaWdpbnRyaWFscy8jL3ZpZXdfdHJpYWwvMzU4NTk5MTIwMzI5Mzc1NzQ0MVxuICAgKi9cbiAgc3RhdGljIGdldCBleHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkKCkge1xuICAgIGxldCByZXN1bHQgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2V4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQ7XG4gICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBwcm90byA9IERPTUFkYXB0ZXIuZ2V0KCkuZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKCkucHJvdG90eXBlO1xuICAgICAgcmVzdWx0ID0gX0NhbnZhc1RleHRNZXRyaWNzLl9leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkID0gXCJsZXR0ZXJTcGFjaW5nXCIgaW4gcHJvdG8gfHwgXCJ0ZXh0TGV0dGVyU3BhY2luZ1wiIGluIHByb3RvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dCAtIHRoZSB0ZXh0IHRoYXQgd2FzIG1lYXN1cmVkXG4gICAqIEBwYXJhbSBzdHlsZSAtIHRoZSBzdHlsZSB0aGF0IHdhcyBtZWFzdXJlZFxuICAgKiBAcGFyYW0gd2lkdGggLSB0aGUgbWVhc3VyZWQgd2lkdGggb2YgdGhlIHRleHRcbiAgICogQHBhcmFtIGhlaWdodCAtIHRoZSBtZWFzdXJlZCBoZWlnaHQgb2YgdGhlIHRleHRcbiAgICogQHBhcmFtIGxpbmVzIC0gYW4gYXJyYXkgb2YgdGhlIGxpbmVzIG9mIHRleHQgYnJva2VuIGJ5IG5ldyBsaW5lcyBhbmQgd3JhcHBpbmcgaWYgc3BlY2lmaWVkIGluIHN0eWxlXG4gICAqIEBwYXJhbSBsaW5lV2lkdGhzIC0gYW4gYXJyYXkgb2YgdGhlIGxpbmUgd2lkdGhzIGZvciBlYWNoIGxpbmUgbWF0Y2hlZCB0byBgbGluZXNgXG4gICAqIEBwYXJhbSBsaW5lSGVpZ2h0IC0gdGhlIG1lYXN1cmVkIGxpbmUgaGVpZ2h0IGZvciB0aGlzIHN0eWxlXG4gICAqIEBwYXJhbSBtYXhMaW5lV2lkdGggLSB0aGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciBhbGwgbWVhc3VyZWQgbGluZXNcbiAgICogQHBhcmFtIHtGb250TWV0cmljc30gZm9udFByb3BlcnRpZXMgLSB0aGUgZm9udCBwcm9wZXJ0aWVzIG9iamVjdCBmcm9tIFRleHRNZXRyaWNzLm1lYXN1cmVGb250XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdHlsZSwgd2lkdGgsIGhlaWdodCwgbGluZXMsIGxpbmVXaWR0aHMsIGxpbmVIZWlnaHQsIG1heExpbmVXaWR0aCwgZm9udFByb3BlcnRpZXMpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICB0aGlzLm1heExpbmVXaWR0aCA9IG1heExpbmVXaWR0aDtcbiAgICB0aGlzLmZvbnRQcm9wZXJ0aWVzID0gZm9udFByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIE1lYXN1cmVzIHRoZSBzdXBwbGllZCBzdHJpbmcgb2YgdGV4dCBhbmQgcmV0dXJucyBhIFJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBtZWFzdXJlLlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgdGV4dCBzdHlsZSB0byB1c2UgZm9yIG1lYXN1cmluZ1xuICAgKiBAcGFyYW0gY2FudmFzIC0gb3B0aW9uYWwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY2FudmFzIHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICAgKiBAcGFyYW0gd29yZFdyYXBcbiAgICogQHJldHVybnMgTWVhc3VyZWQgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGV4dC5cbiAgICovXG4gIHN0YXRpYyBtZWFzdXJlVGV4dCh0ZXh0ID0gXCIgXCIsIHN0eWxlLCBjYW52YXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NhbnZhcywgd29yZFdyYXAgPSBzdHlsZS53b3JkV3JhcCkge1xuICAgIGNvbnN0IHRleHRLZXkgPSBgJHt0ZXh0fToke3N0eWxlLnN0eWxlS2V5fWA7XG4gICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5fbWVhc3VyZW1lbnRDYWNoZVt0ZXh0S2V5XSlcbiAgICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX21lYXN1cmVtZW50Q2FjaGVbdGV4dEtleV07XG4gICAgY29uc3QgZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBjb25zdCBmb250UHJvcGVydGllcyA9IF9DYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlRm9udChmb250KTtcbiAgICBpZiAoZm9udFByb3BlcnRpZXMuZm9udFNpemUgPT09IDApIHtcbiAgICAgIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplID0gc3R5bGUuZm9udFNpemU7XG4gICAgICBmb250UHJvcGVydGllcy5hc2NlbnQgPSBzdHlsZS5mb250U2l6ZTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IF9DYW52YXNUZXh0TWV0cmljcy5fX2NvbnRleHQ7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBvdXRwdXRUZXh0ID0gd29yZFdyYXAgPyBfQ2FudmFzVGV4dE1ldHJpY3MuX3dvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMpIDogdGV4dDtcbiAgICBjb25zdCBsaW5lcyA9IG91dHB1dFRleHQuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKTtcbiAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBfQ2FudmFzVGV4dE1ldHJpY3MuX21lYXN1cmVUZXh0KGxpbmVzW2ldLCBzdHlsZS5sZXR0ZXJTcGFjaW5nLCBjb250ZXh0KTtcbiAgICAgIGxpbmVXaWR0aHNbaV0gPSBsaW5lV2lkdGg7XG4gICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgfVxuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc3R5bGUuX3N0cm9rZT8ud2lkdGggfHwgMDtcbiAgICBsZXQgd2lkdGggPSBtYXhMaW5lV2lkdGggKyBzdHJva2VXaWR0aDtcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgd2lkdGggKz0gc3R5bGUuZHJvcFNoYWRvdy5kaXN0YW5jZTtcbiAgICB9XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQgfHwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHJva2VXaWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gTWF0aC5tYXgobGluZUhlaWdodCwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHJva2VXaWR0aCAqIDIpICsgKGxpbmVzLmxlbmd0aCAtIDEpICogKGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nKTtcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgaGVpZ2h0ICs9IHN0eWxlLmRyb3BTaGFkb3cuZGlzdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IG5ldyBfQ2FudmFzVGV4dE1ldHJpY3MoXG4gICAgICB0ZXh0LFxuICAgICAgc3R5bGUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxpbmVzLFxuICAgICAgbGluZVdpZHRocyxcbiAgICAgIGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nLFxuICAgICAgbWF4TGluZVdpZHRoLFxuICAgICAgZm9udFByb3BlcnRpZXNcbiAgICApO1xuICAgIHJldHVybiBtZWFzdXJlbWVudHM7XG4gIH1cbiAgc3RhdGljIF9tZWFzdXJlVGV4dCh0ZXh0LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSB7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbiAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIGlmICh1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgIHdpZHRoIC09IGxldHRlclNwYWNpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCArPSAoX0NhbnZhc1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyKHRleHQpLmxlbmd0aCAtIDEpICogbGV0dGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIG5ld2xpbmVzIHRvIGEgc3RyaW5nIHRvIGhhdmUgaXQgb3B0aW1hbGx5IGZpdCBpbnRvIHRoZSBob3Jpem9udGFsXG4gICAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHRleHQgLSBTdHJpbmcgdG8gYXBwbHkgd29yZCB3cmFwcGluZyB0b1xuICAgKiBAcGFyYW0gc3R5bGUgLSB0aGUgc3R5bGUgdG8gdXNlIHdoZW4gd3JhcHBpbmdcbiAgICogQHBhcmFtIGNhbnZhcyAtIG9wdGlvbmFsIHNwZWNpZmljYXRpb24gb2YgdGhlIGNhbnZhcyB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAgICogQHJldHVybnMgTmV3IHN0cmluZyB3aXRoIG5ldyBsaW5lcyBhcHBsaWVkIHdoZXJlIHJlcXVpcmVkXG4gICAqL1xuICBzdGF0aWMgX3dvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NhbnZhcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgbGV0IHdpZHRoID0gMDtcbiAgICBsZXQgbGluZSA9IFwiXCI7XG4gICAgbGV0IGxpbmVzID0gXCJcIjtcbiAgICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHsgbGV0dGVyU3BhY2luZywgd2hpdGVTcGFjZSB9ID0gc3R5bGU7XG4gICAgY29uc3QgY29sbGFwc2VTcGFjZXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NvbGxhcHNlU3BhY2VzKHdoaXRlU3BhY2UpO1xuICAgIGNvbnN0IGNvbGxhcHNlTmV3bGluZXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSk7XG4gICAgbGV0IGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgY29uc3Qgd29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgIGNvbnN0IHRva2VucyA9IF9DYW52YXNUZXh0TWV0cmljcy5fdG9rZW5pemUodGV4dCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuX2lzTmV3bGluZSh0b2tlbikpIHtcbiAgICAgICAgaWYgKCFjb2xsYXBzZU5ld2xpbmVzKSB7XG4gICAgICAgICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gXCIgXCI7XG4gICAgICB9XG4gICAgICBpZiAoY29sbGFwc2VTcGFjZXMpIHtcbiAgICAgICAgY29uc3QgY3VycklzQnJlYWtpbmdTcGFjZSA9IF9DYW52YXNUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pO1xuICAgICAgICBjb25zdCBsYXN0SXNCcmVha2luZ1NwYWNlID0gX0NhbnZhc1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShsaW5lW2xpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAoY3VycklzQnJlYWtpbmdTcGFjZSAmJiBsYXN0SXNCcmVha2luZ1NwYWNlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuV2lkdGggPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2dldEZyb21DYWNoZSh0b2tlbiwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgaWYgKHRva2VuV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgIGlmIChsaW5lICE9PSBcIlwiKSB7XG4gICAgICAgICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IF9DYW52YXNUZXh0TWV0cmljcy53b3JkV3JhcFNwbGl0KHRva2VuKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYXJhY3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gY2hhcmFjdGVyc1tqXTtcbiAgICAgICAgICAgIGxldCBsYXN0Q2hhciA9IGNoYXI7XG4gICAgICAgICAgICBsZXQgayA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyc1tqICsga10pIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyYWN0ZXJzW2ogKyBrXTtcbiAgICAgICAgICAgICAgaWYgKCFfQ2FudmFzVGV4dE1ldHJpY3MuY2FuQnJlYWtDaGFycyhsYXN0Q2hhciwgbmV4dENoYXIsIHRva2VuLCBqLCBzdHlsZS5icmVha1dvcmRzKSkge1xuICAgICAgICAgICAgICAgIGNoYXIgKz0gbmV4dENoYXI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdENoYXIgPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaiArPSBrIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlcldpZHRoID0gX0NhbnZhc1RleHRNZXRyaWNzLl9nZXRGcm9tQ2FjaGUoY2hhciwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNoYXJhY3RlcldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZSArPSBjaGFyO1xuICAgICAgICAgICAgd2lkdGggKz0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZSh0b2tlbiwgIWlzTGFzdFRva2VuKTtcbiAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5XaWR0aCArIHdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBsaW5lcyArPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2FkZExpbmUobGluZSk7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDAgfHwgIV9DYW52YXNUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pIHx8IGNhblByZXBlbmRTcGFjZXMpIHtcbiAgICAgICAgICBsaW5lICs9IHRva2VuO1xuICAgICAgICAgIHdpZHRoICs9IHRva2VuV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUsIGZhbHNlKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZpZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9nZ2luZyBlYWNoIGxpbmUgYWRkZWQgZHVyaW5nIHRoZSB3b3JkV3JhcCBtZXRob2QuXG4gICAqIEBwYXJhbSBsaW5lICAgIC0gVGhlIGxpbmUgb2YgdGV4dCB0byBhZGRcbiAgICogQHBhcmFtIG5ld0xpbmUgLSBBZGQgbmV3IGxpbmUgY2hhcmFjdGVyIHRvIGVuZFxuICAgKiBAcmV0dXJucyBBIGZvcm1hdHRlZCBsaW5lXG4gICAqL1xuICBzdGF0aWMgX2FkZExpbmUobGluZSwgbmV3TGluZSA9IHRydWUpIHtcbiAgICBsaW5lID0gX0NhbnZhc1RleHRNZXRyaWNzLl90cmltUmlnaHQobGluZSk7XG4gICAgbGluZSA9IG5ld0xpbmUgPyBgJHtsaW5lfVxuYCA6IGxpbmU7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgJiBzZXRzIHRoZSB3aWR0aHMgb2YgY2FsY3VsYXRlZCBjaGFyYWN0ZXJzIGluIGEgY2FjaGUgb2JqZWN0XG4gICAqIEBwYXJhbSBrZXkgICAgICAgICAgICAtIFRoZSBrZXlcbiAgICogQHBhcmFtIGxldHRlclNwYWNpbmcgIC0gVGhlIGxldHRlciBzcGFjaW5nXG4gICAqIEBwYXJhbSBjYWNoZSAgICAgICAgICAtIFRoZSBjYWNoZVxuICAgKiBAcGFyYW0gY29udGV4dCAgICAgICAgLSBUaGUgY2FudmFzIGNvbnRleHRcbiAgICogQHJldHVybnMgVGhlIGZyb20gY2FjaGUuXG4gICAqL1xuICBzdGF0aWMgX2dldEZyb21DYWNoZShrZXksIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KSB7XG4gICAgbGV0IHdpZHRoID0gY2FjaGVba2V5XTtcbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB3aWR0aCA9IF9DYW52YXNUZXh0TWV0cmljcy5fbWVhc3VyZVRleHQoa2V5LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSArIGxldHRlclNwYWNpbmc7XG4gICAgICBjYWNoZVtrZXldID0gd2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBjb2xsYXBzZSBicmVha2luZyBzcGFjZXMuXG4gICAqIEBwYXJhbSB3aGl0ZVNwYWNlIC0gVGhlIFRleHRTdHlsZSBwcm9wZXJ0eSB3aGl0ZVNwYWNlXG4gICAqIEByZXR1cm5zIFNob3VsZCBjb2xsYXBzZVxuICAgKi9cbiAgc3RhdGljIF9jb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09IFwibm9ybWFsXCIgfHwgd2hpdGVTcGFjZSA9PT0gXCJwcmUtbGluZVwiO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ld0xpbmUgY2hhcnMuXG4gICAqIEBwYXJhbSB3aGl0ZVNwYWNlIC0gVGhlIHdoaXRlIHNwYWNlXG4gICAqIEByZXR1cm5zIHNob3VsZCBjb2xsYXBzZVxuICAgKi9cbiAgc3RhdGljIF9jb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpIHtcbiAgICByZXR1cm4gd2hpdGVTcGFjZSA9PT0gXCJub3JtYWxcIjtcbiAgfVxuICAvKipcbiAgICogVHJpbXMgYnJlYWtpbmcgd2hpdGVzcGFjZXMgZnJvbSBzdHJpbmcuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHRcbiAgICogQHJldHVybnMgVHJpbW1lZCBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyBfdHJpbVJpZ2h0KHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICBpZiAoIV9DYW52YXNUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhcikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBuZXdsaW5lLlxuICAgKiBAcGFyYW0gY2hhciAtIFRoZSBjaGFyYWN0ZXJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBuZXdsaW5lLCBGYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgX2lzTmV3bGluZShjaGFyKSB7XG4gICAgaWYgKHR5cGVvZiBjaGFyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX25ld2xpbmVzLmluY2x1ZGVzKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgY2hhciBpcyBhIGJyZWFraW5nIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIEl0IGFsbG93cyBvbmUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgY2hhciBzaG91bGQgYmUgYSBicmVha2luZyB3aGl0ZXNwYWNlXG4gICAqIEZvciBleGFtcGxlIGNlcnRhaW4gY2hhcmFjdGVycyBpbiBDSksgbGFuZ3Mgb3IgbnVtYmVycy5cbiAgICogSXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgKiBAcGFyYW0gY2hhciAtIFRoZSBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIFtfbmV4dENoYXJdIC0gVGhlIG5leHQgY2hhcmFjdGVyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgd2hpdGVzcGFjZSwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGlzQnJlYWtpbmdTcGFjZShjaGFyLCBfbmV4dENoYXIpIHtcbiAgICBpZiAodHlwZW9mIGNoYXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fYnJlYWtpbmdTcGFjZXMuaW5jbHVkZXMoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXRzIGEgc3RyaW5nIGludG8gd29yZHMsIGJyZWFraW5nLXNwYWNlcyBhbmQgbmV3TGluZSBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHRcbiAgICogQHJldHVybnMgQSB0b2tlbml6ZWQgYXJyYXlcbiAgICovXG4gIHN0YXRpYyBfdG9rZW5pemUodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGxldCB0b2tlbiA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuICAgICAgY29uc3QgbmV4dENoYXIgPSB0ZXh0W2kgKyAxXTtcbiAgICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIsIG5leHRDaGFyKSB8fCBfQ2FudmFzVGV4dE1ldHJpY3MuX2lzTmV3bGluZShjaGFyKSkge1xuICAgICAgICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgdG9rZW4gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKGNoYXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRva2VuICs9IGNoYXI7XG4gICAgfVxuICAgIGlmICh0b2tlbiAhPT0gXCJcIikge1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBoZWxwZXIgbWV0aG9kIHVzZWQgaW50ZXJuYWxseSBieSBUZXh0TWV0cmljcywgZXhwb3NlZCB0byBhbGxvdyBjdXN0b21pemluZyB0aGUgY2xhc3MncyBiZWhhdmlvci5cbiAgICpcbiAgICogSXQgYWxsb3dzIG9uZSB0byBjdXN0b21pc2Ugd2hpY2ggd29yZHMgc2hvdWxkIGJyZWFrXG4gICAqIEV4YW1wbGVzIGFyZSBpZiB0aGUgdG9rZW4gaXMgQ0pLIG9yIG51bWJlcnMuXG4gICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHBhcmFtIF90b2tlbiAtIFRoZSB0b2tlblxuICAgKiBAcGFyYW0gYnJlYWtXb3JkcyAtIFRoZSBzdHlsZSBhdHRyIGJyZWFrIHdvcmRzXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcbiAgICovXG4gIHN0YXRpYyBjYW5CcmVha1dvcmRzKF90b2tlbiwgYnJlYWtXb3Jkcykge1xuICAgIHJldHVybiBicmVha1dvcmRzO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBoZWxwZXIgbWV0aG9kIHVzZWQgaW50ZXJuYWxseSBieSBUZXh0TWV0cmljcywgZXhwb3NlZCB0byBhbGxvdyBjdXN0b21pemluZyB0aGUgY2xhc3MncyBiZWhhdmlvci5cbiAgICpcbiAgICogSXQgYWxsb3dzIG9uZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIHBhaXIgb2YgY2hhcmFjdGVyc1xuICAgKiBzaG91bGQgYmUgYnJva2VuIGJ5IG5ld2xpbmVzXG4gICAqIEZvciBleGFtcGxlIGNlcnRhaW4gY2hhcmFjdGVycyBpbiBDSksgbGFuZ3Mgb3IgbnVtYmVycy5cbiAgICogSXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgKiBAcGFyYW0gX2NoYXIgLSBUaGUgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBfbmV4dENoYXIgLSBUaGUgbmV4dCBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIF90b2tlbiAtIFRoZSB0b2tlbi93b3JkIHRoZSBjaGFyYWN0ZXJzIGFyZSBmcm9tXG4gICAqIEBwYXJhbSBfaW5kZXggLSBUaGUgaW5kZXggaW4gdGhlIHRva2VuIG9mIHRoZSBjaGFyXG4gICAqIEBwYXJhbSBfYnJlYWtXb3JkcyAtIFRoZSBzdHlsZSBhdHRyIGJyZWFrIHdvcmRzXG4gICAqIEByZXR1cm5zIHdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcbiAgICovXG4gIHN0YXRpYyBjYW5CcmVha0NoYXJzKF9jaGFyLCBfbmV4dENoYXIsIF90b2tlbiwgX2luZGV4LCBfYnJlYWtXb3Jkcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBoZWxwZXIgbWV0aG9kIHVzZWQgaW50ZXJuYWxseSBieSBUZXh0TWV0cmljcywgZXhwb3NlZCB0byBhbGxvdyBjdXN0b21pemluZyB0aGUgY2xhc3MncyBiZWhhdmlvci5cbiAgICpcbiAgICogSXQgaXMgY2FsbGVkIHdoZW4gYSB0b2tlbiAodXN1YWxseSBhIHdvcmQpIGhhcyB0byBiZSBzcGxpdCBpbnRvIHNlcGFyYXRlIHBpZWNlc1xuICAgKiBpbiBvcmRlciB0byBkZXRlcm1pbmUgdGhlIHBvaW50IHRvIGJyZWFrIGEgd29yZC5cbiAgICogSXQgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHRva2VuIC0gVGhlIHRva2VuIHRvIHNwbGl0XG4gICAqIEByZXR1cm5zIFRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB0b2tlblxuICAgKiBAc2VlIENhbnZhc1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyXG4gICAqL1xuICBzdGF0aWMgd29yZFdyYXBTcGxpdCh0b2tlbikge1xuICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIodG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udC1zdHlsZVxuICAgKiBAcGFyYW0gZm9udCAtIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN0eWxlIG9mIHRoZSBmb250XG4gICAqIEByZXR1cm5zIEZvbnQgcHJvcGVydGllcyBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBtZWFzdXJlRm9udChmb250KSB7XG4gICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5fZm9udHNbZm9udF0pIHtcbiAgICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gX0NhbnZhc1RleHRNZXRyaWNzLl9jb250ZXh0O1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29uc3QgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQoX0NhbnZhc1RleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HICsgX0NhbnZhc1RleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgIGFzY2VudDogbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgIGRlc2NlbnQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgZm9udFNpemU6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudFxuICAgIH07XG4gICAgX0NhbnZhc1RleHRNZXRyaWNzLl9mb250c1tmb250XSA9IHByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGZvbnQgbWV0cmljcyBpbiBtZXRyaWNzIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZvbnRdIC0gZm9udCBuYW1lLiBJZiBmb250IG5hbWUgbm90IHNldCB0aGVuIGNsZWFyIGNhY2hlIGZvciBhbGwgZm9udHMuXG4gICAqL1xuICBzdGF0aWMgY2xlYXJNZXRyaWNzKGZvbnQgPSBcIlwiKSB7XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIGRlbGV0ZSBfQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWNoZWQgY2FudmFzIGVsZW1lbnQgZm9yIG1lYXN1cmluZyB0ZXh0XG4gICAqIFRPRE86IHRoaXMgc2hvdWxkIGJlIHByaXZhdGUsIGJ1dCBpc24ndCBiZWNhdXNlIG9mIGJhY2t3YXJkIGNvbXBhdCwgd2lsbCBmaXggbGF0ZXIuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBnZXQgX2NhbnZhcygpIHtcbiAgICBpZiAoIV9DYW52YXNUZXh0TWV0cmljcy5fX2NhbnZhcykge1xuICAgICAgbGV0IGNhbnZhcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKTtcbiAgICAgICAgaWYgKGNvbnRleHQ/Lm1lYXN1cmVUZXh0KSB7XG4gICAgICAgICAgX0NhbnZhc1RleHRNZXRyaWNzLl9fY2FudmFzID0gYztcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxMDtcbiAgICAgIF9DYW52YXNUZXh0TWV0cmljcy5fX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fX2NhbnZhcztcbiAgfVxuICAvKipcbiAgICogVE9ETzogdGhpcyBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IGlzbid0IGJlY2F1c2Ugb2YgYmFja3dhcmQgY29tcGF0LCB3aWxsIGZpeCBsYXRlci5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGdldCBfY29udGV4dCgpIHtcbiAgICBpZiAoIV9DYW52YXNUZXh0TWV0cmljcy5fX2NvbnRleHQpIHtcbiAgICAgIF9DYW52YXNUZXh0TWV0cmljcy5fX2NvbnRleHQgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fX2NvbnRleHQ7XG4gIH1cbn07XG4vKipcbiAqIFN0cmluZyB1c2VkIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLlxuICogVGhlc2UgY2hhcmFjdGVycyBhcmUgYWxsIHRhbGwgdG8gaGVscCBjYWxjdWxhdGUgdGhlIGhlaWdodCByZXF1aXJlZCBmb3IgdGV4dC5cbiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HID0gXCJ8XFx4QzlxXFx4QzVcIjtcbi8qKiBCYXNlbGluZSBzeW1ib2wgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MID0gXCJNXCI7XG4vKiogQmFzZWxpbmUgbXVsdGlwbGllciBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5CQVNFTElORV9NVUxUSVBMSUVSID0gMS40O1xuLyoqIEhlaWdodCBtdWx0aXBsaWVyIGZvciBzZXR0aW5nIGhlaWdodCBvZiBjYW52YXMgdG8gY2FsY3VsYXRlIGZvbnQgbWV0cmljcy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5IRUlHSFRfTVVMVElQTElFUiA9IDI7XG4vKipcbiAqIEEgVW5pY29kZSBcImNoYXJhY3RlclwiLCBvciBcImdyYXBoZW1lIGNsdXN0ZXJcIiwgY2FuIGJlIGNvbXBvc2VkIG9mIG11bHRpcGxlIFVuaWNvZGUgY29kZSBwb2ludHMsXG4gKiBzdWNoIGFzIGxldHRlcnMgd2l0aCBkaWFjcml0aWNhbCBtYXJrcyAoZS5nLiBgJ1xcdTAwNjVcXHUwMzAxJ2AsIGxldHRlciBlIHdpdGggYWN1dGUpXG4gKiBvciBlbW9qaXMgd2l0aCBtb2RpZmllcnMgKGUuZy4gYCdcXHVEODNFXFx1REREMVxcdTIwMERcXHVEODNEXFx1RENCQidgLCB0ZWNobm9sb2dpc3QpLlxuICogVGhlIG5ldyBgSW50bC5TZWdtZW50ZXJgIEFQSSBpbiBFUzIwMjIgY2FuIHNwbGl0IHRoZSBzdHJpbmcgaW50byBncmFwaGVtZSBjbHVzdGVycyBjb3JyZWN0bHkuIElmIGl0IGlzIG5vdCBhdmFpbGFibGUsXG4gKiBQaXhpSlMgd2lsbCBmYWxsYmFjayB0byB1c2UgdGhlIGl0ZXJhdG9yIG9mIFN0cmluZywgd2hpY2ggY2FuIG9ubHkgc3BpbHQgdGhlIHN0cmluZyBpbnRvIGNvZGUgcG9pbnRzLlxuICogSWYgeW91IHdhbnQgdG8gZ2V0IGZ1bGwgZnVuY3Rpb25hbGl0eSBpbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IGBJbnRsLlNlZ21lbnRlcmAgKHN1Y2ggYXMgRmlyZWZveCksXG4gKiB5b3UgY2FuIHVzZSBvdGhlciBsaWJyYXJpZXMgc3VjaCBhcyBbZ3JhcGhlbWUtc3BsaXR0ZXJde0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2dyYXBoZW1lLXNwbGl0dGVyfVxuICogb3IgW2dyYXBoZW1lcl17QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ3JhcGhlbWVyfSB0byBjcmVhdGUgYSBwb2x5ZmlsbC4gU2luY2UgdGhlc2UgbGlicmFyaWVzIGNhbiBiZVxuICogcmVsYXRpdmVseSBsYXJnZSBpbiBzaXplIHRvIGhhbmRsZSB2YXJpb3VzIFVuaWNvZGUgZ3JhcGhlbWUgY2x1c3RlcnMgcHJvcGVybHksIFBpeGlKUyB3b24ndCB1c2UgdGhlbSBkaXJlY3RseS5cbiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBJbnRsPy5TZWdtZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcigpO1xuICAgIHJldHVybiAocykgPT4gWy4uLnNlZ21lbnRlci5zZWdtZW50KHMpXS5tYXAoKHgpID0+IHguc2VnbWVudCk7XG4gIH1cbiAgcmV0dXJuIChzKSA9PiBbLi4uc107XG59KSgpO1xuLyoqXG4gKiBOZXcgcmVuZGVyaW5nIGJlaGF2aW9yIGZvciBsZXR0ZXItc3BhY2luZyB3aGljaCB1c2VzIENocm9tZSdzIG5ldyBuYXRpdmUgQVBJLiBUaGlzIHdpbGxcbiAqIGxlYWQgdG8gbW9yZSBhY2N1cmF0ZSBsZXR0ZXItc3BhY2luZyByZXN1bHRzIGJlY2F1c2UgaXQgZG9lcyBub3QgdHJ5IHRvIG1hbnVhbGx5IGRyYXdcbiAqIGVhY2ggY2hhcmFjdGVyLiBIb3dldmVyLCB0aGlzIENocm9tZSBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgbm90IHNlcnZlIGFsbCBjYXNlcyB5ZXQuXG4gKiBAc2VlIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWRcbiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbi8qKiBDYWNoZSBvZiB7QHNlZSBUZXh0TWV0cmljcy5Gb250TWV0cmljc30gb2JqZWN0cy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcbi8qKiBDYWNoZSBvZiBuZXcgbGluZSBjaGFycy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5fbmV3bGluZXMgPSBbXG4gIDEwLFxuICAvLyBsaW5lIGZlZWRcbiAgMTNcbiAgLy8gY2FycmlhZ2UgcmV0dXJuXG5dO1xuLyoqIENhY2hlIG9mIGJyZWFraW5nIHNwYWNlcy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5fYnJlYWtpbmdTcGFjZXMgPSBbXG4gIDksXG4gIC8vIGNoYXJhY3RlciB0YWJ1bGF0aW9uXG4gIDMyLFxuICAvLyBzcGFjZVxuICA4MTkyLFxuICAvLyBlbiBxdWFkXG4gIDgxOTMsXG4gIC8vIGVtIHF1YWRcbiAgODE5NCxcbiAgLy8gZW4gc3BhY2VcbiAgODE5NSxcbiAgLy8gZW0gc3BhY2VcbiAgODE5NixcbiAgLy8gdGhyZWUtcGVyLWVtIHNwYWNlXG4gIDgxOTcsXG4gIC8vIGZvdXItcGVyLWVtIHNwYWNlXG4gIDgxOTgsXG4gIC8vIHNpeC1wZXItZW0gc3BhY2VcbiAgODIwMCxcbiAgLy8gcHVuY3R1YXRpb24gc3BhY2VcbiAgODIwMSxcbiAgLy8gdGhpbiBzcGFjZVxuICA4MjAyLFxuICAvLyBoYWlyIHNwYWNlXG4gIDgyODcsXG4gIC8vIG1lZGl1bSBtYXRoZW1hdGljYWwgc3BhY2VcbiAgMTIyODhcbiAgLy8gaWRlb2dyYXBoaWMgc3BhY2Vcbl07XG5fQ2FudmFzVGV4dE1ldHJpY3MuX21lYXN1cmVtZW50Q2FjaGUgPSB7fTtcbmxldCBDYW52YXNUZXh0TWV0cmljcyA9IF9DYW52YXNUZXh0TWV0cmljcztcblxuZXhwb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1RleHRNZXRyaWNzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3374\n')},13:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   M: () => (/* binding */ fontStringFromTextStyle)\n/* harmony export */ });\n\nconst genericFontFamilies = [\n  "serif",\n  "sans-serif",\n  "monospace",\n  "cursive",\n  "fantasy",\n  "system-ui"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(",");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\"\\\'])[^\\\'\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `"${fontFamily}"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;\n}\n\n\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLHVCQUF1QjtBQUNqSDs7QUFFbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9jYW52YXMvdXRpbHMvZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzPzYzOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBnZW5lcmljRm9udEZhbWlsaWVzID0gW1xuICBcInNlcmlmXCIsXG4gIFwic2Fucy1zZXJpZlwiLFxuICBcIm1vbm9zcGFjZVwiLFxuICBcImN1cnNpdmVcIixcbiAgXCJmYW50YXN5XCIsXG4gIFwic3lzdGVtLXVpXCJcbl07XG5mdW5jdGlvbiBmb250U3RyaW5nRnJvbVRleHRTdHlsZShzdHlsZSkge1xuICBjb25zdCBmb250U2l6ZVN0cmluZyA9IHR5cGVvZiBzdHlsZS5mb250U2l6ZSA9PT0gXCJudW1iZXJcIiA/IGAke3N0eWxlLmZvbnRTaXplfXB4YCA6IHN0eWxlLmZvbnRTaXplO1xuICBsZXQgZm9udEZhbWlsaWVzID0gc3R5bGUuZm9udEZhbWlseTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLmZvbnRGYW1pbHkpKSB7XG4gICAgZm9udEZhbWlsaWVzID0gc3R5bGUuZm9udEZhbWlseS5zcGxpdChcIixcIik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IGZvbnRGYW1pbGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBmb250RmFtaWx5ID0gZm9udEZhbWlsaWVzW2ldLnRyaW0oKTtcbiAgICBpZiAoIS8oW1xcXCJcXCddKVteXFwnXFxcIl0rXFwxLy50ZXN0KGZvbnRGYW1pbHkpICYmICFnZW5lcmljRm9udEZhbWlsaWVzLmluY2x1ZGVzKGZvbnRGYW1pbHkpKSB7XG4gICAgICBmb250RmFtaWx5ID0gYFwiJHtmb250RmFtaWx5fVwiYDtcbiAgICB9XG4gICAgZm9udEZhbWlsaWVzW2ldID0gZm9udEZhbWlseTtcbiAgfVxuICByZXR1cm4gYCR7c3R5bGUuZm9udFN0eWxlfSAke3N0eWxlLmZvbnRWYXJpYW50fSAke3N0eWxlLmZvbnRXZWlnaHR9ICR7Zm9udFNpemVTdHJpbmd9ICR7Zm9udEZhbWlsaWVzLmpvaW4oXCIsXCIpfWA7XG59XG5cbmV4cG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n')},778:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   m: () => (/* binding */ getCanvasFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8409);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9853);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4796);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(557);\n/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1261);\n\n\n\n\n\n\n\n"use strict";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Texture */ .x.WHITE && !fillStyle.fill) {\n    return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(fillStyle.color).toHex();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");\n    const tempMatrix = fillStyle.matrix.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .y.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillPattern */ .h) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");\n    const tempMatrix = fillPattern.transform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .y.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__/* .FillGradient */ .f) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === "linear") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__/* .warn */ .Z)("FillStyle not recognised", fillStyle);\n  return "red";\n}\n\n\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRDtBQUNTO0FBQ3dCO0FBQzNCO0FBQ29CO0FBQ0Y7O0FBRTVFO0FBQ0E7QUFDQSw0QkFBNEIsNkZBQU87QUFDbkMsV0FBVyw0REFBSztBQUNoQixJQUFJO0FBQ0o7QUFDQSwrQ0FBK0MscUVBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUMsdUZBQVc7QUFDbEQ7QUFDQTtBQUNBLG9EQUFvRCxxRUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQyx5RkFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNERBQUs7QUFDaEQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0VBQUk7QUFDTjtBQUNBOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9nZXRDYW52YXNGaWxsU3R5bGUubWpzPzc2MWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgRmlsbEdyYWRpZW50IH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcyc7XG5pbXBvcnQgeyBGaWxsUGF0dGVybiB9IGZyb20gJy4uLy4uLy4uL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxQYXR0ZXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0Q2FudmFzRmlsbFN0eWxlKGZpbGxTdHlsZSwgY29udGV4dCkge1xuICBpZiAoZmlsbFN0eWxlLnRleHR1cmUgPT09IFRleHR1cmUuV0hJVEUgJiYgIWZpbGxTdHlsZS5maWxsKSB7XG4gICAgcmV0dXJuIENvbG9yLnNoYXJlZC5zZXRWYWx1ZShmaWxsU3R5bGUuY29sb3IpLnRvSGV4KCk7XG4gIH0gZWxzZSBpZiAoIWZpbGxTdHlsZS5maWxsKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihmaWxsU3R5bGUudGV4dHVyZS5zb3VyY2UucmVzb3VyY2UsIFwicmVwZWF0XCIpO1xuICAgIGNvbnN0IHRlbXBNYXRyaXggPSBmaWxsU3R5bGUubWF0cml4LmNvcHlUbyhNYXRyaXguc2hhcmVkKTtcbiAgICB0ZW1wTWF0cml4LnNjYWxlKGZpbGxTdHlsZS50ZXh0dXJlLmZyYW1lLndpZHRoLCBmaWxsU3R5bGUudGV4dHVyZS5mcmFtZS5oZWlnaHQpO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKHRlbXBNYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9IGVsc2UgaWYgKGZpbGxTdHlsZS5maWxsIGluc3RhbmNlb2YgRmlsbFBhdHRlcm4pIHtcbiAgICBjb25zdCBmaWxsUGF0dGVybiA9IGZpbGxTdHlsZS5maWxsO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oZmlsbFBhdHRlcm4udGV4dHVyZS5zb3VyY2UucmVzb3VyY2UsIFwicmVwZWF0XCIpO1xuICAgIGNvbnN0IHRlbXBNYXRyaXggPSBmaWxsUGF0dGVybi50cmFuc2Zvcm0uY29weVRvKE1hdHJpeC5zaGFyZWQpO1xuICAgIHRlbXBNYXRyaXguc2NhbGUoXG4gICAgICBmaWxsUGF0dGVybi50ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgZmlsbFBhdHRlcm4udGV4dHVyZS5mcmFtZS5oZWlnaHRcbiAgICApO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKHRlbXBNYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9IGVsc2UgaWYgKGZpbGxTdHlsZS5maWxsIGluc3RhbmNlb2YgRmlsbEdyYWRpZW50KSB7XG4gICAgY29uc3QgZmlsbEdyYWRpZW50ID0gZmlsbFN0eWxlLmZpbGw7XG4gICAgaWYgKGZpbGxHcmFkaWVudC50eXBlID09PSBcImxpbmVhclwiKSB7XG4gICAgICBjb25zdCBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgIGZpbGxHcmFkaWVudC54MCxcbiAgICAgICAgZmlsbEdyYWRpZW50LnkwLFxuICAgICAgICBmaWxsR3JhZGllbnQueDEsXG4gICAgICAgIGZpbGxHcmFkaWVudC55MVxuICAgICAgKTtcbiAgICAgIGZpbGxHcmFkaWVudC5ncmFkaWVudFN0b3BzLmZvckVhY2goKHN0b3ApID0+IHtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3Aub2Zmc2V0LCBDb2xvci5zaGFyZWQuc2V0VmFsdWUoc3RvcC5jb2xvcikudG9IZXgoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gIH1cbiAgd2FybihcIkZpbGxTdHlsZSBub3QgcmVjb2duaXNlZFwiLCBmaWxsU3R5bGUpO1xuICByZXR1cm4gXCJyZWRcIjtcbn1cblxuZXhwb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDYW52YXNGaWxsU3R5bGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///778\n')},2:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(3747);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(900);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs\n\n\n\n\n\n"use strict";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text._getKey();\n    if (gpuText.currentKey !== newKey) {\n      const resolution = text.resolution ?? this._renderer.resolution;\n      const { width, height } = this._renderer.canvasText.getTextureSize(\n        text.text,\n        resolution,\n        text._style\n      );\n      if (\n        // is only being used by this text:\n        this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  addRenderable(text, _instructionSet) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(text) {\n    this._destroyRenderableById(text.uid);\n  }\n  _destroyRenderableById(textUid) {\n    const gpuText = this._gpuText[textUid];\n    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[textUid] = null;\n  }\n  _updateText(text) {\n    const newKey = text._getKey();\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(text);\n    }\n    text._didTextUpdate = false;\n    const padding = text._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n  }\n  _updateGpuText(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    }\n    const resolution = text.resolution ?? this._renderer.resolution;\n    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n      text.text,\n      resolution,\n      text._style,\n      text._getKey()\n    );\n    gpuText.currentKey = text._getKey();\n    batchableSprite.texture = gpuText.texture;\n  }\n  _getGpuText(text) {\n    return this._gpuText[text.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const gpuTextData = {\n      texture: null,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.c)\n    };\n    gpuTextData.batchableSprite.renderable = text;\n    gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    this._gpuText[text.uid] = gpuTextData;\n    this._updateText(text);\n    text.on("destroyed", () => {\n      this.destroyRenderable(text);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "text"\n};\n\n\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(4181);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs\n\n\n"use strict";\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas, resolution = 1) {\n  const { width, height } = canvas;\n  const context = canvas.getContext("2d", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError("Failed to get canvas 2D context");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle/* Rectangle */.A.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new Rectangle/* Rectangle */.A(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\n\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(1647);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(13);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(778);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass CanvasTextSystem {\n  constructor() {\n    this._activeTextures = {};\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = (0,pow2/* nextPow2 */.a9)(width);\n    height = (0,pow2/* nextPow2 */.a9)(height);\n    return { width, height };\n  }\n  getTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(width, height);\n    const { canvas } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.H)(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool/* CanvasPool */.h.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool/* TexturePool */.z.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = "unknown";\n      source.alphaMode = "no-premultiply-alpha";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to \'pre-generate\' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = "black";\n        context.strokeStyle = "black";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color/* Color */.I.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.globalAlpha = style._fill?.alpha ?? 1;\n        context.fillStyle = style._fill ? (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context) : null;\n        if (style._stroke?.width) {\n          context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._stroke, context);\n        }\n        context.shadowColor = "black";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === "right") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === "center") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it\'s for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics/* CanvasTextMetrics */.c.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics/* CanvasTextMetrics */.c.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics/* CanvasTextMetrics */.c.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = "";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "canvasText"\n};\n\n\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(CanvasTextSystem);\nExtensions/* extensions */.Rw.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVqRTtBQUNBLDZCQUFVLEtBQUssZ0JBQWdCO0FBQy9CLDZCQUFVLEtBQUssY0FBYztBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy9DYW52YXNUZXh0UGlwZS5tanM/MTNlZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvY2FudmFzL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcz80NTliIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy9DYW52YXNUZXh0U3lzdGVtLm1qcz82MmJjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2luaXQubWpzPzc3YjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgdXBkYXRlUXVhZEJvdW5kcyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RhdGEvdXBkYXRlUXVhZEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVTcHJpdGUgfSBmcm9tICcuLi8uLi9zcHJpdGUvQmF0Y2hhYmxlU3ByaXRlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ2FudmFzVGV4dFBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2dwdVRleHQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZSh0ZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgbmV3S2V5ID0gdGV4dC5fZ2V0S2V5KCk7XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdGV4dC5yZXNvbHV0aW9uID8/IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZ2V0VGV4dHVyZVNpemUoXG4gICAgICAgIHRleHQudGV4dCxcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgdGV4dC5fc3R5bGVcbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIGlzIG9ubHkgYmVpbmcgdXNlZCBieSB0aGlzIHRleHQ6XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZ2V0UmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KSA9PT0gMSAmJiB3aWR0aCA9PT0gZ3B1VGV4dC50ZXh0dXJlLl9zb3VyY2Uud2lkdGggJiYgaGVpZ2h0ID09PSBncHVUZXh0LnRleHR1cmUuX3NvdXJjZS5oZWlnaHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUodGV4dCwgX2luc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKHRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHQodGV4dCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmFkZFRvQmF0Y2goYmF0Y2hhYmxlU3ByaXRlKTtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKHRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAodGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dCh0ZXh0KTtcbiAgICB9XG4gICAgYmF0Y2hhYmxlU3ByaXRlLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKHRleHQpIHtcbiAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQodGV4dC51aWQpO1xuICB9XG4gIF9kZXN0cm95UmVuZGVyYWJsZUJ5SWQodGV4dFVpZCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9ncHVUZXh0W3RleHRVaWRdO1xuICAgIHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZGVjcmVhc2VSZWZlcmVuY2VDb3VudChncHVUZXh0LmN1cnJlbnRLZXkpO1xuICAgIEJpZ1Bvb2wucmV0dXJuKGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlKTtcbiAgICB0aGlzLl9ncHVUZXh0W3RleHRVaWRdID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlVGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgbmV3S2V5ID0gdGV4dC5fZ2V0S2V5KCk7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICB0aGlzLl91cGRhdGVHcHVUZXh0KHRleHQpO1xuICAgIH1cbiAgICB0ZXh0Ll9kaWRUZXh0VXBkYXRlID0gZmFsc2U7XG4gICAgY29uc3QgcGFkZGluZyA9IHRleHQuX3N0eWxlLnBhZGRpbmc7XG4gICAgdXBkYXRlUXVhZEJvdW5kcyhiYXRjaGFibGVTcHJpdGUuYm91bmRzLCB0ZXh0Ll9hbmNob3IsIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlLCBwYWRkaW5nKTtcbiAgfVxuICBfdXBkYXRlR3B1VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGdwdVRleHQudGV4dHVyZSkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5kZWNyZWFzZVJlZmVyZW5jZUNvdW50KGdwdVRleHQuY3VycmVudEtleSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0ZXh0LnJlc29sdXRpb24gPz8gdGhpcy5fcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICBncHVUZXh0LnRleHR1cmUgPSBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZ2V0VGV4dHVyZShcbiAgICAgIHRleHQudGV4dCxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICB0ZXh0Ll9zdHlsZSxcbiAgICAgIHRleHQuX2dldEtleSgpXG4gICAgKTtcbiAgICBncHVUZXh0LmN1cnJlbnRLZXkgPSB0ZXh0Ll9nZXRLZXkoKTtcbiAgICBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IGdwdVRleHQudGV4dHVyZTtcbiAgfVxuICBfZ2V0R3B1VGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVRleHRbdGV4dC51aWRdIHx8IHRoaXMuaW5pdEdwdVRleHQodGV4dCk7XG4gIH1cbiAgaW5pdEdwdVRleHQodGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHREYXRhID0ge1xuICAgICAgdGV4dHVyZTogbnVsbCxcbiAgICAgIGN1cnJlbnRLZXk6IFwiLS1cIixcbiAgICAgIGJhdGNoYWJsZVNwcml0ZTogQmlnUG9vbC5nZXQoQmF0Y2hhYmxlU3ByaXRlKVxuICAgIH07XG4gICAgZ3B1VGV4dERhdGEuYmF0Y2hhYmxlU3ByaXRlLnJlbmRlcmFibGUgPSB0ZXh0O1xuICAgIGdwdVRleHREYXRhLmJhdGNoYWJsZVNwcml0ZS5ib3VuZHMgPSB7IG1pblg6IDAsIG1heFg6IDEsIG1pblk6IDAsIG1heFk6IDAgfTtcbiAgICBncHVUZXh0RGF0YS5iYXRjaGFibGVTcHJpdGUucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCB0ZXh0Ll9yb3VuZFBpeGVscztcbiAgICB0aGlzLl9ncHVUZXh0W3RleHQudWlkXSA9IGdwdVRleHREYXRhO1xuICAgIHRoaXMuX3VwZGF0ZVRleHQodGV4dCk7XG4gICAgdGV4dC5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKHRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBncHVUZXh0RGF0YTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVUZXh0KSB7XG4gICAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQoaSk7XG4gICAgfVxuICAgIHRoaXMuX2dwdVRleHQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkNhbnZhc1RleHRQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJ0ZXh0XCJcbn07XG5cbmV4cG9ydCB7IENhbnZhc1RleHRQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNUZXh0UGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY2hlY2tSb3coZGF0YSwgd2lkdGgsIHkpIHtcbiAgZm9yIChsZXQgeCA9IDAsIGluZGV4ID0gNCAqIHkgKiB3aWR0aDsgeCA8IHdpZHRoOyArK3gsIGluZGV4ICs9IDQpIHtcbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIHgsIHRvcCwgYm90dG9tKSB7XG4gIGNvbnN0IHN0cmlkZSA9IDQgKiB3aWR0aDtcbiAgZm9yIChsZXQgeSA9IHRvcCwgaW5kZXggPSB0b3AgKiBzdHJpZGUgKyA0ICogeDsgeSA8PSBib3R0b207ICsreSwgaW5kZXggKz0gc3RyaWRlKSB7XG4gICAgaWYgKGRhdGFbaW5kZXggKyAzXSAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldENhbnZhc0JvdW5kaW5nQm94KGNhbnZhcywgcmVzb2x1dGlvbiA9IDEpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXM7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgfSk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBnZXQgY2FudmFzIDJEIGNvbnRleHRcIik7XG4gIH1cbiAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgdG9wID0gMDtcbiAgbGV0IHJpZ2h0ID0gd2lkdGggLSAxO1xuICBsZXQgYm90dG9tID0gaGVpZ2h0IC0gMTtcbiAgd2hpbGUgKHRvcCA8IGhlaWdodCAmJiBjaGVja1JvdyhkYXRhLCB3aWR0aCwgdG9wKSlcbiAgICArK3RvcDtcbiAgaWYgKHRvcCA9PT0gaGVpZ2h0KVxuICAgIHJldHVybiBSZWN0YW5nbGUuRU1QVFk7XG4gIHdoaWxlIChjaGVja1JvdyhkYXRhLCB3aWR0aCwgYm90dG9tKSlcbiAgICAtLWJvdHRvbTtcbiAgd2hpbGUgKGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCBsZWZ0LCB0b3AsIGJvdHRvbSkpXG4gICAgKytsZWZ0O1xuICB3aGlsZSAoY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIHJpZ2h0LCB0b3AsIGJvdHRvbSkpXG4gICAgLS1yaWdodDtcbiAgKytyaWdodDtcbiAgKytib3R0b207XG4gIHJldHVybiBuZXcgUmVjdGFuZ2xlKGxlZnQgLyByZXNvbHV0aW9uLCB0b3AgLyByZXNvbHV0aW9uLCAocmlnaHQgLSBsZWZ0KSAvIHJlc29sdXRpb24sIChib3R0b20gLSB0b3ApIC8gcmVzb2x1dGlvbik7XG59XG5cbmV4cG9ydCB7IGdldENhbnZhc0JvdW5kaW5nQm94IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDYW52YXNCb3VuZGluZ0JveC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBuZXh0UG93MiB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21pc2MvcG93Mi5tanMnO1xuaW1wb3J0IHsgQ2FudmFzUG9vbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NhbnZhcy9nZXRDYW52YXNCb3VuZGluZ0JveC5tanMnO1xuaW1wb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfSBmcm9tICcuLi91dGlscy9nZXRQbzJUZXh0dXJlRnJvbVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5pbXBvcnQgeyBmb250U3RyaW5nRnJvbVRleHRTdHlsZSB9IGZyb20gJy4vdXRpbHMvZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzJztcbmltcG9ydCB7IGdldENhbnZhc0ZpbGxTdHlsZSB9IGZyb20gJy4vdXRpbHMvZ2V0Q2FudmFzRmlsbFN0eWxlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ2FudmFzVGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzID0ge307XG4gIH1cbiAgZ2V0VGV4dHVyZVNpemUodGV4dCwgcmVzb2x1dGlvbiwgc3R5bGUpIHtcbiAgICBjb25zdCBtZWFzdXJlZCA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRleHQgfHwgXCIgXCIsIHN0eWxlKTtcbiAgICBsZXQgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLndpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLmhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAtIDFlLTYpO1xuICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgLSAxZS02KTtcbiAgICB3aWR0aCA9IG5leHRQb3cyKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBuZXh0UG93MihoZWlnaHQpO1xuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgfVxuICBnZXRUZXh0dXJlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlLCB0ZXh0S2V5KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldKSB7XG4gICAgICB0aGlzLl9pbmNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnRleHR1cmU7XG4gICAgfVxuICAgIGNvbnN0IG1lYXN1cmVkID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGV4dCB8fCBcIiBcIiwgc3R5bGUpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKE1hdGguY2VpbChNYXRoLm1heCgxLCBtZWFzdXJlZC53aWR0aCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLmhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB7IGNhbnZhcyB9ID0gY2FudmFzQW5kQ29udGV4dDtcbiAgICB0aGlzLnJlbmRlclRleHRUb0NhbnZhcyh0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbiwgY2FudmFzQW5kQ29udGV4dCk7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdldFBvMlRleHR1cmVGcm9tU291cmNlKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgaWYgKHN0eWxlLnRyaW0pIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMsIHJlc29sdXRpb24pO1xuICAgICAgdGV4dHVyZS5mcmFtZS5jb3B5RnJvbSh0cmltbWVkKTtcbiAgICAgIHRleHR1cmUudXBkYXRlVXZzKCk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0ge1xuICAgICAgY2FudmFzQW5kQ29udGV4dCxcbiAgICAgIHRleHR1cmUsXG4gICAgICB1c2FnZUNvdW50OiAxXG4gICAgfTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICBfaW5jcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udXNhZ2VDb3VudCsrO1xuICB9XG4gIGRlY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIGNvbnN0IGFjdGl2ZVRleHR1cmUgPSB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XTtcbiAgICBhY3RpdmVUZXh0dXJlLnVzYWdlQ291bnQtLTtcbiAgICBpZiAoYWN0aXZlVGV4dHVyZS51c2FnZUNvdW50ID09PSAwKSB7XG4gICAgICBDYW52YXNQb29sLnJldHVybkNhbnZhc0FuZENvbnRleHQoYWN0aXZlVGV4dHVyZS5jYW52YXNBbmRDb250ZXh0KTtcbiAgICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYWN0aXZlVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGFjdGl2ZVRleHR1cmUudGV4dHVyZS5zb3VyY2U7XG4gICAgICBzb3VyY2UucmVzb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlLnVwbG9hZE1ldGhvZElkID0gXCJ1bmtub3duXCI7XG4gICAgICBzb3VyY2UuYWxwaGFNb2RlID0gXCJuby1wcmVtdWx0aXBseS1hbHBoYVwiO1xuICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXRSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnVzYWdlQ291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGV4dCB0byBpdHMgY2FudmFzLCBhbmQgdXBkYXRlcyBpdHMgdGV4dHVyZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIGlzIHVzZWQgaW50ZXJuYWxseSB0byBlbnN1cmUgdGhlIHRleHR1cmUgaXMgY29ycmVjdCBiZWZvcmUgcmVuZGVyaW5nLFxuICAgKiBidXQgaXQgY2FuIGJlIHVzZWQgY2FsbGVkIGV4dGVybmFsbHksIGZvciBleGFtcGxlIGZyb20gdGhpcyBjbGFzcyB0byAncHJlLWdlbmVyYXRlJyB0aGUgdGV4dHVyZSBmcm9tIGEgcGllY2Ugb2YgdGV4dCxcbiAgICogYW5kIHRoZW4gc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSBTcHJpdGVzLlxuICAgKiBAcGFyYW0gdGV4dFxuICAgKiBAcGFyYW0gc3R5bGVcbiAgICogQHBhcmFtIHJlc29sdXRpb25cbiAgICogQHBhcmFtIGNhbnZhc0FuZENvbnRleHRcbiAgICovXG4gIHJlbmRlclRleHRUb0NhbnZhcyh0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbiwgY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGNvbnN0IHsgY2FudmFzLCBjb250ZXh0IH0gPSBjYW52YXNBbmRDb250ZXh0O1xuICAgIGNvbnN0IGZvbnQgPSBmb250U3RyaW5nRnJvbVRleHRTdHlsZShzdHlsZSk7XG4gICAgY29uc3QgbWVhc3VyZWQgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlVGV4dCh0ZXh0IHx8IFwiIFwiLCBzdHlsZSk7XG4gICAgY29uc3QgbGluZXMgPSBtZWFzdXJlZC5saW5lcztcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gbWVhc3VyZWQubGluZUhlaWdodDtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gbWVhc3VyZWQubGluZVdpZHRocztcbiAgICBjb25zdCBtYXhMaW5lV2lkdGggPSBtZWFzdXJlZC5tYXhMaW5lV2lkdGg7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZWFzdXJlZC5mb250UHJvcGVydGllcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnRleHQucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICBjb250ZXh0LnNjYWxlKHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIG1lYXN1cmVkLndpZHRoICsgNCwgbWVhc3VyZWQuaGVpZ2h0ICsgNCk7XG4gICAgaWYgKHN0eWxlLl9zdHJva2U/LndpZHRoKSB7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZSA9IHN0eWxlLl9zdHJva2U7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZVN0eWxlLndpZHRoO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gc3Ryb2tlU3R5bGUubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSBzdHJva2VTdHlsZS5qb2luO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gc3Ryb2tlU3R5bGUuY2FwO1xuICAgIH1cbiAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgIGxldCBsaW5lUG9zaXRpb25YO1xuICAgIGxldCBsaW5lUG9zaXRpb25ZO1xuICAgIGNvbnN0IHBhc3Nlc0NvdW50ID0gc3R5bGUuZHJvcFNoYWRvdyA/IDIgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFzc2VzQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgaXNTaGFkb3dQYXNzID0gc3R5bGUuZHJvcFNoYWRvdyAmJiBpID09PSAwO1xuICAgICAgY29uc3QgZHNPZmZzZXRUZXh0ID0gaXNTaGFkb3dQYXNzID8gTWF0aC5jZWlsKE1hdGgubWF4KDEsIGhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgOiAwO1xuICAgICAgY29uc3QgZHNPZmZzZXRTaGFkb3cgPSBkc09mZnNldFRleHQgKiByZXNvbHV0aW9uO1xuICAgICAgaWYgKGlzU2hhZG93UGFzcykge1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgY29uc3Qgc2hhZG93T3B0aW9ucyA9IHN0eWxlLmRyb3BTaGFkb3c7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dDb2xvciA9IHNoYWRvd09wdGlvbnMuY29sb3I7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dBbHBoYSA9IHNoYWRvd09wdGlvbnMuYWxwaGE7XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShkcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpO1xuICAgICAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHNoYWRvd09wdGlvbnMuYmx1ciAqIHJlc29sdXRpb247XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dEaXN0YW5jZSA9IHNoYWRvd09wdGlvbnMuZGlzdGFuY2UgKiByZXNvbHV0aW9uO1xuICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gTWF0aC5jb3Moc2hhZG93T3B0aW9ucy5hbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IE1hdGguc2luKHNoYWRvd09wdGlvbnMuYW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlICsgZHNPZmZzZXRTaGFkb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gc3R5bGUuX2ZpbGw/LmFscGhhID8/IDE7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGUuX2ZpbGwgPyBnZXRDYW52YXNGaWxsU3R5bGUoc3R5bGUuX2ZpbGwsIGNvbnRleHQpIDogbnVsbDtcbiAgICAgICAgaWYgKHN0eWxlLl9zdHJva2U/LndpZHRoKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGdldENhbnZhc0ZpbGxTdHlsZShzdHlsZS5fc3Ryb2tlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xuICAgICAgfVxuICAgICAgbGV0IGxpbmVQb3NpdGlvbllTaGlmdCA9IChsaW5lSGVpZ2h0IC0gZm9udFByb3BlcnRpZXMuZm9udFNpemUpIC8gMjtcbiAgICAgIGlmIChsaW5lSGVpZ2h0IC0gZm9udFByb3BlcnRpZXMuZm9udFNpemUgPCAwKSB7XG4gICAgICAgIGxpbmVQb3NpdGlvbllTaGlmdCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IHN0eWxlLl9zdHJva2U/LndpZHRoID8/IDA7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbGluZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgICAgIGxpbmVQb3NpdGlvblkgPSBzdHJva2VXaWR0aCAvIDIgKyBpMiAqIGxpbmVIZWlnaHQgKyBmb250UHJvcGVydGllcy5hc2NlbnQgKyBsaW5lUG9zaXRpb25ZU2hpZnQ7XG4gICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2kyXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaTJdKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLl9zdHJva2UpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3TGV0dGVyU3BhY2luZyhcbiAgICAgICAgICAgIGxpbmVzW2kyXSxcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgY2FudmFzQW5kQ29udGV4dCxcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSArIHN0eWxlLnBhZGRpbmcgLSBkc09mZnNldFRleHQsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuX2ZpbGwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMuX2RyYXdMZXR0ZXJTcGFjaW5nKFxuICAgICAgICAgICAgbGluZXNbaTJdLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBjYW52YXNBbmRDb250ZXh0LFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyAtIGRzT2Zmc2V0VGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgdGV4dCB3aXRoIGxldHRlci1zcGFjaW5nLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIGRyYXdcbiAgICogQHBhcmFtIHN0eWxlXG4gICAqIEBwYXJhbSBjYW52YXNBbmRDb250ZXh0XG4gICAqIEBwYXJhbSB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAqIEBwYXJhbSB5IC0gVmVydGljYWwgcG9zaXRpb24gdG8gZHJhdyB0aGUgdGV4dFxuICAgKiBAcGFyYW0gaXNTdHJva2UgLSBJcyB0aGlzIGRyYXdpbmcgZm9yIHRoZSBvdXRzaWRlIHN0cm9rZSBvZiB0aGVcbiAgICogIHRleHQ/IElmIG5vdCwgaXQncyBmb3IgdGhlIGluc2lkZSBmaWxsXG4gICAqL1xuICBfZHJhd0xldHRlclNwYWNpbmcodGV4dCwgc3R5bGUsIGNhbnZhc0FuZENvbnRleHQsIHgsIHksIGlzU3Ryb2tlID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGNvbnRleHQgfSA9IGNhbnZhc0FuZENvbnRleHQ7XG4gICAgY29uc3QgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmc7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbiAgICBpZiAoQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCkge1xuICAgICAgaWYgKENhbnZhc1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcpIHtcbiAgICAgICAgY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgICBjb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDAgfHwgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB4O1xuICAgIGNvbnN0IHN0cmluZ0FycmF5ID0gQ2FudmFzVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIodGV4dCk7XG4gICAgbGV0IHByZXZpb3VzV2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDaGFyID0gc3RyaW5nQXJyYXlbaV07XG4gICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGN1cnJlbnRDaGFyLCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChjdXJyZW50Q2hhciwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0U3RyID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHN0cmluZ0FycmF5Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHRleHRTdHIgKz0gc3RyaW5nQXJyYXlbal07XG4gICAgICB9XG4gICAgICBjdXJyZW50V2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHRTdHIpLndpZHRoO1xuICAgICAgY3VycmVudFBvc2l0aW9uICs9IHByZXZpb3VzV2lkdGggLSBjdXJyZW50V2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgcHJldmlvdXNXaWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlcyA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5DYW52YXNUZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJjYW52YXNUZXh0XCJcbn07XG5cbmV4cG9ydCB7IENhbnZhc1RleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1RleHRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dFBpcGUgfSBmcm9tICcuL2NhbnZhcy9DYW52YXNUZXh0UGlwZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dFN5c3RlbSB9IGZyb20gJy4vY2FudmFzL0NhbnZhc1RleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChDYW52YXNUZXh0U3lzdGVtKTtcbmV4dGVuc2lvbnMuYWRkKENhbnZhc1RleHRQaXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},1647:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H: () => (/* binding */ getPo2TextureFromSource)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6669);\n/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(535);\n\n\n\n"use strict";\nconst tempBounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Bounds */ .Y();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TexturePool */ .z.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = "image";\n  texture.source.resource = image;\n  texture.source.alphaMode = "premultiply-alpha-on-upload";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit("update", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\n\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRjtBQUMvQjs7QUFFM0Q7QUFDQSx1QkFBdUIseUVBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFHQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvdXRpbHMvZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzP2FiNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZShpbWFnZSwgd2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbikge1xuICBjb25zdCBib3VuZHMgPSB0ZW1wQm91bmRzO1xuICBib3VuZHMubWluWCA9IDA7XG4gIGJvdW5kcy5taW5ZID0gMDtcbiAgYm91bmRzLm1heFggPSBpbWFnZS53aWR0aCAvIHJlc29sdXRpb24gfCAwO1xuICBib3VuZHMubWF4WSA9IGltYWdlLmhlaWdodCAvIHJlc29sdXRpb24gfCAwO1xuICBjb25zdCB0ZXh0dXJlID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgYm91bmRzLndpZHRoLFxuICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgcmVzb2x1dGlvbixcbiAgICBmYWxzZVxuICApO1xuICB0ZXh0dXJlLnNvdXJjZS51cGxvYWRNZXRob2RJZCA9IFwiaW1hZ2VcIjtcbiAgdGV4dHVyZS5zb3VyY2UucmVzb3VyY2UgPSBpbWFnZTtcbiAgdGV4dHVyZS5zb3VyY2UuYWxwaGFNb2RlID0gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgdGV4dHVyZS5mcmFtZS53aWR0aCA9IHdpZHRoIC8gcmVzb2x1dGlvbjtcbiAgdGV4dHVyZS5mcmFtZS5oZWlnaHQgPSBoZWlnaHQgLyByZXNvbHV0aW9uO1xuICB0ZXh0dXJlLnNvdXJjZS5lbWl0KFwidXBkYXRlXCIsIHRleHR1cmUuc291cmNlKTtcbiAgdGV4dHVyZS51cGRhdGVVdnMoKTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmV4cG9ydCB7IGdldFBvMlRleHR1cmVGcm9tU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRQbzJUZXh0dXJlRnJvbVNvdXJjZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1647\n')}}]);