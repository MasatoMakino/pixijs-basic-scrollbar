"use strict";(self.webpackChunk_masatomakino_pixijs_basic_scrollbar=self.webpackChunk_masatomakino_pixijs_basic_scrollbar||[]).push([[45],{7045:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  WebGPURenderer: () => (/* binding */ WebGPURenderer)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs + 1 modules\nvar maxRecommendedTextures = __webpack_require__(5267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs\nvar getTextureBatchBindGroup = __webpack_require__(3018);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(2110);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(6600);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs\nvar localUniformBit = __webpack_require__(8070);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(4537);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuGraphicsAdaptor {\n  init() {\n    const localUniforms = new UniformGroup/* UniformGroup */.o({\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uRound: { value: 0, type: "f32" }\n    });\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "graphics",\n      bits: [\n        colorBit/* colorBit */.M,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */.m)((0,maxRecommendedTextures/* getMaxTexturesPerBatch */.N)()),\n        localUniformBit/* localUniformBitGroup2 */.Kt,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    });\n    this.shader = new Shader/* Shader */.e({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      geometry,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setPipelineFromGeometryProgramAndState(\n      geometry,\n      shader.gpuProgram,\n      graphicsPipe.state\n    );\n    encoder.setGeometry(geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.Q)(textureBatch.textures, textureBatch.count);\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUPipesAdaptor\n  ],\n  name: "graphics"\n};\n\n\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs\nvar textureBit = __webpack_require__(9054);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "mesh",\n      bits: [\n        localUniformBit/* localUniformBit */.XH,\n        textureBit/* textureBit */.r,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    });\n    this._shader = new Shader/* Shader */.e({\n      gpuProgram,\n      resources: {\n        uTexture: Texture/* Texture */.x.EMPTY._source,\n        uSampler: Texture/* Texture */.x.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix/* Matrix */.y() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n    } else if (!shader.gpuProgram) {\n      (0,warn/* warn */.Z)("Mesh shader has no gpuProgram", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUPipesAdaptor\n  ],\n  name: "mesh"\n};\n\n\n//# sourceMappingURL=GpuMeshAdapter.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempState = State/* State */.Z.for2d();\nclass GpuBatchAdaptor {\n  init() {\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "batch",\n      bits: [\n        colorBit/* colorBit */.M,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */.m)((0,maxRecommendedTextures/* getMaxTexturesPerBatch */.N)()),\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    });\n    this._shader = new Shader/* Shader */.e({\n      gpuProgram,\n      groups: {\n        // these will be dynamically allocated\n      }\n    });\n  }\n  start(batchPipe, geometry) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = this._shader.gpuProgram;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry, program);\n    tempState.blendMode = "normal";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.Q)(textureBatch.textures, textureBatch.count);\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState\n    );\n    batch.bindGroup._touch(renderer.textureGC.count);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUPipesAdaptor\n  ],\n  name: "batch"\n};\n\n\n//# sourceMappingURL=GpuBatchAdaptor.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs + 1 modules\nvar AbstractRenderer = __webpack_require__(7400);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs + 32 modules\nvar SharedSystems = __webpack_require__(1624);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs\n\n\n"use strict";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === "uniformGroup") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === "buffer") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === "bufferResource") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === "textureSampler") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === "textureSource") {\n        const texture = resource;\n        gpuResource = renderer.texture.getGpuSource(texture).createView({});\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    for (const key of Object.keys(this._hash)) {\n      this._hash[key] = null;\n    }\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "bindGroup"\n};\n\n\n//# sourceMappingURL=BindGroupSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs\nvar fastCopy = __webpack_require__(6633);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs\n\n\n\n"use strict";\nclass GpuBufferSystem {\n  constructor() {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._managedBuffers = [];\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    for (const id in this._gpuBuffers) {\n      this._gpuBuffers[id].destroy();\n    }\n    this._gpuBuffers = {};\n  }\n  createGPUBuffer(buffer) {\n    if (!this._gpuBuffers[buffer.uid]) {\n      buffer.on("update", this.updateBuffer, this);\n      buffer.on("change", this.onBufferChange, this);\n      buffer.on("destroy", this.onBufferDestroy, this);\n      this._managedBuffers.push(buffer);\n    }\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    if (buffer.data) {\n      (0,fastCopy/* fastCopy */.T)(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    this._gpuBuffers[buffer.uid] = gpuBuffer;\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer._updateID = 0;\n    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n  }\n  /**\n   * Disposes buffer\n   * @param buffer - buffer with data\n   */\n  onBufferDestroy(buffer) {\n    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n    this._destroyBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n    this._managedBuffers = null;\n    this._gpuBuffers = null;\n  }\n  _destroyBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer.off("update", this.updateBuffer, this);\n    buffer.off("change", this.onBufferChange, this);\n    buffer.off("destroy", this.onBufferDestroy, this);\n    this._gpuBuffers[buffer.uid] = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "buffer"\n};\n\n\n//# sourceMappingURL=GpuBufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs\n\n\n"use strict";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "colorMask"\n};\n\n\n//# sourceMappingURL=GpuColorMaskSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar environment_adapter = __webpack_require__(3646);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs\n\n\n\n"use strict";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise)\n      return this._initPromise;\n    this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter = await environment_adapter/* DOMAdapter */.z.get().getNavigator().gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      "texture-compression-bc",\n      "texture-compression-astc",\n      "texture-compression-etc2"\n    ].filter((feature) => adapter.features.has(feature));\n    const device = await adapter.requestDevice({\n      requiredFeatures\n    });\n    return { adapter, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "device"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\n\n//# sourceMappingURL=GpuDeviceSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs\n\n\n"use strict";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline)\n      return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer)\n      return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer)\n      return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup)\n      return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.textureGC.count);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry, program) {\n    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n    for (const i in buffersToBind) {\n      this._setVertexBuffer(i, geometry.attributes[buffersToBind[i]].buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry, shader.gpuProgram);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount || geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1]\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [Extensions/* ExtensionType */.nw.WebGPUSystem],\n  name: "encoder",\n  priority: 1\n};\n\n\n//# sourceMappingURL=GpuEncoderSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs\nvar state_const = __webpack_require__(2475);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs\n\n\n\n"use strict";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: state_const/* STENCIL_MODES */.D.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "stencil"\n};\n\n\n//# sourceMappingURL=GpuStencilSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs\nvar UboSystem = __webpack_require__(8809);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs\n\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  "vec2<i32>": { align: 8, size: 8 },\n  "vec2<u32>": { align: 8, size: 8 },\n  "vec2<f32>": { align: 8, size: 8 },\n  "vec2<f16>": { align: 4, size: 4 },\n  "vec3<i32>": { align: 16, size: 12 },\n  "vec3<u32>": { align: 16, size: 12 },\n  "vec3<f32>": { align: 16, size: 12 },\n  "vec3<f16>": { align: 8, size: 6 },\n  "vec4<i32>": { align: 16, size: 16 },\n  "vec4<u32>": { align: 16, size: 16 },\n  "vec4<f32>": { align: 16, size: 16 },\n  "vec4<f16>": { align: 8, size: 8 },\n  "mat2x2<f32>": { align: 8, size: 16 },\n  "mat2x2<f16>": { align: 4, size: 8 },\n  "mat3x2<f32>": { align: 8, size: 24 },\n  "mat3x2<f16>": { align: 4, size: 12 },\n  "mat4x2<f32>": { align: 8, size: 32 },\n  "mat4x2<f16>": { align: 4, size: 16 },\n  "mat2x3<f32>": { align: 16, size: 32 },\n  "mat2x3<f16>": { align: 8, size: 16 },\n  "mat3x3<f32>": { align: 16, size: 48 },\n  "mat3x3<f16>": { align: 8, size: 24 },\n  "mat4x3<f32>": { align: 16, size: 64 },\n  "mat4x3<f16>": { align: 8, size: 32 },\n  "mat2x4<f32>": { align: 16, size: 32 },\n  "mat2x4<f16>": { align: 8, size: 16 },\n  "mat3x4<f32>": { align: 16, size: 48 },\n  "mat3x4<f16>": { align: 8, size: 24 },\n  "mat4x4<f32>": { align: 16, size: 64 },\n  "mat4x4<f16>": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\n\n//# sourceMappingURL=createUboElementsWGSL.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs\nvar createUboSyncFunction = __webpack_require__(9758);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs\nvar uboSyncFunctions = __webpack_require__(5746);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs\n\n\n"use strict";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 data[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}\n         }\n     `;\n}\n\n\n//# sourceMappingURL=generateArraySyncWGSL.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs\n\n\n\n\n"use strict";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return (0,createUboSyncFunction/* createUboSyncFunction */.S)(\n    uboElements,\n    "uboWgsl",\n    generateArraySyncWGSL,\n    uboSyncFunctions/* uboSyncFunctionsWGSL */.R\n  );\n}\n\n\n//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs\n\n\n\n\n\n"use strict";\nclass GpuUboSystem extends UboSystem/* UboSystem */.L {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [Extensions/* ExtensionType */.nw.WebGPUSystem],\n  name: "ubo"\n};\n\n\n//# sourceMappingURL=GpuUboSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs\nvar Buffer = __webpack_require__(7494);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs\nvar BufferResource = __webpack_require__(6496);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(5324);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs\n\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error("UniformBufferBatch: ubo batch got too big");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this._buffer.destroy();\n    this._buffer = null;\n    this.data = null;\n  }\n}\n\n\n//# sourceMappingURL=UboBatch.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs\n\n\n\n\n\n\n\n"use strict";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = buffer_const/* BufferUsage */.F.UNIFORM | buffer_const/* BufferUsage */.F.COPY_DST;\n      if (i === 0)\n        usage |= buffer_const/* BufferUsage */.F.COPY_SRC;\n      this._buffers.push(new Buffer/* Buffer */.l({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    for (const i in this._bindGroupHash) {\n      this._bindGroupHash[i] = null;\n    }\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource/* BufferResource */.q({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup/* BindGroup */.v({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i].destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._bindGroupHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUPipes\n  ],\n  name: "uniformBatch"\n};\n\n\n//# sourceMappingURL=GpuUniformBatchPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs\nvar ensureAttributes = __webpack_require__(6546);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs\nvar createIdFromString = __webpack_require__(8460);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs\nvar GpuStencilModesToPixi = __webpack_require__(647);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs\n\n\n\n\n\n\n\n"use strict";\nconst topologyStringToId = {\n  "point-list": 0,\n  "line-list": 1,\n  "line-strip": 2,\n  "triangle-list": 3,\n  "triangle-strip": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(state_const/* STENCIL_MODES */.D.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount)\n      return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask)\n      return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode)\n      return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi/* GpuStencilModesToPixi */.L[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      (0,ensureAttributes/* ensureAttributes */.B)(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology = topology || geometry.topology;\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key])\n      return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry, program);\n    const blendModes = this._renderer.state.getColorTargets(state);\n    blendModes[0].writeMask = this._stencilMode === state_const/* STENCIL_MODES */.D.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: "depth24plus-stencil8",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? "less" : "always"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n      keyGen[index++] = attribute.instance;\n    }\n    const stringKey = keyGen.join("|");\n    geometry._layoutKey = (0,createIdFromString/* createIdFromString */.Z)(stringKey, "geometry");\n    return geometry._layoutKey;\n  }\n  _generateAttributeLocationsKey(program) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(program.attributeData).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = program.attributeData[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n    }\n    const stringKey = keyGen.join("|");\n    program._attributeLocationsKey = (0,createIdFromString/* createIdFromString */.Z)(stringKey, "programAttributes");\n    return program._attributeLocationsKey;\n  }\n  /**\n   * Returns a hash of buffer names mapped to bind locations.\n   * This is used to bind the correct buffer to the correct location in the shader.\n   * @param geometry - The geometry where to get the buffer names\n   * @param program - The program where to get the buffer names\n   * @returns An object of buffer names mapped to the bind location.\n   */\n  getBufferNamesToBind(geometry, program) {\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bindingNamesCache[key])\n      return this._bindingNamesCache[key];\n    const data = this._createVertexBufferLayouts(geometry, program);\n    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);\n    const attributeData = program.attributeData;\n    for (let i = 0; i < data.length; i++) {\n      for (const j in attributeData) {\n        if (attributeData[j].location === i) {\n          bufferNamesToBind[i] = j;\n          break;\n        }\n      }\n    }\n    this._bindingNamesCache[key] = bufferNamesToBind;\n    return bufferNamesToBind;\n  }\n  _createVertexBufferLayouts(geometry, program) {\n    if (!program._attributeLocationsKey)\n      this._generateAttributeLocationsKey(program);\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bufferLayoutsCache[key]) {\n      return this._bufferLayoutsCache[key];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: "vertex",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in program.attributeData) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          (0,warn/* warn */.Z)(`Attribute ${i} has an invalid divisor value of \'${attribute.divisor}\'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";\n          bufferEntryAttributes.push({\n            shaderLocation: program.attributeData[i].location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[key] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [Extensions/* ExtensionType */.nw.WebGPUSystem],\n  name: "pipeline"\n};\n\n\n//# sourceMappingURL=PipelineSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs + 2 modules\nvar RenderTargetSystem = __webpack_require__(2028);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(6582);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs\nvar CanvasSource = __webpack_require__(6914);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(5206);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs\n\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\n\n//# sourceMappingURL=GpuRenderTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs\n\n\n\n\n\n"use strict";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === "boolean") {\n      clear = clear ? gl_const/* CLEAR */.E.ALL : gl_const/* CLEAR */.E.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            mipLevelCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & gl_const/* CLEAR */.E.COLOR ? "clear" : "load";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: "store",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & gl_const/* CLEAR */.E.STENCIL ? "clear" : "load";\n      const depthLoadOp = clear & gl_const/* CLEAR */.E.DEPTH ? "clear" : "load";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: "store",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: "store"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear)\n      return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (CanvasSource/* CanvasSource */.D.test(colorTexture.resource)) {\n        const context = colorTexture.resource.getContext(\n          "webgpu"\n        );\n        const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: "bgra8unorm",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource/* TextureSource */.p({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\n\n//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs\n\n\n\n\n"use strict";\nclass GpuRenderTargetSystem extends RenderTargetSystem/* RenderTargetSystem */.l {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [Extensions/* ExtensionType */.nw.WebGPUSystem],\n  name: "renderTarget"\n};\n\n\n//# sourceMappingURL=GpuRenderTargetSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs\n\n\n"use strict";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "shader"\n};\n\n\n//# sourceMappingURL=GpuShaderSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs\n\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: "src-alpha",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "dst",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "zero",\n    dstFactor: "zero",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi["normal-npm"] = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "src-alpha",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi["add-npm"] = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "src-alpha",\n    dstFactor: "one",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi["screen-npm"] = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "src-alpha",\n    dstFactor: "one-minus-src",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: "zero",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "zero",\n    dstFactor: "one-minus-src",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.min = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "min"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "min"\n  }\n};\nGpuBlendModesToPixi.max = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "max"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "max"\n  }\n};\n\n\n//# sourceMappingURL=GpuBlendModesToPixi.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs\n\n\n\n\n"use strict";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State/* State */.Z();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   */\n  getColorTargets(state) {\n    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n    return [\n      {\n        format: "bgra8unorm",\n        writeMask: 0,\n        blend\n      }\n    ];\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "state"\n};\n\n\n//# sourceMappingURL=GpuStateSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs\n\nconst gpuUploadBufferImageResource = {\n  type: "image",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelHeight * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\n\n//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs\n\nconst blockDataMap = {\n  "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: "compressed",\n  upload(source, gpuTexture, gpu) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\n\n//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs\n\nconst gpuUploadImageResource = {\n  type: "image",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    if (!resource)\n      return;\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === "premultiply-alpha-on-upload";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\n\n//# sourceMappingURL=gpuUploadImageSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs\n\n\n"use strict";\nconst gpuUploadVideoResource = {\n  type: "video",\n  upload(source, gpuTexture, gpu) {\n    gpuUploadImageResource.upload(source, gpuTexture, gpu);\n  }\n};\n\n\n//# sourceMappingURL=gpuUploadVideoSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs\n\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: "linear" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: "auto",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: "vertexMain"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: "fragmentMain",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === "3d" || texture.dimension === "1d") {\n      throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: "2d",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: "2d",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: "store",\n            loadOp: "clear",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\n\n//# sourceMappingURL=GpuMipmapGenerator.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._gpuSources = /* @__PURE__ */ Object.create(null);\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._textureViewHash = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== "compressed") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    this._gpuSources[source.uid] = gpuTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on("update", this.onSourceUpdate, this);\n      source.on("resize", this.onSourceResize, this);\n      source.on("destroy", this.onSourceDestroy, this);\n      source.on("unload", this.onSourceUnload, this);\n      source.on("updateMipmaps", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture)\n      return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onSourceUnload(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (gpuTexture) {\n      this._gpuSources[source.uid] = null;\n      gpuTexture.destroy();\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceDestroy(source) {\n    source.off("update", this.onSourceUpdate, this);\n    source.off("unload", this.onSourceUnload, this);\n    source.off("destroy", this.onSourceDestroy, this);\n    source.off("resize", this.onSourceResize, this);\n    source.off("updateMipmaps", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  onSourceResize(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      this._textureViewHash[source.uid] = null;\n      this._bindGroupHash[source.uid] = null;\n      this.onSourceUnload(source);\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    return this._gpuSources[source.uid] || this.initSource(source);\n  }\n  /**\n   * this returns s bind group for a specific texture, the bind group contains\n   * - the texture source\n   * - the texture style\n   * - the texture matrix\n   * This is cached so the bind group should only be created once per texture\n   * @param texture - the texture you want the bindgroup for\n   * @returns the bind group for the texture\n   */\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    this._bindGroupHash[texture.uid] = new BindGroup/* BindGroup */.v({\n      0: source,\n      1: source.style,\n      2: new UniformGroup/* UniformGroup */.o({\n        uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }\n      })\n    });\n    return this._bindGroupHash[texture.uid];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n  }\n  _createTextureView(texture) {\n    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n    return this._textureViewHash[texture.uid];\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = environment_adapter/* DOMAdapter */.z.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext("webgpu");\n    context.configure({\n      device: renderer.gpu.device,\n      // eslint-disable-next-line max-len\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: environment_adapter/* DOMAdapter */.z.get().getNavigator().gpu.getPreferredCanvasFormat(),\n      alphaMode: "premultiplied"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n      this._bindGroupHash[key] = null;\n    }\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSources = null;\n    this._bindGroupHash = null;\n    this._textureViewHash = null;\n    this._gpuSamplers = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "texture"\n};\n\n\n//# sourceMappingURL=GpuTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems/* SharedSystems */.N,\n  GpuUboSystem,\n  GpuEncoderSystem,\n  GpuDeviceSystem,\n  GpuBufferSystem,\n  GpuTextureSystem,\n  GpuRenderTargetSystem,\n  GpuShaderSystem,\n  GpuStateSystem,\n  PipelineSystem,\n  GpuColorMaskSystem,\n  GpuStencilSystem,\n  BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedSystems/* SharedRenderPipes */.U, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.WebGPUSystem, systems);\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.WebGPUPipes, renderPipes);\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.WebGPUPipesAdaptor, renderPipeAdaptors);\nExtensions/* extensions */.Rw.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer/* AbstractRenderer */.I {\n  constructor() {\n    const systemConfig = {\n      name: "webgpu",\n      type: types/* RendererType */.g.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\n\n//# sourceMappingURL=WebGPURenderer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQzNCOzs7Ozs7Ozs7QUNuRm1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRTJCO0FBQzNCOzs7OztBQ3BGc0U7QUFDSjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0QkFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUUyQjtBQUMzQjs7O0FDM0ZtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUU4QjtBQUM5Qjs7Ozs7QUM1QjhEO0FBQ0s7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQSwwQkFBMEIscUNBQVU7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyQjtBQUMzQjs7O0FDNUVtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEVBQTBFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0NBQWE7QUFDdEI7QUFDQTtBQUNBOztBQUU0QjtBQUM1Qjs7Ozs7QUMxS21FO0FBQ1Q7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRWxFO0FBQ0E7QUFDQSxLQUFLLGtDQUFhO0FBQ2xCLEVBQUUsWUFBWTtBQUNkLEVBQUUsZ0JBQWdCO0FBQ2xCLEVBQUUsZUFBZTtBQUNqQixFQUFFLGVBQWU7QUFDakIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxxQkFBcUI7QUFDdkIsRUFBRSxlQUFlO0FBQ2pCLEVBQUUsY0FBYztBQUNoQixFQUFFLGNBQWM7QUFDaEIsRUFBRSxrQkFBa0I7QUFDcEIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxlQUFlO0FBQ2pCO0FBQ0EsK0JBQStCLHNDQUFpQixFQUFFLG1CQUFtQjtBQUNyRSwrQkFBK0IsZUFBZSxFQUFFLGNBQWMsRUFBRSxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsNkJBQVUsbUJBQW1CLGdDQUFhO0FBQzFDLDZCQUFVLG1CQUFtQixnQ0FBYTtBQUMxQyw2QkFBVSxtQkFBbUIsZ0NBQWE7QUFDMUMsNkJBQVU7QUFDViw2QkFBNkIsd0NBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL2dwdS9HcHVHcmFwaGljc0FkYXB0b3IubWpzPzUzZmUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL21lc2gvZ3B1L0dwdU1lc2hBZGFwdGVyLm1qcz81MjhmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvR3B1QmF0Y2hBZGFwdG9yLm1qcz8wYTU0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9CaW5kR3JvdXBTeXN0ZW0ubWpzP2E1YTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L2J1ZmZlci9HcHVCdWZmZXJTeXN0ZW0ubWpzP2Y0NWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUNvbG9yTWFza1N5c3RlbS5tanM/MDMzZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvR3B1RGV2aWNlU3lzdGVtLm1qcz81NGE1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVFbmNvZGVyU3lzdGVtLm1qcz80MmU3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVTdGVuY2lsU3lzdGVtLm1qcz8wOWRkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvRWxlbWVudHNXR1NMLm1qcz84MWU4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVBcnJheVN5bmNXR1NMLm1qcz9iZDFiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTC5tanM/OGU5ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvR3B1VWJvU3lzdGVtLm1qcz84MTA2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9idWZmZXIvVWJvQmF0Y2gubWpzPzg2ZDkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdVVuaWZvcm1CYXRjaFBpcGUubWpzPzVmZjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3BpcGVsaW5lL1BpcGVsaW5lU3lzdGVtLm1qcz80MTBkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9yZW5kZXJUYXJnZXQvR3B1UmVuZGVyVGFyZ2V0Lm1qcz8wNTMwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9yZW5kZXJUYXJnZXQvR3B1UmVuZGVyVGFyZ2V0QWRhcHRvci5tanM/N2RkMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvcmVuZGVyVGFyZ2V0L0dwdVJlbmRlclRhcmdldFN5c3RlbS5tanM/NTMxYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0dwdVNoYWRlclN5c3RlbS5tanM/YmI0YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc3RhdGUvR3B1QmxlbmRNb2Rlc1RvUGl4aS5tanM/NjUxNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc3RhdGUvR3B1U3RhdGVTeXN0ZW0ubWpzP2JjNjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UubWpzP2RhMGUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzP2I2NmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZEltYWdlU291cmNlLm1qcz82NmMzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLXNjcm9sbGJhci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3VwbG9hZGVycy9ncHVVcGxvYWRWaWRlb1NvdXJjZS5tanM/OWFjZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvdGV4dHVyZS91dGlscy9HcHVNaXBtYXBHZW5lcmF0b3IubWpzP2U2ZjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtc2Nyb2xsYmFyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvR3B1VGV4dHVyZVN5c3RlbS5tanM/MzAwZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvV2ViR1BVUmVuZGVyZXIubWpzPzNiN2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgZ2V0TWF4VGV4dHVyZXNQZXJCYXRjaCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9iYXRjaGVyL2dsL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzJztcbmltcG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9iYXRjaGVyL2dwdS9nZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlSGlnaFNoYWRlclRvUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgY29sb3JCaXQgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvY29sb3JCaXQubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2dlbmVyYXRlVGV4dHVyZUJhdGNoQml0Lm1qcyc7XG5pbXBvcnQgeyBsb2NhbFVuaWZvcm1CaXRHcm91cDIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtQml0Lm1qcyc7XG5pbXBvcnQgeyByb3VuZFBpeGVsc0JpdCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9yb3VuZFBpeGVsc0JpdC5tanMnO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1NoYWRlci5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdUdyYXBoaWNzQWRhcHRvciB7XG4gIGluaXQoKSB7XG4gICAgY29uc3QgbG9jYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1Um91bmQ6IHsgdmFsdWU6IDAsIHR5cGU6IFwiZjMyXCIgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdwdVByb2dyYW0oe1xuICAgICAgbmFtZTogXCJncmFwaGljc1wiLFxuICAgICAgYml0czogW1xuICAgICAgICBjb2xvckJpdCxcbiAgICAgICAgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQoZ2V0TWF4VGV4dHVyZXNQZXJCYXRjaCgpKSxcbiAgICAgICAgbG9jYWxVbmlmb3JtQml0R3JvdXAyLFxuICAgICAgICByb3VuZFBpeGVsc0JpdFxuICAgICAgXVxuICAgIH0pO1xuICAgIHRoaXMuc2hhZGVyID0gbmV3IFNoYWRlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIC8vIGFkZGVkIG9uIHRoZSBmbHkhXG4gICAgICAgIGxvY2FsVW5pZm9ybXNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBleGVjdXRlKGdyYXBoaWNzUGlwZSwgcmVuZGVyYWJsZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSByZW5kZXJhYmxlLmNvbnRleHQ7XG4gICAgY29uc3Qgc2hhZGVyID0gY29udGV4dC5jdXN0b21TaGFkZXIgfHwgdGhpcy5zaGFkZXI7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBncmFwaGljc1BpcGUucmVuZGVyZXI7XG4gICAgY29uc3QgY29udGV4dFN5c3RlbSA9IHJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBnZW9tZXRyeSxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH0gPSBjb250ZXh0U3lzdGVtLmdldENvbnRleHRSZW5kZXJEYXRhKGNvbnRleHQpO1xuICAgIGNvbnN0IGVuY29kZXIgPSByZW5kZXJlci5lbmNvZGVyO1xuICAgIGVuY29kZXIuc2V0UGlwZWxpbmVGcm9tR2VvbWV0cnlQcm9ncmFtQW5kU3RhdGUoXG4gICAgICBnZW9tZXRyeSxcbiAgICAgIHNoYWRlci5ncHVQcm9ncmFtLFxuICAgICAgZ3JhcGhpY3NQaXBlLnN0YXRlXG4gICAgKTtcbiAgICBlbmNvZGVyLnNldEdlb21ldHJ5KGdlb21ldHJ5LCBzaGFkZXIuZ3B1UHJvZ3JhbSk7XG4gICAgY29uc3QgZ2xvYmFsVW5pZm9ybXNCaW5kR3JvdXAgPSByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy5iaW5kR3JvdXA7XG4gICAgZW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgZ2xvYmFsVW5pZm9ybXNCaW5kR3JvdXAsIHNoYWRlci5ncHVQcm9ncmFtKTtcbiAgICBjb25zdCBsb2NhbEJpbmRHcm91cCA9IHJlbmRlcmVyLnJlbmRlclBpcGVzLnVuaWZvcm1CYXRjaC5nZXRVbmlmb3JtQmluZEdyb3VwKHNoYWRlci5yZXNvdXJjZXMubG9jYWxVbmlmb3JtcywgdHJ1ZSk7XG4gICAgZW5jb2Rlci5zZXRCaW5kR3JvdXAoMiwgbG9jYWxCaW5kR3JvdXAsIHNoYWRlci5ncHVQcm9ncmFtKTtcbiAgICBjb25zdCBiYXRjaGVzID0gaW5zdHJ1Y3Rpb25zLmluc3RydWN0aW9ucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5pbnN0cnVjdGlvblNpemU7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2ldO1xuICAgICAgc2hhZGVyLmdyb3Vwc1sxXSA9IGJhdGNoLmJpbmRHcm91cDtcbiAgICAgIGlmICghYmF0Y2guZ3B1QmluZEdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVCYXRjaCA9IGJhdGNoLnRleHR1cmVzO1xuICAgICAgICBiYXRjaC5iaW5kR3JvdXAgPSBnZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZUJhdGNoLnRleHR1cmVzLCB0ZXh0dXJlQmF0Y2guY291bnQpO1xuICAgICAgICBiYXRjaC5ncHVCaW5kR3JvdXAgPSByZW5kZXJlci5iaW5kR3JvdXAuZ2V0QmluZEdyb3VwKFxuICAgICAgICAgIGJhdGNoLmJpbmRHcm91cCxcbiAgICAgICAgICBzaGFkZXIuZ3B1UHJvZ3JhbSxcbiAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbmNvZGVyLnNldEJpbmRHcm91cCgxLCBiYXRjaC5iaW5kR3JvdXAsIHNoYWRlci5ncHVQcm9ncmFtKTtcbiAgICAgIGVuY29kZXIucmVuZGVyUGFzc0VuY29kZXIuZHJhd0luZGV4ZWQoYmF0Y2guc2l6ZSwgMSwgYmF0Y2guc3RhcnQpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc2hhZGVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1R3JhcGhpY3NBZGFwdG9yLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXNBZGFwdG9yXG4gIF0sXG4gIG5hbWU6IFwiZ3JhcGhpY3NcIlxufTtcblxuZXhwb3J0IHsgR3B1R3JhcGhpY3NBZGFwdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVHcmFwaGljc0FkYXB0b3IubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL2NvbXBpbGVIaWdoU2hhZGVyVG9Qcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBsb2NhbFVuaWZvcm1CaXQgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtQml0Lm1qcyc7XG5pbXBvcnQgeyByb3VuZFBpeGVsc0JpdCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9yb3VuZFBpeGVsc0JpdC5tanMnO1xuaW1wb3J0IHsgdGV4dHVyZUJpdCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy90ZXh0dXJlQml0Lm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1TWVzaEFkYXB0ZXIge1xuICBpbml0KCkge1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdwdVByb2dyYW0oe1xuICAgICAgbmFtZTogXCJtZXNoXCIsXG4gICAgICBiaXRzOiBbXG4gICAgICAgIGxvY2FsVW5pZm9ybUJpdCxcbiAgICAgICAgdGV4dHVyZUJpdCxcbiAgICAgICAgcm91bmRQaXhlbHNCaXRcbiAgICAgIF1cbiAgICB9KTtcbiAgICB0aGlzLl9zaGFkZXIgPSBuZXcgU2hhZGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgdVRleHR1cmU6IFRleHR1cmUuRU1QVFkuX3NvdXJjZSxcbiAgICAgICAgdVNhbXBsZXI6IFRleHR1cmUuRU1QVFkuX3NvdXJjZS5zdHlsZSxcbiAgICAgICAgdGV4dHVyZVVuaWZvcm1zOiB7XG4gICAgICAgICAgdVRleHR1cmVNYXRyaXg6IHsgdHlwZTogXCJtYXQzeDM8ZjMyPlwiLCB2YWx1ZTogbmV3IE1hdHJpeCgpIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGV4ZWN1dGUobWVzaFBpcGUsIG1lc2gpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IG1lc2hQaXBlLnJlbmRlcmVyO1xuICAgIGxldCBzaGFkZXIgPSBtZXNoLl9zaGFkZXI7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHNoYWRlciA9IHRoaXMuX3NoYWRlcjtcbiAgICAgIHNoYWRlci5ncm91cHNbMl0gPSByZW5kZXJlci50ZXh0dXJlLmdldFRleHR1cmVCaW5kR3JvdXAobWVzaC50ZXh0dXJlKTtcbiAgICB9IGVsc2UgaWYgKCFzaGFkZXIuZ3B1UHJvZ3JhbSkge1xuICAgICAgd2FybihcIk1lc2ggc2hhZGVyIGhhcyBubyBncHVQcm9ncmFtXCIsIG1lc2guc2hhZGVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IHNoYWRlci5ncHVQcm9ncmFtO1xuICAgIGlmIChncHVQcm9ncmFtLmF1dG9Bc3NpZ25HbG9iYWxVbmlmb3Jtcykge1xuICAgICAgc2hhZGVyLmdyb3Vwc1swXSA9IHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLmJpbmRHcm91cDtcbiAgICB9XG4gICAgaWYgKGdwdVByb2dyYW0uYXV0b0Fzc2lnbkxvY2FsVW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSBtZXNoUGlwZS5sb2NhbFVuaWZvcm1zO1xuICAgICAgc2hhZGVyLmdyb3Vwc1sxXSA9IHJlbmRlcmVyLnJlbmRlclBpcGVzLnVuaWZvcm1CYXRjaC5nZXRVbmlmb3JtQmluZEdyb3VwKGxvY2FsVW5pZm9ybXMsIHRydWUpO1xuICAgIH1cbiAgICByZW5kZXJlci5lbmNvZGVyLmRyYXcoe1xuICAgICAgZ2VvbWV0cnk6IG1lc2guX2dlb21ldHJ5LFxuICAgICAgc2hhZGVyLFxuICAgICAgc3RhdGU6IG1lc2guc3RhdGVcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3NoYWRlci5kZXN0cm95KHRydWUpO1xuICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVNZXNoQWRhcHRlci5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzQWRhcHRvclxuICBdLFxuICBuYW1lOiBcIm1lc2hcIlxufTtcblxuZXhwb3J0IHsgR3B1TWVzaEFkYXB0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdU1lc2hBZGFwdGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSB9IGZyb20gJy4uLy4uL2hpZ2gtc2hhZGVyL2NvbXBpbGVIaWdoU2hhZGVyVG9Qcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBjb2xvckJpdCB9IGZyb20gJy4uLy4uL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2NvbG9yQml0Lm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdCB9IGZyb20gJy4uLy4uL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2dlbmVyYXRlVGV4dHVyZUJhdGNoQml0Lm1qcyc7XG5pbXBvcnQgeyByb3VuZFBpeGVsc0JpdCB9IGZyb20gJy4uLy4uL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL3JvdW5kUGl4ZWxzQml0Lm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9TaGFkZXIubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9TdGF0ZS5tanMnO1xuaW1wb3J0IHsgZ2V0TWF4VGV4dHVyZXNQZXJCYXRjaCB9IGZyb20gJy4uL2dsL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzJztcbmltcG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9IGZyb20gJy4vZ2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcFN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbmNsYXNzIEdwdUJhdGNoQWRhcHRvciB7XG4gIGluaXQoKSB7XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcImJhdGNoXCIsXG4gICAgICBiaXRzOiBbXG4gICAgICAgIGNvbG9yQml0LFxuICAgICAgICBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdChnZXRNYXhUZXh0dXJlc1BlckJhdGNoKCkpLFxuICAgICAgICByb3VuZFBpeGVsc0JpdFxuICAgICAgXVxuICAgIH0pO1xuICAgIHRoaXMuX3NoYWRlciA9IG5ldyBTaGFkZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdyb3Vwczoge1xuICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGR5bmFtaWNhbGx5IGFsbG9jYXRlZFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXJ0KGJhdGNoUGlwZSwgZ2VvbWV0cnkpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IGJhdGNoUGlwZS5yZW5kZXJlcjtcbiAgICBjb25zdCBlbmNvZGVyID0gcmVuZGVyZXIuZW5jb2RlcjtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5fc2hhZGVyLmdwdVByb2dyYW07XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICBlbmNvZGVyLnNldEdlb21ldHJ5KGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICB0ZW1wU3RhdGUuYmxlbmRNb2RlID0gXCJub3JtYWxcIjtcbiAgICByZW5kZXJlci5waXBlbGluZS5nZXRQaXBlbGluZShcbiAgICAgIGdlb21ldHJ5LFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIHRlbXBTdGF0ZVxuICAgICk7XG4gICAgY29uc3QgZ2xvYmFsVW5pZm9ybXNCaW5kR3JvdXAgPSByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy5iaW5kR3JvdXA7XG4gICAgZW5jb2Rlci5yZXNldEJpbmRHcm91cCgxKTtcbiAgICBlbmNvZGVyLnNldEJpbmRHcm91cCgwLCBnbG9iYWxVbmlmb3Jtc0JpbmRHcm91cCwgcHJvZ3JhbSk7XG4gIH1cbiAgZXhlY3V0ZShiYXRjaFBpcGUsIGJhdGNoKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuX3NoYWRlci5ncHVQcm9ncmFtO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gYmF0Y2hQaXBlLnJlbmRlcmVyO1xuICAgIGNvbnN0IGVuY29kZXIgPSByZW5kZXJlci5lbmNvZGVyO1xuICAgIGlmICghYmF0Y2guYmluZEdyb3VwKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlQmF0Y2ggPSBiYXRjaC50ZXh0dXJlcztcbiAgICAgIGJhdGNoLmJpbmRHcm91cCA9IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCh0ZXh0dXJlQmF0Y2gudGV4dHVyZXMsIHRleHR1cmVCYXRjaC5jb3VudCk7XG4gICAgfVxuICAgIHRlbXBTdGF0ZS5ibGVuZE1vZGUgPSBiYXRjaC5ibGVuZE1vZGU7XG4gICAgY29uc3QgZ3B1QmluZEdyb3VwID0gcmVuZGVyZXIuYmluZEdyb3VwLmdldEJpbmRHcm91cChcbiAgICAgIGJhdGNoLmJpbmRHcm91cCxcbiAgICAgIHByb2dyYW0sXG4gICAgICAxXG4gICAgKTtcbiAgICBjb25zdCBwaXBlbGluZSA9IHJlbmRlcmVyLnBpcGVsaW5lLmdldFBpcGVsaW5lKFxuICAgICAgdGhpcy5fZ2VvbWV0cnksXG4gICAgICBwcm9ncmFtLFxuICAgICAgdGVtcFN0YXRlXG4gICAgKTtcbiAgICBiYXRjaC5iaW5kR3JvdXAuX3RvdWNoKHJlbmRlcmVyLnRleHR1cmVHQy5jb3VudCk7XG4gICAgZW5jb2Rlci5zZXRQaXBlbGluZShwaXBlbGluZSk7XG4gICAgZW5jb2Rlci5yZW5kZXJQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMSwgZ3B1QmluZEdyb3VwKTtcbiAgICBlbmNvZGVyLnJlbmRlclBhc3NFbmNvZGVyLmRyYXdJbmRleGVkKGJhdGNoLnNpemUsIDEsIGJhdGNoLnN0YXJ0KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3NoYWRlci5kZXN0cm95KHRydWUpO1xuICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVCYXRjaEFkYXB0b3IuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlc0FkYXB0b3JcbiAgXSxcbiAgbmFtZTogXCJiYXRjaFwiXG59O1xuXG5leHBvcnQgeyBHcHVCYXRjaEFkYXB0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdUJhdGNoQWRhcHRvci5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQmluZEdyb3VwU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9oYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdwdSkge1xuICAgIHRoaXMuX2dwdSA9IGdwdTtcbiAgfVxuICBnZXRCaW5kR3JvdXAoYmluZEdyb3VwLCBwcm9ncmFtLCBncm91cEluZGV4KSB7XG4gICAgYmluZEdyb3VwLl91cGRhdGVLZXkoKTtcbiAgICBjb25zdCBncHVCaW5kR3JvdXAgPSB0aGlzLl9oYXNoW2JpbmRHcm91cC5fa2V5XSB8fCB0aGlzLl9jcmVhdGVCaW5kR3JvdXAoYmluZEdyb3VwLCBwcm9ncmFtLCBncm91cEluZGV4KTtcbiAgICByZXR1cm4gZ3B1QmluZEdyb3VwO1xuICB9XG4gIF9jcmVhdGVCaW5kR3JvdXAoZ3JvdXAsIHByb2dyYW0sIGdyb3VwSW5kZXgpIHtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLl9ncHUuZGV2aWNlO1xuICAgIGNvbnN0IGdyb3VwTGF5b3V0ID0gcHJvZ3JhbS5sYXlvdXRbZ3JvdXBJbmRleF07XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgZm9yIChjb25zdCBqIGluIGdyb3VwTGF5b3V0KSB7XG4gICAgICBjb25zdCByZXNvdXJjZSA9IGdyb3VwLnJlc291cmNlc1tqXSA/PyBncm91cC5yZXNvdXJjZXNbZ3JvdXBMYXlvdXRbal1dO1xuICAgICAgbGV0IGdwdVJlc291cmNlO1xuICAgICAgaWYgKHJlc291cmNlLl9yZXNvdXJjZVR5cGUgPT09IFwidW5pZm9ybUdyb3VwXCIpIHtcbiAgICAgICAgY29uc3QgdW5pZm9ybUdyb3VwID0gcmVzb3VyY2U7XG4gICAgICAgIHJlbmRlcmVyLnViby51cGRhdGVVbmlmb3JtR3JvdXAodW5pZm9ybUdyb3VwKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdW5pZm9ybUdyb3VwLmJ1ZmZlcjtcbiAgICAgICAgZ3B1UmVzb3VyY2UgPSB7XG4gICAgICAgICAgYnVmZmVyOiByZW5kZXJlci5idWZmZXIuZ2V0R1BVQnVmZmVyKGJ1ZmZlciksXG4gICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgIHNpemU6IGJ1ZmZlci5kZXNjcmlwdG9yLnNpemVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UuX3Jlc291cmNlVHlwZSA9PT0gXCJidWZmZXJcIikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSByZXNvdXJjZTtcbiAgICAgICAgZ3B1UmVzb3VyY2UgPSB7XG4gICAgICAgICAgYnVmZmVyOiByZW5kZXJlci5idWZmZXIuZ2V0R1BVQnVmZmVyKGJ1ZmZlciksXG4gICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgIHNpemU6IGJ1ZmZlci5kZXNjcmlwdG9yLnNpemVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UuX3Jlc291cmNlVHlwZSA9PT0gXCJidWZmZXJSZXNvdXJjZVwiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlclJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgICAgIGdwdVJlc291cmNlID0ge1xuICAgICAgICAgIGJ1ZmZlcjogcmVuZGVyZXIuYnVmZmVyLmdldEdQVUJ1ZmZlcihidWZmZXJSZXNvdXJjZS5idWZmZXIpLFxuICAgICAgICAgIG9mZnNldDogYnVmZmVyUmVzb3VyY2Uub2Zmc2V0LFxuICAgICAgICAgIHNpemU6IGJ1ZmZlclJlc291cmNlLnNpemVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UuX3Jlc291cmNlVHlwZSA9PT0gXCJ0ZXh0dXJlU2FtcGxlclwiKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSByZXNvdXJjZTtcbiAgICAgICAgZ3B1UmVzb3VyY2UgPSByZW5kZXJlci50ZXh0dXJlLmdldEdwdVNhbXBsZXIoc2FtcGxlcik7XG4gICAgICB9IGVsc2UgaWYgKHJlc291cmNlLl9yZXNvdXJjZVR5cGUgPT09IFwidGV4dHVyZVNvdXJjZVwiKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSByZXNvdXJjZTtcbiAgICAgICAgZ3B1UmVzb3VyY2UgPSByZW5kZXJlci50ZXh0dXJlLmdldEdwdVNvdXJjZSh0ZXh0dXJlKS5jcmVhdGVWaWV3KHt9KTtcbiAgICAgIH1cbiAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgIGJpbmRpbmc6IGdyb3VwTGF5b3V0W2pdLFxuICAgICAgICByZXNvdXJjZTogZ3B1UmVzb3VyY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBsYXlvdXQgPSByZW5kZXJlci5zaGFkZXIuZ2V0UHJvZ3JhbURhdGEocHJvZ3JhbSkuYmluZEdyb3Vwc1tncm91cEluZGV4XTtcbiAgICBjb25zdCBncHVCaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgIGxheW91dCxcbiAgICAgIGVudHJpZXNcbiAgICB9KTtcbiAgICB0aGlzLl9oYXNoW2dyb3VwLl9rZXldID0gZ3B1QmluZEdyb3VwO1xuICAgIHJldHVybiBncHVCaW5kR3JvdXA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9oYXNoKSkge1xuICAgICAgdGhpcy5faGFzaFtrZXldID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5faGFzaCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuQmluZEdyb3VwU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiYmluZEdyb3VwXCJcbn07XG5cbmV4cG9ydCB7IEJpbmRHcm91cFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmluZEdyb3VwU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGZhc3RDb3B5IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2J1ZmZlci91dGlscy9mYXN0Q29weS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdUJ1ZmZlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2dwdUJ1ZmZlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9tYW5hZ2VkQnVmZmVycyA9IFtdO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ3B1KSB7XG4gICAgdGhpcy5fZ3B1ID0gZ3B1O1xuICB9XG4gIGdldEdQVUJ1ZmZlcihidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1QnVmZmVyc1tidWZmZXIudWlkXSB8fCB0aGlzLmNyZWF0ZUdQVUJ1ZmZlcihidWZmZXIpO1xuICB9XG4gIHVwZGF0ZUJ1ZmZlcihidWZmZXIpIHtcbiAgICBjb25zdCBncHVCdWZmZXIgPSB0aGlzLl9ncHVCdWZmZXJzW2J1ZmZlci51aWRdIHx8IHRoaXMuY3JlYXRlR1BVQnVmZmVyKGJ1ZmZlcik7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5kYXRhO1xuICAgIGlmIChidWZmZXIuX3VwZGF0ZUlEICYmIGRhdGEpIHtcbiAgICAgIGJ1ZmZlci5fdXBkYXRlSUQgPSAwO1xuICAgICAgdGhpcy5fZ3B1LmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcbiAgICAgICAgZ3B1QnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgLy8gcm91bmQgdG8gdGhlIG5lYXJlc3QgNCBieXRlc1xuICAgICAgICAoYnVmZmVyLl91cGRhdGVTaXplIHx8IGRhdGEuYnl0ZUxlbmd0aCkgKyAzICYgfjNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBncHVCdWZmZXI7XG4gIH1cbiAgLyoqIGRpc3Bvc2UgYWxsIFdlYkdMIHJlc291cmNlcyBvZiBhbGwgbWFuYWdlZCBidWZmZXJzICovXG4gIGRlc3Ryb3lBbGwoKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLl9ncHVCdWZmZXJzKSB7XG4gICAgICB0aGlzLl9ncHVCdWZmZXJzW2lkXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2dwdUJ1ZmZlcnMgPSB7fTtcbiAgfVxuICBjcmVhdGVHUFVCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKCF0aGlzLl9ncHVCdWZmZXJzW2J1ZmZlci51aWRdKSB7XG4gICAgICBidWZmZXIub24oXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGVCdWZmZXIsIHRoaXMpO1xuICAgICAgYnVmZmVyLm9uKFwiY2hhbmdlXCIsIHRoaXMub25CdWZmZXJDaGFuZ2UsIHRoaXMpO1xuICAgICAgYnVmZmVyLm9uKFwiZGVzdHJveVwiLCB0aGlzLm9uQnVmZmVyRGVzdHJveSwgdGhpcyk7XG4gICAgICB0aGlzLl9tYW5hZ2VkQnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuICAgIGNvbnN0IGdwdUJ1ZmZlciA9IHRoaXMuX2dwdS5kZXZpY2UuY3JlYXRlQnVmZmVyKGJ1ZmZlci5kZXNjcmlwdG9yKTtcbiAgICBidWZmZXIuX3VwZGF0ZUlEID0gMDtcbiAgICBpZiAoYnVmZmVyLmRhdGEpIHtcbiAgICAgIGZhc3RDb3B5KGJ1ZmZlci5kYXRhLmJ1ZmZlciwgZ3B1QnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpO1xuICAgICAgZ3B1QnVmZmVyLnVubWFwKCk7XG4gICAgfVxuICAgIHRoaXMuX2dwdUJ1ZmZlcnNbYnVmZmVyLnVpZF0gPSBncHVCdWZmZXI7XG4gICAgcmV0dXJuIGdwdUJ1ZmZlcjtcbiAgfVxuICBvbkJ1ZmZlckNoYW5nZShidWZmZXIpIHtcbiAgICBjb25zdCBncHVCdWZmZXIgPSB0aGlzLl9ncHVCdWZmZXJzW2J1ZmZlci51aWRdO1xuICAgIGdwdUJ1ZmZlci5kZXN0cm95KCk7XG4gICAgYnVmZmVyLl91cGRhdGVJRCA9IDA7XG4gICAgdGhpcy5fZ3B1QnVmZmVyc1tidWZmZXIudWlkXSA9IHRoaXMuY3JlYXRlR1BVQnVmZmVyKGJ1ZmZlcik7XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIGJ1ZmZlclxuICAgKiBAcGFyYW0gYnVmZmVyIC0gYnVmZmVyIHdpdGggZGF0YVxuICAgKi9cbiAgb25CdWZmZXJEZXN0cm95KGJ1ZmZlcikge1xuICAgIHRoaXMuX21hbmFnZWRCdWZmZXJzLnNwbGljZSh0aGlzLl9tYW5hZ2VkQnVmZmVycy5pbmRleE9mKGJ1ZmZlciksIDEpO1xuICAgIHRoaXMuX2Rlc3Ryb3lCdWZmZXIoYnVmZmVyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX21hbmFnZWRCdWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4gdGhpcy5fZGVzdHJveUJ1ZmZlcihidWZmZXIpKTtcbiAgICB0aGlzLl9tYW5hZ2VkQnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5fZ3B1QnVmZmVycyA9IG51bGw7XG4gIH1cbiAgX2Rlc3Ryb3lCdWZmZXIoYnVmZmVyKSB7XG4gICAgY29uc3QgZ3B1QnVmZmVyID0gdGhpcy5fZ3B1QnVmZmVyc1tidWZmZXIudWlkXTtcbiAgICBncHVCdWZmZXIuZGVzdHJveSgpO1xuICAgIGJ1ZmZlci5vZmYoXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGVCdWZmZXIsIHRoaXMpO1xuICAgIGJ1ZmZlci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5vbkJ1ZmZlckNoYW5nZSwgdGhpcyk7XG4gICAgYnVmZmVyLm9mZihcImRlc3Ryb3lcIiwgdGhpcy5vbkJ1ZmZlckRlc3Ryb3ksIHRoaXMpO1xuICAgIHRoaXMuX2dwdUJ1ZmZlcnNbYnVmZmVyLnVpZF0gPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1QnVmZmVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiYnVmZmVyXCJcbn07XG5cbmV4cG9ydCB7IEdwdUJ1ZmZlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1QnVmZmVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcHVDb2xvck1hc2tTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2NvbG9yTWFza0NhY2hlID0gMTU7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBzZXRNYXNrKGNvbG9yTWFzaykge1xuICAgIGlmICh0aGlzLl9jb2xvck1hc2tDYWNoZSA9PT0gY29sb3JNYXNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbG9yTWFza0NhY2hlID0gY29sb3JNYXNrO1xuICAgIHRoaXMuX3JlbmRlcmVyLnBpcGVsaW5lLnNldENvbG9yTWFzayhjb2xvck1hc2spO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX2NvbG9yTWFza0NhY2hlID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdUNvbG9yTWFza1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcImNvbG9yTWFza1wiXG59O1xuXG5leHBvcnQgeyBHcHVDb2xvck1hc2tTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdUNvbG9yTWFza1N5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdURldmljZVN5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYkdQVVJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgYXN5bmMgaW5pdChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2luaXRQcm9taXNlKVxuICAgICAgcmV0dXJuIHRoaXMuX2luaXRQcm9taXNlO1xuICAgIHRoaXMuX2luaXRQcm9taXNlID0gdGhpcy5fY3JlYXRlRGV2aWNlQW5kQWRhcHRvcihvcHRpb25zKS50aGVuKChncHUpID0+IHtcbiAgICAgIHRoaXMuZ3B1ID0gZ3B1O1xuICAgICAgdGhpcy5fcmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmVtaXQodGhpcy5ncHUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9pbml0UHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHRoZSBjb250ZXh0IGNoYW5nZSBldmVudFxuICAgKiBAcGFyYW0gZ3B1XG4gICAqL1xuICBjb250ZXh0Q2hhbmdlKGdwdSkge1xuICAgIHRoaXMuX3JlbmRlcmVyLmdwdSA9IGdwdTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIFdlYkdMIENvbnRleHRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IGdldHMgcGFzc2VkIGluIHRvIHRoZSBjYW52YXMgZWxlbWVudCBjb250YWluaW5nIHRoZVxuICAgKiAgICBjb250ZXh0IGF0dHJpYnV0ZXNcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvZ2V0Q29udGV4dFxuICAgKiBAcmV0dXJucyB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgV2ViR0wgY29udGV4dFxuICAgKi9cbiAgYXN5bmMgX2NyZWF0ZURldmljZUFuZEFkYXB0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBET01BZGFwdGVyLmdldCgpLmdldE5hdmlnYXRvcigpLmdwdS5yZXF1ZXN0QWRhcHRlcih7XG4gICAgICBwb3dlclByZWZlcmVuY2U6IG9wdGlvbnMucG93ZXJQcmVmZXJlbmNlLFxuICAgICAgZm9yY2VGYWxsYmFja0FkYXB0ZXI6IG9wdGlvbnMuZm9yY2VGYWxsYmFja0FkYXB0ZXJcbiAgICB9KTtcbiAgICBjb25zdCByZXF1aXJlZEZlYXR1cmVzID0gW1xuICAgICAgXCJ0ZXh0dXJlLWNvbXByZXNzaW9uLWJjXCIsXG4gICAgICBcInRleHR1cmUtY29tcHJlc3Npb24tYXN0Y1wiLFxuICAgICAgXCJ0ZXh0dXJlLWNvbXByZXNzaW9uLWV0YzJcIlxuICAgIF0uZmlsdGVyKChmZWF0dXJlKSA9PiBhZGFwdGVyLmZlYXR1cmVzLmhhcyhmZWF0dXJlKSk7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKHtcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXNcbiAgICB9KTtcbiAgICByZXR1cm4geyBhZGFwdGVyLCBkZXZpY2UgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZ3B1ID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVEZXZpY2VTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJkZXZpY2VcIlxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgR3B1RGV2aWNlU3lzdGVtLiAqL1xuR3B1RGV2aWNlU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFdlYkdQVU9wdGlvbnMucG93ZXJQcmVmZXJlbmNlfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqL1xuICBwb3dlclByZWZlcmVuY2U6IHZvaWQgMCxcbiAgLyoqXG4gICAqIEZvcmNlIHRoZSB1c2Ugb2YgdGhlIGZhbGxiYWNrIGFkYXB0ZXJcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZvcmNlRmFsbGJhY2tBZGFwdGVyOiBmYWxzZVxufTtcblxuZXhwb3J0IHsgR3B1RGV2aWNlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVEZXZpY2VTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdUVuY29kZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2JvdW5kQmluZEdyb3VwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fYm91bmRWZXJ0ZXhCdWZmZXIgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHJlbmRlclN0YXJ0KCkge1xuICAgIHRoaXMuY29tbWFuZEZpbmlzaGVkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmVDb21tYW5kRmluaXNoZWQgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSB0aGlzLl9yZW5kZXJlci5ncHUuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gIH1cbiAgYmVnaW5SZW5kZXJQYXNzKGdwdVJlbmRlclRhcmdldCkge1xuICAgIHRoaXMuZW5kUmVuZGVyUGFzcygpO1xuICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyID0gdGhpcy5jb21tYW5kRW5jb2Rlci5iZWdpblJlbmRlclBhc3MoZ3B1UmVuZGVyVGFyZ2V0LmRlc2NyaXB0b3IpO1xuICB9XG4gIGVuZFJlbmRlclBhc3MoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyUGFzc0VuY29kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyUGFzc0VuY29kZXIuZW5kKCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyUGFzc0VuY29kZXIgPSBudWxsO1xuICB9XG4gIHNldFZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgdGhpcy5yZW5kZXJQYXNzRW5jb2Rlci5zZXRWaWV3cG9ydCh2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0LCAwLCAxKTtcbiAgfVxuICBzZXRQaXBlbGluZUZyb21HZW9tZXRyeVByb2dyYW1BbmRTdGF0ZShnZW9tZXRyeSwgcHJvZ3JhbSwgc3RhdGUsIHRvcG9sb2d5KSB7XG4gICAgY29uc3QgcGlwZWxpbmUgPSB0aGlzLl9yZW5kZXJlci5waXBlbGluZS5nZXRQaXBlbGluZShnZW9tZXRyeSwgcHJvZ3JhbSwgc3RhdGUsIHRvcG9sb2d5KTtcbiAgICB0aGlzLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcbiAgfVxuICBzZXRQaXBlbGluZShwaXBlbGluZSkge1xuICAgIGlmICh0aGlzLl9ib3VuZFBpcGVsaW5lID09PSBwaXBlbGluZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9ib3VuZFBpcGVsaW5lID0gcGlwZWxpbmU7XG4gICAgdGhpcy5yZW5kZXJQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShwaXBlbGluZSk7XG4gIH1cbiAgX3NldFZlcnRleEJ1ZmZlcihpbmRleCwgYnVmZmVyKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kVmVydGV4QnVmZmVyW2luZGV4XSA9PT0gYnVmZmVyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2JvdW5kVmVydGV4QnVmZmVyW2luZGV4XSA9IGJ1ZmZlcjtcbiAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcihpbmRleCwgdGhpcy5fcmVuZGVyZXIuYnVmZmVyLnVwZGF0ZUJ1ZmZlcihidWZmZXIpKTtcbiAgfVxuICBfc2V0SW5kZXhCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kSW5kZXhCdWZmZXIgPT09IGJ1ZmZlcilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9ib3VuZEluZGV4QnVmZmVyID0gYnVmZmVyO1xuICAgIGNvbnN0IGluZGV4Rm9ybWF0ID0gYnVmZmVyLmRhdGEuQllURVNfUEVSX0VMRU1FTlQgPT09IDIgPyBcInVpbnQxNlwiIDogXCJ1aW50MzJcIjtcbiAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyLnNldEluZGV4QnVmZmVyKHRoaXMuX3JlbmRlcmVyLmJ1ZmZlci51cGRhdGVCdWZmZXIoYnVmZmVyKSwgaW5kZXhGb3JtYXQpO1xuICB9XG4gIHJlc2V0QmluZEdyb3VwKGluZGV4KSB7XG4gICAgdGhpcy5fYm91bmRCaW5kR3JvdXBbaW5kZXhdID0gbnVsbDtcbiAgfVxuICBzZXRCaW5kR3JvdXAoaW5kZXgsIGJpbmRHcm91cCwgcHJvZ3JhbSkge1xuICAgIGlmICh0aGlzLl9ib3VuZEJpbmRHcm91cFtpbmRleF0gPT09IGJpbmRHcm91cClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9ib3VuZEJpbmRHcm91cFtpbmRleF0gPSBiaW5kR3JvdXA7XG4gICAgYmluZEdyb3VwLl90b3VjaCh0aGlzLl9yZW5kZXJlci50ZXh0dXJlR0MuY291bnQpO1xuICAgIGNvbnN0IGdwdUJpbmRHcm91cCA9IHRoaXMuX3JlbmRlcmVyLmJpbmRHcm91cC5nZXRCaW5kR3JvdXAoYmluZEdyb3VwLCBwcm9ncmFtLCBpbmRleCk7XG4gICAgdGhpcy5yZW5kZXJQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoaW5kZXgsIGdwdUJpbmRHcm91cCk7XG4gIH1cbiAgc2V0R2VvbWV0cnkoZ2VvbWV0cnksIHByb2dyYW0pIHtcbiAgICBjb25zdCBidWZmZXJzVG9CaW5kID0gdGhpcy5fcmVuZGVyZXIucGlwZWxpbmUuZ2V0QnVmZmVyTmFtZXNUb0JpbmQoZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIGZvciAoY29uc3QgaSBpbiBidWZmZXJzVG9CaW5kKSB7XG4gICAgICB0aGlzLl9zZXRWZXJ0ZXhCdWZmZXIoaSwgZ2VvbWV0cnkuYXR0cmlidXRlc1tidWZmZXJzVG9CaW5kW2ldXS5idWZmZXIpO1xuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcbiAgICAgIHRoaXMuX3NldEluZGV4QnVmZmVyKGdlb21ldHJ5LmluZGV4QnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgX3NldFNoYWRlckJpbmRHcm91cHMoc2hhZGVyLCBza2lwU3luYykge1xuICAgIGZvciAoY29uc3QgaSBpbiBzaGFkZXIuZ3JvdXBzKSB7XG4gICAgICBjb25zdCBiaW5kR3JvdXAgPSBzaGFkZXIuZ3JvdXBzW2ldO1xuICAgICAgaWYgKCFza2lwU3luYykge1xuICAgICAgICB0aGlzLl9zeW5jQmluZEdyb3VwKGJpbmRHcm91cCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEJpbmRHcm91cChpLCBiaW5kR3JvdXAsIHNoYWRlci5ncHVQcm9ncmFtKTtcbiAgICB9XG4gIH1cbiAgX3N5bmNCaW5kR3JvdXAoYmluZEdyb3VwKSB7XG4gICAgZm9yIChjb25zdCBqIGluIGJpbmRHcm91cC5yZXNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gYmluZEdyb3VwLnJlc291cmNlc1tqXTtcbiAgICAgIGlmIChyZXNvdXJjZS5pc1VuaWZvcm1Hcm91cCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci51Ym8udXBkYXRlVW5pZm9ybUdyb3VwKHJlc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhdyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyBnZW9tZXRyeSwgc2hhZGVyLCBzdGF0ZSwgdG9wb2xvZ3ksIHNpemUsIHN0YXJ0LCBpbnN0YW5jZUNvdW50LCBza2lwU3luYyB9ID0gb3B0aW9ucztcbiAgICB0aGlzLnNldFBpcGVsaW5lRnJvbUdlb21ldHJ5UHJvZ3JhbUFuZFN0YXRlKGdlb21ldHJ5LCBzaGFkZXIuZ3B1UHJvZ3JhbSwgc3RhdGUsIHRvcG9sb2d5KTtcbiAgICB0aGlzLnNldEdlb21ldHJ5KGdlb21ldHJ5LCBzaGFkZXIuZ3B1UHJvZ3JhbSk7XG4gICAgdGhpcy5fc2V0U2hhZGVyQmluZEdyb3VwcyhzaGFkZXIsIHNraXBTeW5jKTtcbiAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyUGFzc0VuY29kZXIuZHJhd0luZGV4ZWQoXG4gICAgICAgIHNpemUgfHwgZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5sZW5ndGgsXG4gICAgICAgIGluc3RhbmNlQ291bnQgfHwgZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCxcbiAgICAgICAgc3RhcnQgfHwgMFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJQYXNzRW5jb2Rlci5kcmF3KHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpLCBpbnN0YW5jZUNvdW50IHx8IGdlb21ldHJ5Lmluc3RhbmNlQ291bnQsIHN0YXJ0IHx8IDApO1xuICAgIH1cbiAgfVxuICBmaW5pc2hSZW5kZXJQYXNzKCkge1xuICAgIGlmICh0aGlzLnJlbmRlclBhc3NFbmNvZGVyKSB7XG4gICAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyLmVuZCgpO1xuICAgICAgdGhpcy5yZW5kZXJQYXNzRW5jb2RlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHBvc3RyZW5kZXIoKSB7XG4gICAgdGhpcy5maW5pc2hSZW5kZXJQYXNzKCk7XG4gICAgdGhpcy5fZ3B1LmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcbiAgICB0aGlzLl9yZXNvbHZlQ29tbWFuZEZpbmlzaGVkKCk7XG4gICAgdGhpcy5jb21tYW5kRW5jb2RlciA9IG51bGw7XG4gIH1cbiAgLy8gcmVzdG9yZXMgYSByZW5kZXIgcGFzcyBpZiBmaW5pc2hSZW5kZXJQYXNzIHdhcyBjYWxsZWRcbiAgLy8gbm90IG9wdGltaXNlZCBhcyByZWFsbHkgdXNlZCBmb3IgZGVidWdnaW5nIVxuICAvLyB1c2VkIHdoZW4gd2Ugd2FudCB0byBzdG9wIGRyYXdpbmcgYW5kIGxvZyBhIHRleHR1cmUuLlxuICByZXN0b3JlUmVuZGVyUGFzcygpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmFkYXB0b3IuZ2V0RGVzY3JpcHRvcihcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclRhcmdldC5yZW5kZXJUYXJnZXQsXG4gICAgICBmYWxzZSxcbiAgICAgIFswLCAwLCAwLCAxXVxuICAgICk7XG4gICAgdGhpcy5yZW5kZXJQYXNzRW5jb2RlciA9IHRoaXMuY29tbWFuZEVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKGRlc2NyaXB0b3IpO1xuICAgIGNvbnN0IGJvdW5kUGlwZWxpbmUgPSB0aGlzLl9ib3VuZFBpcGVsaW5lO1xuICAgIGNvbnN0IGJvdW5kVmVydGV4QnVmZmVyID0geyAuLi50aGlzLl9ib3VuZFZlcnRleEJ1ZmZlciB9O1xuICAgIGNvbnN0IGJvdW5kSW5kZXhCdWZmZXIgPSB0aGlzLl9ib3VuZEluZGV4QnVmZmVyO1xuICAgIGNvbnN0IGJvdW5kQmluZEdyb3VwID0geyAuLi50aGlzLl9ib3VuZEJpbmRHcm91cCB9O1xuICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlclRhcmdldC52aWV3cG9ydDtcbiAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyLnNldFZpZXdwb3J0KHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQsIDAsIDEpO1xuICAgIHRoaXMuc2V0UGlwZWxpbmUoYm91bmRQaXBlbGluZSk7XG4gICAgZm9yIChjb25zdCBpIGluIGJvdW5kVmVydGV4QnVmZmVyKSB7XG4gICAgICB0aGlzLl9zZXRWZXJ0ZXhCdWZmZXIoaSwgYm91bmRWZXJ0ZXhCdWZmZXJbaV0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgaW4gYm91bmRCaW5kR3JvdXApIHtcbiAgICAgIHRoaXMuc2V0QmluZEdyb3VwKGksIGJvdW5kQmluZEdyb3VwW2ldLCBudWxsKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0SW5kZXhCdWZmZXIoYm91bmRJbmRleEJ1ZmZlcik7XG4gIH1cbiAgX2NsZWFyQ2FjaGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB0aGlzLl9ib3VuZEJpbmRHcm91cFtpXSA9IG51bGw7XG4gICAgICB0aGlzLl9ib3VuZFZlcnRleEJ1ZmZlcltpXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2JvdW5kSW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kUGlwZWxpbmUgPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX2dwdSA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRCaW5kR3JvdXAgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kVmVydGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZEluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZFBpcGVsaW5lID0gbnVsbDtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdwdSkge1xuICAgIHRoaXMuX2dwdSA9IGdwdTtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdUVuY29kZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1dLFxuICBuYW1lOiBcImVuY29kZXJcIixcbiAgcHJpb3JpdHk6IDFcbn07XG5cbmV4cG9ydCB7IEdwdUVuY29kZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdUVuY29kZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgU1RFTkNJTF9NT0RFUyB9IGZyb20gJy4uL3NoYXJlZC9zdGF0ZS9jb25zdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdVN0ZW5jaWxTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlclRhcmdldFN0ZW5jaWxTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0Lm9uUmVuZGVyVGFyZ2V0Q2hhbmdlLmFkZCh0aGlzKTtcbiAgfVxuICBvblJlbmRlclRhcmdldENoYW5nZShyZW5kZXJUYXJnZXQpIHtcbiAgICBsZXQgc3RlbmNpbFN0YXRlID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3RlbmNpbFN0YXRlW3JlbmRlclRhcmdldC51aWRdO1xuICAgIGlmICghc3RlbmNpbFN0YXRlKSB7XG4gICAgICBzdGVuY2lsU3RhdGUgPSB0aGlzLl9yZW5kZXJUYXJnZXRTdGVuY2lsU3RhdGVbcmVuZGVyVGFyZ2V0LnVpZF0gPSB7XG4gICAgICAgIHN0ZW5jaWxNb2RlOiBTVEVOQ0lMX01PREVTLkRJU0FCTEVELFxuICAgICAgICBzdGVuY2lsUmVmZXJlbmNlOiAwXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgdGhpcy5zZXRTdGVuY2lsTW9kZShzdGVuY2lsU3RhdGUuc3RlbmNpbE1vZGUsIHN0ZW5jaWxTdGF0ZS5zdGVuY2lsUmVmZXJlbmNlKTtcbiAgfVxuICBzZXRTdGVuY2lsTW9kZShzdGVuY2lsTW9kZSwgc3RlbmNpbFJlZmVyZW5jZSkge1xuICAgIGNvbnN0IHN0ZW5jaWxTdGF0ZSA9IHRoaXMuX3JlbmRlclRhcmdldFN0ZW5jaWxTdGF0ZVt0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQudWlkXTtcbiAgICBzdGVuY2lsU3RhdGUuc3RlbmNpbE1vZGUgPSBzdGVuY2lsTW9kZTtcbiAgICBzdGVuY2lsU3RhdGUuc3RlbmNpbFJlZmVyZW5jZSA9IHN0ZW5jaWxSZWZlcmVuY2U7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICByZW5kZXJlci5waXBlbGluZS5zZXRTdGVuY2lsTW9kZShzdGVuY2lsTW9kZSk7XG4gICAgcmVuZGVyZXIuZW5jb2Rlci5yZW5kZXJQYXNzRW5jb2Rlci5zZXRTdGVuY2lsUmVmZXJlbmNlKHN0ZW5jaWxSZWZlcmVuY2UpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0Lm9uUmVuZGVyVGFyZ2V0Q2hhbmdlLnJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXRTdGVuY2lsU3RhdGUgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1U3RlbmNpbFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcInN0ZW5jaWxcIlxufTtcblxuZXhwb3J0IHsgR3B1U3RlbmNpbFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1U3RlbmNpbFN5c3RlbS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFdHU0xfQUxJR05fU0laRV9EQVRBID0ge1xuICBpMzI6IHsgYWxpZ246IDQsIHNpemU6IDQgfSxcbiAgdTMyOiB7IGFsaWduOiA0LCBzaXplOiA0IH0sXG4gIGYzMjogeyBhbGlnbjogNCwgc2l6ZTogNCB9LFxuICBmMTY6IHsgYWxpZ246IDIsIHNpemU6IDIgfSxcbiAgXCJ2ZWMyPGkzMj5cIjogeyBhbGlnbjogOCwgc2l6ZTogOCB9LFxuICBcInZlYzI8dTMyPlwiOiB7IGFsaWduOiA4LCBzaXplOiA4IH0sXG4gIFwidmVjMjxmMzI+XCI6IHsgYWxpZ246IDgsIHNpemU6IDggfSxcbiAgXCJ2ZWMyPGYxNj5cIjogeyBhbGlnbjogNCwgc2l6ZTogNCB9LFxuICBcInZlYzM8aTMyPlwiOiB7IGFsaWduOiAxNiwgc2l6ZTogMTIgfSxcbiAgXCJ2ZWMzPHUzMj5cIjogeyBhbGlnbjogMTYsIHNpemU6IDEyIH0sXG4gIFwidmVjMzxmMzI+XCI6IHsgYWxpZ246IDE2LCBzaXplOiAxMiB9LFxuICBcInZlYzM8ZjE2PlwiOiB7IGFsaWduOiA4LCBzaXplOiA2IH0sXG4gIFwidmVjNDxpMzI+XCI6IHsgYWxpZ246IDE2LCBzaXplOiAxNiB9LFxuICBcInZlYzQ8dTMyPlwiOiB7IGFsaWduOiAxNiwgc2l6ZTogMTYgfSxcbiAgXCJ2ZWM0PGYzMj5cIjogeyBhbGlnbjogMTYsIHNpemU6IDE2IH0sXG4gIFwidmVjNDxmMTY+XCI6IHsgYWxpZ246IDgsIHNpemU6IDggfSxcbiAgXCJtYXQyeDI8ZjMyPlwiOiB7IGFsaWduOiA4LCBzaXplOiAxNiB9LFxuICBcIm1hdDJ4MjxmMTY+XCI6IHsgYWxpZ246IDQsIHNpemU6IDggfSxcbiAgXCJtYXQzeDI8ZjMyPlwiOiB7IGFsaWduOiA4LCBzaXplOiAyNCB9LFxuICBcIm1hdDN4MjxmMTY+XCI6IHsgYWxpZ246IDQsIHNpemU6IDEyIH0sXG4gIFwibWF0NHgyPGYzMj5cIjogeyBhbGlnbjogOCwgc2l6ZTogMzIgfSxcbiAgXCJtYXQ0eDI8ZjE2PlwiOiB7IGFsaWduOiA0LCBzaXplOiAxNiB9LFxuICBcIm1hdDJ4MzxmMzI+XCI6IHsgYWxpZ246IDE2LCBzaXplOiAzMiB9LFxuICBcIm1hdDJ4MzxmMTY+XCI6IHsgYWxpZ246IDgsIHNpemU6IDE2IH0sXG4gIFwibWF0M3gzPGYzMj5cIjogeyBhbGlnbjogMTYsIHNpemU6IDQ4IH0sXG4gIFwibWF0M3gzPGYxNj5cIjogeyBhbGlnbjogOCwgc2l6ZTogMjQgfSxcbiAgXCJtYXQ0eDM8ZjMyPlwiOiB7IGFsaWduOiAxNiwgc2l6ZTogNjQgfSxcbiAgXCJtYXQ0eDM8ZjE2PlwiOiB7IGFsaWduOiA4LCBzaXplOiAzMiB9LFxuICBcIm1hdDJ4NDxmMzI+XCI6IHsgYWxpZ246IDE2LCBzaXplOiAzMiB9LFxuICBcIm1hdDJ4NDxmMTY+XCI6IHsgYWxpZ246IDgsIHNpemU6IDE2IH0sXG4gIFwibWF0M3g0PGYzMj5cIjogeyBhbGlnbjogMTYsIHNpemU6IDQ4IH0sXG4gIFwibWF0M3g0PGYxNj5cIjogeyBhbGlnbjogOCwgc2l6ZTogMjQgfSxcbiAgXCJtYXQ0eDQ8ZjMyPlwiOiB7IGFsaWduOiAxNiwgc2l6ZTogNjQgfSxcbiAgXCJtYXQ0eDQ8ZjE2PlwiOiB7IGFsaWduOiA4LCBzaXplOiAzMiB9XG59O1xuZnVuY3Rpb24gY3JlYXRlVWJvRWxlbWVudHNXR1NMKHVuaWZvcm1EYXRhKSB7XG4gIGNvbnN0IHVib0VsZW1lbnRzID0gdW5pZm9ybURhdGEubWFwKChkYXRhKSA9PiAoe1xuICAgIGRhdGEsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHNpemU6IDBcbiAgfSkpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1Ym9FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHVib0VsZW1lbnQgPSB1Ym9FbGVtZW50c1tpXTtcbiAgICBsZXQgc2l6ZSA9IFdHU0xfQUxJR05fU0laRV9EQVRBW3Vib0VsZW1lbnQuZGF0YS50eXBlXS5zaXplO1xuICAgIGNvbnN0IGFsaWduID0gV0dTTF9BTElHTl9TSVpFX0RBVEFbdWJvRWxlbWVudC5kYXRhLnR5cGVdLmFsaWduO1xuICAgIGlmICghV0dTTF9BTElHTl9TSVpFX0RBVEFbdWJvRWxlbWVudC5kYXRhLnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtQaXhpLmpzXSBXZWJHUFUgVW5pZm9ybUJ1ZmZlcjogVW5rbm93biB0eXBlICR7dWJvRWxlbWVudC5kYXRhLnR5cGV9YCk7XG4gICAgfVxuICAgIGlmICh1Ym9FbGVtZW50LmRhdGEuc2l6ZSA+IDEpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChzaXplLCBhbGlnbikgKiB1Ym9FbGVtZW50LmRhdGEuc2l6ZTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gTWF0aC5jZWlsKG9mZnNldCAvIGFsaWduKSAqIGFsaWduO1xuICAgIHVib0VsZW1lbnQuc2l6ZSA9IHNpemU7XG4gICAgdWJvRWxlbWVudC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ICs9IHNpemU7XG4gIH1cbiAgb2Zmc2V0ID0gTWF0aC5jZWlsKG9mZnNldCAvIDE2KSAqIDE2O1xuICByZXR1cm4geyB1Ym9FbGVtZW50cywgc2l6ZTogb2Zmc2V0IH07XG59XG5cbmV4cG9ydCB7IFdHU0xfQUxJR05fU0laRV9EQVRBLCBjcmVhdGVVYm9FbGVtZW50c1dHU0wgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVVib0VsZW1lbnRzV0dTTC5tanMubWFwXG4iLCJpbXBvcnQgeyBXR1NMX0FMSUdOX1NJWkVfREFUQSB9IGZyb20gJy4vY3JlYXRlVWJvRWxlbWVudHNXR1NMLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2VuZXJhdGVBcnJheVN5bmNXR1NMKHVib0VsZW1lbnQsIG9mZnNldFRvQWRkKSB7XG4gIGNvbnN0IHsgc2l6ZSwgYWxpZ24gfSA9IFdHU0xfQUxJR05fU0laRV9EQVRBW3Vib0VsZW1lbnQuZGF0YS50eXBlXTtcbiAgY29uc3QgcmVtYWluZGVyID0gKGFsaWduIC0gc2l6ZSkgLyA0O1xuICByZXR1cm4gYFxuICAgICAgICAgdiA9IHV2LiR7dWJvRWxlbWVudC5kYXRhLm5hbWV9O1xuICAgICAgICAgJHtvZmZzZXRUb0FkZCAhPT0gMCA/IGBvZmZzZXQgKz0gJHtvZmZzZXRUb0FkZH07YCA6IFwiXCJ9XG5cbiAgICAgICAgIGFycmF5T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICAgICB0ID0gMDtcblxuICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCAke3Vib0VsZW1lbnQuZGF0YS5zaXplICogKHNpemUgLyA0KX07IGkrKylcbiAgICAgICAgIHtcbiAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgJHtzaXplIC8gNH07IGorKylcbiAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgIGRhdGFbYXJyYXlPZmZzZXQrK10gPSB2W3QrK107XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgICR7cmVtYWluZGVyICE9PSAwID8gYGFycmF5T2Zmc2V0ICs9ICR7cmVtYWluZGVyfTtgIDogXCJcIn1cbiAgICAgICAgIH1cbiAgICAgYDtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVBcnJheVN5bmNXR1NMIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUFycmF5U3luY1dHU0wubWpzLm1hcFxuIiwiaW1wb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3NoYWRlci91dGlscy9jcmVhdGVVYm9TeW5jRnVuY3Rpb24ubWpzJztcbmltcG9ydCB7IHVib1N5bmNGdW5jdGlvbnNXR1NMIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3NoYWRlci91dGlscy91Ym9TeW5jRnVuY3Rpb25zLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUFycmF5U3luY1dHU0wgfSBmcm9tICcuL2dlbmVyYXRlQXJyYXlTeW5jV0dTTC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGNyZWF0ZVVib1N5bmNGdW5jdGlvbldHU0wodWJvRWxlbWVudHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVVib1N5bmNGdW5jdGlvbihcbiAgICB1Ym9FbGVtZW50cyxcbiAgICBcInVib1dnc2xcIixcbiAgICBnZW5lcmF0ZUFycmF5U3luY1dHU0wsXG4gICAgdWJvU3luY0Z1bmN0aW9uc1dHU0xcbiAgKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBVYm9TeXN0ZW0gfSBmcm9tICcuLi9zaGFyZWQvc2hhZGVyL1Vib1N5c3RlbS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlVWJvRWxlbWVudHNXR1NMIH0gZnJvbSAnLi9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvRWxlbWVudHNXR1NMLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVVYm9TeW5jRnVuY3Rpb25XR1NMIH0gZnJvbSAnLi9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdVVib1N5c3RlbSBleHRlbmRzIFVib1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNyZWF0ZVVib0VsZW1lbnRzOiBjcmVhdGVVYm9FbGVtZW50c1dHU0wsXG4gICAgICBnZW5lcmF0ZVVib1N5bmM6IGNyZWF0ZVVib1N5bmNGdW5jdGlvbldHU0xcbiAgICB9KTtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdVVib1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbV0sXG4gIG5hbWU6IFwidWJvXCJcbn07XG5cbmV4cG9ydCB7IEdwdVVib1N5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1VWJvU3lzdGVtLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgVWJvQmF0Y2gge1xuICBjb25zdHJ1Y3Rvcih7IG1pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQgfSkge1xuICAgIHRoaXMuX21pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQgPSAyNTY7XG4gICAgdGhpcy5ieXRlSW5kZXggPSAwO1xuICAgIHRoaXMuX21pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQgPSBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50O1xuICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNjU1MzUpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuYnl0ZUluZGV4ID0gMDtcbiAgfVxuICBhZGRFbXB0eUdyb3VwKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMuX21pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQgLyA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm1CdWZmZXJCYXRjaDogYXJyYXkgaXMgdG9vIGxhcmdlOiAke3NpemUgKiA0fWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuYnl0ZUluZGV4O1xuICAgIGxldCBuZXdTaXplID0gc3RhcnQgKyBzaXplICogNDtcbiAgICBuZXdTaXplID0gTWF0aC5jZWlsKG5ld1NpemUgLyB0aGlzLl9taW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50KSAqIHRoaXMuX21pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQ7XG4gICAgaWYgKG5ld1NpemUgPiB0aGlzLmRhdGEubGVuZ3RoICogNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pZm9ybUJ1ZmZlckJhdGNoOiB1Ym8gYmF0Y2ggZ290IHRvbyBiaWdcIik7XG4gICAgfVxuICAgIHRoaXMuYnl0ZUluZGV4ID0gbmV3U2l6ZTtcbiAgICByZXR1cm4gc3RhcnQ7XG4gIH1cbiAgYWRkR3JvdXAoYXJyYXkpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmFkZEVtcHR5R3JvdXAoYXJyYXkubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGFbb2Zmc2V0IC8gNCArIGldID0gYXJyYXlbaV07XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9idWZmZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBVYm9CYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VWJvQmF0Y2gubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnLi4vc2hhcmVkL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclJlc291cmNlIH0gZnJvbSAnLi4vc2hhcmVkL2J1ZmZlci9CdWZmZXJSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgQnVmZmVyVXNhZ2UgfSBmcm9tICcuLi9zaGFyZWQvYnVmZmVyL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBVYm9CYXRjaCB9IGZyb20gJy4vYnVmZmVyL1Vib0JhdGNoLm1qcyc7XG5pbXBvcnQgeyBCaW5kR3JvdXAgfSBmcm9tICcuL3NoYWRlci9CaW5kR3JvdXAubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50ID0gMTI4O1xuY2xhc3MgR3B1VW5pZm9ybUJhdGNoUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fYmluZEdyb3VwSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vIG51bWJlciBvZiBidWZmZXJzLi5cbiAgICB0aGlzLl9idWZmZXJzID0gW107XG4gICAgdGhpcy5fYmluZEdyb3VwcyA9IFtdO1xuICAgIHRoaXMuX2J1ZmZlclJlc291cmNlcyA9IFtdO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYmF0Y2hCdWZmZXIgPSBuZXcgVWJvQmF0Y2goeyBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50IH0pO1xuICAgIGNvbnN0IHRvdGFsQnVmZmVycyA9IDI1NiAvIG1pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEJ1ZmZlcnM7IGkrKykge1xuICAgICAgbGV0IHVzYWdlID0gQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgaWYgKGkgPT09IDApXG4gICAgICAgIHVzYWdlIHw9IEJ1ZmZlclVzYWdlLkNPUFlfU1JDO1xuICAgICAgdGhpcy5fYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoe1xuICAgICAgICBkYXRhOiB0aGlzLl9iYXRjaEJ1ZmZlci5kYXRhLFxuICAgICAgICB1c2FnZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICByZW5kZXJFbmQoKSB7XG4gICAgdGhpcy5fdXBsb2FkQmluZEdyb3VwcygpO1xuICAgIHRoaXMuX3Jlc2V0QmluZEdyb3VwcygpO1xuICB9XG4gIF9yZXNldEJpbmRHcm91cHMoKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2JpbmRHcm91cEhhc2gpIHtcbiAgICAgIHRoaXMuX2JpbmRHcm91cEhhc2hbaV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9iYXRjaEJ1ZmZlci5jbGVhcigpO1xuICB9XG4gIC8vIGp1c3Qgd29ya3MgZm9yIHNpbmdsZSBiaW5kIGdyb3VwcyBmb3Igbm93XG4gIGdldFVuaWZvcm1CaW5kR3JvdXAoZ3JvdXAsIGR1cGxpY2F0ZSkge1xuICAgIGlmICghZHVwbGljYXRlICYmIHRoaXMuX2JpbmRHcm91cEhhc2hbZ3JvdXAudWlkXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JpbmRHcm91cEhhc2hbZ3JvdXAudWlkXTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIudWJvLmVuc3VyZVVuaWZvcm1Hcm91cChncm91cCk7XG4gICAgY29uc3QgZGF0YSA9IGdyb3VwLmJ1ZmZlci5kYXRhO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2JhdGNoQnVmZmVyLmFkZEVtcHR5R3JvdXAoZGF0YS5sZW5ndGgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnViby5zeW5jVW5pZm9ybUdyb3VwKGdyb3VwLCB0aGlzLl9iYXRjaEJ1ZmZlci5kYXRhLCBvZmZzZXQgLyA0KTtcbiAgICB0aGlzLl9iaW5kR3JvdXBIYXNoW2dyb3VwLnVpZF0gPSB0aGlzLl9nZXRCaW5kR3JvdXAob2Zmc2V0IC8gbWluVW5pZm9ybU9mZnNldEFsaWdubWVudCk7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmRHcm91cEhhc2hbZ3JvdXAudWlkXTtcbiAgfVxuICBnZXRVYm9SZXNvdXJjZShncm91cCkge1xuICAgIHRoaXMuX3JlbmRlcmVyLnViby51cGRhdGVVbmlmb3JtR3JvdXAoZ3JvdXApO1xuICAgIGNvbnN0IGRhdGEgPSBncm91cC5idWZmZXIuZGF0YTtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9iYXRjaEJ1ZmZlci5hZGRHcm91cChkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QnVmZmVyUmVzb3VyY2Uob2Zmc2V0IC8gbWluVW5pZm9ybU9mZnNldEFsaWdubWVudCk7XG4gIH1cbiAgZ2V0QXJyYXlCaW5kR3JvdXAoZGF0YSkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2JhdGNoQnVmZmVyLmFkZEdyb3VwKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLl9nZXRCaW5kR3JvdXAob2Zmc2V0IC8gbWluVW5pZm9ybU9mZnNldEFsaWdubWVudCk7XG4gIH1cbiAgZ2V0QXJyYXlCdWZmZXJSZXNvdXJjZShkYXRhKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fYmF0Y2hCdWZmZXIuYWRkR3JvdXAoZGF0YSk7XG4gICAgY29uc3QgaW5kZXggPSBvZmZzZXQgLyBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50O1xuICAgIHJldHVybiB0aGlzLl9nZXRCdWZmZXJSZXNvdXJjZShpbmRleCk7XG4gIH1cbiAgX2dldEJ1ZmZlclJlc291cmNlKGluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9idWZmZXJSZXNvdXJjZXNbaW5kZXhdKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9idWZmZXJzW2luZGV4ICUgMl07XG4gICAgICB0aGlzLl9idWZmZXJSZXNvdXJjZXNbaW5kZXhdID0gbmV3IEJ1ZmZlclJlc291cmNlKHtcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICBvZmZzZXQ6IChpbmRleCAvIDIgfCAwKSAqIDI1NixcbiAgICAgICAgc2l6ZTogbWluVW5pZm9ybU9mZnNldEFsaWdubWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9idWZmZXJSZXNvdXJjZXNbaW5kZXhdO1xuICB9XG4gIF9nZXRCaW5kR3JvdXAoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX2JpbmRHcm91cHNbaW5kZXhdKSB7XG4gICAgICBjb25zdCBiaW5kR3JvdXAgPSBuZXcgQmluZEdyb3VwKHtcbiAgICAgICAgMDogdGhpcy5fZ2V0QnVmZmVyUmVzb3VyY2UoaW5kZXgpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2JpbmRHcm91cHNbaW5kZXhdID0gYmluZEdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmluZEdyb3Vwc1tpbmRleF07XG4gIH1cbiAgX3VwbG9hZEJpbmRHcm91cHMoKSB7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5fcmVuZGVyZXIuYnVmZmVyO1xuICAgIGNvbnN0IGZpcnN0QnVmZmVyID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICBmaXJzdEJ1ZmZlci51cGRhdGUodGhpcy5fYmF0Y2hCdWZmZXIuYnl0ZUluZGV4KTtcbiAgICBidWZmZXJTeXN0ZW0udXBkYXRlQnVmZmVyKGZpcnN0QnVmZmVyKTtcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuX3JlbmRlcmVyLmdwdS5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2J1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnNbaV07XG4gICAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICAgIGJ1ZmZlclN5c3RlbS5nZXRHUFVCdWZmZXIoZmlyc3RCdWZmZXIpLFxuICAgICAgICBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50LFxuICAgICAgICBidWZmZXJTeXN0ZW0uZ2V0R1BVQnVmZmVyKGJ1ZmZlciksXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMuX2JhdGNoQnVmZmVyLmJ5dGVJbmRleFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIuZ3B1LmRldmljZS5xdWV1ZS5zdWJtaXQoW2NvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2JpbmRHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2JpbmRHcm91cHNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9iaW5kR3JvdXBzID0gbnVsbDtcbiAgICB0aGlzLl9iaW5kR3JvdXBIYXNoID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlclJlc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmZmVyUmVzb3VyY2VzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fYnVmZmVyUmVzb3VyY2VzID0gbnVsbDtcbiAgICB0aGlzLl9iYXRjaEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmluZEdyb3VwSGFzaCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1VW5pZm9ybUJhdGNoUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzXG4gIF0sXG4gIG5hbWU6IFwidW5pZm9ybUJhdGNoXCJcbn07XG5cbmV4cG9ydCB7IEdwdVVuaWZvcm1CYXRjaFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdVVuaWZvcm1CYXRjaFBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgZW5zdXJlQXR0cmlidXRlcyB9IGZyb20gJy4uLy4uL2dsL3NoYWRlci9wcm9ncmFtL2Vuc3VyZUF0dHJpYnV0ZXMubWpzJztcbmltcG9ydCB7IFNURU5DSUxfTU9ERVMgfSBmcm9tICcuLi8uLi9zaGFyZWQvc3RhdGUvY29uc3QubWpzJztcbmltcG9ydCB7IGNyZWF0ZUlkRnJvbVN0cmluZyB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy9jcmVhdGVJZEZyb21TdHJpbmcubWpzJztcbmltcG9ydCB7IEdwdVN0ZW5jaWxNb2Rlc1RvUGl4aSB9IGZyb20gJy4uL3N0YXRlL0dwdVN0ZW5jaWxNb2Rlc1RvUGl4aS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRvcG9sb2d5U3RyaW5nVG9JZCA9IHtcbiAgXCJwb2ludC1saXN0XCI6IDAsXG4gIFwibGluZS1saXN0XCI6IDEsXG4gIFwibGluZS1zdHJpcFwiOiAyLFxuICBcInRyaWFuZ2xlLWxpc3RcIjogMyxcbiAgXCJ0cmlhbmdsZS1zdHJpcFwiOiA0XG59O1xuZnVuY3Rpb24gZ2V0R3JhcGhpY3NTdGF0ZUtleShnZW9tZXRyeUxheW91dCwgc2hhZGVyS2V5LCBzdGF0ZSwgYmxlbmRNb2RlLCB0b3BvbG9neSkge1xuICByZXR1cm4gZ2VvbWV0cnlMYXlvdXQgPDwgMjQgfCBzaGFkZXJLZXkgPDwgMTYgfCBzdGF0ZSA8PCAxMCB8IGJsZW5kTW9kZSA8PCA1IHwgdG9wb2xvZ3k7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxTdGF0ZUtleShzdGVuY2lsU3RhdGVJZCwgbXVsdGlTYW1wbGVDb3VudCwgY29sb3JNYXNrLCByZW5kZXJUYXJnZXQpIHtcbiAgcmV0dXJuIGNvbG9yTWFzayA8PCA2IHwgc3RlbmNpbFN0YXRlSWQgPDwgMyB8IHJlbmRlclRhcmdldCA8PCAxIHwgbXVsdGlTYW1wbGVDb3VudDtcbn1cbmNsYXNzIFBpcGVsaW5lU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9tb2R1bGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2J1ZmZlckxheW91dHNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2JpbmRpbmdOYW1lc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcGlwZUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcGlwZVN0YXRlQ2FjaGVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fY29sb3JNYXNrID0gMTU7XG4gICAgdGhpcy5fbXVsdGlzYW1wbGVDb3VudCA9IDE7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdwdSkge1xuICAgIHRoaXMuX2dwdSA9IGdwdTtcbiAgICB0aGlzLnNldFN0ZW5jaWxNb2RlKFNURU5DSUxfTU9ERVMuRElTQUJMRUQpO1xuICAgIHRoaXMuX3VwZGF0ZVBpcGVIYXNoKCk7XG4gIH1cbiAgc2V0TXVsdGlzYW1wbGVDb3VudChtdWx0aXNhbXBsZUNvdW50KSB7XG4gICAgaWYgKHRoaXMuX211bHRpc2FtcGxlQ291bnQgPT09IG11bHRpc2FtcGxlQ291bnQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fbXVsdGlzYW1wbGVDb3VudCA9IG11bHRpc2FtcGxlQ291bnQ7XG4gICAgdGhpcy5fdXBkYXRlUGlwZUhhc2goKTtcbiAgfVxuICBzZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KSB7XG4gICAgdGhpcy5fbXVsdGlzYW1wbGVDb3VudCA9IHJlbmRlclRhcmdldC5tc2FhU2FtcGxlcztcbiAgICB0aGlzLl9kZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gcmVuZGVyVGFyZ2V0LmRlc2NyaXB0b3IuZGVwdGhTdGVuY2lsQXR0YWNobWVudCA/IDEgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZVBpcGVIYXNoKCk7XG4gIH1cbiAgc2V0Q29sb3JNYXNrKGNvbG9yTWFzaykge1xuICAgIGlmICh0aGlzLl9jb2xvck1hc2sgPT09IGNvbG9yTWFzaylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jb2xvck1hc2sgPSBjb2xvck1hc2s7XG4gICAgdGhpcy5fdXBkYXRlUGlwZUhhc2goKTtcbiAgfVxuICBzZXRTdGVuY2lsTW9kZShzdGVuY2lsTW9kZSkge1xuICAgIGlmICh0aGlzLl9zdGVuY2lsTW9kZSA9PT0gc3RlbmNpbE1vZGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fc3RlbmNpbE1vZGUgPSBzdGVuY2lsTW9kZTtcbiAgICB0aGlzLl9zdGVuY2lsU3RhdGUgPSBHcHVTdGVuY2lsTW9kZXNUb1BpeGlbc3RlbmNpbE1vZGVdO1xuICAgIHRoaXMuX3VwZGF0ZVBpcGVIYXNoKCk7XG4gIH1cbiAgc2V0UGlwZWxpbmUoZ2VvbWV0cnksIHByb2dyYW0sIHN0YXRlLCBwYXNzRW5jb2Rlcikge1xuICAgIGNvbnN0IHBpcGVsaW5lID0gdGhpcy5nZXRQaXBlbGluZShnZW9tZXRyeSwgcHJvZ3JhbSwgc3RhdGUpO1xuICAgIHBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcbiAgfVxuICBnZXRQaXBlbGluZShnZW9tZXRyeSwgcHJvZ3JhbSwgc3RhdGUsIHRvcG9sb2d5KSB7XG4gICAgaWYgKCFnZW9tZXRyeS5fbGF5b3V0S2V5KSB7XG4gICAgICBlbnN1cmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcm9ncmFtLmF0dHJpYnV0ZURhdGEpO1xuICAgICAgdGhpcy5fZ2VuZXJhdGVCdWZmZXJLZXkoZ2VvbWV0cnkpO1xuICAgIH1cbiAgICB0b3BvbG9neSA9IHRvcG9sb2d5IHx8IGdlb21ldHJ5LnRvcG9sb2d5O1xuICAgIGNvbnN0IGtleSA9IGdldEdyYXBoaWNzU3RhdGVLZXkoXG4gICAgICBnZW9tZXRyeS5fbGF5b3V0S2V5LFxuICAgICAgcHJvZ3JhbS5fbGF5b3V0S2V5LFxuICAgICAgc3RhdGUuZGF0YSxcbiAgICAgIHN0YXRlLl9ibGVuZE1vZGVJZCxcbiAgICAgIHRvcG9sb2d5U3RyaW5nVG9JZFt0b3BvbG9neV1cbiAgICApO1xuICAgIGlmICh0aGlzLl9waXBlQ2FjaGVba2V5XSlcbiAgICAgIHJldHVybiB0aGlzLl9waXBlQ2FjaGVba2V5XTtcbiAgICB0aGlzLl9waXBlQ2FjaGVba2V5XSA9IHRoaXMuX2NyZWF0ZVBpcGVsaW5lKGdlb21ldHJ5LCBwcm9ncmFtLCBzdGF0ZSwgdG9wb2xvZ3kpO1xuICAgIHJldHVybiB0aGlzLl9waXBlQ2FjaGVba2V5XTtcbiAgfVxuICBfY3JlYXRlUGlwZWxpbmUoZ2VvbWV0cnksIHByb2dyYW0sIHN0YXRlLCB0b3BvbG9neSkge1xuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuX2dwdS5kZXZpY2U7XG4gICAgY29uc3QgYnVmZmVycyA9IHRoaXMuX2NyZWF0ZVZlcnRleEJ1ZmZlckxheW91dHMoZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIGNvbnN0IGJsZW5kTW9kZXMgPSB0aGlzLl9yZW5kZXJlci5zdGF0ZS5nZXRDb2xvclRhcmdldHMoc3RhdGUpO1xuICAgIGJsZW5kTW9kZXNbMF0ud3JpdGVNYXNrID0gdGhpcy5fc3RlbmNpbE1vZGUgPT09IFNURU5DSUxfTU9ERVMuUkVOREVSSU5HX01BU0tfQUREID8gMCA6IHRoaXMuX2NvbG9yTWFzaztcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9yZW5kZXJlci5zaGFkZXIuZ2V0UHJvZ3JhbURhdGEocHJvZ3JhbSkucGlwZWxpbmU7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICAgIC8vIFRPRE8gbGF0ZXIgY2hlY2sgaWYgaXRzIGhlbHBmdWwgdG8gY3JlYXRlLi5cbiAgICAgIC8vIGxheW91dCxcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBtb2R1bGU6IHRoaXMuX2dldE1vZHVsZShwcm9ncmFtLnZlcnRleC5zb3VyY2UpLFxuICAgICAgICBlbnRyeVBvaW50OiBwcm9ncmFtLnZlcnRleC5lbnRyeVBvaW50LFxuICAgICAgICAvLyBnZW9tZXRyeS4uXG4gICAgICAgIGJ1ZmZlcnNcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBtb2R1bGU6IHRoaXMuX2dldE1vZHVsZShwcm9ncmFtLmZyYWdtZW50LnNvdXJjZSksXG4gICAgICAgIGVudHJ5UG9pbnQ6IHByb2dyYW0uZnJhZ21lbnQuZW50cnlQb2ludCxcbiAgICAgICAgdGFyZ2V0czogYmxlbmRNb2Rlc1xuICAgICAgfSxcbiAgICAgIHByaW1pdGl2ZToge1xuICAgICAgICB0b3BvbG9neSxcbiAgICAgICAgY3VsbE1vZGU6IHN0YXRlLmN1bGxNb2RlXG4gICAgICB9LFxuICAgICAgbGF5b3V0LFxuICAgICAgbXVsdGlzYW1wbGU6IHtcbiAgICAgICAgY291bnQ6IHRoaXMuX211bHRpc2FtcGxlQ291bnRcbiAgICAgIH0sXG4gICAgICAvLyBkZXB0aFN0ZW5jaWwsXG4gICAgICBsYWJlbDogYFBJWEkgUGlwZWxpbmVgXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZGVwdGhTdGVuY2lsQXR0YWNobWVudCkge1xuICAgICAgZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWwgPSB7XG4gICAgICAgIC4uLnRoaXMuX3N0ZW5jaWxTdGF0ZSxcbiAgICAgICAgZm9ybWF0OiBcImRlcHRoMjRwbHVzLXN0ZW5jaWw4XCIsXG4gICAgICAgIGRlcHRoV3JpdGVFbmFibGVkOiBzdGF0ZS5kZXB0aFRlc3QsXG4gICAgICAgIGRlcHRoQ29tcGFyZTogc3RhdGUuZGVwdGhUZXN0ID8gXCJsZXNzXCIgOiBcImFsd2F5c1wiXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwaXBlbGluZSA9IGRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZShkZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gcGlwZWxpbmU7XG4gIH1cbiAgX2dldE1vZHVsZShjb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZHVsZUNhY2hlW2NvZGVdIHx8IHRoaXMuX2NyZWF0ZU1vZHVsZShjb2RlKTtcbiAgfVxuICBfY3JlYXRlTW9kdWxlKGNvZGUpIHtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLl9ncHUuZGV2aWNlO1xuICAgIHRoaXMuX21vZHVsZUNhY2hlW2NvZGVdID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7XG4gICAgICBjb2RlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX21vZHVsZUNhY2hlW2NvZGVdO1xuICB9XG4gIF9nZW5lcmF0ZUJ1ZmZlcktleShnZW9tZXRyeSkge1xuICAgIGNvbnN0IGtleUdlbiA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgYXR0cmlidXRlS2V5cyA9IE9iamVjdC5rZXlzKGdlb21ldHJ5LmF0dHJpYnV0ZXMpLnNvcnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbYXR0cmlidXRlS2V5c1tpXV07XG4gICAgICBrZXlHZW5baW5kZXgrK10gPSBhdHRyaWJ1dGUub2Zmc2V0O1xuICAgICAga2V5R2VuW2luZGV4KytdID0gYXR0cmlidXRlLmZvcm1hdDtcbiAgICAgIGtleUdlbltpbmRleCsrXSA9IGF0dHJpYnV0ZS5zdHJpZGU7XG4gICAgICBrZXlHZW5baW5kZXgrK10gPSBhdHRyaWJ1dGUuaW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ0tleSA9IGtleUdlbi5qb2luKFwifFwiKTtcbiAgICBnZW9tZXRyeS5fbGF5b3V0S2V5ID0gY3JlYXRlSWRGcm9tU3RyaW5nKHN0cmluZ0tleSwgXCJnZW9tZXRyeVwiKTtcbiAgICByZXR1cm4gZ2VvbWV0cnkuX2xheW91dEtleTtcbiAgfVxuICBfZ2VuZXJhdGVBdHRyaWJ1dGVMb2NhdGlvbnNLZXkocHJvZ3JhbSkge1xuICAgIGNvbnN0IGtleUdlbiA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgYXR0cmlidXRlS2V5cyA9IE9iamVjdC5rZXlzKHByb2dyYW0uYXR0cmlidXRlRGF0YSkuc29ydCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2F0dHJpYnV0ZUtleXNbaV1dO1xuICAgICAga2V5R2VuW2luZGV4KytdID0gYXR0cmlidXRlLmxvY2F0aW9uO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmdLZXkgPSBrZXlHZW4uam9pbihcInxcIik7XG4gICAgcHJvZ3JhbS5fYXR0cmlidXRlTG9jYXRpb25zS2V5ID0gY3JlYXRlSWRGcm9tU3RyaW5nKHN0cmluZ0tleSwgXCJwcm9ncmFtQXR0cmlidXRlc1wiKTtcbiAgICByZXR1cm4gcHJvZ3JhbS5fYXR0cmlidXRlTG9jYXRpb25zS2V5O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGFzaCBvZiBidWZmZXIgbmFtZXMgbWFwcGVkIHRvIGJpbmQgbG9jYXRpb25zLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gYmluZCB0aGUgY29ycmVjdCBidWZmZXIgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24gaW4gdGhlIHNoYWRlci5cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gVGhlIGdlb21ldHJ5IHdoZXJlIHRvIGdldCB0aGUgYnVmZmVyIG5hbWVzXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gVGhlIHByb2dyYW0gd2hlcmUgdG8gZ2V0IHRoZSBidWZmZXIgbmFtZXNcbiAgICogQHJldHVybnMgQW4gb2JqZWN0IG9mIGJ1ZmZlciBuYW1lcyBtYXBwZWQgdG8gdGhlIGJpbmQgbG9jYXRpb24uXG4gICAqL1xuICBnZXRCdWZmZXJOYW1lc1RvQmluZChnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGtleSA9IGdlb21ldHJ5Ll9sYXlvdXRLZXkgPDwgMTYgfCBwcm9ncmFtLl9hdHRyaWJ1dGVMb2NhdGlvbnNLZXk7XG4gICAgaWYgKHRoaXMuX2JpbmRpbmdOYW1lc0NhY2hlW2tleV0pXG4gICAgICByZXR1cm4gdGhpcy5fYmluZGluZ05hbWVzQ2FjaGVba2V5XTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY3JlYXRlVmVydGV4QnVmZmVyTGF5b3V0cyhnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgY29uc3QgYnVmZmVyTmFtZXNUb0JpbmQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVEYXRhID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZURhdGEpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZURhdGFbal0ubG9jYXRpb24gPT09IGkpIHtcbiAgICAgICAgICBidWZmZXJOYW1lc1RvQmluZFtpXSA9IGo7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYmluZGluZ05hbWVzQ2FjaGVba2V5XSA9IGJ1ZmZlck5hbWVzVG9CaW5kO1xuICAgIHJldHVybiBidWZmZXJOYW1lc1RvQmluZDtcbiAgfVxuICBfY3JlYXRlVmVydGV4QnVmZmVyTGF5b3V0cyhnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGlmICghcHJvZ3JhbS5fYXR0cmlidXRlTG9jYXRpb25zS2V5KVxuICAgICAgdGhpcy5fZ2VuZXJhdGVBdHRyaWJ1dGVMb2NhdGlvbnNLZXkocHJvZ3JhbSk7XG4gICAgY29uc3Qga2V5ID0gZ2VvbWV0cnkuX2xheW91dEtleSA8PCAxNiB8IHByb2dyYW0uX2F0dHJpYnV0ZUxvY2F0aW9uc0tleTtcbiAgICBpZiAodGhpcy5fYnVmZmVyTGF5b3V0c0NhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXJMYXlvdXRzQ2FjaGVba2V5XTtcbiAgICB9XG4gICAgY29uc3QgdmVydGV4QnVmZmVyc0xheW91dCA9IFtdO1xuICAgIGdlb21ldHJ5LmJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHtcbiAgICAgICAgYXJyYXlTdHJpZGU6IDAsXG4gICAgICAgIHN0ZXBNb2RlOiBcInZlcnRleFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5QXR0cmlidXRlcyA9IGJ1ZmZlckVudHJ5LmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIGlmICgoYXR0cmlidXRlLmRpdmlzb3IgPz8gMSkgIT09IDEpIHtcbiAgICAgICAgICB3YXJuKGBBdHRyaWJ1dGUgJHtpfSBoYXMgYW4gaW52YWxpZCBkaXZpc29yIHZhbHVlIG9mICcke2F0dHJpYnV0ZS5kaXZpc29yfScuIFdlYkdQVSBvbmx5IHN1cHBvcnRzIGEgZGl2aXNvciB2YWx1ZSBvZiAxYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5idWZmZXIgPT09IGJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlckVudHJ5LmFycmF5U3RyaWRlID0gYXR0cmlidXRlLnN0cmlkZTtcbiAgICAgICAgICBidWZmZXJFbnRyeS5zdGVwTW9kZSA9IGF0dHJpYnV0ZS5pbnN0YW5jZSA/IFwiaW5zdGFuY2VcIiA6IFwidmVydGV4XCI7XG4gICAgICAgICAgYnVmZmVyRW50cnlBdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IHByb2dyYW0uYXR0cmlidXRlRGF0YVtpXS5sb2NhdGlvbixcbiAgICAgICAgICAgIG9mZnNldDogYXR0cmlidXRlLm9mZnNldCxcbiAgICAgICAgICAgIGZvcm1hdDogYXR0cmlidXRlLmZvcm1hdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyRW50cnlBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzTGF5b3V0LnB1c2goYnVmZmVyRW50cnkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2J1ZmZlckxheW91dHNDYWNoZVtrZXldID0gdmVydGV4QnVmZmVyc0xheW91dDtcbiAgICByZXR1cm4gdmVydGV4QnVmZmVyc0xheW91dDtcbiAgfVxuICBfdXBkYXRlUGlwZUhhc2goKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0R2xvYmFsU3RhdGVLZXkoXG4gICAgICB0aGlzLl9zdGVuY2lsTW9kZSxcbiAgICAgIHRoaXMuX211bHRpc2FtcGxlQ291bnQsXG4gICAgICB0aGlzLl9jb2xvck1hc2ssXG4gICAgICB0aGlzLl9kZXB0aFN0ZW5jaWxBdHRhY2htZW50XG4gICAgKTtcbiAgICBpZiAoIXRoaXMuX3BpcGVTdGF0ZUNhY2hlc1trZXldKSB7XG4gICAgICB0aGlzLl9waXBlU3RhdGVDYWNoZXNba2V5XSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICB0aGlzLl9waXBlQ2FjaGUgPSB0aGlzLl9waXBlU3RhdGVDYWNoZXNba2V5XTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJMYXlvdXRzQ2FjaGUgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuUGlwZWxpbmVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1dLFxuICBuYW1lOiBcInBpcGVsaW5lXCJcbn07XG5cbmV4cG9ydCB7IFBpcGVsaW5lU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaXBlbGluZVN5c3RlbS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdVJlbmRlclRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB0aGlzLm1zYWFUZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMubXNhYVNhbXBsZXMgPSAxO1xuICB9XG59XG5cbmV4cG9ydCB7IEdwdVJlbmRlclRhcmdldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1UmVuZGVyVGFyZ2V0Lm1qcy5tYXBcbiIsImltcG9ydCB7IENMRUFSIH0gZnJvbSAnLi4vLi4vZ2wvY29uc3QubWpzJztcbmltcG9ydCB7IENhbnZhc1NvdXJjZSB9IGZyb20gJy4uLy4uL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQ2FudmFzU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlU291cmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3RleHR1cmUvc291cmNlcy9UZXh0dXJlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBHcHVSZW5kZXJUYXJnZXQgfSBmcm9tICcuL0dwdVJlbmRlclRhcmdldC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdVJlbmRlclRhcmdldEFkYXB0b3Ige1xuICBpbml0KHJlbmRlcmVyLCByZW5kZXJUYXJnZXRTeXN0ZW0pIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX3JlbmRlclRhcmdldFN5c3RlbSA9IHJlbmRlclRhcmdldFN5c3RlbTtcbiAgfVxuICBjb3B5VG9UZXh0dXJlKHNvdXJjZVJlbmRlclN1cmZhY2VUZXh0dXJlLCBkZXN0aW5hdGlvblRleHR1cmUsIG9yaWdpblNyYywgc2l6ZSwgb3JpZ2luRGVzdCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgY29uc3QgYmFzZUdwdVRleHR1cmUgPSB0aGlzLl9nZXRHcHVDb2xvclRleHR1cmUoXG4gICAgICBzb3VyY2VSZW5kZXJTdXJmYWNlVGV4dHVyZVxuICAgICk7XG4gICAgY29uc3QgYmFja0dwdVRleHR1cmUgPSByZW5kZXJlci50ZXh0dXJlLmdldEdwdVNvdXJjZShcbiAgICAgIGRlc3RpbmF0aW9uVGV4dHVyZS5zb3VyY2VcbiAgICApO1xuICAgIHJlbmRlcmVyLmVuY29kZXIuY29tbWFuZEVuY29kZXIuY29weVRleHR1cmVUb1RleHR1cmUoXG4gICAgICB7XG4gICAgICAgIHRleHR1cmU6IGJhc2VHcHVUZXh0dXJlLFxuICAgICAgICBvcmlnaW46IG9yaWdpblNyY1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGV4dHVyZTogYmFja0dwdVRleHR1cmUsXG4gICAgICAgIG9yaWdpbjogb3JpZ2luRGVzdFxuICAgICAgfSxcbiAgICAgIHNpemVcbiAgICApO1xuICAgIHJldHVybiBkZXN0aW5hdGlvblRleHR1cmU7XG4gIH1cbiAgc3RhcnRSZW5kZXJQYXNzKHJlbmRlclRhcmdldCwgY2xlYXIgPSB0cnVlLCBjbGVhckNvbG9yLCB2aWV3cG9ydCkge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldFN5c3RlbSA9IHRoaXMuX3JlbmRlclRhcmdldFN5c3RlbTtcbiAgICBjb25zdCBncHVSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRTeXN0ZW0uZ2V0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvcihyZW5kZXJUYXJnZXQsIGNsZWFyLCBjbGVhckNvbG9yKTtcbiAgICBncHVSZW5kZXJUYXJnZXQuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XG4gICAgdGhpcy5fcmVuZGVyZXIucGlwZWxpbmUuc2V0UmVuZGVyVGFyZ2V0KGdwdVJlbmRlclRhcmdldCk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZW5jb2Rlci5iZWdpblJlbmRlclBhc3MoZ3B1UmVuZGVyVGFyZ2V0KTtcbiAgICB0aGlzLl9yZW5kZXJlci5lbmNvZGVyLnNldFZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgfVxuICBmaW5pc2hSZW5kZXJQYXNzKCkge1xuICAgIHRoaXMuX3JlbmRlcmVyLmVuY29kZXIuZW5kUmVuZGVyUGFzcygpO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBncHUgdGV4dHVyZSBmb3IgdGhlIGZpcnN0IGNvbG9yIHRleHR1cmUgaW4gdGhlIHJlbmRlciB0YXJnZXRcbiAgICogbWFpbmx5IHVzZWQgYnkgdGhlIGZpbHRlciBtYW5hZ2VyIHRvIGdldCBjb3B5IHRoZSB0ZXh0dXJlIGZvciBibGVuZGluZ1xuICAgKiBAcGFyYW0gcmVuZGVyVGFyZ2V0XG4gICAqIEByZXR1cm5zIGEgZ3B1IHRleHR1cmVcbiAgICovXG4gIF9nZXRHcHVDb2xvclRleHR1cmUocmVuZGVyVGFyZ2V0KSB7XG4gICAgY29uc3QgZ3B1UmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3lzdGVtLmdldEdwdVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIGlmIChncHVSZW5kZXJUYXJnZXQuY29udGV4dHNbMF0pIHtcbiAgICAgIHJldHVybiBncHVSZW5kZXJUYXJnZXQuY29udGV4dHNbMF0uZ2V0Q3VycmVudFRleHR1cmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnRleHR1cmUuZ2V0R3B1U291cmNlKFxuICAgICAgcmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZXNbMF0uc291cmNlXG4gICAgKTtcbiAgfVxuICBnZXREZXNjcmlwdG9yKHJlbmRlclRhcmdldCwgY2xlYXIsIGNsZWFyVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGNsZWFyID09PSBcImJvb2xlYW5cIikge1xuICAgICAgY2xlYXIgPSBjbGVhciA/IENMRUFSLkFMTCA6IENMRUFSLk5PTkU7XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclRhcmdldFN5c3RlbSA9IHRoaXMuX3JlbmRlclRhcmdldFN5c3RlbTtcbiAgICBjb25zdCBncHVSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRTeXN0ZW0uZ2V0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgY29uc3QgY29sb3JBdHRhY2htZW50cyA9IHJlbmRlclRhcmdldC5jb2xvclRleHR1cmVzLm1hcChcbiAgICAgICh0ZXh0dXJlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBncHVSZW5kZXJUYXJnZXQuY29udGV4dHNbaV07XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICBsZXQgcmVzb2x2ZVRhcmdldDtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dHVyZSA9IGNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKTtcbiAgICAgICAgICBjb25zdCBjYW52YXNUZXh0dXJlVmlldyA9IGN1cnJlbnRUZXh0dXJlLmNyZWF0ZVZpZXcoKTtcbiAgICAgICAgICB2aWV3ID0gY2FudmFzVGV4dHVyZVZpZXc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlldyA9IHRoaXMuX3JlbmRlcmVyLnRleHR1cmUuZ2V0R3B1U291cmNlKHRleHR1cmUpLmNyZWF0ZVZpZXcoe1xuICAgICAgICAgICAgbWlwTGV2ZWxDb3VudDogMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncHVSZW5kZXJUYXJnZXQubXNhYVRleHR1cmVzW2ldKSB7XG4gICAgICAgICAgcmVzb2x2ZVRhcmdldCA9IHZpZXc7XG4gICAgICAgICAgdmlldyA9IHRoaXMuX3JlbmRlcmVyLnRleHR1cmUuZ2V0VGV4dHVyZVZpZXcoXG4gICAgICAgICAgICBncHVSZW5kZXJUYXJnZXQubXNhYVRleHR1cmVzW2ldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2FkT3AgPSBjbGVhciAmIENMRUFSLkNPTE9SID8gXCJjbGVhclwiIDogXCJsb2FkXCI7XG4gICAgICAgIGNsZWFyVmFsdWUgPz8gKGNsZWFyVmFsdWUgPSByZW5kZXJUYXJnZXRTeXN0ZW0uZGVmYXVsdENsZWFyQ29sb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgcmVzb2x2ZVRhcmdldCxcbiAgICAgICAgICBjbGVhclZhbHVlLFxuICAgICAgICAgIHN0b3JlT3A6IFwic3RvcmVcIixcbiAgICAgICAgICBsb2FkT3BcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIGxldCBkZXB0aFN0ZW5jaWxBdHRhY2htZW50O1xuICAgIGlmICgocmVuZGVyVGFyZ2V0LnN0ZW5jaWwgfHwgcmVuZGVyVGFyZ2V0LmRlcHRoKSAmJiAhcmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFRleHR1cmUpIHtcbiAgICAgIHJlbmRlclRhcmdldC5lbnN1cmVEZXB0aFN0ZW5jaWxUZXh0dXJlKCk7XG4gICAgICByZW5kZXJUYXJnZXQuZGVwdGhTdGVuY2lsVGV4dHVyZS5zb3VyY2Uuc2FtcGxlQ291bnQgPSBncHVSZW5kZXJUYXJnZXQubXNhYSA/IDQgOiAxO1xuICAgIH1cbiAgICBpZiAocmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFRleHR1cmUpIHtcbiAgICAgIGNvbnN0IHN0ZW5jaWxMb2FkT3AgPSBjbGVhciAmIENMRUFSLlNURU5DSUwgPyBcImNsZWFyXCIgOiBcImxvYWRcIjtcbiAgICAgIGNvbnN0IGRlcHRoTG9hZE9wID0gY2xlYXIgJiBDTEVBUi5ERVBUSCA/IFwiY2xlYXJcIiA6IFwibG9hZFwiO1xuICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IHtcbiAgICAgICAgdmlldzogdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5nZXRHcHVTb3VyY2UocmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFRleHR1cmUuc291cmNlKS5jcmVhdGVWaWV3KCksXG4gICAgICAgIHN0ZW5jaWxTdG9yZU9wOiBcInN0b3JlXCIsXG4gICAgICAgIHN0ZW5jaWxMb2FkT3AsXG4gICAgICAgIGRlcHRoQ2xlYXJWYWx1ZTogMSxcbiAgICAgICAgZGVwdGhMb2FkT3AsXG4gICAgICAgIGRlcHRoU3RvcmVPcDogXCJzdG9yZVwiXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgY29sb3JBdHRhY2htZW50cyxcbiAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnRcbiAgICB9O1xuICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9XG4gIGNsZWFyKHJlbmRlclRhcmdldCwgY2xlYXIgPSB0cnVlLCBjbGVhckNvbG9yLCB2aWV3cG9ydCkge1xuICAgIGlmICghY2xlYXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBncHUsIGVuY29kZXIgfSA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IGRldmljZSA9IGdwdS5kZXZpY2U7XG4gICAgY29uc3Qgc3RhbmRBbG9uZSA9IGVuY29kZXIuY29tbWFuZEVuY29kZXIgPT09IG51bGw7XG4gICAgaWYgKHN0YW5kQWxvbmUpIHtcbiAgICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgICBjb25zdCByZW5kZXJQYXNzRGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvcihyZW5kZXJUYXJnZXQsIGNsZWFyLCBjbGVhckNvbG9yKTtcbiAgICAgIGNvbnN0IHBhc3NFbmNvZGVyID0gY29tbWFuZEVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHJlbmRlclBhc3NEZXNjcmlwdG9yKTtcbiAgICAgIHBhc3NFbmNvZGVyLnNldFZpZXdwb3J0KHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQsIDAsIDEpO1xuICAgICAgcGFzc0VuY29kZXIuZW5kKCk7XG4gICAgICBjb25zdCBncHVDb21tYW5kcyA9IGNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpO1xuICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZ3B1Q29tbWFuZHNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydFJlbmRlclBhc3MocmVuZGVyVGFyZ2V0LCBjbGVhciwgY2xlYXJDb2xvciwgdmlld3BvcnQpO1xuICAgIH1cbiAgfVxuICBpbml0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuICAgIHJlbmRlclRhcmdldC5pc1Jvb3QgPSB0cnVlO1xuICAgIGNvbnN0IGdwdVJlbmRlclRhcmdldCA9IG5ldyBHcHVSZW5kZXJUYXJnZXQoKTtcbiAgICByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlcy5mb3JFYWNoKChjb2xvclRleHR1cmUsIGkpID0+IHtcbiAgICAgIGlmIChDYW52YXNTb3VyY2UudGVzdChjb2xvclRleHR1cmUucmVzb3VyY2UpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjb2xvclRleHR1cmUucmVzb3VyY2UuZ2V0Q29udGV4dChcbiAgICAgICAgICBcIndlYmdwdVwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGFscGhhTW9kZSA9IGNvbG9yVGV4dHVyZS50cmFuc3BhcmVudCA/IFwicHJlbXVsdGlwbGllZFwiIDogXCJvcGFxdWVcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb250ZXh0LmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBkZXZpY2U6IHRoaXMuX3JlbmRlcmVyLmdwdS5kZXZpY2UsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1QgfCBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkMsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiYmdyYTh1bm9ybVwiLFxuICAgICAgICAgICAgYWxwaGFNb2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGdwdVJlbmRlclRhcmdldC5jb250ZXh0c1tpXSA9IGNvbnRleHQ7XG4gICAgICB9XG4gICAgICBncHVSZW5kZXJUYXJnZXQubXNhYSA9IGNvbG9yVGV4dHVyZS5zb3VyY2UuYW50aWFsaWFzO1xuICAgICAgaWYgKGNvbG9yVGV4dHVyZS5zb3VyY2UuYW50aWFsaWFzKSB7XG4gICAgICAgIGNvbnN0IG1zYWFUZXh0dXJlID0gbmV3IFRleHR1cmVTb3VyY2Uoe1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICBzYW1wbGVDb3VudDogNFxuICAgICAgICB9KTtcbiAgICAgICAgZ3B1UmVuZGVyVGFyZ2V0Lm1zYWFUZXh0dXJlc1tpXSA9IG1zYWFUZXh0dXJlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChncHVSZW5kZXJUYXJnZXQubXNhYSkge1xuICAgICAgZ3B1UmVuZGVyVGFyZ2V0Lm1zYWFTYW1wbGVzID0gNDtcbiAgICAgIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhTdGVuY2lsVGV4dHVyZSkge1xuICAgICAgICByZW5kZXJUYXJnZXQuZGVwdGhTdGVuY2lsVGV4dHVyZS5zb3VyY2Uuc2FtcGxlQ291bnQgPSA0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3B1UmVuZGVyVGFyZ2V0O1xuICB9XG4gIGRlc3Ryb3lHcHVSZW5kZXJUYXJnZXQoZ3B1UmVuZGVyVGFyZ2V0KSB7XG4gICAgZ3B1UmVuZGVyVGFyZ2V0LmNvbnRleHRzLmZvckVhY2goKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnRleHQudW5jb25maWd1cmUoKTtcbiAgICB9KTtcbiAgICBncHVSZW5kZXJUYXJnZXQubXNhYVRleHR1cmVzLmZvckVhY2goKHRleHR1cmUpID0+IHtcbiAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIGdwdVJlbmRlclRhcmdldC5tc2FhVGV4dHVyZXMubGVuZ3RoID0gMDtcbiAgICBncHVSZW5kZXJUYXJnZXQuY29udGV4dHMubGVuZ3RoID0gMDtcbiAgfVxuICBlbnN1cmVEZXB0aFN0ZW5jaWxUZXh0dXJlKHJlbmRlclRhcmdldCkge1xuICAgIGNvbnN0IGdwdVJlbmRlclRhcmdldCA9IHRoaXMuX3JlbmRlclRhcmdldFN5c3RlbS5nZXRHcHVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICBpZiAocmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFRleHR1cmUgJiYgZ3B1UmVuZGVyVGFyZ2V0Lm1zYWEpIHtcbiAgICAgIHJlbmRlclRhcmdldC5kZXB0aFN0ZW5jaWxUZXh0dXJlLnNvdXJjZS5zYW1wbGVDb3VudCA9IDQ7XG4gICAgfVxuICB9XG4gIHJlc2l6ZUdwdVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcbiAgICBjb25zdCBncHVSZW5kZXJUYXJnZXQgPSB0aGlzLl9yZW5kZXJUYXJnZXRTeXN0ZW0uZ2V0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgZ3B1UmVuZGVyVGFyZ2V0LndpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgIGdwdVJlbmRlclRhcmdldC5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuICAgIGlmIChncHVSZW5kZXJUYXJnZXQubXNhYSkge1xuICAgICAgcmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZXMuZm9yRWFjaCgoY29sb3JUZXh0dXJlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IG1zYWFUZXh0dXJlID0gZ3B1UmVuZGVyVGFyZ2V0Lm1zYWFUZXh0dXJlc1tpXTtcbiAgICAgICAgbXNhYVRleHR1cmU/LnJlc2l6ZShcbiAgICAgICAgICBjb2xvclRleHR1cmUuc291cmNlLndpZHRoLFxuICAgICAgICAgIGNvbG9yVGV4dHVyZS5zb3VyY2UuaGVpZ2h0LFxuICAgICAgICAgIGNvbG9yVGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb25cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBHcHVSZW5kZXJUYXJnZXRBZGFwdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVSZW5kZXJUYXJnZXRBZGFwdG9yLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFJlbmRlclRhcmdldFN5c3RlbSB9IGZyb20gJy4uLy4uL3NoYXJlZC9yZW5kZXJUYXJnZXQvUmVuZGVyVGFyZ2V0U3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVSZW5kZXJUYXJnZXRBZGFwdG9yIH0gZnJvbSAnLi9HcHVSZW5kZXJUYXJnZXRBZGFwdG9yLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1UmVuZGVyVGFyZ2V0U3lzdGVtIGV4dGVuZHMgUmVuZGVyVGFyZ2V0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgdGhpcy5hZGFwdG9yID0gbmV3IEdwdVJlbmRlclRhcmdldEFkYXB0b3IoKTtcbiAgICB0aGlzLmFkYXB0b3IuaW5pdChyZW5kZXJlciwgdGhpcyk7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVSZW5kZXJUYXJnZXRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1dLFxuICBuYW1lOiBcInJlbmRlclRhcmdldFwiXG59O1xuXG5leHBvcnQgeyBHcHVSZW5kZXJUYXJnZXRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdVJlbmRlclRhcmdldFN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1U2hhZGVyU3lzdGVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZ3B1UHJvZ3JhbURhdGEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdwdSkge1xuICAgIHRoaXMuX2dwdSA9IGdwdTtcbiAgICB0aGlzLm1heFRleHR1cmVzID0gZ3B1LmRldmljZS5saW1pdHMubWF4U2FtcGxlZFRleHR1cmVzUGVyU2hhZGVyU3RhZ2U7XG4gIH1cbiAgZ2V0UHJvZ3JhbURhdGEocHJvZ3JhbSkge1xuICAgIHJldHVybiB0aGlzLl9ncHVQcm9ncmFtRGF0YVtwcm9ncmFtLl9sYXlvdXRLZXldIHx8IHRoaXMuX2NyZWF0ZUdQVVByb2dyYW1EYXRhKHByb2dyYW0pO1xuICB9XG4gIF9jcmVhdGVHUFVQcm9ncmFtRGF0YShwcm9ncmFtKSB7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5fZ3B1LmRldmljZTtcbiAgICBjb25zdCBiaW5kR3JvdXBzID0gcHJvZ3JhbS5ncHVMYXlvdXQubWFwKChncm91cCkgPT4gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7IGVudHJpZXM6IGdyb3VwIH0pKTtcbiAgICBjb25zdCBwaXBlbGluZUxheW91dERlc2MgPSB7IGJpbmRHcm91cExheW91dHM6IGJpbmRHcm91cHMgfTtcbiAgICB0aGlzLl9ncHVQcm9ncmFtRGF0YVtwcm9ncmFtLl9sYXlvdXRLZXldID0ge1xuICAgICAgYmluZEdyb3VwcyxcbiAgICAgIHBpcGVsaW5lOiBkZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQocGlwZWxpbmVMYXlvdXREZXNjKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2dwdVByb2dyYW1EYXRhW3Byb2dyYW0uX2xheW91dEtleV07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9ncHUgPSBudWxsO1xuICAgIHRoaXMuX2dwdVByb2dyYW1EYXRhID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdVNoYWRlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcInNoYWRlclwiXG59O1xuXG5leHBvcnQgeyBHcHVTaGFkZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdVNoYWRlclN5c3RlbS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEdwdUJsZW5kTW9kZXNUb1BpeGkgPSB7fTtcbkdwdUJsZW5kTW9kZXNUb1BpeGkubm9ybWFsID0ge1xuICBhbHBoYToge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyYy1hbHBoYVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9LFxuICBjb2xvcjoge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyYy1hbHBoYVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aS5hZGQgPSB7XG4gIGFscGhhOiB7XG4gICAgc3JjRmFjdG9yOiBcInNyYy1hbHBoYVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjLWFscGhhXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgc3JjRmFjdG9yOiBcIm9uZVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmVcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfVxufTtcbkdwdUJsZW5kTW9kZXNUb1BpeGkubXVsdGlwbHkgPSB7XG4gIGFscGhhOiB7XG4gICAgc3JjRmFjdG9yOiBcIm9uZVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjLWFscGhhXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgc3JjRmFjdG9yOiBcImRzdFwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjLWFscGhhXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH1cbn07XG5HcHVCbGVuZE1vZGVzVG9QaXhpLnNjcmVlbiA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmNcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfVxufTtcbkdwdUJsZW5kTW9kZXNUb1BpeGkub3ZlcmxheSA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmNcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfVxufTtcbkdwdUJsZW5kTW9kZXNUb1BpeGkubm9uZSA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwiemVyb1wiLFxuICAgIGRzdEZhY3RvcjogXCJ6ZXJvXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH1cbn07XG5HcHVCbGVuZE1vZGVzVG9QaXhpW1wibm9ybWFsLW5wbVwiXSA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwic3JjLWFscGhhXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfVxufTtcbkdwdUJsZW5kTW9kZXNUb1BpeGlbXCJhZGQtbnBtXCJdID0ge1xuICBhbHBoYToge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgc3JjRmFjdG9yOiBcInNyYy1hbHBoYVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmVcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfVxufTtcbkdwdUJsZW5kTW9kZXNUb1BpeGlbXCJzY3JlZW4tbnBtXCJdID0ge1xuICBhbHBoYToge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyYy1hbHBoYVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9LFxuICBjb2xvcjoge1xuICAgIHNyY0ZhY3RvcjogXCJzcmMtYWxwaGFcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyY1wiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aS5lcmFzZSA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwiemVyb1wiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjLWFscGhhXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgc3JjRmFjdG9yOiBcInplcm9cIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyY1wiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aS5taW4gPSB7XG4gIGFscGhhOiB7XG4gICAgc3JjRmFjdG9yOiBcIm9uZVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmVcIixcbiAgICBvcGVyYXRpb246IFwibWluXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZVwiLFxuICAgIG9wZXJhdGlvbjogXCJtaW5cIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aS5tYXggPSB7XG4gIGFscGhhOiB7XG4gICAgc3JjRmFjdG9yOiBcIm9uZVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmVcIixcbiAgICBvcGVyYXRpb246IFwibWF4XCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZVwiLFxuICAgIG9wZXJhdGlvbjogXCJtYXhcIlxuICB9XG59O1xuXG5leHBvcnQgeyBHcHVCbGVuZE1vZGVzVG9QaXhpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVCbGVuZE1vZGVzVG9QaXhpLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBHcHVCbGVuZE1vZGVzVG9QaXhpIH0gZnJvbSAnLi9HcHVCbGVuZE1vZGVzVG9QaXhpLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1U3RhdGVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlLmJsZW5kID0gdHJ1ZTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdwdSkge1xuICAgIHRoaXMuZ3B1ID0gZ3B1O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBibGVuZCBtb2RlIGRhdGEgZm9yIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBnZXQgdGhlIGJsZW5kIG1vZGUgZnJvbVxuICAgKi9cbiAgZ2V0Q29sb3JUYXJnZXRzKHN0YXRlKSB7XG4gICAgY29uc3QgYmxlbmQgPSBHcHVCbGVuZE1vZGVzVG9QaXhpW3N0YXRlLmJsZW5kTW9kZV0gfHwgR3B1QmxlbmRNb2Rlc1RvUGl4aS5ub3JtYWw7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgZm9ybWF0OiBcImJncmE4dW5vcm1cIixcbiAgICAgICAgd3JpdGVNYXNrOiAwLFxuICAgICAgICBibGVuZFxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmdwdSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVTdGF0ZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcInN0YXRlXCJcbn07XG5cbmV4cG9ydCB7IEdwdVN0YXRlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVTdGF0ZVN5c3RlbS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGdwdVVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UgPSB7XG4gIHR5cGU6IFwiaW1hZ2VcIixcbiAgdXBsb2FkKHNvdXJjZSwgZ3B1VGV4dHVyZSwgZ3B1KSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBzb3VyY2UucmVzb3VyY2U7XG4gICAgY29uc3QgdG90YWwgPSAoc291cmNlLnBpeGVsV2lkdGggfCAwKSAqIChzb3VyY2UucGl4ZWxIZWlnaHQgfCAwKTtcbiAgICBjb25zdCBieXRlc1BlclBpeGVsID0gcmVzb3VyY2UuYnl0ZUxlbmd0aCAvIHRvdGFsO1xuICAgIGdwdS5kZXZpY2UucXVldWUud3JpdGVUZXh0dXJlKFxuICAgICAgeyB0ZXh0dXJlOiBncHVUZXh0dXJlIH0sXG4gICAgICByZXNvdXJjZSxcbiAgICAgIHtcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICByb3dzUGVySW1hZ2U6IHNvdXJjZS5waXhlbEhlaWdodCxcbiAgICAgICAgYnl0ZXNQZXJSb3c6IHNvdXJjZS5waXhlbEhlaWdodCAqIGJ5dGVzUGVyUGl4ZWxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHdpZHRoOiBzb3VyY2UucGl4ZWxXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzb3VyY2UucGl4ZWxIZWlnaHQsXG4gICAgICAgIGRlcHRoT3JBcnJheUxheWVyczogMVxuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGdwdVVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwdVVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBibG9ja0RhdGFNYXAgPSB7XG4gIFwiYmMxLXJnYmEtdW5vcm1cIjogeyBibG9ja0J5dGVzOiA4LCBibG9ja1dpZHRoOiA0LCBibG9ja0hlaWdodDogNCB9LFxuICBcImJjMi1yZ2JhLXVub3JtXCI6IHsgYmxvY2tCeXRlczogMTYsIGJsb2NrV2lkdGg6IDQsIGJsb2NrSGVpZ2h0OiA0IH0sXG4gIFwiYmMzLXJnYmEtdW5vcm1cIjogeyBibG9ja0J5dGVzOiAxNiwgYmxvY2tXaWR0aDogNCwgYmxvY2tIZWlnaHQ6IDQgfSxcbiAgXCJiYzctcmdiYS11bm9ybVwiOiB7IGJsb2NrQnl0ZXM6IDE2LCBibG9ja1dpZHRoOiA0LCBibG9ja0hlaWdodDogNCB9LFxuICBcImV0YzEtcmdiLXVub3JtXCI6IHsgYmxvY2tCeXRlczogOCwgYmxvY2tXaWR0aDogNCwgYmxvY2tIZWlnaHQ6IDQgfSxcbiAgXCJldGMyLXJnYmE4dW5vcm1cIjogeyBibG9ja0J5dGVzOiAxNiwgYmxvY2tXaWR0aDogNCwgYmxvY2tIZWlnaHQ6IDQgfSxcbiAgXCJhc3RjLTR4NC11bm9ybVwiOiB7IGJsb2NrQnl0ZXM6IDE2LCBibG9ja1dpZHRoOiA0LCBibG9ja0hlaWdodDogNCB9XG59O1xuY29uc3QgZGVmYXVsdEJsb2NrRGF0YSA9IHsgYmxvY2tCeXRlczogNCwgYmxvY2tXaWR0aDogMSwgYmxvY2tIZWlnaHQ6IDEgfTtcbmNvbnN0IGdwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgPSB7XG4gIHR5cGU6IFwiY29tcHJlc3NlZFwiLFxuICB1cGxvYWQoc291cmNlLCBncHVUZXh0dXJlLCBncHUpIHtcbiAgICBsZXQgbWlwV2lkdGggPSBzb3VyY2UucGl4ZWxXaWR0aDtcbiAgICBsZXQgbWlwSGVpZ2h0ID0gc291cmNlLnBpeGVsSGVpZ2h0O1xuICAgIGNvbnN0IGJsb2NrRGF0YSA9IGJsb2NrRGF0YU1hcFtzb3VyY2UuZm9ybWF0XSB8fCBkZWZhdWx0QmxvY2tEYXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLnJlc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsZXZlbEJ1ZmZlciA9IHNvdXJjZS5yZXNvdXJjZVtpXTtcbiAgICAgIGNvbnN0IGJ5dGVzUGVyUm93ID0gTWF0aC5jZWlsKG1pcFdpZHRoIC8gYmxvY2tEYXRhLmJsb2NrV2lkdGgpICogYmxvY2tEYXRhLmJsb2NrQnl0ZXM7XG4gICAgICBncHUuZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcbiAgICAgICAge1xuICAgICAgICAgIHRleHR1cmU6IGdwdVRleHR1cmUsXG4gICAgICAgICAgbWlwTGV2ZWw6IGlcbiAgICAgICAgfSxcbiAgICAgICAgbGV2ZWxCdWZmZXIsXG4gICAgICAgIHtcbiAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgYnl0ZXNQZXJSb3dcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHdpZHRoOiBNYXRoLmNlaWwobWlwV2lkdGggLyBibG9ja0RhdGEuYmxvY2tXaWR0aCkgKiBibG9ja0RhdGEuYmxvY2tXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChtaXBIZWlnaHQgLyBibG9ja0RhdGEuYmxvY2tIZWlnaHQpICogYmxvY2tEYXRhLmJsb2NrSGVpZ2h0LFxuICAgICAgICAgIGRlcHRoT3JBcnJheUxheWVyczogMVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbWlwV2lkdGggPSBNYXRoLm1heChtaXBXaWR0aCA+PiAxLCAxKTtcbiAgICAgIG1pcEhlaWdodCA9IE1hdGgubWF4KG1pcEhlaWdodCA+PiAxLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJsb2NrRGF0YU1hcCwgZ3B1VXBsb2FkQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3B1VXBsb2FkQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGdwdVVwbG9hZEltYWdlUmVzb3VyY2UgPSB7XG4gIHR5cGU6IFwiaW1hZ2VcIixcbiAgdXBsb2FkKHNvdXJjZSwgZ3B1VGV4dHVyZSwgZ3B1KSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBzb3VyY2UucmVzb3VyY2U7XG4gICAgaWYgKCFyZXNvdXJjZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKGdwdVRleHR1cmUud2lkdGgsIHNvdXJjZS5yZXNvdXJjZVdpZHRoIHx8IHNvdXJjZS5waXhlbFdpZHRoKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihncHVUZXh0dXJlLmhlaWdodCwgc291cmNlLnJlc291cmNlSGVpZ2h0IHx8IHNvdXJjZS5waXhlbEhlaWdodCk7XG4gICAgY29uc3QgcHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLmFscGhhTW9kZSA9PT0gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgICBncHUuZGV2aWNlLnF1ZXVlLmNvcHlFeHRlcm5hbEltYWdlVG9UZXh0dXJlKFxuICAgICAgeyBzb3VyY2U6IHJlc291cmNlIH0sXG4gICAgICB7IHRleHR1cmU6IGdwdVRleHR1cmUsIHByZW11bHRpcGxpZWRBbHBoYSB9LFxuICAgICAge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ3B1VXBsb2FkSW1hZ2VSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3B1VXBsb2FkSW1hZ2VTb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgZ3B1VXBsb2FkSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vZ3B1VXBsb2FkSW1hZ2VTb3VyY2UubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBncHVVcGxvYWRWaWRlb1Jlc291cmNlID0ge1xuICB0eXBlOiBcInZpZGVvXCIsXG4gIHVwbG9hZChzb3VyY2UsIGdwdVRleHR1cmUsIGdwdSkge1xuICAgIGdwdVVwbG9hZEltYWdlUmVzb3VyY2UudXBsb2FkKHNvdXJjZSwgZ3B1VGV4dHVyZSwgZ3B1KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ3B1VXBsb2FkVmlkZW9SZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3B1VXBsb2FkVmlkZW9Tb3VyY2UubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcHVNaXBtYXBHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihkZXZpY2UpIHtcbiAgICB0aGlzLmRldmljZSA9IGRldmljZTtcbiAgICB0aGlzLnNhbXBsZXIgPSBkZXZpY2UuY3JlYXRlU2FtcGxlcih7IG1pbkZpbHRlcjogXCJsaW5lYXJcIiB9KTtcbiAgICB0aGlzLnBpcGVsaW5lcyA9IHt9O1xuICB9XG4gIF9nZXRNaXBtYXBQaXBlbGluZShmb3JtYXQpIHtcbiAgICBsZXQgcGlwZWxpbmUgPSB0aGlzLnBpcGVsaW5lc1tmb3JtYXRdO1xuICAgIGlmICghcGlwZWxpbmUpIHtcbiAgICAgIGlmICghdGhpcy5taXBtYXBTaGFkZXJNb2R1bGUpIHtcbiAgICAgICAgdGhpcy5taXBtYXBTaGFkZXJNb2R1bGUgPSB0aGlzLmRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe1xuICAgICAgICAgIGNvZGU6IChcbiAgICAgICAgICAgIC8qIHdnc2wgKi9cbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcjxwcml2YXRlPiBwb3MgOiBhcnJheTx2ZWMyPGYzMj4sIDM+ID0gYXJyYXk8dmVjMjxmMzI+LCAzPihcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzI8ZjMyPigtMS4wLCAtMS4wKSwgdmVjMjxmMzI+KC0xLjAsIDMuMCksIHZlYzI8ZjMyPigzLjAsIC0xLjApKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0IFZlcnRleE91dHB1dCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb24gOiB2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgICAgICAgICBAbG9jYXRpb24oMCkgdGV4Q29vcmQgOiB2ZWMyPGYzMj4sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBAdmVydGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiB2ZXJ0ZXhNYWluKEBidWlsdGluKHZlcnRleF9pbmRleCkgdmVydGV4SW5kZXggOiB1MzIpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0IDogVmVydGV4T3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRleENvb3JkID0gcG9zW3ZlcnRleEluZGV4XSAqIHZlYzI8ZjMyPigwLjUsIC0wLjUpICsgdmVjMjxmMzI+KDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucG9zaXRpb24gPSB2ZWM0PGYzMj4ocG9zW3ZlcnRleEluZGV4XSwgMC4wLCAxLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhciBpbWdTYW1wbGVyIDogc2FtcGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgaW1nIDogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBAZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuIGZyYWdtZW50TWFpbihAbG9jYXRpb24oMCkgdGV4Q29vcmQgOiB2ZWMyPGYzMj4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVTYW1wbGUoaW1nLCBpbWdTYW1wbGVyLCB0ZXhDb29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGlwZWxpbmUgPSB0aGlzLmRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSh7XG4gICAgICAgIGxheW91dDogXCJhdXRvXCIsXG4gICAgICAgIHZlcnRleDoge1xuICAgICAgICAgIG1vZHVsZTogdGhpcy5taXBtYXBTaGFkZXJNb2R1bGUsXG4gICAgICAgICAgZW50cnlQb2ludDogXCJ2ZXJ0ZXhNYWluXCJcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICBtb2R1bGU6IHRoaXMubWlwbWFwU2hhZGVyTW9kdWxlLFxuICAgICAgICAgIGVudHJ5UG9pbnQ6IFwiZnJhZ21lbnRNYWluXCIsXG4gICAgICAgICAgdGFyZ2V0czogW3sgZm9ybWF0IH1dXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5waXBlbGluZXNbZm9ybWF0XSA9IHBpcGVsaW5lO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZWxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBtaXBtYXBzIGZvciB0aGUgZ2l2ZW4gR1BVVGV4dHVyZSBmcm9tIHRoZSBkYXRhIGluIGxldmVsIDAuXG4gICAqIEBwYXJhbSB7bW9kdWxlOkV4dGVybmFsLkdQVVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIGdlbmVyYXRlIG1pcG1hcHMgZm9yLlxuICAgKiBAcmV0dXJucyB7bW9kdWxlOkV4dGVybmFsLkdQVVRleHR1cmV9IC0gVGhlIG9yaWdpbmFsbHkgcGFzc2VkIHRleHR1cmVcbiAgICovXG4gIGdlbmVyYXRlTWlwbWFwKHRleHR1cmUpIHtcbiAgICBjb25zdCBwaXBlbGluZSA9IHRoaXMuX2dldE1pcG1hcFBpcGVsaW5lKHRleHR1cmUuZm9ybWF0KTtcbiAgICBpZiAodGV4dHVyZS5kaW1lbnNpb24gPT09IFwiM2RcIiB8fCB0ZXh0dXJlLmRpbWVuc2lvbiA9PT0gXCIxZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0aW5nIG1pcG1hcHMgZm9yIG5vbi0yZCB0ZXh0dXJlcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQhXCIpO1xuICAgIH1cbiAgICBsZXQgbWlwVGV4dHVyZSA9IHRleHR1cmU7XG4gICAgY29uc3QgYXJyYXlMYXllckNvdW50ID0gdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnMgfHwgMTtcbiAgICBjb25zdCByZW5kZXJUb1NvdXJjZSA9IHRleHR1cmUudXNhZ2UgJiBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQ7XG4gICAgaWYgKCFyZW5kZXJUb1NvdXJjZSkge1xuICAgICAgY29uc3QgbWlwVGV4dHVyZURlc2NyaXB0b3IgPSB7XG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB3aWR0aDogTWF0aC5jZWlsKHRleHR1cmUud2lkdGggLyAyKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbCh0ZXh0dXJlLmhlaWdodCAvIDIpLFxuICAgICAgICAgIGRlcHRoT3JBcnJheUxheWVyczogYXJyYXlMYXllckNvdW50XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogdGV4dHVyZS5mb3JtYXQsXG4gICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDIHwgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgICAgICBtaXBMZXZlbENvdW50OiB0ZXh0dXJlLm1pcExldmVsQ291bnQgLSAxXG4gICAgICB9O1xuICAgICAgbWlwVGV4dHVyZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUobWlwVGV4dHVyZURlc2NyaXB0b3IpO1xuICAgIH1cbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHt9KTtcbiAgICBjb25zdCBiaW5kR3JvdXBMYXlvdXQgPSBwaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCk7XG4gICAgZm9yIChsZXQgYXJyYXlMYXllciA9IDA7IGFycmF5TGF5ZXIgPCBhcnJheUxheWVyQ291bnQ7ICsrYXJyYXlMYXllcikge1xuICAgICAgbGV0IHNyY1ZpZXcgPSB0ZXh0dXJlLmNyZWF0ZVZpZXcoe1xuICAgICAgICBiYXNlTWlwTGV2ZWw6IDAsXG4gICAgICAgIG1pcExldmVsQ291bnQ6IDEsXG4gICAgICAgIGRpbWVuc2lvbjogXCIyZFwiLFxuICAgICAgICBiYXNlQXJyYXlMYXllcjogYXJyYXlMYXllcixcbiAgICAgICAgYXJyYXlMYXllckNvdW50OiAxXG4gICAgICB9KTtcbiAgICAgIGxldCBkc3RNaXBMZXZlbCA9IHJlbmRlclRvU291cmNlID8gMSA6IDA7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRleHR1cmUubWlwTGV2ZWxDb3VudDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGRzdFZpZXcgPSBtaXBUZXh0dXJlLmNyZWF0ZVZpZXcoe1xuICAgICAgICAgIGJhc2VNaXBMZXZlbDogZHN0TWlwTGV2ZWwrKyxcbiAgICAgICAgICBtaXBMZXZlbENvdW50OiAxLFxuICAgICAgICAgIGRpbWVuc2lvbjogXCIyZFwiLFxuICAgICAgICAgIGJhc2VBcnJheUxheWVyOiBhcnJheUxheWVyLFxuICAgICAgICAgIGFycmF5TGF5ZXJDb3VudDogMVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFzc0VuY29kZXIgPSBjb21tYW5kRW5jb2Rlci5iZWdpblJlbmRlclBhc3Moe1xuICAgICAgICAgIGNvbG9yQXR0YWNobWVudHM6IFt7XG4gICAgICAgICAgICB2aWV3OiBkc3RWaWV3LFxuICAgICAgICAgICAgc3RvcmVPcDogXCJzdG9yZVwiLFxuICAgICAgICAgICAgbG9hZE9wOiBcImNsZWFyXCIsXG4gICAgICAgICAgICBjbGVhclZhbHVlOiB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDAgfVxuICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiaW5kR3JvdXAgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICAgIGxheW91dDogYmluZEdyb3VwTGF5b3V0LFxuICAgICAgICAgIGVudHJpZXM6IFt7XG4gICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMuc2FtcGxlclxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICByZXNvdXJjZTogc3JjVmlld1xuICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgICBwYXNzRW5jb2Rlci5zZXRQaXBlbGluZShwaXBlbGluZSk7XG4gICAgICAgIHBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCBiaW5kR3JvdXApO1xuICAgICAgICBwYXNzRW5jb2Rlci5kcmF3KDMsIDEsIDAsIDApO1xuICAgICAgICBwYXNzRW5jb2Rlci5lbmQoKTtcbiAgICAgICAgc3JjVmlldyA9IGRzdFZpZXc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVuZGVyVG9Tb3VyY2UpIHtcbiAgICAgIGNvbnN0IG1pcExldmVsU2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IE1hdGguY2VpbCh0ZXh0dXJlLndpZHRoIC8gMiksXG4gICAgICAgIGhlaWdodDogTWF0aC5jZWlsKHRleHR1cmUuaGVpZ2h0IC8gMiksXG4gICAgICAgIGRlcHRoT3JBcnJheUxheWVyczogYXJyYXlMYXllckNvdW50XG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0ZXh0dXJlLm1pcExldmVsQ291bnQ7ICsraSkge1xuICAgICAgICBjb21tYW5kRW5jb2Rlci5jb3B5VGV4dHVyZVRvVGV4dHVyZSh7XG4gICAgICAgICAgdGV4dHVyZTogbWlwVGV4dHVyZSxcbiAgICAgICAgICBtaXBMZXZlbDogaSAtIDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIHRleHR1cmUsXG4gICAgICAgICAgbWlwTGV2ZWw6IGlcbiAgICAgICAgfSwgbWlwTGV2ZWxTaXplKTtcbiAgICAgICAgbWlwTGV2ZWxTaXplLndpZHRoID0gTWF0aC5jZWlsKG1pcExldmVsU2l6ZS53aWR0aCAvIDIpO1xuICAgICAgICBtaXBMZXZlbFNpemUuaGVpZ2h0ID0gTWF0aC5jZWlsKG1pcExldmVsU2l6ZS5oZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFtjb21tYW5kRW5jb2Rlci5maW5pc2goKV0pO1xuICAgIGlmICghcmVuZGVyVG9Tb3VyY2UpIHtcbiAgICAgIG1pcFRleHR1cmUuZGVzdHJveSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxufVxuXG5leHBvcnQgeyBHcHVNaXBtYXBHZW5lcmF0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdU1pcG1hcEdlbmVyYXRvci5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IENhbnZhc1Bvb2wgfSBmcm9tICcuLi8uLi9zaGFyZWQvdGV4dHVyZS9DYW52YXNQb29sLm1qcyc7XG5pbXBvcnQgeyBCaW5kR3JvdXAgfSBmcm9tICcuLi9zaGFkZXIvQmluZEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlIH0gZnJvbSAnLi91cGxvYWRlcnMvZ3B1VXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgZ3B1VXBsb2FkQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSwgYmxvY2tEYXRhTWFwIH0gZnJvbSAnLi91cGxvYWRlcnMvZ3B1VXBsb2FkQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgZ3B1VXBsb2FkSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vdXBsb2FkZXJzL2dwdVVwbG9hZEltYWdlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBncHVVcGxvYWRWaWRlb1Jlc291cmNlIH0gZnJvbSAnLi91cGxvYWRlcnMvZ3B1VXBsb2FkVmlkZW9Tb3VyY2UubWpzJztcbmltcG9ydCB7IEdwdU1pcG1hcEdlbmVyYXRvciB9IGZyb20gJy4vdXRpbHMvR3B1TWlwbWFwR2VuZXJhdG9yLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1VGV4dHVyZVN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLl9ncHVTb3VyY2VzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZ3B1U2FtcGxlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9iaW5kR3JvdXBIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fdGV4dHVyZVZpZXdIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fdXBsb2FkcyA9IHtcbiAgICAgIGltYWdlOiBncHVVcGxvYWRJbWFnZVJlc291cmNlLFxuICAgICAgYnVmZmVyOiBncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLFxuICAgICAgdmlkZW86IGdwdVVwbG9hZFZpZGVvUmVzb3VyY2UsXG4gICAgICBjb21wcmVzc2VkOiBncHVVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlXG4gICAgfTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ3B1KSB7XG4gICAgdGhpcy5fZ3B1ID0gZ3B1O1xuICB9XG4gIGluaXRTb3VyY2Uoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5hdXRvR2VuZXJhdGVNaXBtYXBzKSB7XG4gICAgICBjb25zdCBiaWdnZXN0RGltZW5zaW9uID0gTWF0aC5tYXgoc291cmNlLnBpeGVsV2lkdGgsIHNvdXJjZS5waXhlbEhlaWdodCk7XG4gICAgICBzb3VyY2UubWlwTGV2ZWxDb3VudCA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKGJpZ2dlc3REaW1lbnNpb24pKSArIDE7XG4gICAgfVxuICAgIGxldCB1c2FnZSA9IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1Q7XG4gICAgaWYgKHNvdXJjZS51cGxvYWRNZXRob2RJZCAhPT0gXCJjb21wcmVzc2VkXCIpIHtcbiAgICAgIHVzYWdlIHw9IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVDtcbiAgICAgIHVzYWdlIHw9IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQztcbiAgICB9XG4gICAgY29uc3QgYmxvY2tEYXRhID0gYmxvY2tEYXRhTWFwW3NvdXJjZS5mb3JtYXRdIHx8IHsgYmxvY2tCeXRlczogNCwgYmxvY2tXaWR0aDogMSwgYmxvY2tIZWlnaHQ6IDEgfTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChzb3VyY2UucGl4ZWxXaWR0aCAvIGJsb2NrRGF0YS5ibG9ja1dpZHRoKSAqIGJsb2NrRGF0YS5ibG9ja1dpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChzb3VyY2UucGl4ZWxIZWlnaHQgLyBibG9ja0RhdGEuYmxvY2tIZWlnaHQpICogYmxvY2tEYXRhLmJsb2NrSGVpZ2h0O1xuICAgIGNvbnN0IHRleHR1cmVEZXNjcmlwdG9yID0ge1xuICAgICAgbGFiZWw6IHNvdXJjZS5sYWJlbCxcbiAgICAgIHNpemU6IHsgd2lkdGgsIGhlaWdodCB9LFxuICAgICAgZm9ybWF0OiBzb3VyY2UuZm9ybWF0LFxuICAgICAgc2FtcGxlQ291bnQ6IHNvdXJjZS5zYW1wbGVDb3VudCxcbiAgICAgIG1pcExldmVsQ291bnQ6IHNvdXJjZS5taXBMZXZlbENvdW50LFxuICAgICAgZGltZW5zaW9uOiBzb3VyY2UuZGltZW5zaW9uLFxuICAgICAgdXNhZ2VcbiAgICB9O1xuICAgIGNvbnN0IGdwdVRleHR1cmUgPSB0aGlzLl9ncHUuZGV2aWNlLmNyZWF0ZVRleHR1cmUodGV4dHVyZURlc2NyaXB0b3IpO1xuICAgIHRoaXMuX2dwdVNvdXJjZXNbc291cmNlLnVpZF0gPSBncHVUZXh0dXJlO1xuICAgIGlmICghdGhpcy5tYW5hZ2VkVGV4dHVyZXMuaW5jbHVkZXMoc291cmNlKSkge1xuICAgICAgc291cmNlLm9uKFwidXBkYXRlXCIsIHRoaXMub25Tb3VyY2VVcGRhdGUsIHRoaXMpO1xuICAgICAgc291cmNlLm9uKFwicmVzaXplXCIsIHRoaXMub25Tb3VyY2VSZXNpemUsIHRoaXMpO1xuICAgICAgc291cmNlLm9uKFwiZGVzdHJveVwiLCB0aGlzLm9uU291cmNlRGVzdHJveSwgdGhpcyk7XG4gICAgICBzb3VyY2Uub24oXCJ1bmxvYWRcIiwgdGhpcy5vblNvdXJjZVVubG9hZCwgdGhpcyk7XG4gICAgICBzb3VyY2Uub24oXCJ1cGRhdGVNaXBtYXBzXCIsIHRoaXMub25VcGRhdGVNaXBtYXBzLCB0aGlzKTtcbiAgICAgIHRoaXMubWFuYWdlZFRleHR1cmVzLnB1c2goc291cmNlKTtcbiAgICB9XG4gICAgdGhpcy5vblNvdXJjZVVwZGF0ZShzb3VyY2UpO1xuICAgIHJldHVybiBncHVUZXh0dXJlO1xuICB9XG4gIG9uU291cmNlVXBkYXRlKHNvdXJjZSkge1xuICAgIGNvbnN0IGdwdVRleHR1cmUgPSB0aGlzLmdldEdwdVNvdXJjZShzb3VyY2UpO1xuICAgIGlmICghZ3B1VGV4dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5fdXBsb2Fkc1tzb3VyY2UudXBsb2FkTWV0aG9kSWRdKSB7XG4gICAgICB0aGlzLl91cGxvYWRzW3NvdXJjZS51cGxvYWRNZXRob2RJZF0udXBsb2FkKHNvdXJjZSwgZ3B1VGV4dHVyZSwgdGhpcy5fZ3B1KTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5hdXRvR2VuZXJhdGVNaXBtYXBzICYmIHNvdXJjZS5taXBMZXZlbENvdW50ID4gMSkge1xuICAgICAgdGhpcy5vblVwZGF0ZU1pcG1hcHMoc291cmNlKTtcbiAgICB9XG4gIH1cbiAgb25Tb3VyY2VVbmxvYWQoc291cmNlKSB7XG4gICAgY29uc3QgZ3B1VGV4dHVyZSA9IHRoaXMuX2dwdVNvdXJjZXNbc291cmNlLnVpZF07XG4gICAgaWYgKGdwdVRleHR1cmUpIHtcbiAgICAgIHRoaXMuX2dwdVNvdXJjZXNbc291cmNlLnVpZF0gPSBudWxsO1xuICAgICAgZ3B1VGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIG9uVXBkYXRlTWlwbWFwcyhzb3VyY2UpIHtcbiAgICBpZiAoIXRoaXMuX21pcG1hcEdlbmVyYXRvcikge1xuICAgICAgdGhpcy5fbWlwbWFwR2VuZXJhdG9yID0gbmV3IEdwdU1pcG1hcEdlbmVyYXRvcih0aGlzLl9ncHUuZGV2aWNlKTtcbiAgICB9XG4gICAgY29uc3QgZ3B1VGV4dHVyZSA9IHRoaXMuZ2V0R3B1U291cmNlKHNvdXJjZSk7XG4gICAgdGhpcy5fbWlwbWFwR2VuZXJhdG9yLmdlbmVyYXRlTWlwbWFwKGdwdVRleHR1cmUpO1xuICB9XG4gIG9uU291cmNlRGVzdHJveShzb3VyY2UpIHtcbiAgICBzb3VyY2Uub2ZmKFwidXBkYXRlXCIsIHRoaXMub25Tb3VyY2VVcGRhdGUsIHRoaXMpO1xuICAgIHNvdXJjZS5vZmYoXCJ1bmxvYWRcIiwgdGhpcy5vblNvdXJjZVVubG9hZCwgdGhpcyk7XG4gICAgc291cmNlLm9mZihcImRlc3Ryb3lcIiwgdGhpcy5vblNvdXJjZURlc3Ryb3ksIHRoaXMpO1xuICAgIHNvdXJjZS5vZmYoXCJyZXNpemVcIiwgdGhpcy5vblNvdXJjZVJlc2l6ZSwgdGhpcyk7XG4gICAgc291cmNlLm9mZihcInVwZGF0ZU1pcG1hcHNcIiwgdGhpcy5vblVwZGF0ZU1pcG1hcHMsIHRoaXMpO1xuICAgIHRoaXMubWFuYWdlZFRleHR1cmVzLnNwbGljZSh0aGlzLm1hbmFnZWRUZXh0dXJlcy5pbmRleE9mKHNvdXJjZSksIDEpO1xuICAgIHRoaXMub25Tb3VyY2VVbmxvYWQoc291cmNlKTtcbiAgfVxuICBvblNvdXJjZVJlc2l6ZShzb3VyY2UpIHtcbiAgICBjb25zdCBncHVUZXh0dXJlID0gdGhpcy5fZ3B1U291cmNlc1tzb3VyY2UudWlkXTtcbiAgICBpZiAoIWdwdVRleHR1cmUpIHtcbiAgICAgIHRoaXMuaW5pdFNvdXJjZShzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAoZ3B1VGV4dHVyZS53aWR0aCAhPT0gc291cmNlLnBpeGVsV2lkdGggfHwgZ3B1VGV4dHVyZS5oZWlnaHQgIT09IHNvdXJjZS5waXhlbEhlaWdodCkge1xuICAgICAgdGhpcy5fdGV4dHVyZVZpZXdIYXNoW3NvdXJjZS51aWRdID0gbnVsbDtcbiAgICAgIHRoaXMuX2JpbmRHcm91cEhhc2hbc291cmNlLnVpZF0gPSBudWxsO1xuICAgICAgdGhpcy5vblNvdXJjZVVubG9hZChzb3VyY2UpO1xuICAgICAgdGhpcy5pbml0U291cmNlKHNvdXJjZSk7XG4gICAgfVxuICB9XG4gIF9pbml0U2FtcGxlcihzYW1wbGVyKSB7XG4gICAgdGhpcy5fZ3B1U2FtcGxlcnNbc2FtcGxlci5fcmVzb3VyY2VJZF0gPSB0aGlzLl9ncHUuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoc2FtcGxlcik7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVNhbXBsZXJzW3NhbXBsZXIuX3Jlc291cmNlSWRdO1xuICB9XG4gIGdldEdwdVNhbXBsZXIoc2FtcGxlcikge1xuICAgIHJldHVybiB0aGlzLl9ncHVTYW1wbGVyc1tzYW1wbGVyLl9yZXNvdXJjZUlkXSB8fCB0aGlzLl9pbml0U2FtcGxlcihzYW1wbGVyKTtcbiAgfVxuICBnZXRHcHVTb3VyY2Uoc291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVNvdXJjZXNbc291cmNlLnVpZF0gfHwgdGhpcy5pbml0U291cmNlKHNvdXJjZSk7XG4gIH1cbiAgLyoqXG4gICAqIHRoaXMgcmV0dXJucyBzIGJpbmQgZ3JvdXAgZm9yIGEgc3BlY2lmaWMgdGV4dHVyZSwgdGhlIGJpbmQgZ3JvdXAgY29udGFpbnNcbiAgICogLSB0aGUgdGV4dHVyZSBzb3VyY2VcbiAgICogLSB0aGUgdGV4dHVyZSBzdHlsZVxuICAgKiAtIHRoZSB0ZXh0dXJlIG1hdHJpeFxuICAgKiBUaGlzIGlzIGNhY2hlZCBzbyB0aGUgYmluZCBncm91cCBzaG91bGQgb25seSBiZSBjcmVhdGVkIG9uY2UgcGVyIHRleHR1cmVcbiAgICogQHBhcmFtIHRleHR1cmUgLSB0aGUgdGV4dHVyZSB5b3Ugd2FudCB0aGUgYmluZGdyb3VwIGZvclxuICAgKiBAcmV0dXJucyB0aGUgYmluZCBncm91cCBmb3IgdGhlIHRleHR1cmVcbiAgICovXG4gIGdldFRleHR1cmVCaW5kR3JvdXAodGV4dHVyZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5kR3JvdXBIYXNoW3RleHR1cmUudWlkXSA/PyB0aGlzLl9jcmVhdGVUZXh0dXJlQmluZEdyb3VwKHRleHR1cmUpO1xuICB9XG4gIF9jcmVhdGVUZXh0dXJlQmluZEdyb3VwKHRleHR1cmUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcbiAgICB0aGlzLl9iaW5kR3JvdXBIYXNoW3RleHR1cmUudWlkXSA9IG5ldyBCaW5kR3JvdXAoe1xuICAgICAgMDogc291cmNlLFxuICAgICAgMTogc291cmNlLnN0eWxlLFxuICAgICAgMjogbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICAgIHVUZXh0dXJlTWF0cml4OiB7IHR5cGU6IFwibWF0M3gzPGYzMj5cIiwgdmFsdWU6IHRleHR1cmUudGV4dHVyZU1hdHJpeC5tYXBDb29yZCB9XG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9iaW5kR3JvdXBIYXNoW3RleHR1cmUudWlkXTtcbiAgfVxuICBnZXRUZXh0dXJlVmlldyh0ZXh0dXJlKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGV4dHVyZS5zb3VyY2U7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVWaWV3SGFzaFtzb3VyY2UudWlkXSA/PyB0aGlzLl9jcmVhdGVUZXh0dXJlVmlldyhzb3VyY2UpO1xuICB9XG4gIF9jcmVhdGVUZXh0dXJlVmlldyh0ZXh0dXJlKSB7XG4gICAgdGhpcy5fdGV4dHVyZVZpZXdIYXNoW3RleHR1cmUudWlkXSA9IHRoaXMuZ2V0R3B1U291cmNlKHRleHR1cmUpLmNyZWF0ZVZpZXcoKTtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVZpZXdIYXNoW3RleHR1cmUudWlkXTtcbiAgfVxuICBnZW5lcmF0ZUNhbnZhcyh0ZXh0dXJlKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHJlbmRlcmVyLmdwdS5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICBjb25zdCBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IHRleHR1cmUuc291cmNlLnBpeGVsV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHRleHR1cmUuc291cmNlLnBpeGVsSGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdwdVwiKTtcbiAgICBjb250ZXh0LmNvbmZpZ3VyZSh7XG4gICAgICBkZXZpY2U6IHJlbmRlcmVyLmdwdS5kZXZpY2UsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQyxcbiAgICAgIGZvcm1hdDogRE9NQWRhcHRlci5nZXQoKS5nZXROYXZpZ2F0b3IoKS5ncHUuZ2V0UHJlZmVycmVkQ2FudmFzRm9ybWF0KCksXG4gICAgICBhbHBoYU1vZGU6IFwicHJlbXVsdGlwbGllZFwiXG4gICAgfSk7XG4gICAgY29tbWFuZEVuY29kZXIuY29weVRleHR1cmVUb1RleHR1cmUoe1xuICAgICAgdGV4dHVyZTogcmVuZGVyZXIudGV4dHVyZS5nZXRHcHVTb3VyY2UodGV4dHVyZS5zb3VyY2UpLFxuICAgICAgb3JpZ2luOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB0ZXh0dXJlOiBjb250ZXh0LmdldEN1cnJlbnRUZXh0dXJlKClcbiAgICB9LCB7XG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgfSk7XG4gICAgcmVuZGVyZXIuZ3B1LmRldmljZS5xdWV1ZS5zdWJtaXQoW2NvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSk7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuICBnZXRQaXhlbHModGV4dHVyZSkge1xuICAgIGNvbnN0IHdlYkdQVUNhbnZhcyA9IHRoaXMuZ2VuZXJhdGVDYW52YXModGV4dHVyZSk7XG4gICAgY29uc3QgY2FudmFzQW5kQ29udGV4dCA9IENhbnZhc1Bvb2wuZ2V0T3B0aW1hbENhbnZhc0FuZENvbnRleHQod2ViR1BVQ2FudmFzLndpZHRoLCB3ZWJHUFVDYW52YXMuaGVpZ2h0KTtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzQW5kQ29udGV4dC5jb250ZXh0O1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHdlYkdQVUNhbnZhcywgMCwgMCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB3ZWJHUFVDYW52YXM7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGltYWdlRGF0YS5kYXRhLmJ1ZmZlcik7XG4gICAgQ2FudmFzUG9vbC5yZXR1cm5DYW52YXNBbmRDb250ZXh0KGNhbnZhc0FuZENvbnRleHQpO1xuICAgIHJldHVybiB7IHBpeGVscywgd2lkdGgsIGhlaWdodCB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMuc2xpY2UoKS5mb3JFYWNoKChzb3VyY2UpID0+IHRoaXMub25Tb3VyY2VEZXN0cm95KHNvdXJjZSkpO1xuICAgIHRoaXMubWFuYWdlZFRleHR1cmVzID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy5fYmluZEdyb3VwSGFzaCkpIHtcbiAgICAgIGNvbnN0IGtleSA9IE51bWJlcihrKTtcbiAgICAgIGNvbnN0IGJpbmRHcm91cCA9IHRoaXMuX2JpbmRHcm91cEhhc2hba2V5XTtcbiAgICAgIGJpbmRHcm91cD8uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fYmluZEdyb3VwSGFzaFtrZXldID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZ3B1ID0gbnVsbDtcbiAgICB0aGlzLl9taXBtYXBHZW5lcmF0b3IgPSBudWxsO1xuICAgIHRoaXMuX2dwdVNvdXJjZXMgPSBudWxsO1xuICAgIHRoaXMuX2JpbmRHcm91cEhhc2ggPSBudWxsO1xuICAgIHRoaXMuX3RleHR1cmVWaWV3SGFzaCA9IG51bGw7XG4gICAgdGhpcy5fZ3B1U2FtcGxlcnMgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1VGV4dHVyZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcInRleHR1cmVcIlxufTtcblxuZXhwb3J0IHsgR3B1VGV4dHVyZVN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1VGV4dHVyZVN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zLCBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBHcHVHcmFwaGljc0FkYXB0b3IgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9ncmFwaGljcy9ncHUvR3B1R3JhcGhpY3NBZGFwdG9yLm1qcyc7XG5pbXBvcnQgeyBHcHVNZXNoQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL21lc2gvZ3B1L0dwdU1lc2hBZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBHcHVCYXRjaEFkYXB0b3IgfSBmcm9tICcuLi8uLi9iYXRjaGVyL2dwdS9HcHVCYXRjaEFkYXB0b3IubWpzJztcbmltcG9ydCB7IEFic3RyYWN0UmVuZGVyZXIgfSBmcm9tICcuLi9zaGFyZWQvc3lzdGVtL0Fic3RyYWN0UmVuZGVyZXIubWpzJztcbmltcG9ydCB7IFNoYXJlZFN5c3RlbXMsIFNoYXJlZFJlbmRlclBpcGVzIH0gZnJvbSAnLi4vc2hhcmVkL3N5c3RlbS9TaGFyZWRTeXN0ZW1zLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi90eXBlcy5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwU3lzdGVtIH0gZnJvbSAnLi9CaW5kR3JvdXBTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdUJ1ZmZlclN5c3RlbSB9IGZyb20gJy4vYnVmZmVyL0dwdUJ1ZmZlclN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR3B1Q29sb3JNYXNrU3lzdGVtIH0gZnJvbSAnLi9HcHVDb2xvck1hc2tTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdURldmljZVN5c3RlbSB9IGZyb20gJy4vR3B1RGV2aWNlU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVFbmNvZGVyU3lzdGVtIH0gZnJvbSAnLi9HcHVFbmNvZGVyU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVTdGVuY2lsU3lzdGVtIH0gZnJvbSAnLi9HcHVTdGVuY2lsU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVVYm9TeXN0ZW0gfSBmcm9tICcuL0dwdVVib1N5c3RlbS5tanMnO1xuaW1wb3J0IHsgR3B1VW5pZm9ybUJhdGNoUGlwZSB9IGZyb20gJy4vR3B1VW5pZm9ybUJhdGNoUGlwZS5tanMnO1xuaW1wb3J0IHsgUGlwZWxpbmVTeXN0ZW0gfSBmcm9tICcuL3BpcGVsaW5lL1BpcGVsaW5lU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVSZW5kZXJUYXJnZXRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXRTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdVNoYWRlclN5c3RlbSB9IGZyb20gJy4vc2hhZGVyL0dwdVNoYWRlclN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR3B1U3RhdGVTeXN0ZW0gfSBmcm9tICcuL3N0YXRlL0dwdVN0YXRlU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi90ZXh0dXJlL0dwdVRleHR1cmVTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBEZWZhdWx0V2ViR1BVU3lzdGVtcyA9IFtcbiAgLi4uU2hhcmVkU3lzdGVtcyxcbiAgR3B1VWJvU3lzdGVtLFxuICBHcHVFbmNvZGVyU3lzdGVtLFxuICBHcHVEZXZpY2VTeXN0ZW0sXG4gIEdwdUJ1ZmZlclN5c3RlbSxcbiAgR3B1VGV4dHVyZVN5c3RlbSxcbiAgR3B1UmVuZGVyVGFyZ2V0U3lzdGVtLFxuICBHcHVTaGFkZXJTeXN0ZW0sXG4gIEdwdVN0YXRlU3lzdGVtLFxuICBQaXBlbGluZVN5c3RlbSxcbiAgR3B1Q29sb3JNYXNrU3lzdGVtLFxuICBHcHVTdGVuY2lsU3lzdGVtLFxuICBCaW5kR3JvdXBTeXN0ZW1cbl07XG5jb25zdCBEZWZhdWx0V2ViR1BVUGlwZXMgPSBbLi4uU2hhcmVkUmVuZGVyUGlwZXMsIEdwdVVuaWZvcm1CYXRjaFBpcGVdO1xuY29uc3QgRGVmYXVsdFdlYkdQVUFkYXB0ZXJzID0gW0dwdUJhdGNoQWRhcHRvciwgR3B1TWVzaEFkYXB0ZXIsIEdwdUdyYXBoaWNzQWRhcHRvcl07XG5jb25zdCBzeXN0ZW1zID0gW107XG5jb25zdCByZW5kZXJQaXBlcyA9IFtdO1xuY29uc3QgcmVuZGVyUGlwZUFkYXB0b3JzID0gW107XG5leHRlbnNpb25zLmhhbmRsZUJ5TmFtZWRMaXN0KEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLCBzeXN0ZW1zKTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlOYW1lZExpc3QoRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcywgcmVuZGVyUGlwZXMpO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeU5hbWVkTGlzdChFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzQWRhcHRvciwgcmVuZGVyUGlwZUFkYXB0b3JzKTtcbmV4dGVuc2lvbnMuYWRkKC4uLkRlZmF1bHRXZWJHUFVTeXN0ZW1zLCAuLi5EZWZhdWx0V2ViR1BVUGlwZXMsIC4uLkRlZmF1bHRXZWJHUFVBZGFwdGVycyk7XG5jbGFzcyBXZWJHUFVSZW5kZXJlciBleHRlbmRzIEFic3RyYWN0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBzeXN0ZW1Db25maWcgPSB7XG4gICAgICBuYW1lOiBcIndlYmdwdVwiLFxuICAgICAgdHlwZTogUmVuZGVyZXJUeXBlLldFQkdQVSxcbiAgICAgIHN5c3RlbXMsXG4gICAgICByZW5kZXJQaXBlcyxcbiAgICAgIHJlbmRlclBpcGVBZGFwdG9yc1xuICAgIH07XG4gICAgc3VwZXIoc3lzdGVtQ29uZmlnKTtcbiAgfVxufVxuXG5leHBvcnQgeyBXZWJHUFVSZW5kZXJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViR1BVUmVuZGVyZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7045\n')},131:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ CanvasPool)\n/* harmony export */ });\n/* unused harmony export CanvasPoolClass */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4181);\n\n\n\n"use strict";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext("2d");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minWidth);\n    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\n\n//# sourceMappingURL=CanvasPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRTtBQUNOOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0VBQVE7QUFDdkIsZ0JBQWdCLHdFQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1zY3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9DYW52YXNQb29sLm1qcz80ZDBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBuZXh0UG93MiB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21pc2MvcG93Mi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENhbnZhc1Bvb2xDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc09wdGlvbnMpIHtcbiAgICB0aGlzLl9jYW52YXNQb29sID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYW52YXNPcHRpb25zID0gY2FudmFzT3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0dXJlIHdpdGggcGFyYW1zIHRoYXQgd2VyZSBzcGVjaWZpZWQgaW4gcG9vbCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHBpeGVsV2lkdGggLSBXaWR0aCBvZiB0ZXh0dXJlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHBpeGVsSGVpZ2h0IC0gSGVpZ2h0IG9mIHRleHR1cmUgaW4gcGl4ZWxzLlxuICAgKi9cbiAgX2NyZWF0ZUNhbnZhc0FuZENvbnRleHQocGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IHBpeGVsV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHBpeGVsSGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgUG93ZXItb2YtVHdvIHJlbmRlciB0ZXh0dXJlIG9yIGZ1bGxTY3JlZW4gdGV4dHVyZVxuICAgKiBAcGFyYW0gbWluV2lkdGggLSBUaGUgbWluaW11bSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSBtaW5IZWlnaHQgLSBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHJldHVybnMgVGhlIG5ldyByZW5kZXIgdGV4dHVyZS5cbiAgICovXG4gIGdldE9wdGltYWxDYW52YXNBbmRDb250ZXh0KG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24gPSAxKSB7XG4gICAgbWluV2lkdGggPSBNYXRoLmNlaWwobWluV2lkdGggKiByZXNvbHV0aW9uIC0gMWUtNik7XG4gICAgbWluSGVpZ2h0ID0gTWF0aC5jZWlsKG1pbkhlaWdodCAqIHJlc29sdXRpb24gLSAxZS02KTtcbiAgICBtaW5XaWR0aCA9IG5leHRQb3cyKG1pbldpZHRoKTtcbiAgICBtaW5IZWlnaHQgPSBuZXh0UG93MihtaW5IZWlnaHQpO1xuICAgIGNvbnN0IGtleSA9IChtaW5XaWR0aCA8PCAxNykgKyAobWluSGVpZ2h0IDw8IDEpO1xuICAgIGlmICghdGhpcy5fY2FudmFzUG9vbFtrZXldKSB7XG4gICAgICB0aGlzLl9jYW52YXNQb29sW2tleV0gPSBbXTtcbiAgICB9XG4gICAgbGV0IGNhbnZhc0FuZENvbnRleHQgPSB0aGlzLl9jYW52YXNQb29sW2tleV0ucG9wKCk7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgICBjYW52YXNBbmRDb250ZXh0ID0gdGhpcy5fY3JlYXRlQ2FudmFzQW5kQ29udGV4dChtaW5XaWR0aCwgbWluSGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0FuZENvbnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIFBsYWNlIGEgcmVuZGVyIHRleHR1cmUgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gY2FudmFzQW5kQ29udGV4dFxuICAgKi9cbiAgcmV0dXJuQ2FudmFzQW5kQ29udGV4dChjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzQW5kQ29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXM7XG4gICAgY29uc3Qga2V5ID0gKHdpZHRoIDw8IDE3KSArIChoZWlnaHQgPDwgMSk7XG4gICAgdGhpcy5fY2FudmFzUG9vbFtrZXldLnB1c2goY2FudmFzQW5kQ29udGV4dCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2FudmFzUG9vbCA9IHt9O1xuICB9XG59XG5jb25zdCBDYW52YXNQb29sID0gbmV3IENhbnZhc1Bvb2xDbGFzcygpO1xuXG5leHBvcnQgeyBDYW52YXNQb29sLCBDYW52YXNQb29sQ2xhc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1Bvb2wubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///131\n')}}]);